# .isolate Design

High level language to describe runtime dependencies.

## Objective

Domain specific language to describe runtime dependencies across different OSes
and build flavor. This file is *compiled* to generated a `.isolated` file, as
described in IsolatedDesign


## Background

To be able to run an executable along with all its run dependencies from an
arbitrary machine, the required files must be listed in a deterministic fashion.
This list is affected by which operating system is used and build configuration
switches that could affect functionality enabled in the end executable. For
example, a Chromium build may have !NaCl disabled, causing corresponding !NaCl
files to not be built.


## Overview

**Goal:** Provide a DSL to describe runtime dependencies in the tersest readable
and editable format for both human and machine.

The process works as follow:
  - The `.isolate` file describes the dependencies depending on build variable,
    e.g. depending on the OS, build flavor, etc.
  - `isolate.py` reads a `.isolate` file, calculate the SHA-1 of each
    dependencies for the platform and generate a `.isolated` file.
  - **The `.isolated` file is a *digested* `.isolate` file**. It contains the
    `relative directory` -> `SHA-1` mapping for a specific build on a specific
    OS. This `.isolated` file is then used by IsolatedDesign to distribute test
    execution.


## Infrastructure

No infrastructure is needed for `.isolate` generation and compilation.


## Detailed Design

### `.isolate` file format

**Goal:** describe how to run a command from a temporary directory with all the
runtime dependencies, according to a matrix of variables that can affect these
lists, like the OS or the build flavor. It is to be considered a "source file"
meant to be "compiled" with a set of variables (OS and build flavor) to generate
a "compiled" file, a `.isolated` file.

The `.isolate` file format is in fact a python file even if it looks like JSON.

The format is designed to be:
  - Machine processed, e.g. a user can trace an executable and the `.isolate`
    file can be updated automatically in the canonical format.
  - Have no duplication, each entry is listed a single time instead of
    duplicating the same files for different configurations. The tool
    automatically search for the most optimal set of conditions.
  - Human readable and editable.
  - Single purpose.
  - Support variables like `PRODUCT_DIR`.
  - The compiled format `.isolated` is self-contained. No side-channel
    information, like command line arguments are necessary to run the embedded
    executable.

Explicit non-goals are:
  - Negative rules. It creates a significant cognitive overhead on the long run
    and is a long term maintenance burden; "Hey the dependency is listed. Oh,
    but it's subtracted elsewhere".
  - Wildcards. An explicit goal was to list the exact list of runtime
    dependencies. So the only "wildcard" supported is "everything under a
    directory". It makes it much easier to grep.

In short, anything that couldn't be generated by the tools automatically.
Overall, we want to avoid up to a certain extent the organic growth that is
happening in the gyp files.


#### Description

A `.isolate` file is a python file (not JSON!) that contains a single dict
instance. The allowed items are:
  - `includes`: list of `.isolate` files to include, i.e. that will be processed
    before processing this file.
  - `variables`: dict of variables. Only 3 variables are allowed:
    - `command`: list that describes the command to run, i.e. each argument.
    - `files`: list of dependencies to track, i.e. files and directories.
    - `read_only`: an integer of value 0, 1 or 2. 1 is the default.
      - 0 means that the tree is created writeable. Any file can be opened for
        write and modified.
      - 1 means that all the files have the write bit removed (or read only bit
        set on Windows) so that the file are not writeable without modifying the
        file mode. This may be or not be enforced by other means.
      - 2 means that the directory are not writeable, so that no file can even
        be added. Enforcement can take different forms but the general concept
        is the same, no modification, no creation.
  - `conditions`: list of GYP conditions, so that the content of each conditions
    applies only if the condition is True. Each condition contains a single set
    of `variables`.

Each dependency entry can be a file or a directory. **If it is a directory, it
must end with a '/'**. Otherwise, it must not end with a '/'. '\' must not be
used.


#### Example

Here's an annotated fictitious example:
```
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

-> The file is a stripped down dialect of python so comments start with '#'.
-> Copyright headers are automatically kept on file update but not inner comments.

{

-> Top level variables are allowed but the tool will have trouble rewriting them.

  'variables': {
    'files': [
      'file/needed/on/all/OSes.txt',
    ],
  },

-> Another .isolate file can be included to reduce duplication.

  'includes': [
    '../common/base.isolate',
  ],

-> Conditions determines the matrix of the build variable -> dependency mapping.

  'conditions': [

-> Conditions are python strings.

    [or OS=="linux" or OS=="mac" or OS=="win"', {

-> Variables are used to declare commands and dependencies.

      'variables': {

-> Files and directories to be archived and mapped. Modification to one of these files force the generation of a new .isolated file.

        'files': [
          '../wrapper_script.py',
          'test/data/',
        ]('OS=="android"),
      },
    }],
    [or OS=="mac" or OS=="win"', {
      'variables': {

-> The command to use to run the executable.

        'command': [
          '../wrapper_script.py',
          '<(PRODUCT_DIR)/base_unittests<(EXECUTABLE_SUFFIX)',
        ]('OS=="linux"),
      },
    }],
    [{
      'variables': {

-> In this example, android has a more complex command than the other OSes.

        'command': [
          'complex_script_to_run_on_emulate.py',
          '<(PRODUCT_DIR)/base_unittests<(EXECUTABLE_SUFFIX)',
        ]('OS=="android"',),

-> An OS can have more dependencies than others.

        'files': [
          'complex_script_to_run_on_emulate.py',
        ],
      },
    }],
  ],
}
```

See
[src/base_unittests.isolate](https://chromium.googlesource.com/chromium/src/+/master/base/base_unittests.isolate)
as found in the Chromium project as a real world example.


## Project information

  - The whole project is written in python.
  - The isolate code is subsumed by the Swarming project.
  - The code is all contained in the directory
    [client](https://chromium.googlesource.com/infra/luci/luci-py.git/+/master/client).
  - The primary consumer project is the Chromium project. As such some
    chromium-specific assumptions still remain throughout the code base but it
    is designed by the team to get rid of them.


## Caveats

  - Keeping the test dependency list in `.isolate` files clean from stale
    entries is be tricky. This would require occasional automated tracing of the
    test to figure out if a file is not accessed anymore and trigger a warning
    accordingly. Tracing is involved since it is slow and every build
    configuration would need to be tested. This will likely make `.isolate` file
    grow over time.
  - The `.isolate` format was based on the `GYP` format but it eventually
    diverted a bit.


## Latency

A few optimizations exists;

  - `isolate.py` keeps a cache in `.isolated.state` of the (file, size,
    timestamp): SHA-1. It skips calculating the SHA-1 of files that were not
    touched, significantly reducing file I/O.
  - `isolate.py` uses IsolatedDesign for high performance cache on high latency
    low bandwidth links.
  - `isolate.py batcharchive` can be used to compile upload several .isolate at
    once.


## Scalability

The purpose of this project is to enable SwarmingDesign to scale running tests.
This project itself doesn't have scalability properties.


## Redundancy and Reliability

There is no redundancy since `.isolate` generation and compilation is single
threaded.


## Security Considerations

N/A, all the processes are single host. Files are content-addressed.


## Testing Plan

  - The isolation code is unit and smoke tested. Since all of the isolate code
    is OS-independent and written in python, testing is relatively easy.
    OS-specific projects are IsolatedDesign and TracingToolsDesign.
  - A canary Continuous Integration master is run by the chromium team at
    http://build.chromium.org/p/chromium.swarm/waterfall.
