// Copyright 2015 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

syntax = "proto3";

package components.auth;


// Signed serialized Subtoken.
//
// This message is just an envelope that carries the serialized Subtoken message
// and its signature.
//
// Next ID: 6.
message DelegationToken {
  reserved 1;

  // Identity of a service that signed this token.
  //
  // It can be a 'service:<app-id>' string or 'user:<service-account-email>'
  // string.
  //
  // In both cases the appropriate certificate store will be queried (via SSL)
  // for the public key to use for signature verification.
  string signer_id = 2;

  // ID of a key used for making the signature.
  //
  // There can be multiple active keys at any moment in time: one used for new
  // signatures, and one being rotated out (but still valid for verification).
  //
  // The lifetime of the token indirectly depends on the lifetime of the signing
  // key, which is 24h. So delegation tokens can't live longer than 24h.
  string signing_key_id = 3;

  // The signature: PKCS1_v1_5+SHA256(serialized_subtoken, signing_key_id).
  bytes pkcs1_sha256_sig = 4;

  // Serialized Subtoken message. It's signature is stored in pkcs1_sha256_sig.
  bytes serialized_subtoken = 5;
}


// Identifies who delegates what authority to whom where.
//
// Next ID: 10.
message Subtoken {
  enum Kind {
    // This is to catch old tokens that don't have 'kind' field yet.
    //
    // Tokens of this kind are interpreted as 'BEARER_DELEGATION_TOKEN' for now,
    // for compatibility. But eventually (when all backends are updated), they
    // will become invalid (and there will be no way to generate them). This is
    // needed to avoid old servers accidentally interpret tokens of kind != 0 as
    // BEARER_DELEGATION_TOKEN tokens.
    UNKNOWN_KIND = 0;

    // The token of this kind can be sent in X-Delegation-Token-V1 HTTP header.
    // The services will check all restrictions of the token, and will
    // authenticate requests as coming from 'delegated_identity'.
    BEARER_DELEGATION_TOKEN = 1;
  }

  // What kind of token is this.
  //
  // Defines how it can be used. See comments for Kind enum.
  Kind kind = 8;

  // Identifier of this subtoken as generated by the token server.
  //
  // Used for logging and tracking purposes.
  int64 subtoken_id = 4;

  // Identity whose authority is delegated.
  //
  // A string of the form "user:<email>".
  string delegated_identity = 1;

  // Who requested this token.
  //
  // This can match delegated_identity if the user is delegating their own
  // identity or it can be a different id if the token is actually
  // an impersonation token.
  string requestor_identity = 7;

  // When the token was generated (and when it becomes valid).
  //
  // Number of seconds since epoch (Unix timestamp).
  int64 creation_time = 2;

  // How long the token is considered valid (in seconds).
  int32 validity_duration = 3;

  // Who can present this token.
  //
  // Each item can be an identity string (e.g. "user:<email>"), a "group:<name>"
  // string, or special "*" string which means "Any bearer can use the token".
  repeated string audience = 5;

  // What services should accept this token.
  //
  // List of services (specified as service identities, e.g. "service:app-id")
  // that should accept this token. May also contain special "*" string, which
  // means "All services".
  repeated string services = 6;

  // Arbitrary key:value pairs embedded into the token by whoever requested it.
  // Convey circumstance of why the token is created.
  //
  // Services that accept the token may use them for additional authorization
  // decisions. Please use extremely carefully, only when you control both sides
  // of the delegation link and can guarantee that services involved understand
  // the tags.
  repeated string tags = 9;
}
