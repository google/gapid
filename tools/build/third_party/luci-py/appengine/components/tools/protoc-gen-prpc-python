#!/usr/bin/env vpython
# Copyright 2017 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

# [VPYTHON:BEGIN]
# wheel: <
#   name: "infra/python/wheels/protobuf-py2_py3"
#   version: "version:3.6.1"
# >
# wheel: <
#   name: "infra/python/wheels/six-py2_py3"
#   version: "version:1.10.0"
# >
# [VPYTHON:END]

import base64
import sys
import zlib

from google.protobuf import descriptor_pb2
from google.protobuf.compiler import plugin_pb2 as plugin


HEADER_FORMAT = '''
# Generated by the pRPC protocol buffer compiler plugin.  DO NOT EDIT!
# source: %(file_name)s

import base64
import zlib

from google.protobuf import descriptor_pb2

# Includes description of the %(file_name)s and all of its transitive
# dependencies. Includes source code info.
FILE_DESCRIPTOR_SET = descriptor_pb2.FileDescriptorSet()
FILE_DESCRIPTOR_SET.ParseFromString(zlib.decompress(base64.b64decode(
%(file_set_descriptor_b64)s)))
_INDEX = {
    f.name: {
      'descriptor': f,
      'services': {s.name: s for s in f.service},
    }
    for f in FILE_DESCRIPTOR_SET.file
}
'''


SERVICE_FORMAT = '''
%(service_name)sServiceDescription = {
  'file_descriptor_set': FILE_DESCRIPTOR_SET,
  'file_descriptor': _INDEX[%(file_name)r]['descriptor'],
  'service_descriptor': _INDEX[%(file_name)r]['services'][%(service_name)r],
}
'''


def build_file_set_descriptor(root_name, files):
  added = set()
  ret = descriptor_pb2.FileDescriptorSet()

  def ensure_file(name):
    if name in added:
      return

    file = files[name]
    added.add(name)
    ret.file.add().CopyFrom(file)
    for dep in file.dependency:
      ensure_file(dep)

  ensure_file(root_name)
  return ret


def string_to_code_lines(s, indent=0):
  """Generates multiline Python string literal."""
  assert isinstance(s, str)
  ret = []
  max_string_line_len = 80 - 2 - indent
  indent_str = ' ' * indent
  i = 0
  while i < len(s):
    chunk = s[i:i + max_string_line_len]
    i += max_string_line_len
    ret.append('%s%r' % (indent_str, chunk))
  return '\n'.join(ret)


def generate_code(file_descriptor, all_files):
  file_set = build_file_set_descriptor(file_descriptor.name, all_files)
  fragments = [HEADER_FORMAT % {
      'file_name': file_descriptor.name,
      'file_set_descriptor_b64': string_to_code_lines(
          base64.b64encode(zlib.compress(file_set.SerializeToString())),
          indent=4),
  }]

  for service in file_descriptor.service:
    fragments.append(SERVICE_FORMAT % {
        'file_name': file_descriptor.name,
        'service_name': service.name,
    })
  return ('\n'.join(fragments)).strip() + '\n'


def main():
  data = sys.stdin.read()
  req = plugin.CodeGeneratorRequest()
  req.ParseFromString(data)
  res = plugin.CodeGeneratorResponse()
  files = {f.name: f for f in req.proto_file}
  for file_name in req.file_to_generate:
    file = files[file_name]
    if file.service:
      res.file.add(
          name=file.name.replace('.proto', '_prpc_pb2.py'),
          content=generate_code(file, files),
      )
  sys.stdout.write(res.SerializeToString())


if __name__ == '__main__':
   main()
