{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{Include "common.tmpl"}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for the specified AST type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Type"}}
  {{if not (IsType $)}}{{Template "C++.Type" (TypeOf $)}}
  {{else if IsVoid        $}}void
  {{else if IsBool        $}}bool
  {{else if IsInt         $}}int
  {{else if IsUint        $}}unsigned int
  {{else if IsSize        $}}size_val
  {{else if IsChar        $}}char
  {{else if IsU8          $}}uint8_t
  {{else if IsS8          $}}int8_t
  {{else if IsU16         $}}uint16_t
  {{else if IsS16         $}}int16_t
  {{else if IsF32         $}}float
  {{else if IsU32         $}}uint32_t
  {{else if IsS32         $}}int32_t
  {{else if IsF64         $}}double
  {{else if IsU64         $}}uint64_t
  {{else if IsS64         $}}int64_t
  {{else if IsEnum        $}}{{Template "C++.EnumType" $}}
  {{else if IsReference   $}}gapil::Ref<{{Template "C++.Type" $.To}}>
  {{else if IsString      $}}{{Template "C++.StringType" $}}
  {{else if IsStaticArray $}}core::StaticArray<{{Template "C++.Type" $.ValueType}}, {{$.Size}}>
  {{else if IsSlice       $}}gapil::Slice<{{if IsVoid $.To}}uint8_t{{else}}{{Template "C++.Type" $.To}}{{end}}>
  {{else if IsPointer     $}}{{Template "C++.Type" $.To}}{{if $.Const}} const{{end}}*
  {{else if IsAny         $}}auto
  {{else}}{{Template "C++.TypeName" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the fixed-size-array postfix for static array parameter types.
-------------------------------------------------------------------------------
*/}}
{{define "C++.StaticArraySuffix"}}
  {{if not (IsType $)}}{{Template "C++.StaticArraySuffix" (TypeOf $)}}
  {{else if IsStaticArray $}}[{{$.Size}}]ยง
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a typename that can be used for string concatenation for the given type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.TypeName"}}
  {{if not (IsType $)}}{{Template "C++.TypeName" (TypeOf $)}}
  {{else if IsPseudonym   $}}{{$.Name}}
  {{else if IsClass       $}}{{Global "prefix"}}{{$.Name}}
  {{else if IsEnum        $}}{{Global "prefix"}}{{$.Name}}
  {{else if IsMap         $}}{{Template "C++.TypeName" $.KeyType}}To{{Template "C++.TypeName" $.ValueType}}{{if $.Dense}}_Dense{{end}}
  {{else if IsVoid        $}}Void
  {{else if IsBool        $}}Bool
  {{else if IsInt         $}}Int
  {{else if IsUint        $}}Uint
  {{else if IsSize        $}}SizeT
  {{else if IsChar        $}}Char
  {{else if IsU8          $}}U8
  {{else if IsS8          $}}S8
  {{else if IsU16         $}}U16
  {{else if IsS16         $}}S16
  {{else if IsF32         $}}F32
  {{else if IsU32         $}}U32
  {{else if IsS32         $}}S32
  {{else if IsF64         $}}F64
  {{else if IsU64         $}}U64
  {{else if IsS64         $}}S64
  {{else if IsString      $}}String
  {{else if IsMessage     $}}const char*
  {{else if IsStaticArray $}}{{Template "C++.TypeName" $.ValueType}}__{{$.Size}}__A
  {{else if IsReference   $}}{{Template "C++.TypeName" $.To}}__R
  {{else if IsSlice       $}}{{Template "C++.TypeName" $.To}}__S
  {{else if IsPointer     $}}{{Template "C++.TypeName" $.To}}__{{if $.Const}}C{{end}}P
  {{else}}{{Error "C++.TypeName passed unsupported type (%T): %s" $ $.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ default value for the provided AST type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Null"}}
  {{AssertType $ "Type"}}
  {{     if IsBool        $}}false
  {{else if IsInt         $}}0
  {{else if IsUint        $}}0
  {{else if IsSize        $}}0
  {{else if IsS8          $}}0
  {{else if IsU8          $}}0
  {{else if IsS16         $}}0
  {{else if IsU16         $}}0
  {{else if IsS32         $}}0
  {{else if IsU32         $}}0
  {{else if IsF32         $}}0
  {{else if IsS64         $}}0
  {{else if IsU64         $}}0
  {{else if IsF64         $}}0
  {{else if IsEnum        $}}0
  {{else if IsChar        $}}0
  {{else if IsString      $}}gapil::String()
  {{else if IsStaticArray $}}{{Template "C++.Type" $}}::create({{Template "C++.Null" $.ValueType}})
  {{else if IsPseudonym   $}}{{Template "C++.Null" $.To}}
  {{else if IsClass       $}}{{Template "C++.Type" $}}({{Template "C++.Arena"}})
  {{else if IsSlice       $}}{{Template "C++.Type" $}}()
  {{else if IsMap         $}}{{Template "C++.Type" $}}({{Template "C++.Arena"}})
  {{else if IsPointer     $}}nullptr
  {{else if IsReference   $}}{{Template "C++.Type" $}}()
  {{else}}{{Error "macro Null called with unsupported type: %s" $.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the identifier of the memory arena which is by default 'arena'.
  This can be overridden with the "C++.ArenaOverride" global.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Arena"}}
  {{$a := Global "C++.ArenaOverride"}}
  {{if $a}}{{$a}}{{else}}arena{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ default value for the provided AST type when used as an argument
  or return value.
-------------------------------------------------------------------------------
*/}}
{{define "C++.NullArgument"}}
  {{AssertType $ "Type"}}
  {{     if IsString      $}}""
  {{else}}{{Template "C++.Null" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for the specified Enum.
-------------------------------------------------------------------------------
*/}}
{{define "C++.EnumType"}}
  {{AssertType $ "Enum"}}

  {{Template "C++.Type" $.NumberType}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for the specified String.
  By default this emits std::string, but this behaviour can be overridden with
  the global "C++.StringTypeOverride".
-------------------------------------------------------------------------------
*/}}
{{define "C++.StringType"}}
  {{if $override := Global "C++.StringTypeOverride"}}{{$override}}
  {{else}}std::string
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the comma-separated list of type-name paired parameters for given
  function.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ConstQualifiedParameters"}}
  {{AssertType $ "Function"}}

  {{range $i, $p := $.CallParameters}}
    {{if $i}}, {{end}}{{Template "C++.ConstQualifiedParameterType" $p}} {{$p.Name}}ยง
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the comma-separated list of type-name paired parameters for given
  function.
-------------------------------------------------------------------------------
*/}}
{{define "C++.CallParameters"}}
  {{AssertType $ "Function"}}

  {{$prevCallFunction := Global "CallFunction"}}
  {{Global "CallFunction" $}}
  {{ForEach $.CallParameters "C++.Parameter" | JoinWith ", "}}
  {{Global "CallFunction" $prevCallFunction}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the comma-separated list of argument names for the given function.
-------------------------------------------------------------------------------
*/}}
{{define "C++.CallArguments"}}
  {{AssertType $ "Function"}}

  {{range $i, $p := $.CallParameters}}
    {{if $i}}, {{end}}{{$p.Name}}ยง
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C++ template type for the given Any parameter
-------------------------------------------------------------------------------
*/}}
{{define "C++.ParameterTypeAny"}}
{{AssertType $ "Parameter"}}
  {{Title $.Named}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for use as a parameter for the given parameter or type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ParameterTypeNoSuffix"}}
  {{AssertType $ "Type" "Parameter"}}
  {{$func := Global "CallFunction"}}

  {{if $abi_type := GetAnnotation $ "abi_type"}}
    {{index $abi_type.Arguments 0}}
  {{else if IsParameter $}}
    {{ if IsAny (TypeOf $)}}
      {{Template "C++.ParameterTypeAny" $}}
    {{else}}
      {{Template "C++.ParameterTypeNoSuffix" (TypeOf $)}}
    {{end}}
  {{else if IsPointer     $}}{{Template "C++.ParameterTypeNoSuffix" $.To}}{{if $.Const}} const{{end}}*
  {{else if IsStaticArray $}}{{Template "C++.Type" $.ValueType}}
  {{else if IsString      $}}{{if $func.Extern}} std::string {{else}} const char* {{end}}
  {{else                   }}{{Template "C++.Type" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for use as a parameter for the given parameter or type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ConstQualifiedParameterType"}}
  {{AssertType $ "Type" "Parameter"}}

  {{     if IsParameter $}}{{Template "C++.ConstQualifiedParameterType" (TypeOf $)}}
  {{else if IsPointer   $}}{{Template "C++.ParameterType" $.To}}{{if $.Const}} const{{end}}*
  {{else if IsString    $}}const char*
  {{else if IsAny       $}}{{Template "C++.ParameterTypeAny" $}}
  {{else                 }}{{Template "C++.Type" $}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C++ type for use as a parameter for the given parameter or type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ParameterType"}}
  {{AssertType $ "Type" "Parameter"}}

  {{Template "C++.ParameterTypeNoSuffix" $}}{{Template "C++.StaticArraySuffix" $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ type, name and suffix for a single parameter.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Parameter"}}
  {{AssertType $ "Type" "Parameter"}}

  {{Template "C++.ParameterTypeNoSuffix" $}} {{$.Name}}{{Template "C++.StaticArraySuffix" $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ return type for the given command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReturnType"}}
  {{AssertType $ "Function"}}
  {{$prevCallFunction := Global "CallFunction"}}
  {{Global "CallFunction" $}}

  {{Template "C++.ParameterType" $.Return}}
  {{Global "CallFunction" $prevCallFunction}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ return type for the given subroutine.
-------------------------------------------------------------------------------
*/}}
{{define "C++.SubReturnType"}}
  {{AssertType $ "Function"}}

  {{$ty := TypeOf $.Return}}
  {{if IsString $ty}}gapil::String{{else}}{{Macro "C++.ReturnType" $}}{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic for all the statements in the given block.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Block"}}
  {{range $s := $.Statements}}
    {{$v := Macro "C++.Statement" $s}}
    {{$v}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the name for the given local variable.
-------------------------------------------------------------------------------
*/}}
{{define "C++.LocalName"}}
  {{AssertType $ "Local"}}

  l_{{$.Name}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to execute the given statement.
  If the global "C++.Statement.Override" is specified then this the macro with
  the specified name is called, otherwise the macro delegates to
  "C++.Statement.Default".
-------------------------------------------------------------------------------
*/}}
{{define "C++.Statement"}}
  {{if $override := Global "C++.Statement.Override"}}
    {{Template $override $}}
  {{else}}
    {{Template "C++.Statement.Default" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to execute the given statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Statement.Default"}}
  {{     if IsDeclareLocal $}}{{Template "C++.DeclareLocal" $}}
  {{else if IsAbort        $}}{{Template "C++.Abort" $}}
  {{else if IsAssign       $}}{{Template "C++.Assign" $}}
  {{else if IsArrayAssign  $}}{{Template "C++.ArrayAssign" $}}
  {{else if IsBlock        $}}{ยถ{{Template "C++.Block" $}}ยถ}
  {{else if IsMapAssign    $}}{{Template "C++.MapAssign" $}}
  {{else if IsSliceAssign  $}}{{Template "C++.SliceAssign" $}}
  {{else if IsMapRemove    $}}{{Template "C++.MapRemove" $}}
  {{else if IsMapClear     $}}{{Template "C++.MapClear" $}}
  {{else if IsReturn       $}}{{Template "C++.Return" $}}
  {{else if IsBranch       $}}{{Template "C++.Branch" $}}
  {{else if IsSwitch       $}}{{Template "C++.Switch" $}}
  {{else if IsIteration    $}}{{Template "C++.Iteration" $}}
  {{else if IsMapIteration $}}{{Template "C++.MapIteration" $}}
  {{else if IsCall         $}}{{Template "C++.Call" $}};
  {{else if IsAssert       $}}
  {{else if IsRead         $}}observer->read({{Template "C++.Read" $.Slice}});
  {{else if IsWrite        $}}observer->write({{Template "C++.Read" $.Slice}});
  {{else if IsCopy         $}}observer->copy({{Template "C++.Read" $.Dst}}, {{Template "C++.Read" $.Src}});
  {{else if IsFence        $}}{{if not (IsNil $.Statement)}}{{Template "C++.Statement" $.Statement}}{{end}}
  {{else                    }}{{Error "unsupported statement %T: %+v" $ $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to declare a local variable.
-------------------------------------------------------------------------------
*/}}
{{define "C++.DeclareLocal"}}
  {{AssertType $ "DeclareLocal"}}

  {{Template "C++.Type" (TypeOf $.Local)}} {{Template "C++.LocalName" $.Local}} = {{Template "C++.Read" $.Local.Value}};
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform an abort statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Abort"}}
  {{AssertType $ "Abort"}}

  abort();
  {{if $.Function.Subroutine}}
    return{{if not (IsVoid $.Function.Return.Type)}} {{Template "C++.Null" (TypeOf $.Function.Return)}}{{end}};
  {{else}}
    break;
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform an assign statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Assign"}}
  {{AssertType $ "Assign"}}

  {{if IsIgnore $.LHS}}
    {{if ne $.Operator "="}}{{Error "Compound assignments to '_' are not supported (%s)" $.Operator}}{{end}}
    (void){{Template "C++.Read" $.RHS}};
  {{else}}
    {{Template "C++.Read" $.LHS}} {{$.Operator}} {{Template "C++.Read" $.RHS}};
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform a static-array assign statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ArrayAssign"}}
  {{AssertType $ "ArrayAssign"}}

  {{Template "C++.Read" $.To.Array}}[{{Template "C++.Read" $.To.Index}}] {{$.Operator}} {{Template "C++.Read" $.Value}};
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform a map assign statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.MapAssign"}}
  {{AssertType $ "MapAssign"}}

  {{Template "C++.Read" $.To.Map}}[{{Template "C++.Read" $.To.Index}}] {{$.Operator}} {{Template "C++.Read" $.Value}};
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to remove a map element.
-------------------------------------------------------------------------------
*/}}
{{define "C++.MapRemove"}}
  {{AssertType $ "MapRemove"}}

  {{Template "C++.Read" $.Map}}.erase({{Template "C++.Read" $.Key}});
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to remove a map element.
-------------------------------------------------------------------------------
*/}}
{{define "C++.MapClear"}}
  {{AssertType $ "MapClear"}}

  {{Template "C++.Read" $.Map}}.clear();
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform a return statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Return"}}
  {{AssertType $ "Return"}}

  return{{if $.Value}} {{Template "C++.Read" $.Value}}{{end}};
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform a slice assign statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.SliceAssign"}}
  {{AssertType $ "SliceAssign"}}

  {{if eq $.Operator "="}}observer->write<{{Template "C++.Type" $.To.Type.To}}>({{Template "C++.Read" $.To.Slice}}, {{Template "C++.Read" $.To.Index}}, {{Template "C++.Read" $.Value}});
  {{else}}{{Error "Unsupported MapAssign operator %s" $.Operator}}{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic for a branch statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Branch"}}
  {{AssertType $ "Branch"}}

  if ({{Template "C++.Read" $.Condition}}) {
    {{Template "C++.Block" $.True}}
    {{if $.False}}
  } else {
    {{Template "C++.Block" $.False}}
    {{end}}
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic for a switch statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Switch"}}
  {{AssertType $ "Switch"}}

  switch ({{Template "C++.Read" $.Value}}) {
    {{range $i, $c := $.Cases}}
      {{range $j, $cond := $c.Conditions}}
        case {{Template "C++.Read" $cond}}:{{if HasMore $j $c.Conditions}} // fall-through...{{else}} {{"{"}}{{end}}
      {{end}}
        {{Template "C++.Block" $c.Block}}
        break;
      }
    {{end}}
    {{if not (IsNil $.Default)}}
    default: {
      {{Template "C++.Block" $.Default}}
      }
    {{end}}
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform an iteration statement.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Iteration"}}
  {{AssertType $ "Iteration"}}

  {{$it := Macro "C++.Read" $.Iterator}}
  for ({{Template "C++.Type" $.From}} {{$it}} = {{Template "C++.Read" $.From}}; {{$it}} < {{Template "C++.Read" $.To}}; ++{{$it}}) {
    {{Template "C++.Block" $.Block}}
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to perform an iteration over a map.
-------------------------------------------------------------------------------
*/}}
{{define "C++.MapIteration"}}
  {{AssertType $ "MapIteration"}}

  {{$i := Macro "C++.LocalName" $.IndexIterator}}
  {{$k := Macro "C++.LocalName" $.KeyIterator}}
  {{$v := Macro "C++.LocalName" $.ValueIterator}}
  {
    {{Template "C++.Type" $.IndexIterator}} {{$i}} = 0;
    for ({{Template "C++.Type" $.Map}}::iterator it = {{Template "C++.Read" $.Map}}.begin(); it != {{Template "C++.Read" $.Map}}.end(); ++it, ++{{$i}}) {
      {{Template "C++.Type" $.KeyIterator}}& {{$k}} = it->first;
      {{Template "C++.Type" $.ValueIterator}}& {{$v}} = it->second;
      {{Template "C++.Block" $.Block}}
    }
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to read the given expression.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Read"}}
  {{     if IsBoolValue        $}}{{$}}
  {{else if IsNumericValue     $}}{{Template "C++.NumericValue" $}}
  {{else if IsStringValue      $}}gapil::String({{Template "C++.Arena"}}, {{printf "%q" $}})
  {{else if IsMessageValue     $}}"{{$.AST.Name.Value}}"
  {{else if IsParameter        $}}{{Template "C++.ReadParameter" $}}
  {{else if IsBinaryOp         $}}({{Template "C++.Read" $.LHS}}) {{$.Operator}} ({{Template "C++.Read" $.RHS}})
  {{else if IsUnaryOp          $}}{{$.Operator}}({{Template "C++.Read" $.Expression}})
  {{else if IsEnumEntry        $}}{{Template "C++.EnumName" $.Owner}}::{{Template "C++.EnumEntryName" $}}
  {{else if IsLocal            $}}{{Template "C++.LocalName" $}}
  {{else if IsBitTest          $}}({{Template "C++.Read" $.Bitfield}} & {{Template "C++.Read" $.Bits}}) != 0
  {{else if IsBinaryOp         $}}({{Template "C++.Read" $.LHS}}) {{$.Operator}} ({{Template "C++.Read" $.RHS}})
  {{else if IsCast             $}}{{Template "C++.Cast" $}}
  {{else if IsCall             $}}{{Template "C++.Call" $}}
  {{else if IsUnknown          $}}{{Global "C++.InferredExpression" "1"}}{{Template "C++.Read" $.Inferred}}{{Global "C++.InferredExpression" ""}}
  {{else if IsObserved         $}}{{Template "C++.Read" $.Parameter}}
  {{else if IsMember           $}}{{Template "C++.Dereference" $.Object}}{{Template "C++.Read" $.Field}}
  {{else if IsGlobal           $}}{{Template "C++.Global" $}}
  {{else if IsArrayIndex       $}}{{Template "C++.Read" $.Array}}[{{Template "C++.Read" $.Index}}]
  {{else if IsMapIndex         $}}{{Template "C++.Read" $.Map}}.findOrZero({{Template "C++.Read" $.Index}})
  {{else if IsMapContains      $}}{{Template "C++.Read" $.Map}}.contains({{Template "C++.Read" $.Key}})
  {{else if IsLength           $}}{{Template "C++.Type" $.Type}}(({{Template "C++.ReadLength" "Type" (TypeOf $.Object) "Value" $.Object}}))
  {{else if IsNull             $}}{{Template "C++.Null" $.Type}}
  {{else if IsNew              $}}gapil::Ref<{{Template "C++.Type" (Unpack $.Type).To}}>::create({{Template "C++.Arena"}})
  {{else if IsCreate           $}}{{Template "C++.Create" $}}
  {{else if IsArrayInitializer $}}{{Template "C++.ArrayInitializer" $}}
  {{else if IsClassInitializer $}}{{Template "C++.ClassInitializer" $}}
  {{else if IsSliceContains    $}}{{Template "C++.Read" $.Slice}}.contains({{Template "C++.Read" $.Value}})
  {{else if IsSliceIndex       $}}{{Template "C++.SliceIndex" $}}
  {{else if IsSliceRange       $}}slice({{Template "C++.Read" $.Slice}}, {{Template "C++.Read" $.Range.LHS}}, {{Template "C++.Read" $.Range.RHS}})
  {{else if IsPointerRange     $}}slice({{Template "C++.Read" $.Pointer}}, {{Template "C++.Read" $.Range.LHS}}, {{Template "C++.Read" $.Range.RHS}})
  {{else if IsClone            $}}observer->clone({{Template "C++.Read" $.Slice}})
  {{else if IsMake             $}}make<{{Template "C++.Type" ($.Type | Unpack).To}}>(observer, {{Template "C++.Read" $.Size}})
  {{else if IsSelect           $}}{{Template "C++.Select" $}}
  {{else if IsField            $}}m{{$.Name}}
  {{else if IsCallable         $}}
    &{{Title (Global "API")}}Spy::{{Template "C++.MethodName" $.Function}}
  {{else}}{{Error "macro C++.Read called with unsupported type: %T" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to read the given expression, skipping any outer casts.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReadParameter"}}
  {{AssertType $ "Parameter"}}

  {{$ty := TypeOf $}}
  {{if IsString $ty}}gapil::String({{Template "C++.Arena"}}, {{$.Name}})
  {{else           }}{{$.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to read the given expression, skipping any outer casts.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReadNoCast"}}
  {{if IsCast $}}{{Template "C++.ReadNoCast" $.Object}}
  {{else}}{{Template "C++.Read" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to read the given expression used as a call argument.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReadAsCallArgument"}}
  {{$wasCallArgument := Global "CallArgument"}}
  {{Global "IsCallArgument" true}}
  {{$arg := Macro "C++.Read" $}}
  {{Global "IsCallArgument" $wasCallArgument}}

  {{$ty := TypeOf $}}
  {{     if IsParameter $  }}{{$.Name}}
  {{else if IsString    $ty}}({{$arg}}).c_str()
  {{else}}{{$arg}}
  {{end}}

{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ for the numerical literal value.
-------------------------------------------------------------------------------
*/}}
{{define "C++.NumericValue"}}
  {{     if IsInt8Value    $}}static_cast<int8_t>({{$}})
  {{else if IsUint8Value   $}}static_cast<uint8_t>({{$}}U)
  {{else if IsInt16Value   $}}static_cast<int16_t>({{$}})
  {{else if IsUint16Value  $}}static_cast<uint16_t>({{$}}U)
  {{else if IsInt32Value   $}}static_cast<int32_t>({{$}})
  {{else if IsUint32Value  $}}static_cast<uint32_t>({{$}}U)
  {{else if IsInt64Value   $}}static_cast<int64_t>({{$}})
  {{else if IsUint64Value  $}}static_cast<uint64_t>({{$}}U)
  {{else if IsFloat32Value $}}{{$s := print $}}{{$s}}{{if not (Contains "." $s)}}.{{end}}f
  {{else if IsFloat64Value $}}{{$}}
  {{else}}{{Error "macro C++.NumericValue called with unsupported type: %T" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to initialize a new instance of an array.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ArrayInitializer"}}
  {{AssertType $ "ArrayInitializer"}}

  {{$values := ForEach $.Values "C++.Read" | JoinWith ", "}}

  {{if Global "IsCallArgument"}}
    std::move({{Template "C++.Type" $.Array}}{{"{"}}{{$values}}{{"}"}})
  {{else}}
    {{"{"}}{{$values}}{{"}"}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to initialize a new instance of a class.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ClassInitializer"}}
  {{AssertType $ "ClassInitializer"}}

  {{Template "C++.Type" $}}(ยง
    {{range $i, $v := $.InitialValues}}
      {{if $i}}, ยง{{end}}
      {{if IsNil $v}}
        {{Template "C++.Null" (TypeOf (index $.Class.Fields $i))}}
      {{else}}
        {{Template "C++.Read" $v}}
      {{end}}ยง
    {{end}}
  )
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to return a pointer to a new instance of a class.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Create"}}
  {{AssertType $ "Create"}}

  {{$ty := Unpack $.Type}}
  gapil::Ref<{{Template "C++.Type" $ty.To}}>::create({{Template "C++.Arena"}}, {{Template "C++.ClassInitializer" $.Initializer}})
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a C++ logic to access a global variable.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Global"}}
  {{AssertType $ "Global"}}

  {{if eq $.Name "$Thread"}}observer->getCurrentThread()
  {{else                  }}mState.{{$.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a C++ dereference (-> or .) for the given value.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Dereference"}}
  {{if (IsReference (TypeOf $))}}
    ({{Template "C++.Read" $}})->
  {{else}}
    {{Template "C++.Read" $}}.
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a comma-separated list of reads as call arguments.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReadListAsCallArgument"}}
  {{$wasCallArgument := Global "CallArgument"}}
  {{Global "IsCallArgument" true}}
  {{range $i, $v := $}}
    {{if $i}}, {{end}}{{Template "C++.ReadAsCallArgument" $v}}ยง
  {{end}}
  {{Global "IsCallArgument" $wasCallArgument}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to execute a cast expression.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Cast"}}
  {{AssertType $ "Cast"}}

  {{$src_ty := $.Object | TypeOf | Underlying | Unpack}}
  {{$dst_ty := $.Type | Underlying | Unpack}}
  {{$src    := Macro "C++.ReadAsCallArgument" $.Object}}

  {{/* A[] -> B[] */}}{{if and (IsSlice $src_ty) (IsSlice $dst_ty)}}
    {{$src}}.as<{{Template "C++.Type" $dst_ty.To}}>()
  {{/* T[] -> T* */}}{{else if and (IsSlice $src_ty) (IsPointer $dst_ty)}}
    {{$src}}.begin()
  {{/* char* -> string */}}{{else if and (IsPointer $src_ty) (IsString $dst_ty)}}
    observer->string({{$src}})
  {{/* char[] -> string */}}{{else if and (IsSlice $src_ty) (IsString $dst_ty)}}
    observer->string({{$src}})
  {{/* string -> char[] */}}{{else if and (IsString $src_ty) (IsSlice $dst_ty)}}
    slice(observer, {{$src}})
  {{else}}
    ({{Template "C++.Type" $.Type}})({{$src}})
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the logic to read the length of the specified expression by
  Value and Type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.ReadLength"}}
  {{AssertType $.Type "Type"}}

  {{$ty := Unpack $.Type}}
  {{     if IsPseudonym   $ty}}{{Template "C++.ReadLength" "Type" $ty.To "Value" $.Value}}
  {{else if IsSlice       $ty}}{{Template "C++.Read" $.Value}}.count()
  {{else if IsString      $ty}}{{Template "C++.Read" $.Value}}.length()
  {{else if IsMap         $ty}}{{Template "C++.Read" $.Value}}.count()
  {{else                     }}{{Error "macro C++.ReadLength called with unsupported type: %v" $.Type}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to execute a call expression.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Call"}}
  {{AssertType $ "Call"}}

  {{$args := Macro "C++.ReadListAsCallArgument" $.Arguments}}

  {{if $.Target.Function.Subroutine}}
    {{Template "C++.MethodName" $.Target.Function}}({{Strings "observer" "call" $args | JoinWith ", "}})
  {{else if $.Target.Object}}
    {{Template "C++.Read" $.Target.Object}}.{{Template "C++.MethodName" $.Target.Function}}({{$args}})
  {{else}}
    {{Template "C++.MethodName" $.Target.Function}}({{Strings "observer" $args | JoinWith ", "}})
  {{end}}

{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic to execute a slice index operation.
-------------------------------------------------------------------------------
*/}}
{{define "C++.SliceIndex"}}
  {{AssertType $ "SliceIndex"}}

  {{if Global "C++.InferredExpression"}}
    {{Template "C++.Read" $.Slice}}[{{Template "C++.Read" $.Index}}]
  {{else}}
    observer->read({{Template "C++.Read" $.Slice}}, {{Template "C++.Read" $.Index}})
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ logic for a select expression.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Select"}}
  {{AssertType $ "Select"}}

  /* switch({{Template "C++.Read" $.Value}}) */ยป
    [&]() -> {{Template "C++.Type" $.Type}} {
      switch({{Template "C++.Read" $.Value}}) {
        {{range $c := $.Choices}}
          /* case {{range $i, $cond := $c.Conditions}}{{if $i}}, {{end}}{{Template "C++.Read" $cond}}{{end}}: */
          {{range $i, $cond := $c.Conditions}}
          case {{Template "C++.Read" $cond}}:
          {{end}} {
            return ({{Template "C++.Read" $c.Expression}});
          }
        {{end}}
        default:
        {{if $.Default}} {
          return {{Template "C++.Read" $.Default}};ยซ
        }
        {{else}} {
          return {{Template "C++.Null" $.Type}};ยซ
        }
        {{end}}
      }
    }()
{{end}}


{{/*
-------------------------------------------------------------------------------
  Transforms the given string or identifier into a format used for a public
  type or field. Example:
    this_is_public -> ThisIsPublic
-------------------------------------------------------------------------------
*/}}
{{define "C++.Public"}}
  {{AssertType $ "string"}}

  {{$ | SplitOn "_" | Title}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a comment stating that the file is automatically generated.
-------------------------------------------------------------------------------
*/}}
{{define "C++.GeneratedHeader"}}โ{{Copyright "generated" "apic"}}โ{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the copyright header.
-------------------------------------------------------------------------------
*/}}
{{define "C++.Copyright"}}โ{{Copyright "generated_c" "apic"}}โ{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a comment block containing the specified text.
-------------------------------------------------------------------------------
*/}}
{{define "C++.CommentHeader"}}
  {{AssertType $ "string"}} {{/* The comment block body text */}}
  ////////////////////////////////////////////////////////////////////////////////
  // {{.}}
  ////////////////////////////////////////////////////////////////////////////////
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ name of an enum type.
-------------------------------------------------------------------------------
*/}}
{{define "C++.EnumName"}}
  {{AssertType $ "Enum"}}

  {{if $p := Global "prefix"}}{{$p}}{{Title $.Name}}
  {{else}}{{$.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ name of an enum entry.
-------------------------------------------------------------------------------
*/}}
{{define "C++.EnumEntryName"}}
  {{AssertType $.Owner "Enum"}}
  {{AssertType $.Name "string"}}

  {{/* TODO: Get rid of enum prefixes. */}}
  {{if $enumPrefix := GetAnnotation $.Owner "prefix"}}
    {{index $enumPrefix.Arguments 0}}_ยง
  {{else if $apiPrefix := Global "prefix"}}
    {{Upper $apiPrefix}}_ยง
    {{$.Owner.Name | SplitPascalCase | Upper | JoinWith "_"}}_ยง
  {{end}}
  {{TrimLeft "_" $.Name}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the printf format code for the specified type
-------------------------------------------------------------------------------
*/}}
{{define "C++.PrintfFormatCode"}}
  {{if not (IsType $)}}{{Template "C++.PrintfFormatCode" (TypeOf $)}}
  {{else if IsPseudonym     $}}{{Template "C++.PrintfFormatCode" $.To}}
  {{else if IsPointer       $}}%p
  {{else if IsStaticArray   $}}%s {{/* TODO */}}
  {{else if IsClass         $}}%s
  {{else if IsString        $}}%s
  {{else if IsBool          $}}%d
  {{else if IsU8            $}}%" PRIu8 "
  {{else if IsS8            $}}%" PRId8 "
  {{else if IsU16           $}}%" PRIu16 "
  {{else if IsS16           $}}%" PRId16 "
  {{else if IsF32           $}}%f
  {{else if IsU32           $}}%" PRIu32 "
  {{else if IsS32           $}}%" PRId32 "
  {{else if IsF64           $}}%f
  {{else if IsU64           $}}%" PRIu64 "
  {{else if IsS64           $}}%" PRId64 "
  {{else if IsInt           $}}%d
  {{else if IsUint          $}}%u
  {{else if IsSize          $}}%" PRIsize "
  {{else if IsEnum          $}}0x%X
  {{else}}{{Error "C++.PrintfFormatCode passed unsupported type: %s" $.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a printf-style string and arguments for logging a call to command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.PrintfCommandCall"}}
  {{AssertType $ "Function"}}

  {{$name := Macro "CmdName" $}}
  {{$args := Macro "C++.PrintfArguments" $}}

  "{{$name}}({{ForEach $.CallParameters "C++.PrintfFormatCode" | JoinWith ", "}})"
  {{if $args}}ยง, {{$args}}{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a printf-style string and arguments for logging a call to command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.PrintfCommandCallWithLabel"}}
  {{AssertType $ "Function"}}

  {{$name := Macro "CmdName" $}}
  {{$args := Macro "C++.PrintfArguments" $}}

  "[%u]{{$name}}({{ForEach $.CallParameters "C++.PrintfFormatCode" | JoinWith ", "}})"
  , cmdLabel{{if $args}}ยง, {{$args}}{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the comma-separated list of arguments for the given function ready for printf.
-------------------------------------------------------------------------------
*/}}
{{define "C++.PrintfArguments"}}
  {{AssertType $ "Function"}}

  {{range $i, $p := $.CallParameters}}
    {{if $i}}, {{end}}
    {{$ty := TypeOf $p}}
    {{if      IsStaticArray $ty}}"<static-array>"{{/* TODO */}}
    {{else if IsClass       $ty}}"<{{$ty.Name}}>"{{/* TODO */}}
    {{else if IsEnum        $ty}}static_cast<uint32_t>({{$p.Name}})
    {{else                     }}{{$p.Name}}
    {{end}}ยง
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits the typedef function-pointer name for a given command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.FunctionPtrType"}}
  {{AssertType $ "Function"}}

  PFN{{Macro "CmdName" $ | Upper}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ function-pointer typedef for a given command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.TypedefFunctionPtr"}}
  {{AssertType $ "Function"}}

  typedef {{Template "C++.ReturnType" $}} ({{Upper (Global "API")}}_API_PTR *{{Template "C++.FunctionPtrType" $}})({{Template "C++.CallParameters" $}});
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ function-pointer variable extern for a given command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.FunctionPtrDecl"}}
  {{AssertType $ "Function"}}

  {{Template "C++.FunctionPtrType" $}} {{Template "CmdName" $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the C++ lazy resolved function variable extern for a given command.
-------------------------------------------------------------------------------
*/}}
{{define "C++.LazyResolvedFunctionDecl"}}
  {{AssertType $ "Function"}}

  LazyResolved<{{Template "C++.FunctionPtrType" $}}> {{Template "CmdName" $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the method name for the given command or subroutine.
-------------------------------------------------------------------------------
*/}}
{{define "C++.MethodName"}}
  {{AssertType $ "Function"}}

  {{$name := Macro "CmdName" $}}
  {{if $.Subroutine}}sub{{$name | Title}}{{else}}{{$name}}{{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the logic to set a proto field.
-------------------------------------------------------------------------------
*/}}
{{define "C++.SetProtoField"}}
  {{AssertType $.Proto  "string"}}
  {{AssertType $.Prefix "string"}}
  {{AssertType $.Name   "string"}}

  {{$setter := $.Name | Strings | Lower | ProtoCppName }}
  {{$ty := $.Type | TypeOf | Underlying}}
  {{if      IsClass       $ty}}{{$.Prefix}}{{$.Name}}.toProto({{$.Proto}}mutable_{{$setter}}(), pbCtx);
  {{else if IsPointer     $ty}}{{$.Proto}}set_{{$setter}}(reinterpret_cast<uint64_t>({{$.Prefix}}{{$.Name}}));
  {{else if IsSlice       $ty}}::gapii::toProto({{$.Proto}}mutable_{{$setter}}(), {{$.Prefix}}{{$.Name}}, pbCtx);
  {{else if IsStaticArray $ty}}::gapii::toProto({{$.Proto}}mutable_{{$setter}}(), core::StaticArray<{{Macro "C++.Type" $ty.ValueType}}, {{$ty.Size}}>({{$.Prefix}}{{$.Name}}), pbCtx);
  {{else if IsMap         $ty}}::gapii::toProto({{$.Proto}}mutable_{{$setter}}(), {{$.Prefix}}{{$.Name}}, pbCtx);
  {{else if IsReference   $ty}}::gapii::toProto({{$.Proto}}mutable_{{$setter}}(), {{$.Prefix}}{{$.Name}}, pbCtx);
  {{else if IsString      $ty}}{{$.Proto}}set_{{$setter}}(::gapii::toProtoString({{$.Prefix}}{{$.Name}}));
  {{else                     }}{{$.Proto}}set_{{$setter}}({{$.Prefix}}{{$.Name}});
  {{end}}
{{end}}
