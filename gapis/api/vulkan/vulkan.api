// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

api_index 2

import "android/vulkan_android.api"
import "linux/vulkan_linux.api"
import "windows/vulkan_windows.api"
import "synthetic.api"
import "errors.api"

///////////////
// Constants //
///////////////

// API version (major.minor.patch)
define VERSION_MAJOR 1
define VERSION_MINOR 0
define VERSION_PATCH 3

// API limits
define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
define VK_UUID_SIZE                     16

define VK_MAX_EXTENSION_NAME_SIZE 256
define VK_MAX_DESCRIPTION_SIZE    256
define VK_MAX_MEMORY_TYPES        32
define VK_MAX_MEMORY_HEAPS        16 /// The maximum number of unique memory heaps, each of which supporting 1 or more memory types.

// API keywords
define VK_TRUE  1
define VK_FALSE 0

// API keyword, but needs special handling by some templates
define NULL_HANDLE 0

@extension("VK_KHR_surface") define VK_KHR_SURFACE_SPEC_VERSION   25
@extension("VK_KHR_surface") define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"

@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_SPEC_VERSION   67
@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"

@extension("VK_KHR_display") define VK_KHR_DISPLAY_SPEC_VERSION   21
@extension("VK_KHR_display") define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"

@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION   9
@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_SPEC_VERSION   1
@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"

@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_SPEC_VERSION   4
@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

/////////////
//  Types  //
/////////////

type u32 VkFlags
type u32 VkBool32
type u64 VkDeviceSize
type u32 VkSampleMask

/// Dispatchable handle types.
@replay_remap @dispatchHandle type size VkInstance
@replay_remap @dispatchHandle type size VkPhysicalDevice
@replay_remap @dispatchHandle type size VkDevice
@replay_remap @dispatchHandle type size VkQueue
@replay_remap @dispatchHandle type size VkCommandBuffer

/// Non dispatchable handle types.
@replay_remap @nonDispatchHandle type u64 VkSemaphore
@replay_remap @nonDispatchHandle type u64 VkFence
@replay_remap @nonDispatchHandle type u64 VkDeviceMemory
@replay_remap @nonDispatchHandle type u64 VkBuffer
@replay_remap @nonDispatchHandle type u64 VkImage
@replay_remap @nonDispatchHandle type u64 VkEvent
@replay_remap @nonDispatchHandle type u64 VkQueryPool
@replay_remap @nonDispatchHandle type u64 VkBufferView
@replay_remap @nonDispatchHandle type u64 VkImageView
@replay_remap @nonDispatchHandle type u64 VkShaderModule
@replay_remap @nonDispatchHandle type u64 VkPipelineCache
@replay_remap @nonDispatchHandle type u64 VkPipelineLayout
@replay_remap @nonDispatchHandle type u64 VkRenderPass
@replay_remap @nonDispatchHandle type u64 VkPipeline
@replay_remap @nonDispatchHandle type u64 VkDescriptorSetLayout
@replay_remap @nonDispatchHandle type u64 VkSampler
@replay_remap @nonDispatchHandle type u64 VkDescriptorPool
@replay_remap @nonDispatchHandle type u64 VkDescriptorSet
@replay_remap @nonDispatchHandle type u64 VkFramebuffer
@replay_remap @nonDispatchHandle type u64 VkCommandPool

@extension("VK_KHR_surface") @replay_remap @nonDispatchHandle type u64 VkSurfaceKHR

@extension("VK_KHR_swapchain") @replay_remap @nonDispatchHandle type u64 VkSwapchainKHR

@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayKHR
@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayModeKHR

@extension("VK_EXT_debug_report") @replay_remap @nonDispatchHandle type u64 VkDebugReportCallbackEXT


/////////////
//  Enums  //
/////////////

extern void mapMemory(void** mem, u8[] slice)
extern void unmapMemory(u8[] slice)
extern void trackMappedCoherentMemory(u64 start, size size)
extern void readMappedCoherentMemory(VkDeviceMemory memory, u64 offset_in_mapped, size readSize)
extern void untrackMappedCoherentMemory(u64 start, size size)

@unused
enum VkPipelineCacheHeaderVersion {
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

@lastUnused(-11)
/// Error and return codes
enum VkResult {
  // Return codes for successful operation execution (positive values)
  VK_SUCCESS     = 0,
  VK_NOT_READY   = 1,
  VK_TIMEOUT     = 2,
  VK_EVENT_SET   = 3,
  VK_EVENT_RESET = 4,
  VK_INCOMPLETE  = 5,

  // Error codes (negative values)
  VK_ERROR_OUT_OF_HOST_MEMORY    = 0xFFFFFFFF, // -1
  VK_ERROR_OUT_OF_DEVICE_MEMORY  = 0xFFFFFFFE, // -2
  VK_ERROR_INITIALIZATION_FAILED = 0xFFFFFFFD, // -3
  VK_ERROR_DEVICE_LOST           = 0xFFFFFFFC, // -4
  VK_ERROR_MEMORY_MAP_FAILED     = 0xFFFFFFFB, // -5
  VK_ERROR_LAYER_NOT_PRESENT     = 0xFFFFFFFA, // -6
  VK_ERROR_EXTENSION_NOT_PRESENT = 0xFFFFFFF9, // -7
  VK_ERROR_FEATURE_NOT_PRESENT   = 0xFFFFFFF8, // -8
  VK_ERROR_INCOMPATIBLE_DRIVER   = 0xFFFFFFF7, // -9
  VK_ERROR_TOO_MANY_OBJECTS      = 0xFFFFFFF6, // -10
  VK_ERROR_FORMAT_NOT_SUPPORTED  = 0xFFFFFFF5, // -11

  //@extension("VK_KHR_surface")
  VK_ERROR_SURFACE_LOST_KHR = 0xC4653600, // -1000000000

  //@extension("VK_KHR_surface")
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = 0xC46535FF, // -1000008001

  //@extension("VK_KHR_swapchain")
  VK_SUBOPTIMAL_KHR = 1000001003,

  //@extension("VK_KHR_swapchain")
  VK_ERROR_OUT_OF_DATE_KHR = 0xC4653214, // -1000001004

  //@extension("VK_KHR_display_swapchain")
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = 0xC4652A47, // -1000003001

  //@extension("VK_EXT_debug_report")
  VK_ERROR_VALIDATION_FAILED_EXT = 0xC4650B07, // -1000011001

  VK_ERROR_INVALID_SHADER_NV = 0x3B9AF8E0, // -1000012000
}

/// Structure type enumerant
enum VkStructureType {
  VK_STRUCTURE_TYPE_APPLICATION_INFO                          = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                      = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                  = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                        = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO                               = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                      = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                       = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                          = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                         = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                     = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                         = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                    = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                        = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                   = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                         = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                    = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                 = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO         = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO   = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO   = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO       = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO  = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO    = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO  = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO    = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO        = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO             = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO              = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO               = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                       = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO         = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO               = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO              = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                      = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                       = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                   = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                   = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                  = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO              = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO           = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                 = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                    = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                     = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                      = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER                            = 46,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO               = 47,
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                 = 48,

  //@extension("VK_KHR_swapchain")
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR          = 1000001001,

  //@extension("VK_KHR_display")
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR    = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,

  //@extension("VK_KHR_display_swapchain")
  VK_STRUCTURE_TYPE_DISPLAY_DISPLAY_PRESENT_INFO_KHR = 1000003000,

  //@extension("VK_KHR_xlib_surface")
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,

  //@extension("VK_KHR_xcb_surface")
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,

  //@extension("VK_KHR_wayland_surface")
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,

  //@extension("VK_KHR_mir_surface")
  VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,

  //@extension("VK_KHR_android_surface")
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,

  //@extension("VK_KHR_win32_surface")
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,

  //@extension("VK_ANDROID_native_buffer")
  VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,

  //@extension("VK_EXT_debug_report")
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,

  //@extension("VK_EXT_debug_marker")
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT  = 1000022001
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT      = 1000022002

  //@extension("VK_NV_dedicated_allocation")
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV    = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV   = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,

  //@extension("VK_KHR_get_memory_requirements2")
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR       = 1000146000,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR        = 1000146001,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR                   = 1000146003,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR      = 1000146004,

  //@extension("VK_KHR_dedicated_allocation")
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR  = 1000127000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,

  //@extension("VK_KHR_get_physical_device_properties2")
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR                 = 1000059000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR               = 1000059001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                        = 1000059002,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR                  = 1000059003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR        = 1000059004,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR                  = 1000059005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR        = 1000059006,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR           = 1000059007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,

  //@extension("VK_KHR_get_surface_capabilities2")
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR         = 1000119001,
  VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR               = 1000119002,
}

enum VkSystemAllocationScope {
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND  = 0x00000000,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT   = 0x00000001,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE    = 0x00000002,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE   = 0x00000003,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 0x00000004,
}

enum VkInternalAllocationType {
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0x00000000,
}

/// Vulkan format definitions
enum VkFormat {
  VK_FORMAT_UNDEFINED                  = 0,
  VK_FORMAT_R4G4_UNORM_PACK8           = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16      = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16      = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16        = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16        = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16      = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16      = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16      = 8,
  VK_FORMAT_R8_UNORM                   = 9,
  VK_FORMAT_R8_SNORM                   = 10,
  VK_FORMAT_R8_USCALED                 = 11,
  VK_FORMAT_R8_SSCALED                 = 12,
  VK_FORMAT_R8_UINT                    = 13,
  VK_FORMAT_R8_SINT                    = 14,
  VK_FORMAT_R8_SRGB                    = 15,
  VK_FORMAT_R8G8_UNORM                 = 16,
  VK_FORMAT_R8G8_SNORM                 = 17,
  VK_FORMAT_R8G8_USCALED               = 18,
  VK_FORMAT_R8G8_SSCALED               = 19,
  VK_FORMAT_R8G8_UINT                  = 20,
  VK_FORMAT_R8G8_SINT                  = 21,
  VK_FORMAT_R8G8_SRGB                  = 22,
  VK_FORMAT_R8G8B8_UNORM               = 23,
  VK_FORMAT_R8G8B8_SNORM               = 24,
  VK_FORMAT_R8G8B8_USCALED             = 25,
  VK_FORMAT_R8G8B8_SSCALED             = 26,
  VK_FORMAT_R8G8B8_UINT                = 27,
  VK_FORMAT_R8G8B8_SINT                = 28,
  VK_FORMAT_R8G8B8_SRGB                = 29,
  VK_FORMAT_B8G8R8_UNORM               = 30,
  VK_FORMAT_B8G8R8_SNORM               = 31,
  VK_FORMAT_B8G8R8_USCALED             = 32,
  VK_FORMAT_B8G8R8_SSCALED             = 33,
  VK_FORMAT_B8G8R8_UINT                = 34,
  VK_FORMAT_B8G8R8_SINT                = 35,
  VK_FORMAT_B8G8R8_SRGB                = 36,
  VK_FORMAT_R8G8B8A8_UNORM             = 37,
  VK_FORMAT_R8G8B8A8_SNORM             = 38,
  VK_FORMAT_R8G8B8A8_USCALED           = 39,
  VK_FORMAT_R8G8B8A8_SSCALED           = 40,
  VK_FORMAT_R8G8B8A8_UINT              = 41,
  VK_FORMAT_R8G8B8A8_SINT              = 42,
  VK_FORMAT_R8G8B8A8_SRGB              = 43,
  VK_FORMAT_B8G8R8A8_UNORM             = 44,
  VK_FORMAT_B8G8R8A8_SNORM             = 45,
  VK_FORMAT_B8G8R8A8_USCALED           = 46,
  VK_FORMAT_B8G8R8A8_SSCALED           = 47,
  VK_FORMAT_B8G8R8A8_UINT              = 48,
  VK_FORMAT_B8G8R8A8_SINT              = 49,
  VK_FORMAT_B8G8R8A8_SRGB              = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32      = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32      = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32    = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32    = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32       = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32       = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32       = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32   = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32   = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32    = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32    = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32   = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32   = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32    = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32    = 69,
  VK_FORMAT_R16_UNORM                  = 70,
  VK_FORMAT_R16_SNORM                  = 71,
  VK_FORMAT_R16_USCALED                = 72,
  VK_FORMAT_R16_SSCALED                = 73,
  VK_FORMAT_R16_UINT                   = 74,
  VK_FORMAT_R16_SINT                   = 75,
  VK_FORMAT_R16_SFLOAT                 = 76,
  VK_FORMAT_R16G16_UNORM               = 77,
  VK_FORMAT_R16G16_SNORM               = 78,
  VK_FORMAT_R16G16_USCALED             = 79,
  VK_FORMAT_R16G16_SSCALED             = 80,
  VK_FORMAT_R16G16_UINT                = 81,
  VK_FORMAT_R16G16_SINT                = 82,
  VK_FORMAT_R16G16_SFLOAT              = 83,
  VK_FORMAT_R16G16B16_UNORM            = 84,
  VK_FORMAT_R16G16B16_SNORM            = 85,
  VK_FORMAT_R16G16B16_USCALED          = 86,
  VK_FORMAT_R16G16B16_SSCALED          = 87,
  VK_FORMAT_R16G16B16_UINT             = 88,
  VK_FORMAT_R16G16B16_SINT             = 89,
  VK_FORMAT_R16G16B16_SFLOAT           = 90,
  VK_FORMAT_R16G16B16A16_UNORM         = 91,
  VK_FORMAT_R16G16B16A16_SNORM         = 92,
  VK_FORMAT_R16G16B16A16_USCALED       = 93,
  VK_FORMAT_R16G16B16A16_SSCALED       = 94,
  VK_FORMAT_R16G16B16A16_UINT          = 95,
  VK_FORMAT_R16G16B16A16_SINT          = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT        = 97,
  VK_FORMAT_R32_UINT                   = 98,
  VK_FORMAT_R32_SINT                   = 99,
  VK_FORMAT_R32_SFLOAT                 = 100,
  VK_FORMAT_R32G32_UINT                = 101,
  VK_FORMAT_R32G32_SINT                = 102,
  VK_FORMAT_R32G32_SFLOAT              = 103,
  VK_FORMAT_R32G32B32_UINT             = 104,
  VK_FORMAT_R32G32B32_SINT             = 105,
  VK_FORMAT_R32G32B32_SFLOAT           = 106,
  VK_FORMAT_R32G32B32A32_UINT          = 107,
  VK_FORMAT_R32G32B32A32_SINT          = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT        = 109,
  VK_FORMAT_R64_UINT                   = 110,
  VK_FORMAT_R64_SINT                   = 111,
  VK_FORMAT_R64_SFLOAT                 = 112,
  VK_FORMAT_R64G64_UINT                = 113,
  VK_FORMAT_R64G64_SINT                = 114,
  VK_FORMAT_R64G64_SFLOAT              = 115,
  VK_FORMAT_R64G64B64_UINT             = 116,
  VK_FORMAT_R64G64B64_SINT             = 117,
  VK_FORMAT_R64G64B64_SFLOAT           = 118,
  VK_FORMAT_R64G64B64A64_UINT          = 119,
  VK_FORMAT_R64G64B64A64_SINT          = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT        = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32    = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32     = 123,
  VK_FORMAT_D16_UNORM                  = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32        = 125,
  VK_FORMAT_D32_SFLOAT                 = 126,
  VK_FORMAT_S8_UINT                    = 127,
  VK_FORMAT_D16_UNORM_S8_UINT          = 128,
  VK_FORMAT_D24_UNORM_S8_UINT          = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT         = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK        = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK         = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK       = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK        = 134,
  VK_FORMAT_BC2_UNORM_BLOCK            = 135,
  VK_FORMAT_BC2_SRGB_BLOCK             = 136,
  VK_FORMAT_BC3_UNORM_BLOCK            = 137,
  VK_FORMAT_BC3_SRGB_BLOCK             = 138,
  VK_FORMAT_BC4_UNORM_BLOCK            = 139,
  VK_FORMAT_BC4_SNORM_BLOCK            = 140,
  VK_FORMAT_BC5_UNORM_BLOCK            = 141,
  VK_FORMAT_BC5_SNORM_BLOCK            = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK          = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK          = 144,
  VK_FORMAT_BC7_UNORM_BLOCK            = 145,
  VK_FORMAT_BC7_SRGB_BLOCK             = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK    = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK     = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK  = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK   = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK  = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK   = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK        = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK        = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK     = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK     = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK       = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK        = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK       = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK        = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK       = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK        = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK       = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK        = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK       = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK        = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK       = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK        = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK       = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK        = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK       = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK        = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK      = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK       = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK      = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK       = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK      = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK       = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK     = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK      = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK     = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK      = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK     = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK      = 184,
}

enum VkImageType {
  VK_IMAGE_TYPE_1D = 0x00000000,
  VK_IMAGE_TYPE_2D = 0x00000001,
  VK_IMAGE_TYPE_3D = 0x00000002,
}

enum VkImageTiling {
  VK_IMAGE_TILING_OPTIMAL = 0x00000000,
  VK_IMAGE_TILING_LINEAR  = 0x00000001,
}

enum VkPhysicalDeviceType {
  VK_PHYSICAL_DEVICE_TYPE_OTHER          = 0x00000000,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 0x00000001,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   = 0x00000002,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    = 0x00000003,
  VK_PHYSICAL_DEVICE_TYPE_CPU            = 0x00000004,
}

enum VkQueryType {
  VK_QUERY_TYPE_OCCLUSION           = 0x00000000,
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 0x00000001, /// Optional
  VK_QUERY_TYPE_TIMESTAMP           = 0x00000002,
}

enum VkSharingMode {
  VK_SHARING_MODE_EXCLUSIVE  = 0x00000000,
  VK_SHARING_MODE_CONCURRENT = 0x00000001,
}

enum VkImageLayout {
  VK_IMAGE_LAYOUT_UNDEFINED                        = 0x00000000, /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
  VK_IMAGE_LAYOUT_GENERAL                          = 0x00000001, /// General layout when image can be used for any kind of access
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL         = 0x00000002, /// Optimal layout when image is only used for color attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 0x00000003, /// Optimal layout when image is only used for depth/stencil attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL  = 0x00000004, /// Optimal layout when image is used for read only depth/stencil attachment and shader access
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL         = 0x00000005, /// Optimal layout when image is used for read only shader access
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL             = 0x00000006, /// Optimal layout when image is used only as source of transfer operations
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL             = 0x00000007, /// Optimal layout when image is used only as destination of transfer operations
  VK_IMAGE_LAYOUT_PREINITIALIZED                   = 0x00000008, /// Initial layout used when the data is populated by the CPU

  //@extension("VK_KHR_swapchain")
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
}

enum VkImageViewType {
  VK_IMAGE_VIEW_TYPE_1D         = 0x00000000,
  VK_IMAGE_VIEW_TYPE_2D         = 0x00000001,
  VK_IMAGE_VIEW_TYPE_3D         = 0x00000002,
  VK_IMAGE_VIEW_TYPE_CUBE       = 0x00000003,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY   = 0x00000004,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY   = 0x00000005,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 0x00000006,
}

enum VkComponentSwizzle {
  VK_COMPONENT_SWIZZLE_IDENTITY = 0x00000000,
  VK_COMPONENT_SWIZZLE_ZERO     = 0x00000001,
  VK_COMPONENT_SWIZZLE_ONE      = 0x00000002,
  VK_COMPONENT_SWIZZLE_R        = 0x00000003,
  VK_COMPONENT_SWIZZLE_G        = 0x00000004,
  VK_COMPONENT_SWIZZLE_B        = 0x00000005,
  VK_COMPONENT_SWIZZLE_A        = 0x00000006,
}

enum VkVertexInputRate {
  VK_VERTEX_INPUT_RATE_VERTEX   = 0x00000000,
  VK_VERTEX_INPUT_RATE_INSTANCE = 0x00000001,
}

enum VkPrimitiveTopology {
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST                    = 0x00000000,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST                     = 0x00000001,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                    = 0x00000002,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 = 0x00000003,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                = 0x00000004,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  = 0x00000005,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      = 0x00000006,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     = 0x00000007,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  = 0x00000008,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 0x00000009,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    = 0x0000000a,
}

enum VkPolygonMode {
  VK_POLYGON_MODE_FILL  = 0x00000000,
  VK_POLYGON_MODE_LINE  = 0x00000001,
  VK_POLYGON_MODE_POINT = 0x00000002,
}

enum VkFrontFace {
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0x00000000,
  VK_FRONT_FACE_CLOCKWISE         = 0x00000001,
}

enum VkCompareOp {
  VK_COMPARE_OP_NEVER            = 0x00000000,
  VK_COMPARE_OP_LESS             = 0x00000001,
  VK_COMPARE_OP_EQUAL            = 0x00000002,
  VK_COMPARE_OP_LESS_OR_EQUAL    = 0x00000003,
  VK_COMPARE_OP_GREATER          = 0x00000004,
  VK_COMPARE_OP_NOT_EQUAL        = 0x00000005,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 0x00000006,
  VK_COMPARE_OP_ALWAYS           = 0x00000007,
}

enum VkStencilOp {
  VK_STENCIL_OP_KEEP                = 0x00000000,
  VK_STENCIL_OP_ZERO                = 0x00000001,
  VK_STENCIL_OP_REPLACE             = 0x00000002,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 0x00000003,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 0x00000004,
  VK_STENCIL_OP_INVERT              = 0x00000005,
  VK_STENCIL_OP_INCREMENT_AND_WRAP  = 0x00000006,
  VK_STENCIL_OP_DECREMENT_AND_WRAP  = 0x00000007,
}

enum VkLogicOp {
  VK_LOGIC_OP_CLEAR         = 0x00000000,
  VK_LOGIC_OP_AND           = 0x00000001,
  VK_LOGIC_OP_AND_REVERSE   = 0x00000002,
  VK_LOGIC_OP_COPY          = 0x00000003,
  VK_LOGIC_OP_AND_INVERTED  = 0x00000004,
  VK_LOGIC_OP_NO_OP         = 0x00000005,
  VK_LOGIC_OP_XOR           = 0x00000006,
  VK_LOGIC_OP_OR            = 0x00000007,
  VK_LOGIC_OP_NOR           = 0x00000008,
  VK_LOGIC_OP_EQUIVALENT    = 0x00000009,
  VK_LOGIC_OP_INVERT        = 0x0000000a,
  VK_LOGIC_OP_OR_REVERSE    = 0x0000000b,
  VK_LOGIC_OP_COPY_INVERTED = 0x0000000c,
  VK_LOGIC_OP_OR_INVERTED   = 0x0000000d,
  VK_LOGIC_OP_NAND          = 0x0000000e,
  VK_LOGIC_OP_SET           = 0x0000000f,
}

enum VkBlendFactor {
  VK_BLEND_FACTOR_ZERO                     = 0x00000000,
  VK_BLEND_FACTOR_ONE                      = 0x00000001,
  VK_BLEND_FACTOR_SRC_COLOR                = 0x00000002,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      = 0x00000003,
  VK_BLEND_FACTOR_DST_COLOR                = 0x00000004,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      = 0x00000005,
  VK_BLEND_FACTOR_SRC_ALPHA                = 0x00000006,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      = 0x00000007,
  VK_BLEND_FACTOR_DST_ALPHA                = 0x00000008,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      = 0x00000009,
  VK_BLEND_FACTOR_CONSTANT_COLOR           = 0x0000000a,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 0x0000000b,
  VK_BLEND_FACTOR_CONSTANT_ALPHA           = 0x0000000c,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 0x0000000d,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       = 0x0000000e,
  VK_BLEND_FACTOR_SRC1_COLOR               = 0x0000000f,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     = 0x00000010,
  VK_BLEND_FACTOR_SRC1_ALPHA               = 0x00000011,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     = 0x00000012,
}

enum VkBlendOp {
  VK_BLEND_OP_ADD              = 0x00000000,
  VK_BLEND_OP_SUBTRACT         = 0x00000001,
  VK_BLEND_OP_REVERSE_SUBTRACT = 0x00000002,
  VK_BLEND_OP_MIN              = 0x00000003,
  VK_BLEND_OP_MAX              = 0x00000004,
}

enum VkDynamicState {
  VK_DYNAMIC_STATE_VIEWPORT             = 0x00000000,
  VK_DYNAMIC_STATE_SCISSOR              = 0x00000001,
  VK_DYNAMIC_STATE_LINE_WIDTH           = 0x00000002,
  VK_DYNAMIC_STATE_DEPTH_BIAS           = 0x00000003,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS      = 0x00000004,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS         = 0x00000005,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 0x00000006,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK   = 0x00000007,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE    = 0x00000008,
}

enum VkFilter {
  VK_FILTER_NEAREST   = 0x00000000,
  VK_FILTER_LINEAR    = 0x00000001,
  VK_FILTER_CUBIC_IMG = 0x3B9B0498
}

enum VkSamplerMipmapMode {
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0x00000000, /// Choose nearest mip level
  VK_SAMPLER_MIPMAP_MODE_LINEAR  = 0x00000001, /// Linear filter between mip levels
}

enum VkSamplerAddressMode {
  VK_SAMPLER_ADDRESS_MODE_REPEAT               = 0x00000000,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      = 0x00000001,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        = 0x00000002,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      = 0x00000003,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 0x00000004,
}

enum VkBorderColor {
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0x00000000,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   = 0x00000001,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      = 0x00000002,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK        = 0x00000003,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      = 0x00000004,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE        = 0x00000005,
}

// NOTE: when updating this enum, be sure to update vkUpdateDescriptorSets
// in sync.
enum VkDescriptorType {
  VK_DESCRIPTOR_TYPE_SAMPLER                = 0x00000000,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 0x00000001,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE          = 0x00000002,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          = 0x00000003,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   = 0x00000004,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   = 0x00000005,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         = 0x00000006,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         = 0x00000007,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 0x00000008,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 0x00000009,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT       = 0x0000000a,
}

enum VkAttachmentLoadOp {
  VK_ATTACHMENT_LOAD_OP_LOAD      = 0x00000000,
  VK_ATTACHMENT_LOAD_OP_CLEAR     = 0x00000001,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 0x00000002,
}

enum VkAttachmentStoreOp {
  VK_ATTACHMENT_STORE_OP_STORE     = 0x00000000,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 0x00000001,
}

enum VkPipelineBindPoint {
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0x00000000,
  VK_PIPELINE_BIND_POINT_COMPUTE  = 0x00000001,
}

enum VkCommandBufferLevel {
  VK_COMMAND_BUFFER_LEVEL_PRIMARY   = 0x00000000,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 0x00000001,
}

enum VkIndexType {
  VK_INDEX_TYPE_UINT16 = 0x00000000,
  VK_INDEX_TYPE_UINT32 = 0x00000001,
}

enum VkSubpassContents {
  VK_SUBPASS_CONTENTS_INLINE                    = 0x00000000,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 0x00000001,
}



/////////////////
//  Bitfields  //
/////////////////

@reserved_flags
type VkFlags VkInstanceCreateFlags

/// Format capability flags
@unused
bitfield VkFormatFeatureFlagBits {
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                  = 0x00000001, /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                  = 0x00000002, /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT           = 0x00000004, /// Format supports atomic operations in case it's used for storage images
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT           = 0x00000008, /// Format can be used for uniform texel buffers (TBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT           = 0x00000010, /// Format can be used for storage texel buffers (IBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT    = 0x00000020, /// Format supports atomic operations in case it's used for storage texel buffers
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                  = 0x00000040, /// Format can be used for vertex buffers (VBOs)
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT               = 0x00000080, /// Format can be used for color attachment images
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT         = 0x00000100, /// Format supports blending in case it's used for color attachment images
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT       = 0x00000200, /// Format can be used for depth/stencil attachment images
  VK_FORMAT_FEATURE_BLIT_SRC_BIT                       = 0x00000400, /// Format can be used as the source image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_BLIT_DST_BIT                       = 0x00000800, /// Format can be used as the destination image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT    = 0x00001000,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
}
type VkFlags VkFormatFeatureFlags

/// Image usage flags
@unused
bitfield VkImageUsageFlagBits {
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT             = 0x00000001, /// Can be used as a source of transfer operations
  VK_IMAGE_USAGE_TRANSFER_DST_BIT             = 0x00000002, /// Can be used as a destination of transfer operations
  VK_IMAGE_USAGE_SAMPLED_BIT                  = 0x00000004, /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_IMAGE_USAGE_STORAGE_BIT                  = 0x00000008, /// Can be used as storage image (STORAGE_IMAGE descriptor type)
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT         = 0x00000010, /// Can be used as framebuffer color attachment
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020, /// Can be used as framebuffer depth/stencil attachment
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     = 0x00000040, /// Image data not needed outside of rendering
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         = 0x00000080, /// Can be used as framebuffer input attachment
}
type VkFlags VkImageUsageFlags

/// Image creation flags
@unused
bitfield VkImageCreateFlagBits {
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Image should support sparse backing
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Image should support sparse backing with partial residency
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT   = 0x00000008, /// Allows image views to have different format than the base image
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT  = 0x00000010, /// Allows creating image views with cube type from the created image
}
type VkFlags VkImageCreateFlags

bitfield VkSampleCountFlagBits {
  VK_SAMPLE_COUNT_1_BIT  = 0x00000001,
  VK_SAMPLE_COUNT_2_BIT  = 0x00000002,
  VK_SAMPLE_COUNT_4_BIT  = 0x00000004,
  VK_SAMPLE_COUNT_8_BIT  = 0x00000008,
  VK_SAMPLE_COUNT_16_BIT = 0x00000010,
  VK_SAMPLE_COUNT_32_BIT = 0x00000020,
  VK_SAMPLE_COUNT_64_BIT = 0x00000040,
}
type VkFlags VkSampleCountFlags

bitfield VkQueueFlagBits {
  VK_QUEUE_GRAPHICS_BIT       = 0x00000001, /// Queue supports graphics operations
  VK_QUEUE_COMPUTE_BIT        = 0x00000002, /// Queue supports compute operations
  VK_QUEUE_TRANSFER_BIT       = 0x00000004, /// Queue supports transfer operations
  VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008, /// Queue supports sparse resource memory management operations
}
type VkFlags VkQueueFlags

bitfield VkMemoryPropertyFlagBits {
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT     = 0x00000001,
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT     = 0x00000002,
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT    = 0x00000004,
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT      = 0x00000008,
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
}
type VkFlags VkMemoryPropertyFlags

@unused
bitfield VkMemoryHeapFlagBits {
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
}
type VkFlags VkMemoryHeapFlags
@reserved_flags
type VkFlags VkDeviceCreateFlags
@reserved_flags
type VkFlags VkDeviceQueueCreateFlags

/// Pipeline stages
bitfield VkPipelineStageFlagBits {
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                    = 0x00000001, /// Before subsequent commands are processed
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  = 0x00000002, /// Draw/DispatchIndirect command fetch
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   = 0x00000004, /// Vertex/index fetch
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  = 0x00000008, /// Vertex shading
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    = 0x00000010, /// Tessellation control shading
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, /// Tessellation evaluation shading
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                = 0x00000040, /// Geometry shading
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                = 0x00000080, /// Fragment shading
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           = 0x00000100, /// Early fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            = 0x00000200, /// Late fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        = 0x00000400, /// Color attachment writes
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                 = 0x00000800, /// Compute shading
  VK_PIPELINE_STAGE_TRANSFER_BIT                       = 0x00001000, /// Transfer/copy operations
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 = 0x00002000,
  VK_PIPELINE_STAGE_HOST_BIT                           = 0x00004000, /// Indicates host (CPU) is a source/sink of the dependency
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                   = 0x00008000, /// All stages of the graphics pipeline
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                   = 0x00010000, /// All graphics, compute, copy, and transition commands
}
type VkFlags VkPipelineStageFlags
@reserved_flags
type VkFlags VkMemoryMapFlags

bitfield VkImageAspectFlagBits {
  VK_IMAGE_ASPECT_COLOR_BIT    = 0x00000001,
  VK_IMAGE_ASPECT_DEPTH_BIT    = 0x00000002,
  VK_IMAGE_ASPECT_STENCIL_BIT  = 0x00000004,
  VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
}
type VkFlags VkImageAspectFlags

@unused
bitfield VkSparseImageFormatFlagBits {
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         = 0x00000001, /// Image uses a single miptail region for all array slices
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       = 0x00000002, /// Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels.
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004, /// Image uses a non-standard sparse block size
}
type VkFlags VkSparseImageFormatFlags

@unused
bitfield VkSparseMemoryBindFlagBits {
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
}
type VkFlags VkSparseMemoryBindFlags

bitfield VkFenceCreateFlagBits {
  VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
}
type VkFlags VkFenceCreateFlags
@reserved_flags
type VkFlags VkSemaphoreCreateFlags
@reserved_flags
type VkFlags VkEventCreateFlags
@reserved_flags
type VkFlags VkQueryPoolCreateFlags

@unused
bitfield VkQueryPipelineStatisticFlagBits {
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    = 0x00000001, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  = 0x00000002, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  = 0x00000004, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                = 0x00000008, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 = 0x00000010, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       = 0x00000020, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        = 0x00000040, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                = 0x00000080, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        = 0x00000100, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 = 0x00000400, /// Optional
}
type VkFlags VkQueryPipelineStatisticFlags

@unused
bitfield VkQueryResultFlagBits {
  VK_QUERY_RESULT_64_BIT                = 0x00000001, /// Results of the queries are written to the destination buffer as 64-bit values
  VK_QUERY_RESULT_WAIT_BIT              = 0x00000002, /// Results of the queries are waited on before proceeding with the result copy
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004, /// Besides the results of the query, the availability of the results is also written
  VK_QUERY_RESULT_PARTIAL_BIT           = 0x00000008, /// Copy the partial results of the query even if the final results aren't available
}
type VkFlags VkQueryResultFlags

@unused
bitfield VkBufferCreateFlagBits {
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Buffer should support sparse backing
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Buffer should support sparse backing with partial residency
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers
}
type VkFlags VkBufferCreateFlags

type VkFlags VkBufferUsageFlags
@unused
bitfield VkBufferUsageFlagBits {
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT         = 0x00000001, /// Can be used as a source of transfer operations
  VK_BUFFER_USAGE_TRANSFER_DST_BIT         = 0x00000002, /// Can be used as a destination of transfer operations
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004, /// Can be used as TBO
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008, /// Can be used as IBO
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT       = 0x00000010, /// Can be used as UBO
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT       = 0x00000020, /// Can be used as SSBO
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT         = 0x00000040, /// Can be used as source of fixed function index fetch (index buffer)
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT        = 0x00000080, /// Can be used as source of fixed function vertex fetch (VBO)
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT      = 0x00000100, /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
}
@reserved_flags
type VkFlags VkBufferViewCreateFlags
@reserved_flags
type VkFlags VkImageViewCreateFlags
@reserved_flags
type VkFlags VkShaderModuleCreateFlags
@reserved_flags
type VkFlags VkPipelineCacheCreateFlags

@unused
bitfield VkPipelineCreateFlagBits {
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT    = 0x00000002,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT           = 0x00000004,
}
type VkFlags VkPipelineCreateFlags
@reserved_flags
type VkFlags VkPipelineShaderStageCreateFlags


bitfield VkShaderStageFlagBits {
  VK_SHADER_STAGE_VERTEX_BIT                  = 0x00000001,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT    = 0x00000002,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
  VK_SHADER_STAGE_GEOMETRY_BIT                = 0x00000008,
  VK_SHADER_STAGE_FRAGMENT_BIT                = 0x00000010,
  VK_SHADER_STAGE_COMPUTE_BIT                 = 0x00000020,
  VK_SHADER_STAGE_ALL_GRAPHICS                = 0x0000001F,
  VK_SHADER_STAGE_ALL                         = 0x7FFFFFFF,
}
type VkFlags VkShaderStageFlags
@reserved_flags
type VkFlags VkPipelineVertexInputStateCreateFlags
@reserved_flags
type VkFlags VkPipelineInputAssemblyStateCreateFlags
@reserved_flags
type VkFlags VkPipelineTessellationStateCreateFlags
@reserved_flags
type VkFlags VkPipelineViewportStateCreateFlags
@reserved_flags
type VkFlags VkPipelineRasterizationStateCreateFlags


@unused
bitfield VkCullModeFlagBits {
  VK_CULL_MODE_NONE           = 0x00000000,
  VK_CULL_MODE_FRONT_BIT      = 0x00000001,
  VK_CULL_MODE_BACK_BIT       = 0x00000002,
  VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkCullModeFlags

@reserved_flags
type VkFlags VkPipelineMultisampleStateCreateFlags
@reserved_flags
type VkFlags VkPipelineDepthStencilStateCreateFlags
@reserved_flags
type VkFlags VkPipelineColorBlendStateCreateFlags

@unused
bitfield VkColorComponentFlagBits {
  VK_COLOR_COMPONENT_R_BIT = 0x00000001,
  VK_COLOR_COMPONENT_G_BIT = 0x00000002,
  VK_COLOR_COMPONENT_B_BIT = 0x00000004,
  VK_COLOR_COMPONENT_A_BIT = 0x00000008,
}
type VkFlags VkColorComponentFlags

@reserved_flags
type VkFlags VkPipelineDynamicStateCreateFlags
@reserved_flags
type VkFlags VkPipelineLayoutCreateFlags
@reserved_flags
type VkFlags VkSamplerCreateFlags
@reserved_flags
type VkFlags VkDescriptorSetLayoutCreateFlags

@unused
bitfield VkDescriptorPoolCreateFlagBits {
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
}
type VkFlags VkDescriptorPoolCreateFlags

@reserved_flags
type VkFlags VkDescriptorPoolResetFlags
@reserved_flags
type VkFlags VkFramebufferCreateFlags
@reserved_flags
type VkFlags VkRenderPassCreateFlags

@unused
bitfield VkAttachmentDescriptionFlagBits {
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001, /// The attachment may alias physical memory of another attachment in the same renderpass
}
type VkFlags VkAttachmentDescriptionFlags

@reserved_flags
type VkFlags VkSubpassDescriptionFlags


@unused
bitfield VkAccessFlagBits {
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT          = 0x00000001,
  VK_ACCESS_INDEX_READ_BIT                     = 0x00000002,
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT          = 0x00000004,
  VK_ACCESS_UNIFORM_READ_BIT                   = 0x00000008,
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT          = 0x00000010,
  VK_ACCESS_SHADER_READ_BIT                    = 0x00000020,
  VK_ACCESS_SHADER_WRITE_BIT                   = 0x00000040,
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT          = 0x00000080,
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT         = 0x00000100,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT  = 0x00000200,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
  VK_ACCESS_TRANSFER_READ_BIT                  = 0x00000800,
  VK_ACCESS_TRANSFER_WRITE_BIT                 = 0x00001000,
  VK_ACCESS_HOST_READ_BIT                      = 0x00002000,
  VK_ACCESS_HOST_WRITE_BIT                     = 0x00004000,
  VK_ACCESS_MEMORY_READ_BIT                    = 0x00008000,
  VK_ACCESS_MEMORY_WRITE_BIT                   = 0x00010000,
}
type VkFlags VkAccessFlags

@unused
bitfield VkDependencyFlagBits {
  VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
}
type VkFlags VkDependencyFlags

@unused
bitfield VkCommandPoolCreateFlagBits {
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT            = 0x00000001, /// Command buffers have a short lifetime
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002, /// Command buffers may release their memory individually
}
type VkFlags VkCommandPoolCreateFlags

@unused
bitfield VkCommandPoolResetFlagBits {
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the pool
}
type VkFlags VkCommandPoolResetFlags

@unused
bitfield VkCommandBufferUsageFlagBits {
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      = 0x00000001,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     = 0x00000004,
}
type VkFlags VkCommandBufferUsageFlags

@unused
bitfield VkQueryControlFlagBits {
  VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
}
type VkFlags VkQueryControlFlags

@unused
bitfield VkCommandBufferResetFlagBits {
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the buffer
}
type VkFlags VkCommandBufferResetFlags

@unused
bitfield VkStencilFaceFlagBits {
  VK_STENCIL_FACE_FRONT_BIT = 0x00000001, /// Front face
  VK_STENCIL_FACE_BACK_BIT  = 0x00000002, /// Back face
  VK_STENCIL_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkStencilFaceFlags



// Function pointers. TODO: add support for function pointers.

@external type void* PFN_vkAllocationFunction
@pfn cmd void* vkAllocationFunction(
    void*                   pUserData,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkReallocationFunction
@pfn cmd void* vkReallocationFunction(
    void*                   pUserData,
    void*                   pOriginal,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkFreeFunction
@pfn cmd void vkFreeFunction(
    void* pUserData,
    void* pMemory) {
}

@external type void* PFN_vkInternalAllocationNotification
@pfn cmd void vkInternalAllocationNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkInternalFreeNotification
@pfn cmd void vkInternalFreeNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkVoidFunction
@pfn cmd void vkVoidFunction() {
}

class VkApplicationInfo {
  VkStructureType sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO
  const void*     pNext              /// Next structure in chain
  const char*     pApplicationName
  u32             applicationVersion
  const char*     pEngineName
  u32             engineVersion
  u32             apiVersion
}

class VkInstanceCreateInfo {
  VkStructureType          sType                   /// Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
  const void*              pNext                   /// Pointer to next structure
  VkInstanceCreateFlags    flags
  const VkApplicationInfo* pApplicationInfo
  u32                      enabledLayerCount
  const char* const*       ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                      enabledExtensionCount
  const char* const*       ppEnabledExtensionNames /// Extension names to be enabled
}

class VkAllocationCallbacks {
  void*                                pUserData
  PFN_vkAllocationFunction             pfnAllocation
  PFN_vkReallocationFunction           pfnReallocation
  PFN_vkFreeFunction                   pfnFree
  PFN_vkInternalAllocationNotification pfnInternalAllocation
  PFN_vkInternalFreeNotification       pfnInternalFree
}

class VkPhysicalDeviceFeatures {
  VkBool32 robustBufferAccess                      /// out of bounds buffer accesses are well defined
  VkBool32 fullDrawIndexUint32                     /// full 32-bit range of indices for indexed draw calls
  VkBool32 imageCubeArray                          /// image views which are arrays of cube maps
  VkBool32 independentBlend                        /// blending operations are controlled per-attachment
  VkBool32 geometryShader                          /// geometry stage
  VkBool32 tessellationShader                      /// tessellation control and evaluation stage
  VkBool32 sampleRateShading                       /// per-sample shading and interpolation
  VkBool32 dualSrcBlend                            /// blend operations which take two sources
  VkBool32 logicOp                                 /// logic operations
  VkBool32 multiDrawIndirect                       /// multi draw indirect
  VkBool32 drawIndirectFirstInstance
  VkBool32 depthClamp                              /// depth clamping
  VkBool32 depthBiasClamp                          /// depth bias clamping
  VkBool32 fillModeNonSolid                        /// point and wireframe fill modes
  VkBool32 depthBounds                             /// depth bounds test
  VkBool32 wideLines                               /// lines with width greater than 1
  VkBool32 largePoints                             /// points with size greater than 1
  VkBool32 alphaToOne                              /// The fragment alpha channel can be forced to maximum representable alpha value
  VkBool32 multiViewport
  VkBool32 samplerAnisotropy
  VkBool32 textureCompressionETC2                  /// ETC texture compression formats
  VkBool32 textureCompressionASTC_LDR              /// ASTC LDR texture compression formats
  VkBool32 textureCompressionBC                    /// BC1-7 texture compressed formats
  VkBool32 occlusionQueryPrecise
  VkBool32 pipelineStatisticsQuery                 /// pipeline statistics query
  VkBool32 vertexPipelineStoresAndAtomics
  VkBool32 fragmentStoresAndAtomics
  VkBool32 shaderTessellationAndGeometryPointSize
  VkBool32 shaderImageGatherExtended               /// texture gather with run-time values and independent offsets
  VkBool32 shaderStorageImageExtendedFormats       /// the extended set of formats can be used for storage images
  VkBool32 shaderStorageImageMultisample           /// multisample images can be used for storage images
  VkBool32 shaderStorageImageReadWithoutFormat
  VkBool32 shaderStorageImageWriteWithoutFormat
  VkBool32 shaderUniformBufferArrayDynamicIndexing /// arrays of uniform buffers can be accessed with dynamically uniform indices
  VkBool32 shaderSampledImageArrayDynamicIndexing  /// arrays of sampled images can be accessed with dynamically uniform indices
  VkBool32 shaderStorageBufferArrayDynamicIndexing /// arrays of storage buffers can be accessed with dynamically uniform indices
  VkBool32 shaderStorageImageArrayDynamicIndexing  /// arrays of storage images can be accessed with dynamically uniform indices
  VkBool32 shaderClipDistance                      /// clip distance in shaders
  VkBool32 shaderCullDistance                      /// cull distance in shaders
  VkBool32 shaderFloat64                           /// 64-bit floats (doubles) in shaders
  VkBool32 shaderInt64                             /// 64-bit integers in shaders
  VkBool32 shaderInt16                             /// 16-bit integers in shaders
  VkBool32 shaderResourceResidency                 /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
  VkBool32 shaderResourceMinLod                    /// shader can use texture operations that specify minimum resource LOD
  VkBool32 sparseBinding                           /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
  VkBool32 sparseResidencyBuffer                   /// Sparse resources support: GPU can access partially resident buffers
  VkBool32 sparseResidencyImage2D                  /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images
  VkBool32 sparseResidencyImage3D                  /// Sparse resources support: GPU can access partially resident 3D images
  VkBool32 sparseResidency2Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
  VkBool32 sparseResidency4Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
  VkBool32 sparseResidency8Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
  VkBool32 sparseResidency16Samples                /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
  VkBool32 sparseResidencyAliased                  /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
  VkBool32 variableMultisampleRate
  VkBool32 inheritedQueries
}

class VkFormatProperties {
  VkFormatFeatureFlags linearTilingFeatures  /// Format features in case of linear tiling
  VkFormatFeatureFlags optimalTilingFeatures /// Format features in case of optimal tiling
  VkFormatFeatureFlags bufferFeatures        /// Format features supported by buffers
}

class VkExtent3D {
  u32 Width
  u32 Height
  u32 Depth
}

class VkImageFormatProperties {
  VkExtent3D         maxExtent       /// max image dimensions for this resource type
  u32                maxMipLevels    /// max number of mipmap levels for this resource type
  u32                maxArrayLayers  /// max array layers for this resource type
  VkSampleCountFlags sampleCounts    /// supported sample counts for this resource type
  VkDeviceSize       maxResourceSize /// max size (in bytes) of this resource type
}

class VkPhysicalDeviceLimits {
  /// resource maximum sizes
  u32 maxImageDimension1D    /// max 1D image dimension
  u32 maxImageDimension2D    /// max 2D image dimension
  u32 maxImageDimension3D    /// max 3D image dimension
  u32 maxImageDimensionCube  /// max cubemap image dimension
  u32 maxImageArrayLayers    /// max layers for image arrays
  u32 maxTexelBufferElements
  u32 maxUniformBufferRange  /// max uniform buffer size (bytes)
  u32 maxStorageBufferRange  /// max storage buffer size (bytes)
  u32 maxPushConstantsSize   /// max size of the push constants pool (bytes)
  /// memory limits
  u32          maxMemoryAllocationCount  /// max number of device memory allocations supported
  u32          maxSamplerAllocationCount
  VkDeviceSize bufferImageGranularity    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
  VkDeviceSize sparseAddressSpaceSize    /// Total address space available for sparse allocations (bytes)
  /// descriptor set limits
  u32 maxBoundDescriptorSets                /// max number of descriptors sets that can be bound to a pipeline
  u32 maxPerStageDescriptorSamplers         /// max num of samplers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorUniformBuffers   /// max num of uniform buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageBuffers   /// max num of storage buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorSampledImages    /// max num of sampled images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageImages    /// max num of storage images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorInputAttachments
  u32 maxPerStageResources
  u32 maxDescriptorSetSamplers              /// max num of samplers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffers        /// max num of uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffersDynamic /// max num of dynamic uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffers        /// max num of storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffersDynamic /// max num of dynamic storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetSampledImages         /// max num of sampled images allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageImages         /// max num of storage images allowed in all stages in a descriptor set
  u32 maxDescriptorSetInputAttachments
  /// vertex stage limits
  u32 maxVertexInputAttributes      /// max num of vertex input attribute slots
  u32 maxVertexInputBindings        /// max num of vertex input binding slots
  u32 maxVertexInputAttributeOffset /// max vertex input attribute offset added to vertex buffer offset
  u32 maxVertexInputBindingStride   /// max vertex input binding stride
  u32 maxVertexOutputComponents     /// max num of output components written by vertex shader
  /// tessellation control stage limits
  u32 maxTessellationGenerationLevel                  /// max level supported by tess primitive generator
  u32 maxTessellationPatchSize                        /// max patch size (vertices)
  u32 maxTessellationControlPerVertexInputComponents  /// max num of input components per-vertex in TCS
  u32 maxTessellationControlPerVertexOutputComponents /// max num of output components per-vertex in TCS
  u32 maxTessellationControlPerPatchOutputComponents  /// max num of output components per-patch in TCS
  u32 maxTessellationControlTotalOutputComponents     /// max total num of per-vertex and per-patch output components in TCS
  u32 maxTessellationEvaluationInputComponents        /// max num of input components per vertex in TES
  u32 maxTessellationEvaluationOutputComponents       /// max num of output components per vertex in TES
  /// geometry stage limits
  u32 maxGeometryShaderInvocations     /// max invocation count supported in geometry shader
  u32 maxGeometryInputComponents       /// max num of input components read in geometry stage
  u32 maxGeometryOutputComponents      /// max num of output components written in geometry stage
  u32 maxGeometryOutputVertices        /// max num of vertices that can be emitted in geometry stage
  u32 maxGeometryTotalOutputComponents /// max total num of components (all vertices) written in geometry stage
  /// fragment stage limits
  u32 maxFragmentInputComponents         /// max num of input compontents read in fragment stage
  u32 maxFragmentOutputAttachments       /// max num of output attachments written in fragment stage
  u32 maxFragmentDualSrcAttachments      /// max num of output attachments written when using dual source blending
  u32 maxFragmentCombinedOutputResources /// max total num of storage buffers, storage images and output buffers
  /// compute stage limits
  u32    maxComputeSharedMemorySize     /// max total storage size of work group local storage (bytes)
  u32[3] maxComputeWorkGroupCount       /// max num of compute work groups that may be dispatched by a single command (x,y,z)
  u32    maxComputeWorkGroupInvocations /// max total compute invocations in a single local work group
  u32[3] maxComputeWorkGroupSize        /// max local size of a compute work group (x,y,z)

  u32 subPixelPrecisionBits /// num bits of subpixel precision in screen x and y
  u32 subTexelPrecisionBits /// num bits of subtexel precision
  u32 mipmapPrecisionBits   /// num bits of mipmap precision

  u32 maxDrawIndexedIndexValue /// max index value for indexed draw calls (for 32-bit indices)
  u32 maxDrawIndirectCount

  f32 maxSamplerLodBias    /// max absolute sampler level of detail bias
  f32 maxSamplerAnisotropy /// max degree of sampler anisotropy

  u32    maxViewports          /// max number of active viewports
  u32[2] maxViewportDimensions /// max viewport dimensions (x,y)
  f32[2] viewportBoundsRange   /// viewport bounds range (min,max)
  u32    viewportSubPixelBits  /// num bits of subpixel precision for viewport

  size         minMemoryMapAlignment           /// min required alignment of pointers returned by MapMemory (bytes)
  VkDeviceSize minTexelBufferOffsetAlignment   /// min required alignment for texel buffer offsets (bytes)
  VkDeviceSize minUniformBufferOffsetAlignment /// min required alignment for uniform buffer sizes and offsets (bytes)
  VkDeviceSize minStorageBufferOffsetAlignment /// min required alignment for storage buffer offsets (bytes)

  s32 minTexelOffset                  /// min texel offset for OpTextureSampleOffset
  u32 maxTexelOffset                  /// max texel offset for OpTextureSampleOffset
  s32 minTexelGatherOffset            /// min texel offset for OpTextureGatherOffset
  u32 maxTexelGatherOffset            /// max texel offset for OpTextureGatherOffset
  f32 minInterpolationOffset          /// furthest negative offset for interpolateAtOffset
  f32 maxInterpolationOffset          /// furthest positive offset for interpolateAtOffset
  u32 subPixelInterpolationOffsetBits /// num of subpixel bits for interpolateAtOffset

  u32                maxFramebufferWidth                 /// max width for a framebuffer
  u32                maxFramebufferHeight                /// max height for a framebuffer
  u32                maxFramebufferLayers                /// max layer count for a layered framebuffer
  VkSampleCountFlags framebufferColorSampleCounts
  VkSampleCountFlags framebufferDepthSampleCounts
  VkSampleCountFlags framebufferStencilSampleCounts
  VkSampleCountFlags framebufferNoAttachmentSampleCounts
  u32                maxColorAttachments                 /// max num of framebuffer color attachments

  VkSampleCountFlags sampledImageColorSampleCounts
  VkSampleCountFlags sampledImageIntegerSampleCounts
  VkSampleCountFlags sampledImageDepthSampleCounts
  VkSampleCountFlags sampledImageStencilSampleCounts
  VkSampleCountFlags storageImageSampleCounts
  u32                maxSampleMaskWords              /// max num of sample mask words
  VkBool32           timestampComputeAndGraphics

  f32 timestampPeriod

  u32 maxClipDistances                /// max number of clip distances
  u32 maxCullDistances                /// max number of cull distances
  u32 maxCombinedClipAndCullDistances /// max combined number of user clipping

  u32 discreteQueuePriorities

  f32[2]   pointSizeRange          /// range (min,max) of supported point sizes
  f32[2]   lineWidthRange          /// range (min,max) of supported line widths
  f32      pointSizeGranularity    /// granularity of supported point sizes
  f32      lineWidthGranularity    /// granularity of supported line widths
  VkBool32 strictLines
  VkBool32 standardSampleLocations

  VkDeviceSize optimalBufferCopyOffsetAlignment
  VkDeviceSize optimalBufferCopyRowPitchAlignment
  VkDeviceSize nonCoherentAtomSize
}

class VkPhysicalDeviceSparseProperties {
  VkBool32 residencyStandard2DBlockShape            /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard2DMultisampleBlockShape /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard3DBlockShape            /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyAlignedMipSize                  /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
  VkBool32 residencyNonResidentStrict               /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

class VkPhysicalDeviceProperties {
  u32                                    apiVersion
  u32                                    driverVersion
  u32                                    vendorID
  u32                                    deviceID
  VkPhysicalDeviceType                   deviceType
  char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName
  u8[VK_UUID_SIZE]                       pipelineCacheUUID
  VkPhysicalDeviceLimits                 limits
  VkPhysicalDeviceSparseProperties       sparseProperties
}

class VkQueueFamilyProperties {
  VkQueueFlags queueFlags                  /// Queue flags
  u32          queueCount
  u32          timestampValidBits
  VkExtent3D   minImageTransferGranularity
}

class VkMemoryType {
  VkMemoryPropertyFlags propertyFlags /// Memory properties of this memory type
  u32                   heapIndex     /// Index of the memory heap allocations of this memory type are taken from
}

class VkMemoryHeap {
  VkDeviceSize      size  /// Available memory in the heap
  VkMemoryHeapFlags flags /// Flags for the heap
}

class VkPhysicalDeviceMemoryProperties {
  u32                               memoryTypeCount
  VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes
  u32                               memoryHeapCount
  VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps
}

class VkDeviceQueueCreateInfo {
  VkStructureType          sType            /// Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkDeviceQueueCreateFlags flags
  u32                      queueFamilyIndex
  u32                      queueCount
  const f32*               pQueuePriorities
}

class VkDeviceCreateInfo {
  VkStructureType                 sType                   /// Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
  const void*                     pNext                   /// Pointer to next structure
  VkDeviceCreateFlags             flags
  u32                             queueCreateInfoCount
  const VkDeviceQueueCreateInfo*  pQueueCreateInfos
  u32                             enabledLayerCount
  const char* const*              ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                             enabledExtensionCount
  const char* const*              ppEnabledExtensionNames
  const VkPhysicalDeviceFeatures* pEnabledFeatures
}

class VkExtensionProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] extensionName /// extension name
  u32                              specVersion   /// version of the extension specification implemented
}

class VkLayerProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] layerName             /// layer name
  u32                              specVersion           /// version of the layer specification implemented
  u32                              implementationVersion /// build or release version of the layer's library
  char[VK_MAX_DESCRIPTION_SIZE]    description           /// Free-form description of the layer
}

class VkSubmitInfo {
  VkStructureType             sType                /// Type of structure. Should be VK_STRUCTURE_TYPE_SUBMIT_INFO
  const void*                 pNext                /// Next structure in chain
  u32                         waitSemaphoreCount
  const VkSemaphore*          pWaitSemaphores
  const VkPipelineStageFlags* pWaitDstStageMask
  u32                         commandBufferCount
  const VkCommandBuffer*      pCommandBuffers
  u32                         signalSemaphoreCount
  const VkSemaphore*          pSignalSemaphores
}

class VkMemoryAllocateInfo {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
  const void*     pNext           /// Pointer to next structure
  VkDeviceSize    allocationSize  /// Size of memory allocation
  u32             memoryTypeIndex /// Index of the of the memory type to allocate from
}

class VkMappedMemoryRange {
  VkStructureType sType  /// Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
  const void*     pNext  /// Pointer to next structure
  VkDeviceMemory  memory /// Mapped memory object
  VkDeviceSize    offset /// Offset within the mapped memory the range starts from
  VkDeviceSize    size   /// Size of the range within the mapped memory
}

class VkMemoryRequirements {
  VkDeviceSize size           /// Specified in bytes
  VkDeviceSize alignment      /// Specified in bytes
  u32          memoryTypeBits /// Bitfield of the allowed memory type indices into memoryTypes[] for this object
}

class VkSparseImageFormatProperties {
  VkImageAspectFlags       aspectMask
  VkExtent3D               imageGranularity
  VkSparseImageFormatFlags flags
}

class VkSparseImageMemoryRequirements {
  VkSparseImageFormatProperties formatProperties
  u32                           imageMipTailFirstLod
  VkDeviceSize                  imageMipTailSize     /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailOffset   /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailStride   /// Specified in bytes, must be a multiple of image block size / alignment
}

class VkSparseMemoryBind {
  VkDeviceSize            resourceOffset /// Specified in bytes
  VkDeviceSize            size           /// Specified in bytes
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset   /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

class VkSparseBufferMemoryBindInfo {
  VkBuffer                  buffer
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

class VkSparseImageOpaqueMemoryBindInfo {
  VkImage                   image
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

class VkImageSubresource {
  VkImageAspectFlags aspectMask
  u32                mipLevel
  u32                arrayLayer
}

class VkOffset3D {
  s32 x
  s32 y
  s32 z
}

class VkSparseImageMemoryBind {
  VkImageSubresource      subresource
  VkOffset3D              offset
  VkExtent3D              extent
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

class VkSparseImageMemoryBindInfo {
  VkImage                        image
  u32                            bindCount
  const VkSparseImageMemoryBind* pBinds
}

class VkBindSparseInfo {
  VkStructureType                          sType                /// Must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
  const void*                              pNext
  u32                                      waitSemaphoreCount
  const VkSemaphore*                       pWaitSemaphores
  u32                                      bufferBindCount
  const VkSparseBufferMemoryBindInfo*      pBufferBinds
  u32                                      imageOpaqueBindCount
  const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
  u32                                      imageBindCount
  const VkSparseImageMemoryBindInfo*       pImageBinds
  u32                                      signalSemaphoreCount
  const VkSemaphore*                       pSignalSemaphores
}

class VkFenceCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkFenceCreateFlags flags /// Fence creation flags
}

class VkSemaphoreCreateInfo {
  VkStructureType        sType /// Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
  const void*            pNext /// Pointer to next structure
  VkSemaphoreCreateFlags flags /// Semaphore creation flags
}

class VkEventCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkEventCreateFlags flags /// Event creation flags
}

class VkQueryPoolCreateInfo {
  VkStructureType               sType              /// Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
  const void*                   pNext              /// Pointer to next structure
  VkQueryPoolCreateFlags        flags
  VkQueryType                   queryType
  u32                           queryCount
  VkQueryPipelineStatisticFlags pipelineStatistics /// Optional
}

class VkBufferCreateInfo {
  VkStructureType     sType                 /// Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
  const void*         pNext                 /// Pointer to next structure.
  VkBufferCreateFlags flags                 /// Buffer creation flags
  VkDeviceSize        size                  /// Specified in bytes
  VkBufferUsageFlags  usage                 /// Buffer usage flags
  VkSharingMode       sharingMode
  u32                 queueFamilyIndexCount
  const u32*          pQueueFamilyIndices
}

class VkBufferViewCreateInfo {
  VkStructureType         sType  /// Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
  const void*             pNext  /// Pointer to next structure.
  VkBufferViewCreateFlags flags
  VkBuffer                buffer
  VkFormat                format /// Optionally specifies format of elements
  VkDeviceSize            offset /// Specified in bytes
  VkDeviceSize            range  /// View size specified in bytes
}

class VkImageCreateInfo {
  VkStructureType       sType                 /// Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
  const void*           pNext                 /// Pointer to next structure.
  VkImageCreateFlags    flags                 /// Image creation flags
  VkImageType           imageType
  VkFormat              format
  VkExtent3D            extent
  u32                   mipLevels
  u32                   arrayLayers
  VkSampleCountFlagBits samples
  VkImageTiling         tiling
  VkImageUsageFlags     usage                 /// Image usage flags
  VkSharingMode         sharingMode           /// Cross-queue-family sharing mode
  u32                   queueFamilyIndexCount /// Number of queue families to share across
  const u32*            pQueueFamilyIndices   /// Array of queue family indices to share across
  VkImageLayout         initialLayout         /// Initial image layout for all subresources
}

class VkSubresourceLayout {
  VkDeviceSize offset     /// Specified in bytes
  VkDeviceSize size       /// Specified in bytes
  VkDeviceSize rowPitch   /// Specified in bytes
  VkDeviceSize arrayPitch /// Specified in bytes
  VkDeviceSize depthPitch /// Specified in bytes
}

class VkComponentMapping {
  VkComponentSwizzle r
  VkComponentSwizzle g
  VkComponentSwizzle b
  VkComponentSwizzle a
}

class VkImageSubresourceRange {
  VkImageAspectFlags aspectMask
  u32                baseMipLevel
  u32                levelCount
  u32                baseArrayLayer
  u32                layerCount
}

class VkImageViewCreateInfo {
  VkStructureType         sType            /// Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
  const void*             pNext            /// Pointer to next structure
  VkImageViewCreateFlags  flags
  VkImage                 image
  VkImageViewType         viewType
  VkFormat                format
  VkComponentMapping      components
  VkImageSubresourceRange subresourceRange
}

class VkShaderModuleCreateInfo {
  VkStructureType           sType    /// Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
  const void*               pNext    /// Pointer to next structure
  VkShaderModuleCreateFlags flags    /// Reserved
  size                      codeSize /// Specified in bytes
  const u32*                pCode    /// Binary code of size codeSize
}

class VkPipelineCacheCreateInfo {
  VkStructureType            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
  const void*                pNext           /// Pointer to next structure
  VkPipelineCacheCreateFlags flags
  size                       initialDataSize /// Size of initial data to populate cache, in bytes
  const void*                pInitialData    /// Initial data to populate cache
}

class VkSpecializationMapEntry {
  u32  constantID /// The SpecConstant ID specified in the BIL
  u32  offset     /// Offset of the value in the data block
  size size       /// Size in bytes of the SpecConstant
}

class VkSpecializationInfo {
  u32                             mapEntryCount /// Number of entries in the map
  const VkSpecializationMapEntry* pMapEntries   /// Array of map entries
  size                            dataSize      /// Size in bytes of pData
  const void*                     pData         /// Pointer to SpecConstant data
}

class VkPipelineShaderStageCreateInfo {
  VkStructureType                  sType               /// Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
  const void*                      pNext               /// Pointer to next structure
  VkPipelineShaderStageCreateFlags flags
  VkShaderStageFlagBits            stage
  VkShaderModule                   module
  const char*                      pName
  const VkSpecializationInfo*      pSpecializationInfo
}

class VkVertexInputBindingDescription {
  u32               binding   /// Vertex buffer binding id
  u32               stride    /// Distance between vertices in bytes (0 = no advancement)
  VkVertexInputRate inputRate /// Rate at which binding is incremented
}

class VkVertexInputAttributeDescription {
  u32      location /// location of the shader vertex attrib
  u32      binding  /// Vertex buffer binding id
  VkFormat format   /// format of source data
  u32      offset   /// Offset of first element in bytes from base of vertex
}

class VkPipelineVertexInputStateCreateInfo {
  VkStructureType                          sType                           /// Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
  const void*                              pNext                           /// Pointer to next structure
  VkPipelineVertexInputStateCreateFlags    flags
  u32                                      vertexBindingDescriptionCount   /// number of bindings
  const VkVertexInputBindingDescription*   pVertexBindingDescriptions
  u32                                      vertexAttributeDescriptionCount /// number of attributes
  const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
}

class VkPipelineInputAssemblyStateCreateInfo {
  VkStructureType                         sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
  const void*                             pNext                  /// Pointer to next structure
  VkPipelineInputAssemblyStateCreateFlags flags
  VkPrimitiveTopology                     topology
  VkBool32                                primitiveRestartEnable
}

class VkPipelineTessellationStateCreateInfo {
  VkStructureType                        sType              /// Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
  const void*                            pNext              /// Pointer to next structure
  VkPipelineTessellationStateCreateFlags flags
  u32                                    patchControlPoints
}

class VkViewport {
  f32 x
  f32 y
  f32 width
  f32 height
  f32 minDepth
  f32 maxDepth
}

class VkOffset2D {
  s32 x
  s32 y
}

class VkExtent2D {
  u32 Width
  u32 Height
}

class VkRect2D {
  VkOffset2D offset
  VkExtent2D extent
}

class VkPipelineViewportStateCreateInfo {
  VkStructureType                    sType         /// Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
  const void*                        pNext         /// Pointer to next structure
  VkPipelineViewportStateCreateFlags flags
  u32                                viewportCount
  const VkViewport*                  pViewports
  u32                                scissorCount
  const VkRect2D*                    pScissors
}

class VkPipelineRasterizationStateCreateInfo {
  VkStructureType                         sType                   /// Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
  const void*                             pNext                   /// Pointer to next structure
  VkPipelineRasterizationStateCreateFlags flags
  VkBool32                                depthClampEnable
  VkBool32                                rasterizerDiscardEnable
  VkPolygonMode                           polygonMode             /// optional (GL45)
  VkCullModeFlags                         cullMode
  VkFrontFace                             frontFace
  VkBool32                                depthBiasEnable
  f32                                     depthBiasConstantFactor
  f32                                     depthBiasClamp
  f32                                     depthBiasSlopeFactor
  f32                                     lineWidth
}

class VkPipelineMultisampleStateCreateInfo {
  VkStructureType                       sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
  const void*                           pNext                 /// Pointer to next structure
  VkPipelineMultisampleStateCreateFlags flags
  VkSampleCountFlagBits                 rasterizationSamples  /// Number of samples used for rasterization
  VkBool32                              sampleShadingEnable   /// optional (GL45)
  f32                                   minSampleShading      /// optional (GL45)
  const VkSampleMask*                   pSampleMask
  VkBool32                              alphaToCoverageEnable
  VkBool32                              alphaToOneEnable
}

class VkStencilOpState {
  VkStencilOp failOp
  VkStencilOp passOp
  VkStencilOp depthFailOp
  VkCompareOp compareOp
  u32         compareMask
  u32         writeMask
  u32         reference
}

class VkPipelineDepthStencilStateCreateInfo {
  VkStructureType                        sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
  const void*                            pNext                 /// Pointer to next structure
  VkPipelineDepthStencilStateCreateFlags flags
  VkBool32                               depthTestEnable
  VkBool32                               depthWriteEnable
  VkCompareOp                            depthCompareOp
  VkBool32                               depthBoundsTestEnable /// optional (depth_bounds_test)
  VkBool32                               stencilTestEnable
  VkStencilOpState                       front
  VkStencilOpState                       back
  f32                                    minDepthBounds
  f32                                    maxDepthBounds
}

class VkPipelineColorBlendAttachmentState {
  VkBool32              blendEnable
  VkBlendFactor         srcColorBlendFactor
  VkBlendFactor         dstColorBlendFactor
  VkBlendOp             colorBlendOp
  VkBlendFactor         srcAlphaBlendFactor
  VkBlendFactor         dstAlphaBlendFactor
  VkBlendOp             alphaBlendOp
  VkColorComponentFlags colorWriteMask
}

class VkPipelineColorBlendStateCreateInfo {
  VkStructureType                            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
  const void*                                pNext           /// Pointer to next structure
  VkPipelineColorBlendStateCreateFlags       flags
  VkBool32                                   logicOpEnable
  VkLogicOp                                  logicOp
  u32                                        attachmentCount /// # of pAttachments
  const VkPipelineColorBlendAttachmentState* pAttachments
  f32[4]                                     blendConstants
}

class VkPipelineDynamicStateCreateInfo {
  VkStructureType                   sType             /// Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
  const void*                       pNext             /// Pointer to next structure
  VkPipelineDynamicStateCreateFlags flags
  u32                               dynamicStateCount
  const VkDynamicState*             pDynamicStates
}

class VkGraphicsPipelineCreateInfo {
  VkStructureType                               sType               /// Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
  const void*                                   pNext               /// Pointer to next structure
  VkPipelineCreateFlags                         flags               /// Pipeline creation flags
  u32                                           stageCount
  const VkPipelineShaderStageCreateInfo*        pStages             /// One entry for each active shader stage
  const VkPipelineVertexInputStateCreateInfo*   pVertexInputState
  const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
  const VkPipelineTessellationStateCreateInfo*  pTessellationState
  const VkPipelineViewportStateCreateInfo*      pViewportState
  const VkPipelineRasterizationStateCreateInfo* pRasterizationState
  const VkPipelineMultisampleStateCreateInfo*   pMultisampleState
  const VkPipelineDepthStencilStateCreateInfo*  pDepthStencilState
  const VkPipelineColorBlendStateCreateInfo*    pColorBlendState
  const VkPipelineDynamicStateCreateInfo*       pDynamicState
  VkPipelineLayout                              layout              /// Interface layout of the pipeline
  VkRenderPass                                  renderPass
  u32                                           subpass
  VkPipeline                                    basePipelineHandle  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                                           basePipelineIndex   /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkComputePipelineCreateInfo {
  VkStructureType                 sType              /// Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
  const void*                     pNext              /// Pointer to next structure
  VkPipelineCreateFlags           flags              /// Pipeline creation flags
  VkPipelineShaderStageCreateInfo stage
  VkPipelineLayout                layout             /// Interface layout of the pipeline
  VkPipeline                      basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                             basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkPushConstantRange {
  VkShaderStageFlags stageFlags /// Which stages use the range
  u32                offset     /// Start of the range, in bytes
  u32                size       /// Length of the range, in bytes
}

class VkPipelineLayoutCreateInfo {
  VkStructureType              sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
  const void*                  pNext                  /// Pointer to next structure
  VkPipelineLayoutCreateFlags  flags
  u32                          setLayoutCount         /// Number of descriptor sets interfaced by the pipeline
  const VkDescriptorSetLayout* pSetLayouts            /// Array of <setCount> number of descriptor set layout objects defining the layout of the
  u32                          pushConstantRangeCount /// Number of push-constant ranges used by the pipeline
  const VkPushConstantRange*   pPushConstantRanges    /// Array of pushConstantRangeCount number of ranges used by various shader stages
}

class VkSamplerCreateInfo {
  VkStructureType      sType                   /// Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
  const void*          pNext                   /// Pointer to next structure
  VkSamplerCreateFlags flags
  VkFilter             magFilter               /// Filter mode for magnification
  VkFilter             minFilter               /// Filter mode for minifiation
  VkSamplerMipmapMode  mipmapMode              /// Mipmap selection mode
  VkSamplerAddressMode addressModeU
  VkSamplerAddressMode addressModeV
  VkSamplerAddressMode addressModeW
  f32                  mipLodBias
  VkBool32             anisotropyEnable
  f32                  maxAnisotropy
  VkBool32             compareEnable
  VkCompareOp          compareOp
  f32                  minLod
  f32                  maxLod
  VkBorderColor        borderColor
  VkBool32             unnormalizedCoordinates
}

class VkDescriptorSetLayoutBinding {
  u32                binding
  VkDescriptorType   descriptorType     /// Type of the descriptors in this binding
  u32                descriptorCount    /// Number of descriptors in this binding
  VkShaderStageFlags stageFlags         /// Shader stages this binding is visible to
  const VkSampler*   pImmutableSamplers /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains <count> number of elements)
}

class VkDescriptorSetLayoutCreateInfo {
  VkStructureType                     sType        /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
  const void*                         pNext        /// Pointer to next structure
  VkDescriptorSetLayoutCreateFlags    flags
  u32                                 bindingCount /// Number of bindings in the descriptor set layout
  const VkDescriptorSetLayoutBinding* pBindings    /// Array of descriptor set layout bindings
}

class VkDescriptorPoolSize {
  VkDescriptorType type
  u32              descriptorCount
}

class VkDescriptorPoolCreateInfo {
  VkStructureType             sType         /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
  const void*                 pNext         /// Pointer to next structure
  VkDescriptorPoolCreateFlags flags
  u32                         maxSets
  u32                         poolSizeCount
  const VkDescriptorPoolSize* pPoolSizes
}

class VkDescriptorSetAllocateInfo {
  VkStructureType              sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
  const void*                  pNext              /// Pointer to next structure
  VkDescriptorPool             descriptorPool
  u32                          descriptorSetCount
  const VkDescriptorSetLayout* pSetLayouts
}

class VkDescriptorImageInfo {
  VkSampler     Sampler
  VkImageView   ImageView
  VkImageLayout ImageLayout
}

class VkDescriptorBufferInfo {
  VkBuffer     Buffer /// Buffer used for this descriptor when the descriptor is UNIFORM_BUFFER[_DYNAMIC]
  VkDeviceSize Offset /// Base offset from buffer start in bytes to update in the descriptor set.
  VkDeviceSize Range  /// Size in bytes of the buffer resource for this descriptor update.
}

class VkWriteDescriptorSet {
  VkStructureType               sType            /// Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
  const void*                   pNext            /// Pointer to next structure
  VkDescriptorSet               dstSet           /// Destination descriptor set
  u32                           dstBinding       /// Binding within the destination descriptor set to write
  u32                           dstArrayElement  /// Array element within the destination binding to write
  u32                           descriptorCount  /// Number of descriptors to write (determines the size of the array pointed by <pDescriptors>)
  VkDescriptorType              descriptorType   /// Descriptor type to write (determines which fields of the array pointed by <pDescriptors> are going to be used)
  const VkDescriptorImageInfo*  pImageInfo
  const VkDescriptorBufferInfo* pBufferInfo
  const VkBufferView*           pTexelBufferView
}

class VkCopyDescriptorSet {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
  const void*     pNext           /// Pointer to next structure
  VkDescriptorSet srcSet          /// Source descriptor set
  u32             srcBinding      /// Binding within the source descriptor set to copy from
  u32             srcArrayElement /// Array element within the source binding to copy from
  VkDescriptorSet dstSet          /// Destination descriptor set
  u32             dstBinding      /// Binding within the destination descriptor set to copy to
  u32             dstArrayElement /// Array element within the destination binding to copy to
  u32             descriptorCount /// Number of descriptors to copy
}

class VkFramebufferCreateInfo {
  VkStructureType          sType           /// Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
  const void*              pNext           /// Pointer to next structure
  VkFramebufferCreateFlags flags
  VkRenderPass             renderPass
  u32                      attachmentCount
  const VkImageView*       pAttachments
  u32                      width
  u32                      height
  u32                      layers
}

class VkAttachmentDescription {
  VkAttachmentDescriptionFlags flags
  VkFormat                     format
  VkSampleCountFlagBits        samples
  VkAttachmentLoadOp           loadOp         /// Load op for color or depth data
  VkAttachmentStoreOp          storeOp        /// Store op for color or depth data
  VkAttachmentLoadOp           stencilLoadOp  /// Load op for stencil data
  VkAttachmentStoreOp          stencilStoreOp /// Store op for stencil data
  VkImageLayout                initialLayout
  VkImageLayout                finalLayout
}

class VkAttachmentReference {
  u32           Attachment // We have capitalized these so we can manipulate
  VkImageLayout Layout     // them in Go
}

class VkSubpassDescription {
  VkSubpassDescriptionFlags    flags
  VkPipelineBindPoint          pipelineBindPoint       /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
  u32                          inputAttachmentCount
  const VkAttachmentReference* pInputAttachments
  u32                          colorAttachmentCount
  const VkAttachmentReference* pColorAttachments
  const VkAttachmentReference* pResolveAttachments
  const VkAttachmentReference* pDepthStencilAttachment
  u32                          preserveAttachmentCount
  const u32*                   pPreserveAttachments
}

class VkSubpassDependency {
  u32                  srcSubpass
  u32                  dstSubpass
  VkPipelineStageFlags srcStageMask
  VkPipelineStageFlags dstStageMask
  VkAccessFlags        srcAccessMask
  VkAccessFlags        dstAccessMask
  VkDependencyFlags    dependencyFlags
}

class VkRenderPassCreateInfo {
  VkStructureType                sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
  const void*                    pNext           /// Pointer to next structure
  VkRenderPassCreateFlags        flags
  u32                            attachmentCount
  const VkAttachmentDescription* pAttachments
  u32                            subpassCount
  const VkSubpassDescription*    pSubpasses
  u32                            dependencyCount
  const VkSubpassDependency*     pDependencies
}

class VkCommandPoolCreateInfo {
  VkStructureType          sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkCommandPoolCreateFlags flags            /// Command pool creation flags
  u32                      queueFamilyIndex
}

class VkCommandBufferAllocateInfo {
  VkStructureType      sType              /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
  const void*          pNext              /// Pointer to next structure
  VkCommandPool        commandPool
  VkCommandBufferLevel level
  u32                  commandBufferCount
}

class VkCommandBufferInheritanceInfo {
  VkStructureType               sType                /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
  const void*                   pNext                /// Pointer to next structure
  VkRenderPass                  renderPass           /// Render pass for secondary command buffers
  u32                           subpass
  VkFramebuffer                 framebuffer          /// Framebuffer for secondary command buffers
  VkBool32                      occlusionQueryEnable
  VkQueryControlFlags           queryFlags
  VkQueryPipelineStatisticFlags pipelineStatistics
}

class VkCommandBufferBeginInfo {
  VkStructureType                       sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
  const void*                           pNext            /// Pointer to next structure
  VkCommandBufferUsageFlags             flags            /// Command buffer usage flags
  const VkCommandBufferInheritanceInfo* pInheritanceInfo
}

class VkBufferCopy {
  VkDeviceSize srcOffset /// Specified in bytes
  VkDeviceSize dstOffset /// Specified in bytes
  VkDeviceSize size      /// Specified in bytes
}

class VkImageSubresourceLayers {
  VkImageAspectFlags aspectMask
  u32                mipLevel
  u32                baseArrayLayer
  u32                layerCount
}

class VkImageCopy {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset      /// Specified in pixels for both compressed and uncompressed images
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset      /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               extent         /// Specified in pixels for both compressed and uncompressed images
}

class VkImageBlit {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D[2]            srcOffsets
  VkImageSubresourceLayers dstSubresource
  VkOffset3D[2]            dstOffsets
}

class VkBufferImageCopy {
  VkDeviceSize             bufferOffset      /// Specified in bytes
  u32                      bufferRowLength   /// Specified in texels
  u32                      bufferImageHeight
  VkImageSubresourceLayers imageSubresource
  VkOffset3D               imageOffset       /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               imageExtent       /// Specified in pixels for both compressed and uncompressed images
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
class VkClearColorValue {
  //f32[4]                                      float32
  //s32[4]                                      int32
  u32[4] uint32
}

class VkClearDepthStencilValue {
  f32 depth
  u32 stencil
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.
class VkClearValue {
  VkClearColorValue color
//    VkClearDepthStencilValue                    depthStencil
}

class VkClearAttachment {
  VkImageAspectFlags aspectMask
  u32                colorAttachment
  VkClearValue       clearValue
}

class VkClearRect {
  VkRect2D rect
  u32      baseArrayLayer
  u32      layerCount
}

class VkImageResolve {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset
  VkExtent3D               extent
}

class VkMemoryBarrier {
  VkStructureType sType         /// Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
  const void*     pNext         /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
}

class VkBufferMemoryBarrier {
  VkStructureType sType               /// Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
  const void*     pNext               /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
  u32             srcQueueFamilyIndex /// Queue family to transition ownership from
  u32             dstQueueFamilyIndex /// Queue family to transition ownership to
  VkBuffer        buffer              /// Buffer to sync
  VkDeviceSize    offset              /// Offset within the buffer to sync
  VkDeviceSize    size                /// Amount of bytes to sync
}

class VkImageMemoryBarrier {
  VkStructureType         sType               /// Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
  const void*             pNext               /// Pointer to next structure.
  VkAccessFlags           srcAccessMask
  VkAccessFlags           dstAccessMask
  VkImageLayout           oldLayout           /// Current layout of the image
  VkImageLayout           newLayout           /// New layout to transition the image to
  u32                     srcQueueFamilyIndex /// Queue family to transition ownership from
  u32                     dstQueueFamilyIndex /// Queue family to transition ownership to
  VkImage                 image               /// Image to sync
  VkImageSubresourceRange subresourceRange    /// Subresource range to sync
}

class VkRenderPassBeginInfo {
  VkStructureType     sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
  const void*         pNext           /// Pointer to next structure
  VkRenderPass        renderPass
  VkFramebuffer       framebuffer
  VkRect2D            renderArea
  u32                 clearValueCount
  const VkClearValue* pClearValues
}

class VkDispatchIndirectCommand {
  u32 x
  u32 y
  u32 z
}

class VkDrawIndexedIndirectCommand {
  u32 indexCount
  u32 instanceCount
  u32 firstIndex
  s32 vertexOffset
  u32 firstInstance
}

class VkDrawIndirectCommand {
  u32 vertexCount
  u32 instanceCount
  u32 firstVertex
  u32 firstInstance
}

////////////////////////////////////////////////////////////////////////////////
////////// Extensions //////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// VK_NV_dedicated_allocation

/// Format capability flags
@unused
@extension("VK_NV_dedicated_allocation")
bitfield VkExternalMemoryHandleTypeFlagBitsNV {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV     = 0x00000001,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV      = 0x00000004,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV  = 0x00000008,
}
@unused
@extension("VK_NV_dedicated_allocation")
type VkFlags VkExternalMemoryHandleTypeFlagsNV

@extension("VK_NV_dedicated_allocation")
class VkDedicatedAllocationImageCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@extension("VK_NV_dedicated_allocation")
class VkDedicatedAllocationBufferCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@extension("VK_NV_dedicated_allocation")
class VkDedicatedAllocationMemoryAllocateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  VkImage                 image
  VkBuffer                buffer
}

// VK_KHR_get_memory_requirements2

@extension("VK_KHR_get_memory_requirements2")
class VkBufferMemoryRequirementsInfo2KHR {
  VkStructureType sType
  const void*     pNext
  VkBuffer        buffer
}

@extension("VK_KHR_get_memory_requirements2")
class VkImageMemoryRequirementsInfo2KHR {
  VkStructureType sType
  const void*     pNext
  VkImage         image
}

@extension("VK_KHR_get_memory_requirements2")
class VkMemoryRequirements2KHR {
  VkStructureType      sType
  void*                pNext
  VkMemoryRequirements memoryRequirements
}

@extension("VK_KHR_get_memory_requirements2")
class VkImageSparseMemoryRequirementsInfo2KHR {
  VkStructureType sType
  const void*     pNext
  VkImage         image
}

@extension("VK_KHR_get_memory_requirements2")
class VkSparseImageMemoryRequirements2KHR {
  VkStructureType                 sType
  void*                           pNext
  VkSparseImageMemoryRequirements memoryRequirements
}

@extension("VK_KHR_get_memory_requirements2")
@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements2KHR(
    VkDevice                                 device,
    const VkImageMemoryRequirementsInfo2KHR* pInfo,
    VkMemoryRequirements2KHR*                pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  info := pInfo[0]
  // TODO: handle pNext for 'info'

  fence

  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements2KHR") }
  pMemoryRequirements[0] = ?
  memReq := pMemoryRequirements[0]

  if !(info.image in Images) { vkErrorInvalidImage(info.image) }
  // TODO: Drop the touch of the image object once we extract the memory
  // requirement info out of the image object.
  Images[info.image].MemoryRequirements = memReq.memoryRequirements

  if memReq.pNext != null {
    numPNext := numberOfPNext(as!const void*(memReq.pNext))
    next := MutableVoidPtr(as!void*(memReq.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: {
          ext := as!VkMemoryDedicatedRequirementsKHR*(next.Ptr)[0:1][0]
          Images[info.image].DedicatedRequirementsKHR = new!DedicatedRequirementsKHR(
            PrefersDedicatedAllocation:   ext.prefersDedicatedAllocation,
            RequiresDedicatedAllocation:  ext.requiresDedicatedAllocation,
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
}

@extension("VK_KHR_get_memory_requirements2")
@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements2KHR(
    VkDevice                                  device,
    const VkBufferMemoryRequirementsInfo2KHR* pInfo,
    VkMemoryRequirements2KHR*                 pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  info := pInfo[0]
  // TODO: handle pNext

  fence

  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements2KHR") }
  pMemoryRequirements[0] = ?
  // TODO: handle pNext for 'memReq'
  memReq := pMemoryRequirements[0]
  if !(info.buffer in Buffers) { vkErrorInvalidBuffer(info.buffer) }
  // TODO: Do the touch of the buffer object once we extract the memory
  // requirement info out of the buffer objectd.
  Buffers[info.buffer].MemoryRequirements = memReq.memoryRequirements

  if memReq.pNext != null {
    numPNext := numberOfPNext(as!const void*(memReq.pNext))
    next := MutableVoidPtr(as!void*(memReq.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: {
          ext := as!VkMemoryDedicatedRequirementsKHR*(next.Ptr)[0:1][0]
          Buffers[info.buffer].DedicatedRequirementsKHR = new!DedicatedRequirementsKHR(
            PrefersDedicatedAllocation:   ext.prefersDedicatedAllocation,
            RequiresDedicatedAllocation:  ext.requiresDedicatedAllocation,
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
}

@extension("VK_KHR_get_memory_requirements2")
@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements2KHR(
    VkDevice                                       device,
    const VkImageSparseMemoryRequirementsInfo2KHR* pInfo,
    u32*                                           pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2KHR*           pSparseMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  info := pInfo[0]
  image := info.image
  if !(image in Images) { vkErrorInvalidImage(image) }
  // TODO: handle pNext
  if pSparseMemoryRequirementCount == null { vkErrorNullPointer("uint32_t") }
  read(pSparseMemoryRequirementCount[0:1])

  fence

  if pSparseMemoryRequirements == null {
    pSparseMemoryRequirementCount[0] = ?
  } else {
    count := as!u32(?)
    requirements := pSparseMemoryRequirements[0:count]
    for i in (0 .. count) {
      requirements[i] = ?
      // TODO: handle pNext for 'requirements[i]'
      aspect := requirements[i].memoryRequirements.formatProperties.aspectMask
      // TODO: Drop the touch of the image object.
      Images[image].SparseMemoryRequirements[as!u32(aspect)] = requirements[i].memoryRequirements
    }
    pSparseMemoryRequirementCount[0] = count
  }
}

// VK_KHR_dedicated_allocation

@extension("VK_KHR_dedicated_allocation")
class VkMemoryDedicatedRequirementsKHR {
  VkStructureType sType
  void*           pNext
  VkBool32        prefersDedicatedAllocation
  VkBool32        requiresDedicatedAllocation
}

@extension("VK_KHR_dedicated_allocation")
class VkMemoryDedicatedAllocationInfoKHR {
  VkStructureType sType
  const void*     pNext
  VkImage         image
  VkBuffer        buffer
}

// VK_KHR_get_physical_device_properties2

@extension("VK_KHR_device_properties2")
class VkPhysicalDeviceFeatures2KHR {
  VkStructureType          sType
  void*                    pNext
  VkPhysicalDeviceFeatures features
}

@extension("VK_KHR_device_properties2")
class VkPhysicalDeviceProperties2KHR {
  VkStructureType            sType
  void*                      pNext
  VkPhysicalDeviceProperties properties
}

@extension("VK_KHR_device_properties2")
class VkFormatProperties2KHR {
  VkStructureType    sType
  void*              pNext
  VkFormatProperties formatProperties
}

@extension("VK_KHR_device_properties2")
class VkImageFormatProperties2KHR {
  VkStructureType         sType
  void*                   pNext
  VkImageFormatProperties imageFormatProperties
}

@extension("VK_KHR_device_properties2")
class VkPhysicalDeviceImageFormatInfo2KHR {
  VkStructureType    sType
  const void*        pNext
  VkFormat           format
  VkImageType        type
  VkImageTiling      tiling
  VkImageUsageFlags  usage
  VkImageCreateFlags flags
}

@extension("VK_KHR_device_properties2")
class VkQueueFamilyProperties2KHR {
  VkStructureType         sType
  void*                   pNext
  VkQueueFamilyProperties queueFamilyProperties
}

@extension("VK_KHR_device_properties2")
class VkPhysicalDeviceMemoryProperties2KHR {
  VkStructureType                  sType
  void*                            pNext
  VkPhysicalDeviceMemoryProperties memoryProperties
}

@extension("VK_KHR_device_properties2")
class VkSparseImageFormatProperties2KHR {
  VkStructureType               sType
  void*                         pNext
  VkSparseImageFormatProperties properties
}

@extension("VK_KHR_device_properties2")
class VkPhysicalDeviceSparseImageFormatInfo2KHR {
  VkStructureType       sType
  const void*           pNext
  VkFormat              format
  VkImageType           type
  VkSampleCountFlagBits samples
  VkImageUsageFlags     usage
  VkImageTiling         tiling
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice              physicalDevice,
    VkPhysicalDeviceFeatures2KHR* pFeatures) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFeatures == null { vkErrorNullPointer("VkPhysicalDeviceFeatures2KHR") }
  pFeatures[0] = ?
  // TODO: handle pNext
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice                physicalDevice,
    VkPhysicalDeviceProperties2KHR* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pProperties == null { vkErrorNullPointer("VkPhysicalDeviceProperties2KHR") }
  pProperties[0] = ?
  // TODO: handle pNext
  PhysicalDevices[physicalDevice].PhysicalDeviceProperties = pProperties[0].properties
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice        physicalDevice,
    VkFormat                format,
    VkFormatProperties2KHR* pFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFormatProperties == null { vkErrorNullPointer("VkFormatProperties2KHR") }
  pFormatProperties[0] = ?
  // TODO: handle pNext
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice                           physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2KHR* pImageFormatInfo,
    VkImageFormatProperties2KHR*               pImageFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pImageFormatInfo == null { vkErrorNullPointer("const VkPhysicalDeviceImageFormatInfo2KHR") }
  if pImageFormatProperties == null { vkErrorNullPointer("VkImageFormatProperties2KHR") }
  pImageFormatProperties[0] = ?
  // TODO: handle pNext
  return ?
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice             physicalDevice,
    u32*                         pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2KHR* pQueueFamilyProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pQueueFamilyPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: handle pNext
    }
    pQueueFamilyPropertyCount[0] = count
    if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i].queueFamilyProperties
    }
  }
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice                      physicalDevice,
    VkPhysicalDeviceMemoryProperties2KHR* pMemoryProperties) {
  if pMemoryProperties == null { vkErrorNullPointer("VkPhysicalDeviceMemoryProperties2KHR") }
  fence
  pMemoryProperties[0] = ?
  memoryProperties := pMemoryProperties[0]

  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  PhysicalDevices[physicalDevice].MemoryProperties = memoryProperties.memoryProperties
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_device_properties2")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice                                 physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2KHR* pFormatInfo,
    u32*                                             pPropertyCount,
    VkSparseImageFormatProperties2KHR*               pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@extension("VK_KHR_get_surface_capabilities2")
class VkPhysicalDeviceSurfaceInfo2KHR {
  VkStructureType sType
  const void*     pNext
  VkSurfaceKHR    surface
}

@extension("VK_KHR_get_surface_capabilities2")
class VkSurfaceCapabilities2KHR {
  VkStructureType          sType
  void*                    pNext
  VkSurfaceCapabilitiesKHR surfaceCapabilities
}

@extension("VK_KHR_get_surface_capabilities2")
class VkSurfaceFormat2KHR {
  VkStructureType    sType
  void*              pNext
  VkSurfaceFormatKHR surfaceFormat
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_get_surface_capabilities2")
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                       physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR*             pSurfaceCapabilities) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pSurfaceInfo == null { vkErrorNullPointer("const VkPhysicalDeviceSurfaceInfo2KHR") }
  info := pSurfaceInfo[0]
  // TODO: handle pNext
  if !(info.surface in Surfaces) { vkErrorInvalidSurface(info.surface) }
  if pSurfaceCapabilities == null { vkErrorNullPointer("VkSurfaceCapabilitiesKHR") }
  pSurfaceCapabilities[0] = ?
  // TODO: handle pNext
  return ?

}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@extension("VK_KHR_get_surface_capabilities2")
cmd VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                       physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    u32*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                   pSurfaceFormats) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pSurfaceInfo == null { vkErrorNullPointer("const VkPhysicalDeviceSurfaceInfo2KHR") }
  info := pSurfaceInfo[0]
  // TODO: handle pNext
  if !(info.surface in Surfaces) { vkErrorInvalidSurface(info.surface) }
  if pSurfaceFormatCount == null { vkErrorNullPointer("uint32_t") }
  _ = pSurfaceFormatCount[0]
  fence
  if pSurfaceFormats == null {
    pSurfaceFormatCount[0] = ?
  } else {
    count := as!u32(?)
    formats := pSurfaceFormats[0:count]
    for i in (0 .. count) {
      formats[i] = ?
    }
    pSurfaceFormatCount[0] = count
  }

  return ?
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@internal class MutableVoidPtr {
  void* Ptr
}

type void* VoidPtr
// Declare the type so external function: numberOfPNext can use the type.
type const void** ConstVoidPtrPtr
// Returns the number of structs in the linked list pointed by the pNext pointer.
extern u32 numberOfPNext(const void* pNext)

@custom
@threadSafety("system")
@override
cmd VkResult vkCreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance*                  pInstance) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkInstance() in synthetic.api. Change both together.

  instance := createInstanceObject(pCreateInfo)
  // TODO: pAllocator
  handle := ?
  if pInstance == null { vkErrorNullPointer("VkInstance") }
  pInstance[0] = handle
  instance.VulkanHandle = handle
  Instances[handle] = instance
  return ?
}

@threadSafety("system")
@indirect("VkInstance")
@override
@custom
cmd void vkDestroyInstance(
    VkInstance                   instance,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Instances, instance)
}

@threadSafety("system")
@indirect("VkInstance")
cmd VkResult vkEnumeratePhysicalDevices(
    VkInstance        instance,
    u32*              pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices) {
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
  if pPhysicalDeviceCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPhysicalDeviceCount[0]

  fence
  if pPhysicalDevices == null {
    pPhysicalDeviceCount[0] = ?
  } else {
    count := as!u32(?)
    devices := pPhysicalDevices[0:count]
    for i in (0 .. count) {
      device := ?
      devices[i] = device
    }
    pPhysicalDeviceCount[0] = count

    for i in (0 .. count) {
      object := switch (PhysicalDevices[devices[i]] == null) {
        case true:
          new!PhysicalDeviceObject()
        case false:
          PhysicalDevices[devices[i]]
      }
      object.Instance = instance
      object.Index = i
      object.VulkanHandle = devices[i]
      PhysicalDevices[devices[i]] = object
    }
  }

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice          physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFeatures == null { vkErrorNullPointer("VkPhysicalDeviceFeatures") }
  pFeatures[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice    physicalDevice,
    VkFormat            format,
    VkFormatProperties* pFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFormatProperties == null { vkErrorNullPointer("VkFormatProperties") }
  pFormatProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice         physicalDevice,
    VkFormat                 format,
    VkImageType              type,
    VkImageTiling            tiling,
    VkImageUsageFlags        usage,
    VkImageCreateFlags       flags,
    VkImageFormatProperties* pImageFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pImageFormatProperties == null { vkErrorNullPointer("VkImageFormatProperties") }
  pImageFormatProperties[0] = ?
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice            physicalDevice,
    VkPhysicalDeviceProperties* pProperties) {
  if pProperties == null { vkErrorNullPointer("VkPhysicalDeviceProperties") }
  pProperties[0] = ?
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  PhysicalDevices[physicalDevice].PhysicalDeviceProperties = pProperties[0]
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice         physicalDevice,
    u32*                     pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
  if pQueueFamilyPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pQueueFamilyPropertyCount[0] = count
    if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i]
    }
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                  physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  memoryProperties := ?
  if pMemoryProperties == null { vkErrorNullPointer("VkPhysicalDeviceMemoryProperties") }
  pMemoryProperties[0] = memoryProperties

  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  dev := PhysicalDevices[physicalDevice]
  dev.MemoryProperties = memoryProperties
  PhysicalDevices[physicalDevice] = dev
}

@indirect("VkInstance")
@override
cmd PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance  instance,
    const char* pName) {

  _ = as!string(pName)
  return ?
}

@indirect("VkDevice")
@override
cmd PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice    device,
    const char* pName) {

  _ = as!string(pName)
  return ?
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@override
@custom
cmd VkResult vkCreateDevice(
    VkPhysicalDevice             physicalDevice,
    const VkDeviceCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice*                    pDevice) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkDevice() in synthetic.api. Change both together.
  device := createDeviceObject(pCreateInfo)
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  device.PhysicalDevice = physicalDevice
  // TODO: pAllocator

  handle := ?
  if pDevice == null { vkErrorNullPointer("VkDevice*") }
  pDevice[0] = handle
  device.VulkanHandle = handle
  Devices[handle] = device

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@override
@custom
cmd void vkDestroyDevice(
    VkDevice                     device,
    const VkAllocationCallbacks* pAllocator) {
  if (device in Devices) {
    dev := Devices[device]
    for _, _, v in dev.QueueObjects {
      if LastBoundQueue == v {
        LastBoundQueue = null
      }
      for i in (0 .. LastPresentInfo.PresentImageCount) {
        if (LastPresentInfo.PresentImages[i].Device == device) {
          delete(LastPresentInfo.PresentImages, i)
        }
      }
      delete(Queues, v.VulkanHandle)
    }
  }
  
  // TODO: pAllocator  
  delete(Devices, device)
}

sub void queryExtensionProperties(u32* pPropertyCount, VkExtensionProperties* pProperties) {
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceExtensionProperties(
    const char*            pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {

  _ = as!string(pLayerName)

  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice       physicalDevice,
    const char*            pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {

  _ = as!string(pLayerName)

  // Do not check validness of physicalDevice as the loader may feed 0 to it.
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

sub void queryLayerProperties(u32* pPropertyCount, VkLayerProperties* pProperties) {
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceLayerProperties(
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice   physicalDevice,
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  // Do not check validness of physicalDevice as the loader may feed 0 to it.
  queryLayerProperties(pPropertyCount, pProperties)
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkGetDeviceQueue(
    VkDevice device,
    u32      queueFamilyIndex,
    u32      queueIndex,
    VkQueue* pQueue) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  dev := Devices[device]
  id := ?
  Queues[id] = new!QueueObject(Device: device,Family:  queueFamilyIndex,Index:  queueIndex,VulkanHandle:  id)
  
  dev.QueueObjects[len(dev.QueueObjects)] = Queues[id]

  if pQueue == null { vkErrorNullPointer("VkQueue") }
  pQueue[0] = id
}

// TODO: Not all vkQueueSubmit calls submit vkCmdDrawXXX commands. Need better
// a way so that only those recorded with draw commands will be labelled as
// draw call.
@draw_call
@threadSafety("app")
@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueSubmit(
    VkQueue             queue,
    u32                 submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence             fence) {
  if !(queue in Queues) { vkErrorInvalidQueue(queue) }
  LastSubmission = SUBMIT
  submitInfo := pSubmits[0:submitCount]
  LastBoundQueue = Queues[queue]

  enterSubcontext()
  for i in (0 .. submitCount) {
    info := submitInfo[i]
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for j in (0 .. info.waitSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
      = new!CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
        Unsignal,    wait_semaphores[j],    null)
    }
    read(info.pWaitDstStageMask[0:info.waitSemaphoreCount])

    command_buffers := info.pCommandBuffers[0:info.commandBufferCount]

    enterSubcontext()
    for j in (0 .. info.commandBufferCount) {
      enterSubcontext()
      cb := CommandBuffers[command_buffers[j]]
      for k in (0 .. len(cb.CommandReferences)) {
        ref := cb.CommandReferences[as!u32(k)]
        LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
        = new!CommandReference(
          ref.Buffer,
          ref.CommandIndex,
          ref.Type,
          ref.MapIndex,
          ref.SemaphoreUpdate,
          ref.Semaphore,
          ref.SparseBinds,
        )
        notifyPendingCommandAdded(queue)
        if ref.Type == cmd_vkCmdExecuteCommands {
          enterSubcontext()
          ec := cb.BufferCommands.vkCmdExecuteCommands[ref.MapIndex]
          for l in (0 .. len(ec.CommandBuffers)) {
            scb := CommandBuffers[ec.CommandBuffers[as!u32(l)]]
            enterSubcontext()
            for c in (0 .. len(scb.CommandReferences)) {
              sref := scb.CommandReferences[as!u32(c)]
              LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
              = new!CommandReference(
                sref.Buffer,
                sref.CommandIndex,
                sref.Type,
                sref.MapIndex,
                sref.SemaphoreUpdate,
                sref.Semaphore,
                sref.SparseBinds,
              )
              notifyPendingCommandAdded(queue)
            }
            leaveSubcontext()
            nextSubcontext()
          }
          leaveSubcontext()
        }
      }
      leaveSubcontext()
      nextSubcontext()
    }
    leaveSubcontext()

    signal_semaphores := info.pSignalSemaphores[0:info.signalSemaphoreCount]
    for j in (0 .. info.signalSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
      = new!CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
        Signal,      signal_semaphores[j],  null)
    }
    nextSubcontext()
  }
  leaveSubcontext()
  execPendingCommands(queue)
  fence
  return ?
}

@threadSafety("system")
@indirect("VkQueue", "VkDevice")
@blocking
cmd VkResult vkQueueWaitIdle(
    VkQueue queue) {
  if !(queue in Queues) { vkErrorInvalidQueue(queue) }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkDeviceWaitIdle(
    VkDevice device) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  return ?
}

sub bool IsMemoryCoherent(ref!DeviceMemoryObject memory) {
  physical_device := PhysicalDevices[Devices[memory.Device].PhysicalDevice]
  return 0 != (as!u32(physical_device.MemoryProperties.memoryTypes[memory.MemoryTypeIndex].propertyFlags) &
  as!u32(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkAllocateMemory(
    VkDevice                     device,
    const VkMemoryAllocateInfo*  pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory*              pMemory) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pAllocateInfo == null { vkErrorNullPointer("VkMemoryAllocateInfo") }
  allocateInfo := pAllocateInfo[0]

  memoryObject := new!DeviceMemoryObject(
    Device:           device,
    VulkanHandle:     0,
    AllocationSize:   allocateInfo.allocationSize,
    MappedOffset:     0,
    MappedSize:       0,
    MappedLocation:   null,
    MemoryTypeIndex:  allocateInfo.memoryTypeIndex
  )
  memoryObject.Data = make!u8(allocateInfo.allocationSize)

  // Handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
          ext := as!VkDedicatedAllocationMemoryAllocateInfoNV*(next.Ptr)[0:1][0]
          memoryObject.DedicatedAllocationNV = new!MemoryDedicatedAllocationInfo(
            Image:   ext.image,
            Buffer:  ext.buffer,
          )
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: {
          ext := as!VkMemoryDedicatedAllocationInfoKHR*(next.Ptr)[0:1][0]
          memoryObject.DedicatedAllocationKHR = new!MemoryDedicatedAllocationInfo(
            Image:   ext.image,
            Buffer:  ext.buffer,
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  memory := ?
  if pMemory == null { vkErrorNullPointer("VkDeviceMemory") }
  pMemory[0] = memory

  memoryObject.VulkanHandle = memory
  DeviceMemories[memory] = memoryObject
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkFreeMemory(
    VkDevice                     device,
    VkDeviceMemory               memory,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (memory != as!VkDeviceMemory(0)) {
    memoryObject := DeviceMemories[memory]

    if (memoryObject.MappedSize != 0) {
      mappedLocation := as!u8*(memoryObject.MappedLocation)
      unmapMemory(mappedLocation[0:memoryObject.MappedSize])
    }
    delete(DeviceMemories, memory)
  }
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkMapMemory(
    VkDevice         device,
    VkDeviceMemory   memory,
    VkDeviceSize     offset,
    VkDeviceSize     size,
    VkMemoryMapFlags flags,
    void**           ppData) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memory) }
  // TODO(awoloszyn): Figure out why we need the read/write here
  // in order for the replay to allocate the memory we need.
  // see: b/32300796
  memoryObject := DeviceMemories[memory]
  memoryObject.MappedOffset = offset
  if (size == 0xFFFFFFFFFFFFFFFF) {
    memoryObject.MappedSize = memoryObject.AllocationSize - offset
  } else {
    memoryObject.MappedSize = size
  }
  if ppData == null { vkErrorNullPointer("void*") }
  read(ppData[0:1])
  memoryLocation := ?
  ppData[0] = memoryLocation

  mapMemory(ppData, as!u8*(memoryLocation)[0:memoryObject.MappedSize])
  memoryObject.MappedLocation = memoryLocation
  DeviceMemories[memory] = memoryObject
  if (IsMemoryCoherent(memoryObject)) {
    trackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  return ?
}

@threadSafety("app")
@indirect("VkDevice")
cmd void vkUnmapMemory(
    VkDevice       device,
    VkDeviceMemory memory) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memory) }
  memoryObject := DeviceMemories[memory]
  mappedLocation := as!u8*(memoryObject.MappedLocation)
  if (IsMemoryCoherent(memoryObject)) {
    readCoherentMemory(memoryObject, memoryObject.MappedOffset, memoryObject.MappedSize)
    untrackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  unmapMemory(mappedLocation[0:memoryObject.MappedSize])
  memoryObject.MappedSize = 0
  memoryObject.MappedLocation = null
}

@indirect("VkDevice")
cmd VkResult vkFlushMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount
    const VkMappedMemoryRange* pMemoryRanges) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    flushRange := memoryRanges[i]
    if !(flushRange.memory in DeviceMemories) { vkErrorInvalidDeviceMemory(flushRange.memory) }
    memoryObject := DeviceMemories[flushRange.memory]
    mappedLocation := as!u8*(memoryObject.MappedLocation)
    flushStart := flushRange.offset - memoryObject.MappedOffset
    // TODO: Log errors if flush offset - mapped offset is negative or
    // flushRange.size is out of bounds.

    if (IsMemoryCoherent(memoryObject)) {
      readCoherentMemory(memoryObject, flushRange.offset, flushRange.size)
    } else {
      if (flushRange.size == 0xFFFFFFFFFFFFFFFF) {
        // copy() contains an implicit read observation
        copy(memoryObject.Data[flushRange.offset:memoryObject.MappedOffset + memoryObject.MappedSize], (mappedLocation)[flushStart:memoryObject.MappedSize])
      } else {
        // copy() contains an implicit read observation
        copy(memoryObject.Data[flushRange.offset:flushRange.offset + flushRange.size], (mappedLocation)[flushStart:flushStart + flushRange.size])
      }
    }
  }
  return ?
}

@internal
class MemoryRangeArray {
  map!(u32, void*) PData
  map!(u32, u64)   Start
  map!(u32, u64)   End
}

@indirect("VkDevice")
cmd VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  ranges := new!MemoryRangeArray()
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    invalidateRange := memoryRanges[i]
    invalidateOffset := invalidateRange.offset
    if !(invalidateRange.memory in DeviceMemories) { vkErrorInvalidDeviceMemory(invalidateRange.memory) }
    mappedLocation := DeviceMemories[invalidateRange.memory].MappedLocation
    mappedOffset := DeviceMemories[invalidateRange.memory].MappedOffset
    mappedSize := DeviceMemories[invalidateRange.memory].MappedSize
    ranges.PData[i] = mappedLocation
    ranges.Start[i] = as!u64(invalidateOffset - mappedOffset)
    // TODO: Log errors if invalidate offset - mapped offset is negative or
    // invalidateRange.size is out of bounds.
    if (invalidateRange.size == 0xFFFFFFFFFFFFFFFF) {
      ranges.End[i] = as!u64(mappedSize)
    } else {
      ranges.End[i] = ranges.Start[i] + as!u64(invalidateRange.size)
    }
  }
  for i in (0 .. memoryRangeCount) {
    write(ranges.PData[i][ranges.Start[i]:ranges.End[i]])
  }
  return ?
}


// Memory management API functions

@indirect("VkDevice")
cmd void vkGetDeviceMemoryCommitment(
    VkDevice       device,
    VkDeviceMemory memory,
    VkDeviceSize*  pCommittedMemoryInBytes) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memory) }
  _ = pCommittedMemoryInBytes[0]
}

@indirect("VkDevice")
cmd VkResult vkBindBufferMemory(
    VkDevice       device,
    VkBuffer       buffer,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memory) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  Buffers[buffer].Memory = DeviceMemories[memory]
  Buffers[buffer].MemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(buffer)] = memoryOffset
  if (Buffers[buffer].Info.DedicatedAllocationNV != null) && (DeviceMemories[memory].DedicatedAllocationNV == null) {
    vkErrorExpectNVDedicatedlyAllocatedHandle("VkBuffer", as!u64(buffer))
  }
  if (Buffers[buffer].Info.DedicatedAllocationNV == null) && (DeviceMemories[memory].DedicatedAllocationNV != null) {
    vkErrorExpectNVDedicatedlyAllocatedHandle("VkDeviceMemory", as!u64(memory))
  }
  return ?
}

@indirect("VkDevice")
cmd VkResult vkBindImageMemory(
    VkDevice       device,
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memory) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  Images[image].BoundMemory = DeviceMemories[memory]
  Images[image].BoundMemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(image)] = memoryOffset
  if (Images[image].Info.DedicatedAllocationNV != null) && (DeviceMemories[memory].DedicatedAllocationNV == null) {
    vkErrorExpectNVDedicatedlyAllocatedHandle("VkImage", as!u64(image))
  }
  if (Images[image].Info.DedicatedAllocationNV == null) && (DeviceMemories[memory].DedicatedAllocationNV != null) {
    vkErrorExpectNVDedicatedlyAllocatedHandle("VkDeviceMemory", as!u64(memory))
  }
  return ?
}

@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements(
    VkDevice              device,
    VkBuffer              buffer,
    VkMemoryRequirements* pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  requirements := ?
  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements") }
  pMemoryRequirements[0] = requirements
  Buffers[buffer].MemoryRequirements = requirements
  if (as!u32(Buffers[buffer].Info.Usage) & as!u32(VK_IMAGE_USAGE_TRANSFER_SRC_BIT)) != 0 {
    if !(device in TransferBufferMemoryRequirements) {
      TransferBufferMemoryRequirements[device] = VkMemoryRequirements()
    }
    reqs := TransferBufferMemoryRequirements[device]
    reqs.memoryTypeBits =
    reqs.memoryTypeBits | Buffers[buffer].MemoryRequirements.memoryTypeBits
    TransferBufferMemoryRequirements[device] = reqs
  }
}

@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements(
    VkDevice              device,
    VkImage               image,
    VkMemoryRequirements* pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  requirements := ?
  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements") }
  pMemoryRequirements[0] = requirements
  Images[image].MemoryRequirements = requirements
}

@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements(
    VkDevice                         device,
    VkImage                          image,
    u32*                             pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  if pSparseMemoryRequirementCount == null { vkErrorNullPointer("uint32_t") }
  read(pSparseMemoryRequirementCount[0:1])

  fence

  if pSparseMemoryRequirements == null {
    pSparseMemoryRequirementCount[0] = ?
  } else {
    count := as!u32(?)
    requirements := pSparseMemoryRequirements[0:count]
    for i in (0 .. count) {
      requirements[i] = ?
      aspect := requirements[i].formatProperties.aspectMask
      Images[image].SparseMemoryRequirements[as!u32(aspect)] = requirements[i]
    }
    pSparseMemoryRequirementCount[0] = count
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice               physicalDevice,
    VkFormat                       format,
    VkImageType                    type,
    VkSampleCountFlagBits          samples,
    VkImageUsageFlags              usage,
    VkImageTiling                  tiling,
    u32*                           pPropertyCount,
    VkSparseImageFormatProperties* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueBindSparse(
    VkQueue                 queue,
    u32                     bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence                 fence) {
  if !(queue in Queues) { vkErrorInvalidQueue(queue) }
  LastBoundQueue = Queues[queue]
  infos := pBindInfo[0:bindInfoCount]
  enterSubcontext()
  for i in (0 .. bindInfoCount) {
    info := infos[i]
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for j in (0 .. info.waitSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
      = new!CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
        Unsignal,    wait_semaphores[j],    null)
    }

    queuedBinds := new!QueuedSparseBinds()

    bufferBinds := info.pBufferBinds[0:info.bufferBindCount]
    for j in (0 .. info.bufferBindCount) {
      bufferBindInfo := bufferBinds[j]
      if !(bufferBindInfo.buffer in Buffers) { vkErrorInvalidBuffer(bufferBindInfo.buffer) }
      bindsToQueue := new!SparseMemoryBinds()
      memoryBinds := bufferBindInfo.pBinds[0:bufferBindInfo.bindCount]
      for k in (0 .. bufferBindInfo.bindCount) {
        if !(memoryBinds[k].memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memoryBinds[k].memory) }
        bindsToQueue.SparseMemoryBinds[k] = memoryBinds[k]
      }
      queuedBinds.BufferBinds[bufferBindInfo.buffer] = bindsToQueue
    }

    opaqueBinds := info.pImageOpaqueBinds[0:info.imageOpaqueBindCount]
    for j in (0 .. info.imageOpaqueBindCount) {
      opaqueBindInfo := opaqueBinds[j]
      if !(opaqueBindInfo.image in Images) { vkErrorInvalidImage(opaqueBindInfo.image) }
      bindsToQueue := new!SparseMemoryBinds()
      memoryBinds := opaqueBindInfo.pBinds[0:opaqueBindInfo.bindCount]
      for k in (0 .. opaqueBindInfo.bindCount) {
        if !(memoryBinds[k].memory in DeviceMemories) { vkErrorInvalidDeviceMemory(memoryBinds[k].memory) }
        bindsToQueue.SparseMemoryBinds[k] = memoryBinds[k]
      }
      queuedBinds.OpaqueImageBinds[opaqueBindInfo.image] = bindsToQueue
    }

    imageBinds := info.pImageBinds[0:info.imageBindCount]
    for j in (0 .. info.imageBindCount) {
      imageBindInfo := imageBinds[j]
      if !(imageBindInfo.image in Images) { vkErrorInvalidImage(imageBindInfo.image) }
      bindsToQueue := new!SparseImageMemoryBinds()
      imageMemoryBinds := imageBindInfo.pBinds[0:imageBindInfo.bindCount]
      for k in (0 .. imageBindInfo.bindCount) {
        if !(imageMemoryBinds[k].memory in DeviceMemories) { vkErrorInvalidDeviceMemory(imageMemoryBinds[k].memory) }
        bindsToQueue.SparseImageMemoryBinds[k] = imageMemoryBinds[k]
      }
      queuedBinds.ImageBinds[imageBindInfo.image] = bindsToQueue
    }

    LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
    = new!CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
      None,          as!VkSemaphore(0),     queuedBinds)

    signal_semaphores := info.pSignalSemaphores[0:info.signalSemaphoreCount]
    for j in (0 .. info.signalSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
      = new!CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
        Signal,      signal_semaphores[j],  null)
    }
  }
  leaveSubcontext()
  execPendingCommands(queue)
  fence
  return ?
}

sub void addSparseImageMemoryBinding(VkImage image, VkSparseImageMemoryBind bind) {
  img := Images[image]
  aspect := as!u32(bind.subresource.aspectMask)
  if !(aspect in img.SparseImageMemoryBindings) {
    img.SparseImageMemoryBindings[aspect] = new!SparseBoundImageAspectInfo()
  }
  aspectInfo := img.SparseImageMemoryBindings[aspect]
  layer := bind.subresource.arrayLayer
  if !(layer in aspectInfo.Layers) {
    aspectInfo.Layers[layer] = new!SparseBoundImageLayerInfo()
  }
  layerInfo := aspectInfo.Layers[layer]
  level := bind.subresource.mipLevel
  if !(level in layerInfo.Levels) {
    layerInfo.Levels[level] = new!SparseBoundImageLevelInfo()
  }
  levelInfo := layerInfo.Levels[level]

  blockSize := img.MemoryRequirements.alignment
  if (aspect in img.SparseMemoryRequirements) {
    gran := img.SparseMemoryRequirements[aspect].formatProperties.imageGranularity
    mipWidth := getMipSize(img.Info.Extent.Width, level)
    mipHeight := getMipSize(img.Info.Extent.Height, level)
    widthInBlocks := roundUpTo(mipWidth, gran.Width)
    heightInBlocks := roundUpTo(mipHeight, gran.Height)

    xe := roundUpTo(bind.extent.Width, gran.Width)
    ye := roundUpTo(bind.extent.Height, gran.Height)
    ze := roundUpTo(bind.extent.Depth, gran.Depth)
    for zi in (0 .. ze) {
      for yi in (0 .. ye) {
        for xi in (0 .. xe) {
          loc := xi + yi * widthInBlocks + zi * widthInBlocks * heightInBlocks
          offset := VkOffset3D(
            x:  bind.offset.x + as!s32(xi * gran.Width),
            y:  bind.offset.y + as!s32(yi * gran.Height),
            z:  bind.offset.z + as!s32(zi * gran.Depth),
          )
          memOffset := as!u64(bind.memoryOffset + as!VkDeviceSize(loc) * blockSize)
          levelInfo.Blocks[memOffset] = new!SparseBoundImageBlockInfo(
            Offset:        offset,
            Extent:        gran,
            Memory:        bind.memory,
            MemoryOffset:  as!VkDeviceSize(memOffset),
            Size:          blockSize,
            Flags:         bind.flags,
          )
        }
      }
    }
  }
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFence(
    VkDevice                     device,
    const VkFenceCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence*                     pFence) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkFenceCreateInfo") }
  f := new!FenceObject()
  create_info := pCreateInfo[0]
  f.Device = device

  if ((as!u32(create_info.flags) & as!u32(VK_FENCE_CREATE_SIGNALED_BIT)) != 0) {
    f.Signaled = true
  } else {
    f.Signaled = false
  }
  handle := ?
  if pFence == null { vkErrorNullPointer("VkFence") }
  pFence[0] = handle
  f.VulkanHandle = handle
  Fences[handle] = f
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFence(
    VkDevice                     device,
    VkFence                      fence,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(Fences, fence)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  read(pFences[0:fenceCount])
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetFenceStatus(
    VkDevice device,
    VkFence  fence) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(fence in Fences) { vkErrorInvalidFence(fence) }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkWaitForFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences,
    VkBool32       waitAll,
    u64            timeout) { /// timeout in nanoseconds
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  fences := pFences[0:fenceCount]
  for i in (0 .. fenceCount) {
    if !(fences[i] in Fences) { vkErrorInvalidFence(fences[i]) }
    _ = fences[i]
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSemaphore(
    VkDevice                     device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore*                 pSemaphore) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkSemaphoreCreateInfo") }
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  semaphoreObject := new!SemaphoreObject(Device: device,
    VulkanHandle:           handle)
  if pSemaphore == null { vkErrorNullPointer("VkSemaphore") }
  pSemaphore[0] = handle
  Semaphores[handle] = semaphoreObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySemaphore(
    VkDevice                     device,
    VkSemaphore                  semaphore,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(Semaphores, semaphore)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateEvent(
    VkDevice                     device,
    const VkEventCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent*                     pEvent) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkEventCreateInfo") }
  read(pCreateInfo[0:1])
  event := new!EventObject()
  event.Device = device
  event.Signaled = false
  event.SubmitQueue = as!VkQueue(0)
  handle := ?
  if pEvent == null { vkErrorNullPointer("VkEvent") }
  pEvent[0] = handle
  event.VulkanHandle = handle
  Events[handle] = event
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyEvent(
    VkDevice                     device,
    VkEvent                      event,
    const VkAllocationCallbacks* pAllocator) {
  delete(Events, event)
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetEventStatus(
    VkDevice device,
    VkEvent  event) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(event in Events) { vkErrorInvalidEvent(event) }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkSetEvent(
    VkDevice device,
    VkEvent  event) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(event in Events) { vkErrorInvalidEvent(event) }
  e := Events[event]
  e.Signaled = true
  queue := e.SubmitQueue
  if queue != as!VkQueue(0) {
    q := Queues[queue]
    if e.VulkanHandle in q.PendingEvents {
      delete(q.PendingEvents, e.VulkanHandle)
    }
    // If all pending events are signaled, so all removed from the pending
    // event list in the queue object, we should roll out the pending commands
    if len(q.PendingEvents) == 0 {
      LastBoundQueue = Queues[queue]
      execPendingCommands(queue)
    }
  }
  fence
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetEvent(
    VkDevice device,
    VkEvent  event) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(event in Events) { vkErrorInvalidEvent(event) }
  Events[event].Signaled = false
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateQueryPool(
    VkDevice                     device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool*                 pQueryPool) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkQueuePoolCreateInfo") }
  info := pCreateInfo[0]

  handle := ?
  pool := new!QueryPoolObject(
    Device:              device,
    VulkanHandle:        handle,
    QueryType:           info.queryType,
    QueryCount:          info.queryCount,
    PipelineStatistics:  info.pipelineStatistics)
  for i in (0 .. info.queryCount) {
    pool.Status[i] = QUERY_STATUS_INACTIVE
  }

  QueryPools[handle] = pool
  if pQueryPool == null { vkErrorNullPointer("VkQueuePool") }
  pQueryPool[0] = handle

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyQueryPool(
    VkDevice                     device,
    VkQueryPool                  queryPool,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(QueryPools, queryPool)
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
@no_replay
// GetQueryPoolResults has no semantic impact
// on replay, so avoid replaying it. It can cause
// hangs depending on the state of the query pool
// TODO(awoloszyn): Work out all of the cases where this
// may cause hangs, and fix it for replay.
cmd VkResult vkGetQueryPoolResults(
    VkDevice           device,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    size               dataSize,
    void*              pData,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  write(as!u8*(pData)[0:dataSize])
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateBuffer(
    VkDevice                     device,
    const VkBufferCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer*                    pBuffer) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkBufferCreateInfo") }
  buffer_create_info := pCreateInfo[0]

  queueFamilyIndices := buffer_create_info.pQueueFamilyIndices[
  0:buffer_create_info.queueFamilyIndexCount]

  bufferInfo := BufferInfo(
    CreateFlags:  buffer_create_info.flags,
    Size:         buffer_create_info.size,
    Usage:        buffer_create_info.usage,
    SharingMode:  buffer_create_info.sharingMode,
  )
  for i in (0 .. buffer_create_info.queueFamilyIndexCount) {
    bufferInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  // Handle pNext
  if buffer_create_info.pNext != null {
    numPNext := numberOfPNext(buffer_create_info.pNext)
    next := MutableVoidPtr(as!void*(buffer_create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationBufferCreateInfoNV*(next.Ptr)[0]
          bufferInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
            DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  buffer := ?
  if pBuffer == null { vkErrorNullPointer("VkBuffer") }
  pBuffer[0] = buffer
  bufferObject := new!BufferObject(
    Device:        device,
    VulkanHandle:  buffer,
    Info:          bufferInfo,
  )
  Buffers[buffer] = bufferObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBuffer(
    VkDevice                     device,
    VkBuffer                     buffer,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (buffer != as!VkBuffer(0)) {
    bufferObject := Buffers[buffer]
    if (bufferObject.Memory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(bufferObject.Memory.BoundObjects,
      as!u64(buffer))
    }
    delete(Buffers, buffer)
  }
}

// Buffer view functions
@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateBufferView(
    VkDevice                      device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkBufferView*                 pView) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkBufferViewCreateInfo") }
  buffer_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  bufferViewObject := new!BufferViewObject(
    Device:        device,
    VulkanHandle:  handle,
    Buffer:        Buffers[buffer_view_create_info.buffer],
    Format:        buffer_view_create_info.format,
    Offset:        buffer_view_create_info.offset,
    Range:         buffer_view_create_info.range)
  if pView == null { vkErrorNullPointer("VkBufferView") }
  pView[0] = handle
  BufferViews[handle] = bufferViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBufferView(
    VkDevice                     device,
    VkBufferView                 bufferView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(BufferViews, bufferView)
}

sub u32 getMipSize(u32 original, u32 level) {
  value := original / (1 << level)
  return switch (value) {
    case 0:  1
    default: value
  }
}

sub u32 roundUpTo(u32 dividend, u32 divisor) {
  return (dividend + divisor - 1) / divisor
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateImage(
    VkDevice                     device,
    const VkImageCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage*                     pImage) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkImageCreateInfo") }
  // TODO: pAllocator
  info := pCreateInfo[0]
  queueFamilyIndices := info.pQueueFamilyIndices[0:info.queueFamilyIndexCount]

  imageInfo := ImageInfo(
    Flags:        info.flags,
    ImageType:    info.imageType,
    Format:       info.format,
    Extent:       info.extent,
    MipLevels:    info.mipLevels,
    ArrayLayers:  info.arrayLayers,
    Samples:      info.samples,
    Tiling:       info.tiling,
    Usage:        info.usage,
    SharingMode:  info.sharingMode,
    Layout:       info.initialLayout,
  )

  for i in (0 .. info.queueFamilyIndexCount) {
    imageInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  imageAspect := as!VkImageAspectFlags(
    switch info.format {
      // Depth only
      case VK_FORMAT_D16_UNORM,
          VK_FORMAT_X8_D24_UNORM_PACK32,
          VK_FORMAT_D32_SFLOAT:
        VK_IMAGE_ASPECT_DEPTH_BIT
      // Stencil only
      case VK_FORMAT_S8_UINT:
        VK_IMAGE_ASPECT_STENCIL_BIT
      // Depth and Stencil
      case VK_FORMAT_D16_UNORM_S8_UINT,
          VK_FORMAT_D24_UNORM_S8_UINT,
          VK_FORMAT_D32_SFLOAT_S8_UINT:
        VK_IMAGE_ASPECT_DEPTH_BIT |
        VK_IMAGE_ASPECT_STENCIL_BIT
      // Others
      default:
        VK_IMAGE_ASPECT_COLOR_BIT
    })

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
          imageInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
            DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  handle := ?
  if pImage == null { vkErrorNullPointer("VkImage") }
  pImage[0] = handle
  object := new!ImageObject(
    Device:            device,
    IsSwapchainImage:  false,
    VulkanHandle:      handle,
    Info:              imageInfo,
    ImageAspect:       imageAspect,
  )

  for j in (0 .. info.arrayLayers) {
    layer := new!ImageLayer()
    object.Layers[j] = layer
    for i in (0 .. info.mipLevels) {
      width := getMipSize(info.extent.Width, i)
      height := getMipSize(info.extent.Height, i)
      depth := getMipSize(info.extent.Depth, i)
      level := new!ImageLevel(Width: width,Height:  height,Depth:  depth)
      elementAndTexelBlockSize := getElementAndTexelBlockSize(object.Info.Format)
      // Roundup the width and height in the number of blocks.
      widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
      heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
      // Align to the next multiple times of 8
      size := ((widthInBlocks * heightInBlocks * depth * elementAndTexelBlockSize.ElementSize) + 7) & (0xFFFFFFF8)
      level.Data = make!u8(size)
      object.Layers[j].Levels[i] = level
    }
  }
  Images[handle] = object

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImage(
    VkDevice                     device,
    VkImage                      image,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (image != as!VkImage(0)) {
    imageObject := Images[image]
    if (imageObject.BoundMemory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(imageObject.BoundMemory.BoundObjects, as!u64(image))
    }
    delete(Images, image)
    for _, _, v in ImageViews {
      if v.Image.VulkanHandle == image {
        v.Image = null
      }
    }
    for i in (0 .. LastPresentInfo.PresentImageCount) {
      if (LastPresentInfo.PresentImages[i].VulkanHandle == image) {
        delete(LastPresentInfo.PresentImages, i)
      }
    }
  }
}

@indirect("VkDevice")
cmd void vkGetImageSubresourceLayout(
    VkDevice                  device,
    VkImage                   image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout*      pLayout) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  _ = pSubresource[0]

  pLayout[0] = ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateImageView(
    VkDevice                     device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView*                 pView) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkImageViewCreateInfo") }
  image_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  if !(image_view_create_info.image in Images) { vkErrorInvalidImage(image_view_create_info.image) }
  imageViewObject := new!ImageViewObject(Device: device,
    VulkanHandle:           handle,
    Image:                  Images[image_view_create_info.image],
    Type:                   image_view_create_info.viewType,
    Format:                 image_view_create_info.format,
    Components:             image_view_create_info.components,
    SubresourceRange:       image_view_create_info.subresourceRange
  )
  if pView == null { vkErrorNullPointer("VkImageView") }
  pView[0] = handle
  ImageViews[handle] = imageViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImageView(
    VkDevice                     device,
    VkImageView                  imageView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(ImageViews, imageView)
  for _, _, drawInfo in LastDrawInfos {
    for _, i, v in drawInfo.Framebuffer.ImageAttachments {
      if (v != null) && (v.VulkanHandle == imageView) {
        drawInfo.Framebuffer.ImageAttachments[i] = null
      }
    }
  }
  for _, _, descSet in DescriptorSets {
    for _, _, binding in descSet.Bindings {
      for _, _, imgBinding in binding.ImageBinding {
        if imgBinding.ImageView == imageView {
          imgBinding.ImageView = as!VkImageView(0)
        }
      }
    }
  }
}

@indirect("VkDevice")
cmd VkResult vkCreateShaderModule(
    VkDevice                        device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkShaderModule*                 pShaderModule) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkShaderModuleCreateInfo") }
  create_info := pCreateInfo[0]

  num_words := as!u64(create_info.codeSize) / 4
  object := new!ShaderModuleObject(device, clone(create_info.pCode[0:num_words]))

  handle := ?
  if pShaderModule == null { vkErrorNullPointer("VkShaderModule") }
  pShaderModule[0] = handle
  object.VulkanHandle = handle
  ShaderModules[handle] = object

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyShaderModule(
    VkDevice                     device,
    VkShaderModule               shaderModule,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(ShaderModules, shaderModule)
}

@indirect("VkDevice")
cmd VkResult vkCreatePipelineCache(
    VkDevice                         device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*     pAllocator,
    VkPipelineCache*                 pPipelineCache) {
  //TODO(awoloszyn): Add Allocator support
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkPipelineCacheCreateInfo") }
  create_info := pCreateInfo[0]
  read(as!u8*(create_info.pInitialData)[0:create_info.initialDataSize])
  handle := ?
  if pPipelineCache == null { vkErrorNullPointer("VkPipelineCache") }
  pPipelineCache[0] = handle
  PipelineCaches[handle] = new!PipelineCacheObject(device, handle)
  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipelineCache(
    VkDevice                     device,
    VkPipelineCache              pipelineCache,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(PipelineCaches, pipelineCache)
}

@indirect("VkDevice")
cmd VkResult vkGetPipelineCacheData(
    VkDevice        device,
    VkPipelineCache pipelineCache,
    size*           pDataSize,
    void*           pData) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  if pDataSize == null { vkErrorNullPointer("size_t") }
  _ = pDataSize[0]

  writeDataSize := ?
  pDataSize[0] = writeDataSize
  if pData != null {
    write(as!u8*(pData)[0:writeDataSize])
  }
  return ?
}

@indirect("VkDevice")
cmd VkResult vkMergePipelineCaches(
    VkDevice               device,
    VkPipelineCache        dstCache,
    u32                    srcCacheCount,
    const VkPipelineCache* pSrcCaches) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(dstCache in PipelineCaches) { vkErrorInvalidPipelineCache(dstCache) }
  srcCaches := pSrcCaches[0:srcCacheCount]
  for i in (0 .. srcCacheCount) {
    if !(srcCaches[i] in PipelineCaches) { vkErrorInvalidPipelineCache(srcCaches[i]) }
    _ = srcCaches[i]
  }
  return ?
}

extern bool hasDynamicProperty(const VkPipelineDynamicStateCreateInfo* info,
                               VkDynamicState                          state)

@internal
class CreatedGraphicsPipelines {
  map!(u32, ref!GraphicsPipelineObject) Objects
}

@indirect("VkDevice")
cmd VkResult vkCreateGraphicsPipelines(
    VkDevice                            device,
    VkPipelineCache                     pipelineCache,
    u32                                 createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*        pAllocator,
    VkPipeline*                         pPipelines) {

  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipelineCache != as!VkPipelineCache(0) {
    if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  }
  // TODO(awoloszyn): Figure out what fields we want to store off
  //    in the state block.
  infos := pCreateInfos[0:createInfoCount]
  pipelines := pPipelines[0:createInfoCount]

  createdPipelines := CreatedGraphicsPipelines()

  for i in (0 .. createInfoCount) {
    obj := new!GraphicsPipelineObject(
      PipelineCache: PipelineCaches[pipelineCache]
    )
    obj.Device = device
    create_info := infos[i]
    // TODO: create_info.pNext
    obj.Flags = create_info.flags

    pipeline_shader_stage_create_infos :=
    create_info.pStages[0:create_info.stageCount]
    for j in (0 .. create_info.stageCount) {
      stage_create_info := pipeline_shader_stage_create_infos[j]
      if !(stage_create_info.module in ShaderModules) { vkErrorInvalidShaderModule(stage_create_info.module) }
      stage_data := StageData(
        Stage:       stage_create_info.stage,
        Module:      ShaderModules[stage_create_info.module],
        EntryPoint:  as!string(stage_create_info.pName),
      )
      if (stage_create_info.pSpecializationInfo != null) {
        spec_info := stage_create_info.pSpecializationInfo[0]
        spec_data := new!SpecializationInfo()
        spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
        for k in (0 .. spec_info.mapEntryCount) {
          spec_data.Specializations[k] = spec_map[k]
        }
        spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
        stage_data.Specialization = spec_data
      }
      obj.Stages[j] = stage_data
    }

    vertex_input_state := create_info.pVertexInputState[0]
    vertex_descriptions := vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount]
    // TODO: vertex_input_state.pNext
    for b in (0 .. vertex_input_state.vertexBindingDescriptionCount) {
      vertex_binding := vertex_descriptions[b]
      obj.VertexInputState.BindingDescriptions[vertex_binding.binding] = vertex_binding
    }

    vertex_attributes := vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount]

    for b in (0 .. vertex_input_state.vertexAttributeDescriptionCount) {
      attribute := vertex_attributes[b]
      obj.VertexInputState.AttributeDescriptions[b] = attribute
    }

    input_assembly_state := create_info.pInputAssemblyState[0]
    obj.InputAssemblyState.Topology = input_assembly_state.topology
    obj.InputAssemblyState.PrimitiveRestartEnable = input_assembly_state.primitiveRestartEnable

    // TODO: pInputAssemblypNext
    if (create_info.pTessellationState != null) {
      tessellation_state := create_info.pTessellationState[0]
      obj.TessellationState = new!TessellationStateData(
        PatchControlPoints: tessellation_state.patchControlPoints
      )
    }
    if (create_info.pViewportState != null) {

      // TODO: pViewportpNext
      pipeline_viewport_state_create_info := create_info.pViewportState[0]

      viewport_data := new!ViewportData()

      // Even if the viewports and scissors are set dynamically, the number of
      // viewports and scissors must match with the viewportCount and
      // sicssorCount set in this VkPipelineViewportStateCreateInfo struct.
      viewport_data.ViewportCount = pipeline_viewport_state_create_info.viewportCount
      viewport_data.ScissorCount = pipeline_viewport_state_create_info.scissorCount

      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_VIEWPORT)) {
        viewports := pipeline_viewport_state_create_info.pViewports[0:viewport_data.ViewportCount]
        for k in (0 .. viewport_data.ViewportCount) {
          viewport_data.Viewports[k] = viewports[k]
        }
      }

      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_SCISSOR)) {
        scissors := pipeline_viewport_state_create_info.pScissors[0:viewport_data.ScissorCount]
        for k in (0 .. viewport_data.ScissorCount) {
          viewport_data.Scissors[k] = scissors[k]
        }
      }

      obj.ViewportState = viewport_data
    }
    rasterization_state := create_info.pRasterizationState[0]

    obj.RasterizationState.DepthClampEnable = rasterization_state.depthClampEnable
    obj.RasterizationState.RasterizerDiscardEnable = rasterization_state.rasterizerDiscardEnable
    obj.RasterizationState.PolygonMode = rasterization_state.polygonMode
    obj.RasterizationState.CullMode = rasterization_state.cullMode
    obj.RasterizationState.FrontFace = rasterization_state.frontFace
    obj.RasterizationState.DepthBiasEnable = rasterization_state.depthBiasEnable
    obj.RasterizationState.DepthBiasConstantFactor = rasterization_state.depthBiasConstantFactor
    obj.RasterizationState.DepthBiasClamp = rasterization_state.depthBiasClamp
    obj.RasterizationState.DepthBiasSlopeFactor = rasterization_state.depthBiasSlopeFactor
    obj.RasterizationState.LineWidth = rasterization_state.lineWidth

    // TODO _.pNext

    if (create_info.pMultisampleState != null) {
      multisample_state := create_info.pMultisampleState[0]
      multisample_data := new!MultisampleData(
        RasterizationSamples:   multisample_state.rasterizationSamples,
        SampleShadingEnable:    multisample_state.sampleShadingEnable,
        MinSampleShading:       multisample_state.minSampleShading,
        AlphaToCoverageEnable:  multisample_state.alphaToCoverageEnable,
        AlphaToOneEnable:       multisample_state.alphaToOneEnable
      )
      // TODO: multisample_state.pNext
      if (multisample_state.pSampleMask != null) {
        num_samples := as!u32(multisample_state.rasterizationSamples)
        sizeof_samplemask := (num_samples + 31) / 32
        sample_masks := multisample_state.pSampleMask[0:sizeof_samplemask]
        for k in (0 .. sizeof_samplemask) {
          multisample_data.SampleMask[k] = sample_masks[k]
        }
      }
      obj.MultisampleState = multisample_data
    }

    if (create_info.pDepthStencilState != null) {
      // TODO: pDepthStencilpNext
      depth_stencil_state := create_info.pDepthStencilState[0]
      obj.DepthState = new!DepthData(
        DepthTestEnable:        depth_stencil_state.depthTestEnable,
        DepthWriteEnable:       depth_stencil_state.depthWriteEnable,
        DepthCompareOp:         depth_stencil_state.depthCompareOp,
        DepthBoundsTestEnable:  depth_stencil_state.depthBoundsTestEnable,
        StencilTestEnable:      depth_stencil_state.stencilTestEnable,
        Front:                  depth_stencil_state.front,
        Back:                   depth_stencil_state.back,
        MinDepthBounds:         depth_stencil_state.minDepthBounds,
        MaxDepthBounds:         depth_stencil_state.maxDepthBounds)
    }
    if (create_info.pColorBlendState != null) {
      color_blend_state := create_info.pColorBlendState[0]
      color_blend_data := new!ColorBlendData(
        LogicOpEnable:   color_blend_state.logicOpEnable,
        LogicOp:         color_blend_state.logicOp,
        BlendConstants:  color_blend_state.blendConstants
      )
      // TODO: color_blend_state.pNext
      attachments := color_blend_state.pAttachments[0:
      color_blend_state.attachmentCount]
      for k in (0 .. color_blend_state.attachmentCount) {
        color_blend_data.Attachments[k] = attachments[k]
      }
      obj.ColorBlendState = color_blend_data
    }
    if (create_info.pDynamicState != null) {
      dynamic_state_info := create_info.pDynamicState[0]
      dynamic_data := new!DynamicData()
      // TODO: dynamic_state_info.pNext
      states := dynamic_state_info.pDynamicStates[0:
      dynamic_state_info.dynamicStateCount]
      for k in (0 .. dynamic_state_info.dynamicStateCount) {
        dynamic_data.DynamicStates[k] = states[k]
      }
      obj.DynamicState = dynamic_data
    }
    obj.Layout = PipelineLayouts[create_info.layout]
    obj.RenderPass = RenderPasses[create_info.renderPass]
    obj.Subpass = create_info.subpass
    if ((as!u32(create_info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (create_info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = create_info.basePipelineIndex
      } else {
        obj.BasePipeline = create_info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    createdPipelines.Objects[i] = obj
  }

  fence

  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    createdPipelines.Objects[i].VulkanHandle = pipeline
    if (createdPipelines.Objects[i].BasePipelineIndex != -1) {
      createdPipelines.Objects[i].BasePipeline = pipelines[createdPipelines.Objects[i].BasePipelineIndex]
    }
    GraphicsPipelines[pipeline] = createdPipelines.Objects[i]
  }

  return ?
}

@internal
class CreatedComputePipelines {
  map!(u32, ref!ComputePipelineObject) Objects
}

@indirect("VkDevice")
cmd VkResult vkCreateComputePipelines(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    u32                                createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*       pAllocator,
    VkPipeline*                        pPipelines) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipelineCache != as!VkPipelineCache(0) {
    if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  }
  created_pipelines := CreatedComputePipelines()
  infos := pCreateInfos[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    info := infos[i]
    obj := new!ComputePipelineObject(
      PipelineCache:   PipelineCaches[pipelineCache],
      Device:          device,
      Flags:           info.flags,
      PipelineLayout:  PipelineLayouts[info.layout]
    )
    stage_create_info := infos[i].stage
    stage_data := StageData(
      Stage:       stage_create_info.stage,
      Module:      ShaderModules[stage_create_info.module],
      EntryPoint:  as!string(stage_create_info.pName),
    )
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      spec_data := new!SpecializationInfo()
      spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
      for k in (0 .. spec_info.mapEntryCount) {
        spec_data.Specializations[k] = spec_map[k]
      }
      spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
      stage_data.Specialization = spec_data
    }
    obj.Stage = stage_data
    if ((as!u32(info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = info.basePipelineIndex
      } else {
        obj.BasePipeline = info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    created_pipelines.Objects[i] = obj
  }
  // TODO: pAllocator

  pipelines := pPipelines[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    created_pipelines.Objects[i].VulkanHandle = pipeline
    if (created_pipelines.Objects[i].BasePipelineIndex != -1) {
      created_pipelines.Objects[i].BasePipeline = pipelines[created_pipelines.Objects[i].BasePipelineIndex]
    }
    ComputePipelines[pipeline] = created_pipelines.Objects[i]
  }

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipeline(
    VkDevice                     device,
    VkPipeline                   pipeline,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipeline in GraphicsPipelines {
    delete(GraphicsPipelines, pipeline)
  }
  if pipeline in ComputePipelines {
    delete(ComputePipelines, pipeline)
  }
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreatePipelineLayout(
    VkDevice                          device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkPipelineLayout*                 pPipelineLayout) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkPipelineLayoutCreateInfo") }
  info := pCreateInfo[0]
  pipelineLayout := new!PipelineLayoutObject(Device: device)
  // TODO: info.pNext
  // TODO: pAllocator

  layoutCount := info.setLayoutCount
  layouts := info.pSetLayouts[0:layoutCount]
  for i in (0 .. layoutCount) {
    pipelineLayout.SetLayouts[i] = DescriptorSetLayouts[layouts[i]]
  }
  pushConstantCount := info.pushConstantRangeCount
  pushConstants := info.pPushConstantRanges[0:pushConstantCount]
  for i in (0 .. pushConstantCount) {
    pipelineLayout.PushConstantRanges[i] = pushConstants[i]
  }

  handle := ?
  if pPipelineLayout == null { vkErrorNullPointer("VkPipelineLayout") }
  pPipelineLayout[0] = handle
  pipelineLayout.VulkanHandle = handle
  PipelineLayouts[handle] = pipelineLayout
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipelineLayout(
    VkDevice                     device,
    VkPipelineLayout             pipelineLayout,
    const VkAllocationCallbacks* pAllocator) {

  if !(device in Devices) { vkErrorInvalidDevice(device) }
  // TODO: pAllocator
  delete(PipelineLayouts, pipelineLayout)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSampler(
    VkDevice                     device,
    const VkSamplerCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler*                   pSampler) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkSamplerCreateInfo") }
  create_info := pCreateInfo[0]
  sampler := new!SamplerObject(
    Device:                   device,
    MagFilter:                create_info.magFilter,
    MinFilter:                create_info.minFilter,
    MipMapMode:               create_info.mipmapMode,
    AddressModeU:             create_info.addressModeU,
    AddressModeV:             create_info.addressModeV,
    AddressModeW:             create_info.addressModeW,
    MipLodBias:               create_info.mipLodBias,
    AnisotropyEnable:         create_info.anisotropyEnable,
    MaxAnisotropy:            create_info.maxAnisotropy,
    CompareEnable:            create_info.compareEnable,
    CompareOp:                create_info.compareOp,
    MinLod:                   create_info.minLod,
    MaxLod:                   create_info.maxLod,
    BorderColor:              create_info.borderColor,
    UnnormalizedCoordinates:  create_info.unnormalizedCoordinates
  )
  handle := ?
  if pSampler == null { vkErrorNullPointer("VkSampler") }
  pSampler[0] = handle
  sampler.VulkanHandle = handle
  Samplers[handle] = sampler
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySampler(
    VkDevice                     device,
    VkSampler                    sampler,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  // TODO: pAllocator
  delete(Samplers, sampler)
}

@internal class MutableU32 {
  u32 Val
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorSetLayout(
    VkDevice                               device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*           pAllocator,
    VkDescriptorSetLayout*                 pSetLayout) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkDescriptorSetLayoutCreateInfo") }
  info := pCreateInfo[0]
  // TODO: info.pNext
  count := info.bindingCount
  bindings := info.pBindings[0:count]
  descriptorSetLayout := new!DescriptorSetLayoutObject()
  descriptorSetLayout.Device = device
  largestBinding := MutableU32(0)

  for i in (0 .. count) {
    descriptorBinding := DescriptorSetLayoutBinding(
      Type:    bindings[i].descriptorType,
      Count:   bindings[i].descriptorCount,
      Stages:  bindings[i].stageFlags
    )
    c := bindings[i].descriptorCount
    if (c != 0) && (bindings[i].pImmutableSamplers != null) {
      samplers := bindings[i].pImmutableSamplers[0:c]
      for j in (0 .. c) {
        sampler := samplers[j]
        descriptorBinding.ImmutableSamplers[j] = Samplers[sampler]
      }
    }
    descriptorSetLayout.Bindings[bindings[i].binding] = descriptorBinding
    if (bindings[i].binding > largestBinding.Val) {
      largestBinding.Val = bindings[i].binding
    }
  }
  descriptorSetLayout.MaximumBinding = largestBinding.Val

  // TODO: pAllocator

  handle := ?
  if pSetLayout == null { vkErrorNullPointer("VkDescriptorSetLayout") }
  pSetLayout[0] = handle
  descriptorSetLayout.VulkanHandle = handle
  DescriptorSetLayouts[handle] = descriptorSetLayout

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorSetLayout(
    VkDevice                     device,
    VkDescriptorSetLayout        descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(DescriptorSetLayouts, descriptorSetLayout)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorPool(
    VkDevice                          device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDescriptorPool*                 pDescriptorPool) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkDescriptorPoolCreateInfo") }
  info := pCreateInfo[0]
  pool := new!DescriptorPoolObject(
    Device:   device,
    Flags:    info.flags,
    MaxSets:  info.maxSets)

  sizes := info.pPoolSizes[0:info.poolSizeCount]
  for i in (0 .. info.poolSizeCount) {
    pool.Sizes[i] = sizes[i]
  }
  // TODO: info.pNext

  // TODO: pAllocator

  handle := ?
  if pDescriptorPool == null { vkErrorNullPointer("VkDescriptorPool") }
  pDescriptorPool[0] = handle
  pool.VulkanHandle = handle
  DescriptorPools[handle] = pool

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorPool(
    VkDevice                     device,
    VkDescriptorPool             descriptorPool,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (descriptorPool != as!VkDescriptorPool(0)) {
    if !(descriptorPool in DescriptorPools) { vkErrorInvalidDescriptorPool(descriptorPool) }
    sets := DescriptorPools[descriptorPool].DescriptorSets
    for _ , s , _ in sets {
      delete(DescriptorSets, s)
    }
    delete(DescriptorPools, descriptorPool)
  }
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkResetDescriptorPool(
    VkDevice                   device,
    VkDescriptorPool           descriptorPool,
    VkDescriptorPoolResetFlags flags) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(descriptorPool in DescriptorPools) { vkErrorInvalidDescriptorPool(descriptorPool) }
  // We need to iterate through all the descriptor sets in the descriptor pool
  // and remove them from the pool. The following line will makes a copy of
  // the map in the generated C++ code, to prevent us from deleting an item
  // while iterating the map. However, in the generated Go code, this does not
  // make a copy of the map but a reference. But according to the examples in
  // Effective Go (https://golang.org/doc/effective_go.html#for), deleting
  // while iterating is safe for Go. So the code here should behave as we
  // expect.
  sets := DescriptorPools[descriptorPool].DescriptorSets
  for _ , s , _ in sets {
    delete(DescriptorSets, s)
  }
  old_object := DescriptorPools[descriptorPool]
  pool := new!DescriptorPoolObject(
    Device:        old_object.Device,
    VulkanHandle:  old_object.VulkanHandle,
    Flags:         old_object.Flags,
    MaxSets:       old_object.MaxSets,
    Sizes:         old_object.Sizes,
    DebugInfo:     old_object.DebugInfo
  )
  DescriptorPools[descriptorPool] = pool
  return ?
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkAllocateDescriptorSets(
    VkDevice                           device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet*                   pDescriptorSets) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pAllocateInfo == null { vkErrorNullPointer("VkDescriptorSetAllocateInfo") }
  info := pAllocateInfo[0]
  // TODO: info.pNext
  count := info.descriptorSetCount

  layouts := info.pSetLayouts[0:count]
  read(info.pSetLayouts[0:count])
  if pDescriptorSets == null { vkErrorNullPointer("VkDescriptorSet") }
  sets := pDescriptorSets[0:count]

  for i in (0 .. count) {
    handle := ?
    sets[i] = handle
    object := new!DescriptorSetObject(device, handle,
      info.descriptorPool)
    pool := DescriptorPools[info.descriptorPool]
    pool.DescriptorSets[handle] = object
    object.Layout = DescriptorSetLayouts[layouts[i]]
    for j in (0 .. object.Layout.MaximumBinding + 1) {
      if j in object.Layout.Bindings {
        binding := object.Layout.Bindings[j]
        descriptorBinding := DescriptorBinding(
          BindingType: binding.Type)
        imageInfos := descriptorBinding.ImageBinding
        bufferInfos := descriptorBinding.BufferBinding
        bufferViews := descriptorBinding.BufferViewBindings
        for k in (0 .. binding.Count) {
          switch binding.Type {
            case VK_DESCRIPTOR_TYPE_SAMPLER,
                VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
                VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
              imageInfos[k] = new!VkDescriptorImageInfo()
            case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
                VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
              bufferViews[k] = as!VkBufferView(0)
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              bufferInfos[k] = new!VkDescriptorBufferInfo()
          }
        }
        descriptorBinding.ImageBinding = imageInfos
        descriptorBinding.BufferBinding = bufferInfos
        descriptorBinding.BufferViewBindings = bufferViews
        object.Bindings[j] = descriptorBinding
      }
    }
    DescriptorSets[handle] = object
  }

  return ?
}

@indirect("VkDevice")
cmd VkResult vkFreeDescriptorSets(
    VkDevice               device,
    VkDescriptorPool       descriptorPool,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(descriptorPool in DescriptorPools) { vkErrorInvalidDescriptorPool(descriptorPool) }
  if pDescriptorSets == null { vkErrorNullPointer("VkDescriptorSet") }
  sets := pDescriptorSets[0:descriptorSetCount]
  for i in (0 .. descriptorSetCount) {
    pool := DescriptorPools[DescriptorSets[sets[i]].DescriptorPool]
    delete(pool.DescriptorSets, sets[i])
    delete(DescriptorSets, sets[i])
  }

  return ?
}

@internal class ProcessedDescriptorSet {
  u32 Binding
  u32 ArrayIndex
  u32 BindingElementCount
  u32 BindingIndex
}

@internal class DescriptorSetWrite {
  u32                        Binding
  u32                        BindingArrayIndex
  VkDescriptorType           Type
  VkDescriptorSet            DstSet
  ref!VkDescriptorImageInfo  ImageInfo
  ref!VkDescriptorBufferInfo BufferInfo
  VkBufferView               BufferView
}

@internal class WriteReturnMap {
  map!(u32, DescriptorSetWrite) Map
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetWrite) RewriteWriteDescriptorSets
    (u32                         descriptorWriteCount,
     const VkWriteDescriptorSet* pDescriptorWrites) {
  descriptor_set := ProcessedDescriptorSet(0, 0, 0)
  descriptor_writes := pDescriptorWrites[0:descriptorWriteCount]
  ret_val := WriteReturnMap()
  for i in (0 .. descriptorWriteCount) {
    write := descriptor_writes[i]
    count := write.descriptorCount
    set := DescriptorSets[write.dstSet]
    descriptor_set.Binding = write.dstBinding
    descriptor_set.ArrayIndex = write.dstArrayElement
    descriptor_set.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      descriptor_set.BindingElementCount =
      len(set.Bindings[descriptor_set.Binding].ImageBinding) +
      len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
      len(set.Bindings[descriptor_set.Binding].BufferBinding)
      base_binding := descriptor_set.Binding
      for k in (base_binding .. len(set.Bindings)) {
        if (descriptor_set.ArrayIndex > descriptor_set.BindingElementCount - 1) {
          descriptor_set.ArrayIndex = 0
          descriptor_set.Binding = descriptor_set.Binding + 1
          descriptor_set.BindingElementCount =
          len(set.Bindings[descriptor_set.Binding].ImageBinding) +
          len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
          len(set.Bindings[descriptor_set.Binding].BufferBinding)
        }
      }
      switch (write.descriptorType) {
        case VK_DESCRIPTOR_TYPE_SAMPLER,
            VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
          imageInfos := write.pImageInfo[0:descriptor_set.BindingIndex + 1]
          imageInfo := imageInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            DstSet:             write.dstSet,
            Type:               write.descriptorType,
            ImageInfo:          new!VkDescriptorImageInfo(
              Sampler:      imageInfo.Sampler,
              ImageView:    imageInfo.ImageView,
              ImageLayout:  imageInfo.ImageLayout
            )
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
          bufferViews := write.pTexelBufferView[0:descriptor_set.BindingIndex + 1]
          bufferView := bufferViews[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            Type:               write.descriptorType,
            DstSet:             write.dstSet,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            BufferView:         bufferView
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
          bufferInfos := write.pBufferInfo[0:descriptor_set.BindingIndex + 1]
          bufferInfo := bufferInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            Type:               write.descriptorType,
            DstSet:             write.dstSet,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            BufferInfo:         new!VkDescriptorBufferInfo(
              Buffer:  bufferInfo.Buffer,
              Offset:  bufferInfo.Offset,
              Range:   bufferInfo.Range
            )
          )
        }
        default: {
          // Do nothing, we should also never get here
        }
      }
      descriptor_set.BindingIndex =
      descriptor_set.BindingIndex + 1
      descriptor_set.ArrayIndex = descriptor_set.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@internal class CopyReturnMap {
  map!(u32, DescriptorSetCopy) Map
}

@internal class DescriptorSetCopy {
  u32             SrcBinding
  u32             DstBinding
  u32             SrcArrayIndex
  u32             DstArrayIndex
  VkDescriptorSet SrcSet
  VkDescriptorSet DstSet
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetCopy) RewriteWriteDescriptorCopies
    (u32                        descriptorCopyCount,
     const VkCopyDescriptorSet* pDescriptorCopies) {
  srcDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  dstDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  descriptorCopies := pDescriptorCopies[0:descriptorCopyCount]
  ret_val := CopyReturnMap()
  for i in (0 .. descriptorCopyCount) {
    copy := descriptorCopies[i]
    count := copy.descriptorCount
    srcSet := DescriptorSets[copy.srcSet]
    dstSet := DescriptorSets[copy.dstSet]

    srcDescriptorSet.Binding = copy.srcBinding
    srcDescriptorSet.ArrayIndex = copy.srcArrayElement
    srcDescriptorSet.BindingIndex = 0

    dstDescriptorSet.Binding = copy.dstBinding
    dstDescriptorSet.ArrayIndex = copy.dstArrayElement
    dstDescriptorSet.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      srcDescriptorSet.BindingElementCount =
      len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
      len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
      len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
      dstDescriptorSet.BindingElementCount =
      len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
      len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
      len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
      srcBaseBinding := srcDescriptorSet.Binding
      dstBaseBinding := dstDescriptorSet.Binding

      for k in (srcBaseBinding .. len(srcSet.Bindings)) {
        if (srcDescriptorSet.ArrayIndex > srcDescriptorSet.BindingElementCount - 1) {
          srcDescriptorSet.ArrayIndex = 0
          srcDescriptorSet.Binding = srcDescriptorSet.Binding + 1
          srcDescriptorSet.BindingElementCount =
          len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
          len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
          len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
        }
      }

      for k in (dstBaseBinding .. len(dstSet.Bindings)) {
        if (dstDescriptorSet.ArrayIndex > dstDescriptorSet.BindingElementCount - 1) {
          dstDescriptorSet.ArrayIndex = 0
          dstDescriptorSet.Binding = dstDescriptorSet.Binding + 1
          dstDescriptorSet.BindingElementCount =
          len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
          len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
          len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
        }
      }


      ret_val.Map[len(ret_val.Map)] = DescriptorSetCopy(
        SrcBinding:     srcDescriptorSet.Binding,
        DstBinding:     dstDescriptorSet.Binding,
        SrcArrayIndex:  srcDescriptorSet.ArrayIndex,
        DstArrayIndex:  dstDescriptorSet.ArrayIndex,
        SrcSet:         copy.srcSet,
        DstSet:         copy.dstSet)

      srcDescriptorSet.BindingIndex =
      srcDescriptorSet.BindingIndex + 1
      srcDescriptorSet.ArrayIndex = srcDescriptorSet.ArrayIndex + 1
      dstDescriptorSet.BindingIndex =
      dstDescriptorSet.BindingIndex + 1
      dstDescriptorSet.ArrayIndex = dstDescriptorSet.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@indirect("VkDevice")
cmd void vkUpdateDescriptorSets(
    VkDevice                    device,
    u32                         descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    u32                         descriptorCopyCount,
    const VkCopyDescriptorSet*  pDescriptorCopies) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }

  writes := RewriteWriteDescriptorSets(
    descriptorWriteCount,
    pDescriptorWrites)
  for _ , _ , w in writes {
    set := DescriptorSets[w.DstSet]
    binding := w.Binding
    arrayIndex := w.BindingArrayIndex
    setBinding := set.Bindings[binding]
    switch w.Type {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
        imageBinding := setBinding.ImageBinding
        imageBinding[arrayIndex] = w.ImageInfo
        setBinding.ImageBinding = imageBinding
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
        viewBindings := setBinding.BufferViewBindings
        viewBindings[arrayIndex] = w.BufferView
        setBinding.BufferViewBindings = viewBindings
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
        bufferBindings := setBinding.BufferBinding
        bufferBindings[arrayIndex] = w.BufferInfo
        setBinding.BufferBinding = bufferBindings
      }
    }
    set.Bindings[binding] = setBinding
  }

  copies := RewriteWriteDescriptorCopies(
    descriptorCopyCount,
    pDescriptorCopies)
  for _ , _ , c in copies {
    srcSet := DescriptorSets[c.SrcSet]
    dstSet := DescriptorSets[c.DstSet]
    srcBinding := srcSet.Bindings[c.SrcBinding]
    dstBinding := dstSet.Bindings[c.DstBinding]
    switch (srcBinding.BindingType) {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
        imageBinding := dstBinding.ImageBinding
        imageBinding[c.DstArrayIndex] =
        srcBinding.ImageBinding[c.SrcArrayIndex]
        dstBinding.ImageBinding = imageBinding
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
        bufferViews := dstBinding.BufferViewBindings
        bufferViews[c.DstArrayIndex] =
        srcBinding.BufferViewBindings[c.SrcArrayIndex]
        dstBinding.BufferViewBindings = bufferViews
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
        bufferBinding := dstBinding.BufferBinding
        bufferBinding[c.DstArrayIndex] =
        srcBinding.BufferBinding[c.SrcArrayIndex]
        dstBinding.BufferBinding = bufferBinding
      }
    }
    dstSet.Bindings[c.DstBinding] = dstBinding
  }
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkFramebuffer*                 pFramebuffer) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkFramebufferCreateInfo") }
  create_info := pCreateInfo[0]
  attachments := create_info.pAttachments[0:create_info.attachmentCount]

  framebufferObject := new!FramebufferObject(Device: device,
    Width:                    create_info.width,
    Height:                   create_info.height,
    Layers:                   create_info.layers,
    RenderPass:               RenderPasses[create_info.renderPass])
  for i in (0 .. create_info.attachmentCount) {
    framebufferObject.ImageAttachments[i] = ImageViews[attachments[i]]
  }

  handle := ?
  if pFramebuffer == null { vkErrorNullPointer("VkFramebuffer") }
  pFramebuffer[0] = handle
  framebufferObject.VulkanHandle = handle
  Framebuffers[handle] = framebufferObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFramebuffer(
    VkDevice                     device,
    VkFramebuffer                framebuffer,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(Framebuffers, framebuffer)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateRenderPass(
    VkDevice                      device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkRenderPass*                 pRenderPass) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  renderPass := new!RenderPassObject()
  renderPass.Device = device
  if pCreateInfo == null { vkErrorNullPointer("VkRenderPassCreateInfo") }
  info := pCreateInfo[0]

  attachments := info.pAttachments[0:info.attachmentCount]
  for i in (0 .. info.attachmentCount) {
    renderPass.AttachmentDescriptions[i] = attachments[i]
  }
  subpasses := info.pSubpasses[0:info.subpassCount]
  read(subpasses)
  for i in (0 .. info.subpassCount) {
    subpass := subpasses[i]
    description := SubpassDescription(
      PipelineBindPoint: subpass.pipelineBindPoint,
    )
    inputAttachments := subpass.pInputAttachments[0:subpass.inputAttachmentCount]
    for j in (0 .. subpass.inputAttachmentCount) {
      description.InputAttachments[j] = inputAttachments[j]
    }
    colorAttachments := subpass.pColorAttachments[0:subpass.colorAttachmentCount]
    for j in (0 .. subpass.colorAttachmentCount) {
      description.ColorAttachments[j] = colorAttachments[j]
    }
    if subpass.pResolveAttachments != null {
      resolveAttachments := subpass.pResolveAttachments[0:subpass.colorAttachmentCount]
      for j in (0 .. subpass.colorAttachmentCount) {
        description.ResolveAttachments[j] = resolveAttachments[j]
      }
    }
    if (subpass.pDepthStencilAttachment != null) {
      depth_attachment := subpass.pDepthStencilAttachment[0]
      description.DepthStencilAttachment = new!VkAttachmentReference(
        Attachment: depth_attachment.Attachment,
        Layout:     depth_attachment.Layout)
    }
    preserveAttachments := subpass.pPreserveAttachments[0:subpass.preserveAttachmentCount]
    for j in (0 .. subpass.preserveAttachmentCount) {
      description.PreserveAttachments[j] = preserveAttachments[j]
    }
    renderPass.SubpassDescriptions[i] = description
  }
  dependencies := info.pDependencies[0:info.dependencyCount]
  for i in (0 .. info.dependencyCount) {
    renderPass.SubpassDependencies[i] = dependencies[i]
  }
  handle := ?
  if pRenderPass == null { vkErrorNullPointer("VkRenderPass") }
  pRenderPass[0] = handle
  renderPass.VulkanHandle = pRenderPass[0]
  RenderPasses[handle] = renderPass
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyRenderPass(
    VkDevice                     device,
    VkRenderPass                 renderPass,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(RenderPasses, renderPass)
}

@indirect("VkDevice")
cmd void vkGetRenderAreaGranularity(
    VkDevice     device,
    VkRenderPass renderPass,
    VkExtent2D*  pGranularity) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(renderPass in RenderPasses) { vkErrorInvalidRenderPass(renderPass) }
  write(pGranularity[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateCommandPool(
    VkDevice                       device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkCommandPool*                 pCommandPool) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkCommandPoolCreateInfo") }
  create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  if pCommandPool == null { vkErrorNullPointer("VkCommandPool") }
  pCommandPool[0] = handle
  commandPoolObject := new!CommandPoolObject(Device: device,
    VulkanHandle:             handle,
    Flags:                    create_info.flags,
    QueueFamilyIndex:         create_info.queueFamilyIndex)
  CommandPools[handle] = commandPoolObject

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyCommandPool(
    VkDevice                     device,
    VkCommandPool                commandPool,
    const VkAllocationCallbacks* pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if (commandPool != as!VkCommandPool(0)) {
    if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
    for _ , k , _ in CommandPools[commandPool].CommandBuffers {
      delete(CommandBuffers, k)
    }
    delete(CommandPools, commandPool)
  }
}

@internal class emptyMap {
  map!(u32, ref!CommandReference) m
}

sub void resetCommandBuffer(ref!CommandBufferObject obj) {
  obj.BufferCommands = BufferCommands()
  obj.CommandReferences = emptyMap().m
  resetCmd(obj.VulkanHandle)
}

@indirect("VkDevice")
cmd VkResult vkResetCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolResetFlags flags) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
  pool := CommandPools[commandPool]
  for _ , _ , b in pool.CommandBuffers {
    b.BeginInfo = null
    b.Recording = NOT_STARTED
    resetCommandBuffer(b)
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkAllocateCommandBuffers(
    VkDevice                           device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer*                   pCommandBuffers) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pAllocateInfo == null { vkErrorNullPointer("VkCommandBufferAllocateInfo") }
  allocateInfo := pAllocateInfo[0]
  count := allocateInfo.commandBufferCount

  fence
  if pCommandBuffers == null { vkErrorNullPointer("VkCommandBuffer") }
  cb := pCommandBuffers[0:count]

  for i in (0 .. count) {
    command_buffer := ?
    cb[i] = command_buffer
    CommandBuffers[command_buffer] = new!CommandBufferObject(
      Device:        device,
      VulkanHandle:  command_buffer,
      Recording:     NOT_STARTED,
      Pool:          allocateInfo.commandPool,
      Level:         allocateInfo.level)
    command_pool := CommandPools[allocateInfo.commandPool]
    command_pool.CommandBuffers[command_buffer] = CommandBuffers[command_buffer]
    CommandPools[allocateInfo.commandPool] = command_pool
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd void vkFreeCommandBuffers(
    VkDevice               device,
    VkCommandPool          commandPool,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(commandPool in CommandPools) { vkErrorInvalidCommandPool(commandPool) }
  cb := pCommandBuffers[0:commandBufferCount]
  for i in (0 .. commandBufferCount) {
    buffer := cb[i]
    if buffer != as!VkCommandBuffer(0) {
      if !(buffer in CommandBuffers) { vkErrorInvalidCommandBuffer(buffer) }
      buffer_object := CommandBuffers[buffer]
      pool := buffer_object.Pool
      pool_object := CommandPools[pool]
      delete(pool_object.CommandBuffers, buffer)
      CommandPools[pool] = pool_object
      resetCmd(buffer)
      delete(CommandBuffers, buffer)
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkBeginCommandBuffer(
    VkCommandBuffer                 commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pBeginInfo == null { vkErrorNullPointer("VkCommandBufferBeginInfo") }
  info := pBeginInfo[0]
  begin := new!CommandBufferBegin(Flags: info.flags,Inherited:  false)

  // TODO: pBeginInfo->pNext
  if info.pInheritanceInfo != null {
    inheritanceInfo := info.pInheritanceInfo[0]
    begin.Inherited = true
    begin.InheritedRenderPass = inheritanceInfo.renderPass
    begin.InheritedSubpass = inheritanceInfo.subpass
    begin.InheritedFramebuffer = inheritanceInfo.framebuffer
    begin.InheritedOcclusionQuery = inheritanceInfo.occlusionQueryEnable
    begin.InheritedQueryFlags = inheritanceInfo.queryFlags
    begin.InheritedPipelineStatsFlags = inheritanceInfo.pipelineStatistics
    // TODO: pBeginInfo->pInheritanceInfo->pNext
  }
  buff := CommandBuffers[commandBuffer]
  buff.BeginInfo = begin
  buff.Recording = RECORDING
  CommandBuffers[commandBuffer] = buff
  resetCommandBuffer(buff)
  return ?
}
@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkEndCommandBuffer(
    VkCommandBuffer commandBuffer) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  buff := CommandBuffers[commandBuffer]
  buff.Recording = COMPLETED
  CommandBuffers[commandBuffer] = buff
  return ?
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkResetCommandBuffer(
    VkCommandBuffer           commandBuffer,
    VkCommandBufferResetFlags flags) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  buff := CommandBuffers[commandBuffer]
  buff.Recording = NOT_STARTED
  buff.BeginInfo = null
  CommandBuffers[commandBuffer] = buff
  resetCommandBuffer(buff)
  return ?
}

extern void notifyPendingCommandAdded(VkQueue queue)
extern void enterSubcontext()
extern void nextSubcontext()
extern void leaveSubcontext()
extern void resetSubcontext()
extern void pushDebugMarker(string name)
extern void popDebugMarker()
extern void pushRenderPassMarker(VkRenderPass renderPass)
extern void popRenderPassMarker()
extern void popAndPushMarkerForNextSubpass(u32 nextSubpass)
extern void postBindSparse(ref!QueuedSparseBinds binds)
extern void onPreSubcommand(ref!CommandReference ref)
extern void onPreProcessCommand(ref!CommandReference ref)
extern void onPostSubcommand(ref!CommandReference ref)
extern void onDeferSubcommand(ref!CommandReference ref)
extern void onCommandAdded(VkCommandBuffer buffer)
extern void resetCmd(VkCommandBuffer buffer)

sub void AddCommand(
    VkCommandBuffer commandBuffer,
    CommandType     type,
    u32             mapPos
) {
  commandIndex := as!u32(len(CommandBuffers[commandBuffer].CommandReferences))
  cmd := new!CommandReference(commandBuffer, commandIndex,      type,
    mapPos,          None,          as!VkSemaphore(0), as!ref!QueuedSparseBinds(null))
  CommandBuffers[commandBuffer].CommandReferences[commandIndex] = cmd
  onCommandAdded(commandBuffer)
}


@internal class vkCmdBindPipelineArgs {
  VkPipelineBindPoint PipelineBindPoint
  VkPipeline          Pipeline
}

sub void dovkCmdBindPipeline(ref!vkCmdBindPipelineArgs args) {
  switch args.PipelineBindPoint {
    case VK_PIPELINE_BIND_POINT_COMPUTE:
      CurrentComputePipeline = ComputePipelines[args.Pipeline]
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
      lastDrawInfo().GraphicsPipeline = GraphicsPipelines[args.Pipeline]
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindPipeline(
    VkCommandBuffer     commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline          pipeline) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBindPipeline))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBindPipeline[mapPos] =
  new!vkCmdBindPipelineArgs(
    PipelineBindPoint: pipelineBindPoint,
    Pipeline:          pipeline)

  AddCommand(commandBuffer, cmd_vkCmdBindPipeline, mapPos)
}

@internal class vkCmdSetViewportArgs {
  u32                   FirstViewport
  map!(u32, VkViewport) Viewports
}

sub void dovkCmdSetViewport(ref!vkCmdSetViewportArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetViewport(
    VkCommandBuffer   commandBuffer,
    u32               firstViewport,
    u32               viewportCount,
    const VkViewport* pViewports) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pViewports == null { vkErrorNullPointer("VkViewport") }
  viewports := pViewports[0:viewportCount]
  args := new!vkCmdSetViewportArgs(
    firstViewport
  )
  for i in (0 .. viewportCount) {
    args.Viewports[i] = viewports[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetViewport))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetViewport[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetViewport, mapPos)
}

@internal class vkCmdSetScissorArgs {
  u32                 FirstScissor
  map!(u32, VkRect2D) Scissors
}

sub void dovkCmdSetScissor(ref!vkCmdSetScissorArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    u32             firstScissor,
    u32             scissorCount,
    const VkRect2D* pScissors) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pScissors == null { vkErrorNullPointer("VkRect2D") }
  scissors := pScissors[0:scissorCount]
  args := new!vkCmdSetScissorArgs(
    firstScissor
  )
  for i in (0 .. scissorCount) {
    args.Scissors[i] = scissors[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetScissor))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetScissor[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetScissor, mapPos)
}

@internal class vkCmdSetLineWidthArgs {
  f32 LineWidth
}

sub void dovkCmdSetLineWidth(ref!vkCmdSetLineWidthArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    f32             lineWidth) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetLineWidthArgs(lineWidth)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetLineWidth))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetLineWidth[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetLineWidth, mapPos)
}

@internal class vkCmdSetDepthBiasArgs {
  f32 DepthBiasConstantFactor
  f32 DepthBiasClamp
  f32 DepthBiasSlopeFactor
}

sub void dovkCmdSetDepthBias(ref!vkCmdSetDepthBiasArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    f32             depthBiasConstantFactor,
    f32             depthBiasClamp,
    f32             depthBiasSlopeFactor) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetDepthBiasArgs(
    depthBiasConstantFactor,
    depthBiasClamp,
    depthBiasSlopeFactor
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBias))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBias[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetDepthBias, mapPos)
}

@internal class vkCmdSetBlendConstantsArgs {
  f32 R
  f32 G
  f32 B
  f32 A
}

sub void dovkCmdSetBlendConstants(ref!vkCmdSetBlendConstantsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetBlendConstants(
              VkCommandBuffer commandBuffer,
    @readonly f32[4]          blendConstants) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetBlendConstantsArgs(
    blendConstants[0],
    blendConstants[1],
    blendConstants[2],
    blendConstants[3])

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetBlendConstants))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetBlendConstants[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetBlendConstants, mapPos)
}

@internal class vkCmdSetDepthBoundsArgs {
  f32 MinDepthBounds
  f32 MaxDepthBounds
}

sub void dovkCmdSetDepthBounds(ref!vkCmdSetDepthBoundsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    f32             minDepthBounds,
    f32             maxDepthBounds) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetDepthBoundsArgs(
    minDepthBounds,
    maxDepthBounds)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBounds))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBounds[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetDepthBounds, mapPos)
}

@internal class vkCmdSetStencilCompareMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                CompareMask
}

sub void dovkCmdSetStencilCompareMask(ref!vkCmdSetStencilCompareMaskArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilCompareMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                compareMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilCompareMaskArgs(
    faceMask,
    compareMask
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilCompareMask))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilCompareMask[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilCompareMask, mapPos)
}

@internal class vkCmdSetStencilWriteMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                WriteMask
}

sub void dovkCmdSetStencilWriteMask(ref!vkCmdSetStencilWriteMaskArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilWriteMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                writeMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilWriteMaskArgs(
    faceMask,
    writeMask
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilWriteMask))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilWriteMask[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilWriteMask, mapPos)
}

@internal class vkCmdSetStencilReferenceArgs {
  VkStencilFaceFlags FaceMask
  u32                Reference
}

sub void dovkCmdSetStencilReference(ref!vkCmdSetStencilReferenceArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilReference(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                reference) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilReferenceArgs(
    faceMask,
    reference
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilReference))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilReference[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilReference, mapPos)
}

@internal class
vkCmdBindDescriptorSetsArgs {
  VkPipelineBindPoint        PipelineBindPoint
  VkPipelineLayout           Layout
  u32                        FirstSet
  map!(u32, VkDescriptorSet) DescriptorSets
  map!(u32, u32)             DynamicOffsets
}

sub void dovkCmdBindDescriptorSets(ref!vkCmdBindDescriptorSetsArgs args) {
  dynamic_offset_index := MutableU32(0)

  for i , _ , set in args.DescriptorSets {
    lastDrawInfo().DescriptorSets[args.FirstSet + as!u32(i)] = DescriptorSets[set]
  }

  for i in (0 .. len(args.DescriptorSets)) {
    if args.DescriptorSets[as!u32(i)] in DescriptorSets {
      set := DescriptorSets[args.DescriptorSets[as!u32(i)]]

      // Since the pDynamicOffsets point into the bindings in order of
      // binding index, and then array index, we have to loop over all
      // of the BoundBuffers in order of the binding number.

      // Since `for _, k, v in set.BoundBuffers` loops over in an
      // arbitrary order, instead we loop over all bindings for the layout
      // and see if it is a buffer.
      for j in (0 .. len(set.Bindings)) {
        binding := set.Bindings[as!u32(j)]
        for k in (0 .. len(binding.BufferBinding)) {
          bufferBinding := binding.BufferBinding[as!u32(k)]

          binding_offset := switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              as!VkDeviceSize(args.DynamicOffsets[dynamic_offset_index.Val]) + bufferBinding.Offset
            default:
              bufferBinding.Offset
          }
          dynamic_offset_index.Val = switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              dynamic_offset_index.Val + 1
            default:
              dynamic_offset_index.Val
          }
          if (bufferBinding.Buffer in Buffers) {
            bufferObject := Buffers[bufferBinding.Buffer]
            readCoherentMemoryInBuffer(bufferObject, binding_offset, bufferBinding.Range)
          }
        }
        for k in (0 .. len(binding.BufferViewBindings)) {
          buffer_view := binding.BufferViewBindings[as!u32(k)]
          if (buffer_view != as!VkBufferView(0)) {
            buffer_view_object := BufferViews[buffer_view]
            readCoherentMemoryInBuffer(buffer_view_object.Buffer, buffer_view_object.Offset, buffer_view_object.Range)
          }
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindDescriptorSets(
    VkCommandBuffer        commandBuffer,
    VkPipelineBindPoint    pipelineBindPoint,
    VkPipelineLayout       layout,
    u32                    firstSet,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    u32                    dynamicOffsetCount,
    const u32*             pDynamicOffsets) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pDescriptorSets == null { vkErrorNullPointer("VkDescriptorSet") }
  sets := pDescriptorSets[0:descriptorSetCount]
  args := new!vkCmdBindDescriptorSetsArgs(
    PipelineBindPoint: pipelineBindPoint,
    Layout:            layout,
    FirstSet:          firstSet
  )

  dynamic_offsets := pDynamicOffsets[0:dynamicOffsetCount]
  for i in (0 .. dynamicOffsetCount) {
    args.DynamicOffsets[i] = dynamic_offsets[i]
  }
  for i in (0 .. descriptorSetCount) {
    args.DescriptorSets[i] = sets[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBindDescriptorSets))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBindDescriptorSets[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBindDescriptorSets, mapPos)
}

@internal
class BoundBuffer {
  ref!BufferObject Buffer
  VkDeviceSize     Offset
  VkDeviceSize     Range
}

@internal
class BoundIndexBuffer {
  VkIndexType Type
  BoundBuffer BoundBuffer
}

@internal class
vkCmdBindIndexBufferArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  VkIndexType  IndexType
}


sub void dovkCmdBindIndexBuffer(ref!vkCmdBindIndexBufferArgs buffer) {
  lastDrawInfo().BoundIndexBuffer = new!BoundIndexBuffer(buffer.IndexType,
    BoundBuffer(Buffers[buffer.Buffer], buffer.Offset, 0))
  Buffers[buffer.Buffer].LastBoundQueue = LastBoundQueue
}


@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    VkIndexType     indexType) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  args := new!vkCmdBindIndexBufferArgs(
    Buffer:     buffer,
    Offset:     offset,
    IndexType:  indexType
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBindIndexBuffer))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBindIndexBuffer[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBindIndexBuffer, mapPos)
}

@internal class
vkCmdBindVertexBuffersArgs {
  u32                     FirstBinding
  u32                     BindingCount
  map!(u32, VkBuffer)     Buffers
  map!(u32, VkDeviceSize) Offsets
}

@internal
class CmdBindBuffer {
  map!(u32, BoundBuffer) BoundBuffers
}

sub void dovkCmdBindVertexBuffers(ref!vkCmdBindVertexBuffersArgs bind) {
  for i , _ , v in bind.Buffers {
    lastDrawInfo().BoundVertexBuffers[as!u32(i)] = BoundBuffer(
      Buffers[v], bind.Offsets[as!u32(i)],
      Buffers[v].Info.Size - bind.Offsets[as!u32(i)])
    Buffers[v].LastBoundQueue = LastBoundQueue
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindVertexBuffers(
    VkCommandBuffer     commandBuffer,
    u32                 firstBinding,
    u32                 bindingCount,
    const VkBuffer*     pBuffers,
    const VkDeviceSize* pOffsets) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdBindVertexBuffersArgs(
    FirstBinding:  firstBinding,
    BindingCount:  bindingCount
  )
  buffers := pBuffers[0:bindingCount]
  offsets := pOffsets[0:bindingCount]
  for i in (0 .. bindingCount) {
    if !(buffers[i] in Buffers) { vkErrorInvalidBuffer(buffers[i]) }
    args.Buffers[i] = buffers[i]
    args.Offsets[i] = offsets[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBindVertexBuffers))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBindVertexBuffers[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBindVertexBuffers, mapPos)
}

sub VkDeviceSize deviceMemoryOffsetToMappedSpace(ref!DeviceMemoryObject memory, VkDeviceSize offsetInDeviceMemory) {
  ret := switch memory.MappedLocation == null {
    case true:
      as!VkDeviceSize(0xFFFFFFFFFFFFFFFF)
    case false:
      switch offsetInDeviceMemory < memory.MappedOffset {
        case true:
          as!VkDeviceSize(0xFFFFFFFFFFFFFFFF)
        case false:
          switch offsetInDeviceMemory >= memory.MappedOffset + memory.MappedSize {
            case true:
              as!VkDeviceSize(0xFFFFFFFFFFFFFFFF)
            case false:
              offsetInDeviceMemory - memory.MappedOffset
          }
      }
  }
  return ret
}

sub void readCoherentMemory(ref!DeviceMemoryObject memory, VkDeviceSize readOffset, VkDeviceSize readSize) {
  if IsMemoryCoherent(memory) && (memory.MappedLocation != null) {
    offset_in_mapped := deviceMemoryOffsetToMappedSpace(memory, readOffset)
    if offset_in_mapped != as!VkDeviceSize(0xFFFFFFFFFFFFFFFF) {
      read_size_in_mapped := switch (
      (readSize == as!VkDeviceSize(0xFFFFFFFFFFFFFFFF)) ||
      ((offset_in_mapped + readSize) > memory.MappedSize)) {
        case true:
          memory.MappedSize - offset_in_mapped
        case false:
          readSize
      }
      if (offset_in_mapped + read_size_in_mapped) > offset_in_mapped {
        readMappedCoherentMemory(memory.VulkanHandle, as!u64(offset_in_mapped),
          as!size(read_size_in_mapped))
      }
    }
  }
}

sub void readCoherentMemoryInBuffer(ref!BufferObject buffer, VkDeviceSize readOffset, VkDeviceSize readSize) {
  mem := buffer.Memory
  if mem != null {
    if as!u64(readSize) == 0xFFFFFFFFFFFFFFFF {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, buffer.Info.Size - readOffset)
    } else {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, readSize)
    }
  }
}

sub void readCoherentMemoryInImage(ref!ImageObject image) {
  mem := image.BoundMemory
  if mem != null {
    // Host access to image memory is only well-defined for images created with
    // VK_IMAGE_TILING_LINEAR tiling and for image subresources of those images
    // which are currently in either VK_IMAGE_LAYOUT_PREINITIALIZED or
    // VK_IMAGE_LAYOUT_GENERAL layout.
    // TODO: Complete the layout tracking logic then update this if statement
    // to check the layout of the underlying image.
    if image.Info.Tiling == VK_IMAGE_TILING_LINEAR {
      readCoherentMemory(mem, image.BoundMemoryOffset, inferImageSize(image))
    }
  }
}

sub void readCoherentMemoryInCurrentPipelineBoundVertexBuffers(u32 vertexCount, u32 instanceCount, u32 firstVertex, u32 firstInstance) {
  for _ , _ , vertex_binding in lastDrawInfo().GraphicsPipeline.VertexInputState.BindingDescriptions {
    if vertex_binding.binding in lastDrawInfo().BoundVertexBuffers {
      bound_vertex_buffer := lastDrawInfo().BoundVertexBuffers[vertex_binding.binding]
      backing_buf := bound_vertex_buffer.Buffer
      if ((backing_buf.Memory != null) && IsMemoryCoherent(backing_buf.Memory)) {
        start_vertex := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            firstVertex
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            firstInstance
        }
        num_vertices := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            vertexCount
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            instanceCount
        }
        start_offset := bound_vertex_buffer.Offset + as!VkDeviceSize(start_vertex * vertex_binding.stride)
        num := switch vertexCount == 0xFFFFFFFF {
          case true:
            backing_buf.Info.Size - start_offset
          case false:
            as!VkDeviceSize(num_vertices * vertex_binding.stride)
        }
        readCoherentMemoryInBuffer(backing_buf, start_offset, num)
      }
    }
  }
}

@internal class vkCmdDrawArgs {
  u32 VertexCount
  u32 InstanceCount
  u32 FirstVertex
  u32 FirstInstance
}


sub void dovkCmdDraw(ref!vkCmdDrawArgs draw) {
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(draw.VertexCount, draw.InstanceCount, draw.FirstVertex, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  lastDrawInfo().CommandParameters.Draw = draw
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDraw(
    VkCommandBuffer commandBuffer,
    u32             vertexCount,
    u32             instanceCount,
    u32             firstVertex,
    u32             firstInstance) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdDrawArgs(vertexCount, instanceCount, firstVertex, firstInstance)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDraw))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDraw[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDraw, mapPos)
}

@internal class
vkCmdDrawIndexedArgs {
  u32 IndexCount
  u32 InstanceCount
  u32 FirstIndex
  s32 VertexOffset
  u32 FirstInstance
}

sub void dovkCmdDrawIndexed(ref!vkCmdDrawIndexedArgs draw) {
  // Loop through the index buffer, and find the low and high
  // vertices. Then read all of the applicable vertex buffers.
  lastDraw := lastDrawInfo()
  indexBuffer := lastDraw.BoundIndexBuffer.BoundBuffer.Buffer
  indexSize := switch (lastDraw.BoundIndexBuffer.Type) {
    case VK_INDEX_TYPE_UINT16:
      as!VkDeviceSize(2)
    case VK_INDEX_TYPE_UINT32:
      as!VkDeviceSize(4)
  }

  numBytes := as!VkDeviceSize(draw.IndexCount) * indexSize
  startOffset := lastDrawInfo().BoundIndexBuffer.BoundBuffer.Offset + (indexSize * as!VkDeviceSize(draw.FirstIndex))

  // Read the data of the index buffer if the index buffer is backed with coherent memory.
  readCoherentMemoryInBuffer(indexBuffer, startOffset, numBytes)
  // Read the whole vertex buffer if a buffer is backed with coherent memory.
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, draw.InstanceCount, 0, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  lastDrawInfo().CommandParameters.DrawIndexed = draw
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    u32             indexCount,
    u32             instanceCount,
    u32             firstIndex,
    s32             vertexOffset,
    u32             firstInstance) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdDrawIndexedArgs(
    IndexCount:     indexCount,
    InstanceCount:  instanceCount,
    FirstIndex:     firstIndex,
    VertexOffset:   vertexOffset,
    FirstInstance:  firstInstance
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndexed))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndexed[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDrawIndexed, mapPos)
}

@internal class vkCmdDrawIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  u32          DrawCount
  u32          Stride
}

sub void dovkCmdDrawIndirect(ref!vkCmdDrawIndirectArgs draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through all the vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    lastDrawInfo().CommandParameters.DrawIndirect = draw
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  args := new!vkCmdDrawIndirectArgs(buffer, offset, drawCount, stride)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndirect))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndirect[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDrawIndirect, mapPos)
}

@internal class vkCmdDrawIndexedIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  u32          DrawCount
  u32          Stride
}

sub void dovkCmdDrawIndexedIndirect(ref!vkCmdDrawIndexedIndirectArgs draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through the whole index buffer if it uses coherent menory.
    indexBuffer := lastDrawInfo().BoundIndexBuffer.BoundBuffer.Buffer
    readCoherentMemoryInBuffer(indexBuffer, 0, indexBuffer.Info.Size)
    // Read through all the coherent memory vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    lastDrawInfo().CommandParameters.DrawIndexedIndirect = draw
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  args := new!vkCmdDrawIndexedIndirectArgs(buffer, offset, drawCount, stride)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndexedIndirect))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDrawIndexedIndirect[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDrawIndexedIndirect, mapPos)
}

@internal class vkCmdDispatchArgs {
  u32 GroupCountX,
  u32 GroupCountY,
  u32 GroupCountZ
}

sub void dovkCmdDispatch(ref!vkCmdDispatchArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    u32             groupCountX,
    u32             groupCountY,
    u32             groupCountZ) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args :=
  new!vkCmdDispatchArgs(groupCountX, groupCountY, groupCountZ)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDispatch))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDispatch[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDispatch, mapPos)
}

@internal
class vkCmdDispatchIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
}

sub void dovkCmdDispatchIndirect(ref!vkCmdDispatchIndirectArgs dispatch) {
  command_size := as!VkDeviceSize(12)
  readCoherentMemoryInBuffer(Buffers[dispatch.Buffer], dispatch.Offset, command_size)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  args := new!vkCmdDispatchIndirectArgs(buffer, offset)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDispatchIndirect))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDispatchIndirect[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDispatchIndirect, mapPos)
}

@internal class vkCmdCopyBufferArgs {
  VkBuffer                SrcBuffer  ,
  VkBuffer                DstBuffer  ,
  map!(u32, VkBufferCopy) CopyRegions
}

sub void dovkCmdCopyBuffer(ref!vkCmdCopyBufferArgs buffer) {
  sourceBuffer := Buffers[buffer.SrcBuffer]
  destBuffer := Buffers[buffer.DstBuffer]
  for _ , _ , region in buffer.CopyRegions {
    srcMemoryOffset := sourceBuffer.MemoryOffset + region.srcOffset
    dstMemoryOffset := destBuffer.MemoryOffset + region.dstOffset
    readCoherentMemoryInBuffer(sourceBuffer, region.srcOffset, region.size)
    copy(destBuffer.Memory.Data[dstMemoryOffset:dstMemoryOffset + region.size],
      sourceBuffer.Memory.Data[srcMemoryOffset:srcMemoryOffset + region.size])
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBuffer(
    VkCommandBuffer     commandBuffer,
    VkBuffer            srcBuffer,
    VkBuffer            dstBuffer,
    u32                 regionCount,
    const VkBufferCopy* pRegions) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(srcBuffer in Buffers) { vkErrorInvalidBuffer(srcBuffer) }
  if !(srcBuffer in Buffers) { vkErrorInvalidBuffer(dstBuffer) }
  args := new!vkCmdCopyBufferArgs(
    SrcBuffer:  srcBuffer,
    DstBuffer:  dstBuffer
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.CopyRegions[i] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyBuffer))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyBuffer[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdCopyBuffer, mapPos)
}

@internal
class vkCmdCopyImageArgs {
  VkImage                SrcImage
  VkImageLayout          SrcImageLayout
  VkImage                DstImage
  VkImageLayout          DstImageLayout
  map!(u32, VkImageCopy) Regions
}

sub void dovkCmdCopyImage(ref!vkCmdCopyImageArgs args) {
  srcImageObject := Images[args.SrcImage]
  dstImageObject := Images[args.DstImage]

  // The following read on coherent memory of the source image does not affect the data in imageLevel.Data, as they are different memory spaces.
  // But such a read is necessary if the backing memory of the source image is coherent, as we need the read observations on all memory changes
  // in order to replay correctly. However, as the UI's texture data comes from imageLevel.Data, just using the following call will not bring
  // the changes in coherent memory to the UI's texture view.
  readCoherentMemoryInImage(srcImageObject)

  srcFormat := srcImageObject.Info.Format
  srcElementAndTexelBlockSize := getElementAndTexelBlockSize(srcFormat)
  dstFormat := dstImageObject.Info.Format
  dstElementAndTexelBlockSize := getElementAndTexelBlockSize(dstFormat)
  for r in (0 .. len(args.Regions)) {
    // TODO: (qining) Handle the apsect mask
    region := args.Regions[as!u32(r)]
    srcBaseLayer := region.srcSubresource.baseArrayLayer
    dstBaseLayer := region.srcSubresource.baseArrayLayer
    srcMipLevel := region.srcSubresource.mipLevel
    dstMipLevel := region.dstSubresource.mipLevel

    srcElementSize := as!u64(srcElementAndTexelBlockSize.ElementSize)
    srcBlockWidth := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Width)
    srcBlockHeight := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Height)
    dstElementSize := as!u64(dstElementAndTexelBlockSize.ElementSize)
    dstBlockWidth := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Width)
    dstBlockHeight := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Height)

    srcXStartInBlocks := as!u64(as!u64(region.srcOffset.x) / srcBlockWidth)
    srcYStartInBlocks := as!u64(as!u64(region.srcOffset.y) / srcBlockHeight)
    srcZStart := as!u64(region.srcOffset.z)
    dstXStartInBlocks := as!u64(as!u64(region.dstOffset.x) / dstBlockWidth)
    dstYStartInBlocks := as!u64(as!u64(region.dstOffset.y) / dstBlockHeight)
    dstZStart := as!u64(region.dstOffset.z)

    extentXInBlocks := roundUpTo(region.extent.Width, as!u32(srcBlockWidth))
    extentYInBlocks := roundUpTo(region.extent.Height, as!u32(srcBlockHeight))
    extentZ := region.extent.Depth

    for l in (0 .. region.srcSubresource.layerCount) {
      srcImageLevel := srcImageObject.Layers[srcBaseLayer + l].Levels[srcMipLevel]
      dstImageLevel := dstImageObject.Layers[dstBaseLayer + l].Levels[dstMipLevel]

      srcImageLevelWidthInBlocks := as!u64(roundUpTo(srcImageLevel.Width, as!u32(srcBlockWidth)))
      srcImageLevelHeightInBlocks := as!u64(roundUpTo(srcImageLevel.Height, as!u32(srcBlockHeight)))
      dstImageLevelWidthInBlocks := as!u64(roundUpTo(dstImageLevel.Width, as!u32(dstBlockWidth)))
      dstImageLevelHeightInBlocks := as!u64(roundUpTo(dstImageLevel.Height, as!u32(dstBlockHeight)))

      for z in (0 .. extentZ) {
        for y in (0 .. extentYInBlocks) {
          copySize := as!u64(extentXInBlocks) * srcElementSize
          dstY := dstYStartInBlocks + as!u64(y)
          dstZ := dstZStart + as!u64(z)
          srcY := srcYStartInBlocks + as!u64(y)
          srcZ := srcZStart + as!u64(z)
          dstStart := ((((dstZ * dstImageLevelHeightInBlocks) + dstY) * dstImageLevelWidthInBlocks) + dstXStartInBlocks) * dstElementSize
          srcStart := ((((srcZ * srcImageLevelHeightInBlocks) + srcY) * srcImageLevelWidthInBlocks) + srcXStartInBlocks) * srcElementSize
          copy(dstImageLevel.Data[dstStart:dstStart + copySize], srcImageLevel.Data[srcStart:srcStart + copySize])
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageCopy* pRegions) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(srcImage in Images) { vkErrorInvalidImage(srcImage) }
  if !(dstImage in Images) { vkErrorInvalidImage(dstImage) }
  args := new!vkCmdCopyImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdCopyImage, mapPos)
}

@internal
class vkCmdBlitImageArgs {
  VkImage                SrcImage
  VkImageLayout          SrcImageLayout
  VkImage                DstImage
  VkImageLayout          DstImageLayout
  map!(u32, VkImageBlit) Regions
  VkFilter               Filter
}

sub void dovkCmdBlitImage(ref!vkCmdBlitImageArgs dispatch) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBlitImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageBlit* pRegions,
    VkFilter           filter) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(srcImage in Images) { vkErrorInvalidImage(srcImage) }
  if !(dstImage in Images) { vkErrorInvalidImage(dstImage) }
  args := new!vkCmdBlitImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout,
    Filter:          filter
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBlitImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBlitImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBlitImage, mapPos)
}

@internal
class TexelBlockSizePair {
  u32 Width
  u32 Height
}

@internal
class ElementAndTexelBlockSize {
  u32                ElementSize
  TexelBlockSizePair TexelBlockSize
}

// This should roughly correspond to "Compatible formats" in the Vulkan spec
sub ElementAndTexelBlockSize getElementAndTexelBlockSize(VkFormat format) {
  return switch (format) {
    case VK_FORMAT_R4G4_UNORM_PACK8,
        VK_FORMAT_R8_UNORM,
        VK_FORMAT_R8_SNORM,
        VK_FORMAT_R8_USCALED,
        VK_FORMAT_R8_SSCALED,
        VK_FORMAT_R8_UINT,
        VK_FORMAT_R8_SINT,
        VK_FORMAT_R8_SRGB:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        VK_FORMAT_R5G6B5_UNORM_PACK16,
        VK_FORMAT_B5G6R5_UNORM_PACK16,
        VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        VK_FORMAT_R8G8_UNORM,
        VK_FORMAT_R8G8_SNORM,
        VK_FORMAT_R8G8_USCALED,
        VK_FORMAT_R8G8_SSCALED,
        VK_FORMAT_R8G8_UINT,
        VK_FORMAT_R8G8_SINT,
        VK_FORMAT_R8G8_SRGB,
        VK_FORMAT_R16_UNORM,
        VK_FORMAT_R16_SNORM,
        VK_FORMAT_R16_USCALED,
        VK_FORMAT_R16_SSCALED,
        VK_FORMAT_R16_UINT,
        VK_FORMAT_R16_SINT,
        VK_FORMAT_R16_SFLOAT:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8_UNORM,
        VK_FORMAT_R8G8B8_SNORM,
        VK_FORMAT_R8G8B8_USCALED,
        VK_FORMAT_R8G8B8_SSCALED,
        VK_FORMAT_R8G8B8_UINT,
        VK_FORMAT_R8G8B8_SINT,
        VK_FORMAT_R8G8B8_SRGB,
        VK_FORMAT_B8G8R8_UNORM,
        VK_FORMAT_B8G8R8_SNORM,
        VK_FORMAT_B8G8R8_USCALED,
        VK_FORMAT_B8G8R8_SSCALED,
        VK_FORMAT_B8G8R8_UINT,
        VK_FORMAT_B8G8R8_SINT,
        VK_FORMAT_B8G8R8_SRGB:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8A8_UNORM,
        VK_FORMAT_R8G8B8A8_SNORM,
        VK_FORMAT_R8G8B8A8_USCALED,
        VK_FORMAT_R8G8B8A8_SSCALED,
        VK_FORMAT_R8G8B8A8_UINT,
        VK_FORMAT_R8G8B8A8_SINT,
        VK_FORMAT_R8G8B8A8_SRGB,
        VK_FORMAT_B8G8R8A8_UNORM,
        VK_FORMAT_B8G8R8A8_SNORM,
        VK_FORMAT_B8G8R8A8_USCALED,
        VK_FORMAT_B8G8R8A8_SSCALED,
        VK_FORMAT_B8G8R8A8_UINT,
        VK_FORMAT_B8G8R8A8_SINT,
        VK_FORMAT_B8G8R8A8_SRGB,
        VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        VK_FORMAT_A8B8G8R8_UINT_PACK32,
        VK_FORMAT_A8B8G8R8_SINT_PACK32,
        VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        VK_FORMAT_A2R10G10B10_UINT_PACK32,
        VK_FORMAT_A2R10G10B10_SINT_PACK32,
        VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        VK_FORMAT_A2B10G10R10_UINT_PACK32,
        VK_FORMAT_A2B10G10R10_SINT_PACK32,
        VK_FORMAT_R16G16_UNORM,
        VK_FORMAT_R16G16_SNORM,
        VK_FORMAT_R16G16_USCALED,
        VK_FORMAT_R16G16_SSCALED,
        VK_FORMAT_R16G16_UINT,
        VK_FORMAT_R16G16_SINT,
        VK_FORMAT_R16G16_SFLOAT,
        VK_FORMAT_R32_UINT,
        VK_FORMAT_R32_SINT,
        VK_FORMAT_R32_SFLOAT,
        VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16_UNORM,
        VK_FORMAT_R16G16B16_SNORM,
        VK_FORMAT_R16G16B16_USCALED,
        VK_FORMAT_R16G16B16_SSCALED,
        VK_FORMAT_R16G16B16_UINT,
        VK_FORMAT_R16G16B16_SINT,
        VK_FORMAT_R16G16B16_SFLOAT:
      ElementAndTexelBlockSize(6, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16A16_UNORM,
        VK_FORMAT_R16G16B16A16_SNORM,
        VK_FORMAT_R16G16B16A16_USCALED,
        VK_FORMAT_R16G16B16A16_SSCALED,
        VK_FORMAT_R16G16B16A16_UINT,
        VK_FORMAT_R16G16B16A16_SINT,
        VK_FORMAT_R16G16B16A16_SFLOAT,
        VK_FORMAT_R32G32_UINT,
        VK_FORMAT_R32G32_SINT,
        VK_FORMAT_R32G32_SFLOAT,
        VK_FORMAT_R64_UINT,
        VK_FORMAT_R64_SINT,
        VK_FORMAT_R64_SFLOAT:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32_UINT,
        VK_FORMAT_R32G32B32_SINT,
        VK_FORMAT_R32G32B32_SFLOAT:
      ElementAndTexelBlockSize(12, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32A32_UINT,
        VK_FORMAT_R32G32B32A32_SINT,
        VK_FORMAT_R32G32B32A32_SFLOAT,
        VK_FORMAT_R64G64_UINT,
        VK_FORMAT_R64G64_SINT,
        VK_FORMAT_R64G64_SFLOAT:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64_UINT,
        VK_FORMAT_R64G64B64_SINT,
        VK_FORMAT_R64G64B64_SFLOAT:
      ElementAndTexelBlockSize(24, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64A64_UINT,
        VK_FORMAT_R64G64B64A64_SINT,
        VK_FORMAT_R64G64B64A64_SFLOAT:
      ElementAndTexelBlockSize(32, TexelBlockSizePair(1, 1))
    case VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC2_UNORM_BLOCK,
        VK_FORMAT_BC2_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC3_UNORM_BLOCK,
        VK_FORMAT_BC3_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC4_UNORM_BLOCK,
        VK_FORMAT_BC4_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC5_UNORM_BLOCK,
        VK_FORMAT_BC5_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC6H_UFLOAT_BLOCK,
        VK_FORMAT_BC6H_SFLOAT_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC7_UNORM_BLOCK,
        VK_FORMAT_BC7_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11_UNORM_BLOCK,
        VK_FORMAT_EAC_R11_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 4))
    case VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 5))
    case VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 5))
    case VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 6))
    case VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 5))
    case VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 6))
    case VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 8))
    case VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 5))
    case VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 6))
    case VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 8))
    case VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 10))
    case VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 10))
    case VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 12))
    case VK_FORMAT_D16_UNORM:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_X8_D24_UNORM_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_S8_UINT:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D16_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D24_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT_S8_UINT:
      ElementAndTexelBlockSize(5, TexelBlockSizePair(1, 1))
    default:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
  }
}

@internal
class RowLengthAndImageHeight {
  u32 RowLength
  u32 ImageHeight
}

sub RowLengthAndImageHeight getRowLengthAndImageHeight(VkBufferImageCopy region) {
  rowLength := switch region.bufferRowLength == 0 {
    case true:  region.imageExtent.Width
    case false: region.bufferRowLength
  }
  imageHeight := switch region.bufferImageHeight == 0 {
    case true:  region.imageExtent.Height
    case false: region.bufferImageHeight
  }
  return RowLengthAndImageHeight(rowLength, imageHeight)
}

@interal
class MutableVkDeviceSize {
  VkDeviceSize Val
}

sub VkDeviceSize inferImageSize(ref!ImageObject img) {
  img_info := img.Info
  img_size := MutableVkDeviceSize(0)
  for m in (0 .. img_info.MipLevels) {
    img_size.Val += inferImageLevelSize(img, m)
  }
  return img_size.Val
}

sub VkDeviceSize inferImageLevelSize(ref!ImageObject img, u32 level) {
  img_info := img.Info
  level_size := MutableVkDeviceSize(0)
  if level < img_info.MipLevels {
    block_info := getElementAndTexelBlockSize(img_info.Format)
    width := getMipSize(img_info.Extent.Width, level)
    height := getMipSize(img_info.Extent.Height, level)
    depth := getMipSize(img_info.Extent.Depth, level)
    width_in_blocks := roundUpTo(width, block_info.TexelBlockSize.Width)
    height_in_blocks := roundUpTo(height, block_info.TexelBlockSize.Height)
    level_size.Val += as!VkDeviceSize(width_in_blocks * height_in_blocks * depth * block_info.ElementSize * img_info.ArrayLayers)
  }
  return level_size.Val
}

@internal
class vkCmdCopyBufferToImageArgs {
  VkBuffer                     SrcBuffer
  VkImage                      DstImage
  VkImageLayout                Layout
  map!(u32, VkBufferImageCopy) Regions
}

sub void dovkCmdCopyBufferToImage(ref!vkCmdCopyBufferToImageArgs args) {
  bufferObject := Buffers[args.SrcBuffer]
  imageObject := Images[args.DstImage]
  format := imageObject.Info.Format
  elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
  // Iterate through regions
  for i in (0 .. len(args.Regions)) {
    region := args.Regions[as!u32(i)]
    rowLengthAndImageHeight := getRowLengthAndImageHeight(region)
    rowLength := as!u64(rowLengthAndImageHeight.RowLength / elementAndTexelBlockSize.TexelBlockSize.Width)
    imageHeight := as!u64(rowLengthAndImageHeight.ImageHeight / elementAndTexelBlockSize.TexelBlockSize.Height)
    elementSize := as!u64(elementAndTexelBlockSize.ElementSize)
    layerSize := rowLength * imageHeight * elementSize
    zStart := as!u64(region.imageOffset.z)
    zEnd := zStart + as!u64(region.imageExtent.Depth)
    yStart := as!u64(as!u32(region.imageOffset.y) / elementAndTexelBlockSize.TexelBlockSize.Height)
    yEnd := yStart + as!u64(region.imageExtent.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
    xStart := as!u64(as!u32(region.imageOffset.x) / elementAndTexelBlockSize.TexelBlockSize.Width)
    xEnd := xStart + as!u64(region.imageExtent.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
    // When multiple layers are specified in the buffer image copy region,
    // Vulkan assumes the data of all the layers are placed continuously in
    // the source buffer memory.
    // TODO: (qining) Handle aspect mask
    for j in (0 .. region.imageSubresource.layerCount) {
      layerIndex := region.imageSubresource.baseArrayLayer + j
      bufferLayerOffset := as!u64(j) * layerSize
      imageLevel := imageObject.Layers[layerIndex].Levels[region.imageSubresource.mipLevel]
      imageLevelWidthInBlocks := as!u64(imageLevel.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
      imageLevelHeightInBlocks := as!u64(imageLevel.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
      // Iterate through depths and rows to copy
      for z in (zStart .. zEnd) {
        for y in (yStart .. yEnd) {
          copySize := (xEnd - xStart) * elementSize
          dstStart := ((((z * imageLevelHeightInBlocks) + y) * imageLevelWidthInBlocks) + xStart) * elementSize
          dstEnd := dstStart + copySize
          zInExtent := z - zStart
          yInExtent := y - yStart
          rowStartInExtent := (((zInExtent * imageHeight) + yInExtent) * rowLength) * elementSize
          srcStart := as!u64(bufferObject.MemoryOffset) + as!u64(region.bufferOffset) + bufferLayerOffset + rowStartInExtent
          srcEnd := srcStart + copySize
          readCoherentMemoryInBuffer(bufferObject, region.bufferOffset + as!VkDeviceSize(bufferLayerOffset + rowStartInExtent), as!VkDeviceSize(copySize))
          copy(imageLevel.Data[dstStart:dstEnd], bufferObject.Memory.Data[srcStart:srcEnd])
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBufferToImage(
    VkCommandBuffer          commandBuffer,
    VkBuffer                 srcBuffer,
    VkImage                  dstImage,
    VkImageLayout            dstImageLayout,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(srcBuffer in Buffers) { vkErrorInvalidBuffer(srcBuffer) }
  if !(dstImage in Images) { vkErrorInvalidImage(dstImage) }
  regions := pRegions[0:regionCount]
  read(regions)
  args := new!vkCmdCopyBufferToImageArgs(srcBuffer, dstImage, dstImageLayout)
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyBufferToImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyBufferToImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdCopyBufferToImage, mapPos)
}

@internal
class vkCmdCopyImageToBufferArgs {
  VkImage                      SrcImage
  VkImageLayout                SrcImageLayout
  VkBuffer                     DstBuffer
  map!(u32, VkBufferImageCopy) Regions
}

sub void dovkCmdCopyImageToBuffer(ref!vkCmdCopyImageToBufferArgs dispatch) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImageToBuffer(
    VkCommandBuffer          commandBuffer,
    VkImage                  srcImage,
    VkImageLayout            srcImageLayout,
    VkBuffer                 dstBuffer,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(dstBuffer in Buffers) { vkErrorInvalidBuffer(dstBuffer) }
  if !(srcImage in Images) { vkErrorInvalidImage(srcImage) }
  regions := pRegions[0:regionCount]
  args := new!vkCmdCopyImageToBufferArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstBuffer:       dstBuffer,
  )
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyImageToBuffer))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyImageToBuffer[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdCopyImageToBuffer, mapPos)
}

@internal class vkCmdUpdateBufferArgs {
  VkBuffer     DstBuffer
  VkDeviceSize DstOffset
  VkDeviceSize DataSize
  u8[]         Data
}

sub void dovkCmdUpdateBuffer(ref!vkCmdUpdateBufferArgs args) {
  Buffers[args.DstBuffer].LastBoundQueue = LastBoundQueue
  buff := Buffers[args.DstBuffer]
  start := buff.MemoryOffset + args.DstOffset
  copy(buff.Memory.Data[start:start + args.DataSize],
    args.Data[0:args.DataSize])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    dataSize,
    const void*     pData) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(dstBuffer in Buffers) { vkErrorInvalidBuffer(dstBuffer) }
  args := new!vkCmdUpdateBufferArgs(
    dstBuffer,
    dstOffset,
    dataSize,
  )
  args.Data = clone(as!u8*(pData)[0:dataSize])

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdUpdateBuffer))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdUpdateBuffer[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdUpdateBuffer, mapPos)
}

@internal
class vkCmdFillBufferArgs {
  VkBuffer     Buffer
  VkDeviceSize DstOffset,
  VkDeviceSize Size
  u32          Data
}

sub void dovkCmdFillBuffer(ref!vkCmdFillBufferArgs args) {
  // DO NOT CHECK IN: IMPLEMENT THIS
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    size,
    u32             data) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(dstBuffer in Buffers) { vkErrorInvalidBuffer(dstBuffer) }
  args := new!vkCmdFillBufferArgs(
    dstBuffer,
    dstOffset,
    size,
    data
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdFillBuffer))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdFillBuffer[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdFillBuffer, mapPos)
}

@internal
class vkCmdClearColorImageArgs {
  VkImage                            Image
  VkImageLayout                      ImageLayout
  VkClearColorValue                  Color
  map!(u32, VkImageSubresourceRange) Ranges
}

sub void dovkCmdClearColorImage(ref!vkCmdClearColorImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearColorImage(
    VkCommandBuffer                commandBuffer,
    VkImage                        image,
    VkImageLayout                  imageLayout,
    const VkClearColorValue*       pColor,
    u32                            rangeCount,
    const VkImageSubresourceRange* pRanges) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  if pColor == null { vkErrorNullPointer("VkClearColorValue") }
  color := pColor[0]
  ranges := pRanges[0:rangeCount]
  args := new!vkCmdClearColorImageArgs(
    Image:        image,
    ImageLayout:  imageLayout,
    Color:        color,
  )
  for i in (0 .. rangeCount) {
    args.Ranges[as!u32(i)] = ranges[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdClearColorImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdClearColorImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdClearColorImage, mapPos)
}

@internal
class vkCmdClearDepthStencilImageArgs {
  VkImage                            Image
  VkImageLayout                      ImageLayout
  VkClearDepthStencilValue           DepthStencil
  map!(u32, VkImageSubresourceRange) Ranges
}

sub void dovkCmdClearDepthStencilImage(ref!vkCmdClearDepthStencilImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearDepthStencilImage(
    VkCommandBuffer                 commandBuffer,
    VkImage                         image,
    VkImageLayout                   imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    u32                             rangeCount,
    const VkImageSubresourceRange*  pRanges) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  if pDepthStencil == null { vkErrorNullPointer("VkClearDepthStencilValue") }
  depthStencil := pDepthStencil[0]
  ranges := pRanges[0:rangeCount]
  args := new!vkCmdClearDepthStencilImageArgs(
    Image:         image,
    ImageLayout:   imageLayout,
    DepthStencil:  depthStencil,
  )
  for i in (0 .. rangeCount) {
    args.Ranges[as!u32(i)] = ranges[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdClearDepthStencilImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdClearDepthStencilImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdClearDepthStencilImage, mapPos)
}

@internal
class vkCmdClearAttachmentsArgs {
  map!(u32, VkClearAttachment) Attachments
  map!(u32, VkClearRect)       Rects
}

sub void dovkCmdClearAttachments(ref!vkCmdClearAttachmentsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearAttachments(
    VkCommandBuffer          commandBuffer,
    u32                      attachmentCount,
    const VkClearAttachment* pAttachments,
    u32                      rectCount,
    const VkClearRect*       pRects) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdClearAttachmentsArgs()
  attachments := pAttachments[0:attachmentCount]
  rects := pRects[0:rectCount]
  for i in (0 .. attachmentCount) {
    args.Attachments[as!u32(i)] = attachments[i]
  }
  for i in (0 .. rectCount) {
    args.Rects[as!u32(i)] = rects[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdClearAttachments))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdClearAttachments[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdClearAttachments, mapPos)
}

@internal class vkCmdResolveImageArgs {
  VkImage                   SrcImage      ,
  VkImageLayout             SrcImageLayout,
  VkImage                   DstImage      ,
  VkImageLayout             DstImageLayout,
  map!(u32, VkImageResolve) ResolveRegions
}

sub void dovkCmdResolveImage(ref!vkCmdResolveImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResolveImage(
    VkCommandBuffer       commandBuffer,
    VkImage               srcImage,
    VkImageLayout         srcImageLayout,
    VkImage               dstImage,
    VkImageLayout         dstImageLayout,
    u32                   regionCount,
    const VkImageResolve* pRegions) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(srcImage in Images) { vkErrorInvalidImage(srcImage) }
  if !(dstImage in Images) { vkErrorInvalidImage(dstImage) }
  args := new!vkCmdResolveImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.ResolveRegions[as!u32(i)] = regions[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdResolveImage))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdResolveImage[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdResolveImage, mapPos)
}

@internal class vkCmdSetEventArgs {
  VkEvent              Event
  VkPipelineStageFlags StageMask
}

sub void dovkCmdSetEvent(ref!vkCmdSetEventArgs event) {
  Events[event.Event].Signaled = true
  Events[event.Event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(event in Events) { vkErrorInvalidEvent(event) }
  args := new!vkCmdSetEventArgs(
    Event:      event,
    StageMask:  stageMask
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetEvent))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetEvent[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetEvent, mapPos)
}

@internal class vkCmdResetEventArgs {
  VkEvent              Event
  VkPipelineStageFlags StageMask
}

sub void dovkCmdResetEvent(ref!vkCmdResetEventArgs event) {
  Events[event.Event].Signaled = false
  Events[event.Event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(event in Events) { vkErrorInvalidEvent(event) }
  args := new!vkCmdResetEventArgs(
    Event:      event,
    StageMask:  stageMask,
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdResetEvent))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdResetEvent[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdResetEvent, mapPos)
}

@internal class vkCmdWaitEventsArgs {
  map!(u32, VkEvent)               Events
  VkPipelineStageFlags             SrcStageMask
  VkPipelineStageFlags             DstStageMask
  map!(u32, VkMemoryBarrier)       MemoryBarriers
  map!(u32, VkBufferMemoryBarrier) BufferMemoryBarriers
  map!(u32, VkImageMemoryBarrier)  ImageMemoryBarriers
}


sub void dovkCmdWaitEvents(ref!vkCmdWaitEventsArgs args) {
  for _ , _ , e in args.Events {
    if !(e in Events) { vkErrorInvalidEvent(e) }
    event := Events[e]
    event.SubmitQueue = LastBoundQueue.VulkanHandle
    if event.Signaled != true {
      LastBoundQueue.PendingEvents[e] = event
    }
  }
  if len(LastBoundQueue.PendingEvents) == 0 {
    for _ , _ , b in args.ImageMemoryBarriers {
      if !(b.image in Images) { vkErrorInvalidImage(b.image) }
      image := Images[b.image]
      image.Info.Layout = b.newLayout
      image.LastBoundQueue = LastBoundQueue
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWaitEvents(
    VkCommandBuffer              commandBuffer,
    u32                          eventCount,
    const VkEvent*               pEvents,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdWaitEventsArgs(
    SrcStageMask:  srcStageMask,
    DstStageMask:  dstStageMask,
  )
  events := pEvents[0:eventCount]
  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. eventCount) {
    if !(events[i] in Events) { vkErrorInvalidEvent(events[i]) }
    args.Events[i] = events[i]
  }
  for i in (0 .. memoryBarrierCount) {
    args.MemoryBarriers[i] = memoryBarriers[i]
  }
  for i in (0 .. bufferMemoryBarrierCount) {
    args.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }
  for i in (0 .. imageMemoryBarrierCount) {
    args.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdWaitEvents))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdWaitEvents[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdWaitEvents, mapPos)
}

@internal class vkCmdPipelineBarrierArgs {
  VkPipelineStageFlags             SrcStageMask        ,
  VkPipelineStageFlags             DstStageMask        ,
  VkDependencyFlags                DependencyFlags     ,
  map!(u32, VkMemoryBarrier)       MemoryBarriers      ,
  map!(u32, VkBufferMemoryBarrier) BufferMemoryBarriers,
  map!(u32, VkImageMemoryBarrier)  ImageMemoryBarriers
}

sub void dovkCmdPipelineBarrier(ref!vkCmdPipelineBarrierArgs args) {
  for _ , _ , v in args.ImageMemoryBarriers {
    if !(v.image in Images) { vkErrorInvalidImage(v.image) }
    image := Images[v.image]
    image.Info.Layout = v.newLayout
    image.LastBoundQueue = LastBoundQueue
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPipelineBarrier(
    VkCommandBuffer              commandBuffer,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    VkDependencyFlags            dependencyFlags,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdPipelineBarrierArgs(
    SrcStageMask:     srcStageMask,
    DstStageMask:     dstStageMask,
    DependencyFlags:  dependencyFlags
  )
  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  for i in (0 .. memoryBarrierCount) {
    args.MemoryBarriers[i] = memoryBarriers[i]
  }

  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  for i in (0 .. bufferMemoryBarrierCount) {
    args.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }

  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. imageMemoryBarrierCount) {
    args.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdPipelineBarrier))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdPipelineBarrier[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdPipelineBarrier, mapPos)
}

@internal class vkCmdBeginQueryArgs {
  VkQueryPool         QueryPool
  u32                 Query
  VkQueryControlFlags Flags
}

sub void dovkCmdBeginQuery(ref!vkCmdBeginQueryArgs args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_ACTIVE
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginQuery(
    VkCommandBuffer     commandBuffer,
    VkQueryPool         queryPool,
    u32                 query,
    VkQueryControlFlags flags) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  args := new!vkCmdBeginQueryArgs(
    queryPool,          query, flags
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBeginQuery))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBeginQuery[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBeginQuery, mapPos)
}

@internal class
vkCmdEndQueryArgs {
  VkQueryPool QueryPool
  u32         Query
}

sub void dovkCmdEndQuery(ref!vkCmdEndQueryArgs args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_COMPLETE
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             query) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  args := new!vkCmdEndQueryArgs(
    queryPool,        query
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdEndQuery))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdEndQuery[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdEndQuery, mapPos)
}

@internal class
vkCmdResetQueryPoolArgs {
  VkQueryPool QueryPool
  u32         FirstQuery
  u32         QueryCount
}

sub void dovkCmdResetQueryPool(ref!vkCmdResetQueryPoolArgs args) {
  pool := QueryPools[args.QueryPool]
  for i in (0 .. args.QueryCount) {
    pool.Status[args.FirstQuery + i] = QUERY_STATUS_INACTIVE
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             firstQuery,
    u32             queryCount) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  args := new!vkCmdResetQueryPoolArgs(
    queryPool,              firstQuery, queryCount
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdResetQueryPool))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdResetQueryPool[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdResetQueryPool, mapPos)
}

@internal class vkCmdWriteTimestampArgs {
  VkPipelineStageFlagBits PipelineStage,
  VkQueryPool             QueryPool    ,
  u32                     Query
}

sub void dovkCmdWriteTimestamp(ref!vkCmdWriteTimestampArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWriteTimestamp(
    VkCommandBuffer         commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool             queryPool,
    u32                     query) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  args := new!vkCmdWriteTimestampArgs(
    pipelineStage,          queryPool, query
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdWriteTimestamp))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdWriteTimestamp[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdWriteTimestamp, mapPos)
}

@internal
class vkCmdCopyQueryPoolResultsArgs {
  VkQueryPool        QueryPool
  u32                FirstQuery
  u32                QueryCount
  VkBuffer           DstBuffer
  VkDeviceSize       DstOffset
  VkDeviceSize       Stride
  VkQueryResultFlags Flags
}

sub void dovkCmdCopyQueryPoolResults(ref!vkCmdCopyQueryPoolResultsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyQueryPoolResults(
    VkCommandBuffer    commandBuffer,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    VkBuffer           dstBuffer,
    VkDeviceSize       dstOffset,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if !(queryPool in QueryPools) { vkErrorInvalidQueryPool(queryPool) }
  if !(dstBuffer in Buffers) { vkErrorInvalidBuffer(dstBuffer) }
  args := new!vkCmdCopyQueryPoolResultsArgs(
    QueryPool:   queryPool,
    FirstQuery:  firstQuery,
    QueryCount:  queryCount,
    DstBuffer:   dstBuffer,
    DstOffset:   dstOffset,
    Stride:      stride,
    Flags:       flags
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyQueryPoolResults))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdCopyQueryPoolResults[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdCopyQueryPoolResults, mapPos)
}

@internal class
vkCmdPushConstantsArgs {
  VkPipelineLayout   Layout
  VkShaderStageFlags StageFlags
  u32                Offset
  u32                Size
  u8[]               Data
}

sub void dovkCmdPushConstants(ref!vkCmdPushConstantsArgs args) {
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPushConstants(
    VkCommandBuffer    commandBuffer,
    VkPipelineLayout   layout,
    VkShaderStageFlags stageFlags,
    u32                offset,
    u32                size,
    const void*        pValues) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdPushConstantsArgs(
    layout,                stageFlags, offset, size, clone(as!u8*(pValues)[0:size])
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdPushConstants))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdPushConstants[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdPushConstants, mapPos)
}

@internal class
vkCmdBeginRenderPassArgs {
  VkSubpassContents       Contents
  VkRenderPass            RenderPass
  VkFramebuffer           Framebuffer
  VkRect2D                RenderArea
  map!(u32, VkClearValue) ClearValues
}

sub void dovkCmdBeginRenderPass(ref!vkCmdBeginRenderPassArgs args) {
  VK_ATTACHMENT_UNUSED := as!u32(0xFFFFFFFF)
  lastDrawInfo().Framebuffer = Framebuffers[args.Framebuffer]
  lastDrawInfo().LastSubpass = 0
  lastDrawInfo().RenderPass = RenderPasses[args.RenderPass]
  lastDrawInfo().InRenderPass = true
  for _ , _ , v in lastDrawInfo().Framebuffer.ImageAttachments {
    v.Image.LastBoundQueue = LastBoundQueue
  }
  subpass := lastDrawInfo().RenderPass.SubpassDescriptions[0]
  for _ , _ , a in subpass.InputAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  for _ , _ , a in subpass.ColorAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  for _ , _ , a in subpass.ResolveAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  if subpass.DepthStencilAttachment != null {
    dsRef := subpass.DepthStencilAttachment
    if dsRef.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[dsRef.Attachment].Image.Info.Layout = dsRef.Layout
    }
  }

  pushRenderPassMarker(args.RenderPass)
}


@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginRenderPass(
    VkCommandBuffer              commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents            contents) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pRenderPassBegin == null { vkErrorNullPointer("VkRenderPassBeginInfo") }
  begin_info := pRenderPassBegin[0]
  if !(begin_info.renderPass in RenderPasses) { vkErrorInvalidRenderPass(begin_info.renderPass) }
  if !(begin_info.framebuffer in Framebuffers) { vkErrorInvalidFramebuffer(begin_info.framebuffer) }
  args := new!vkCmdBeginRenderPassArgs(
    Contents:     contents,
    RenderPass:   begin_info.renderPass,
    Framebuffer:  begin_info.framebuffer,
    RenderArea:   begin_info.renderArea
  )
  clear_values := begin_info.pClearValues[0:begin_info.clearValueCount]
  for i in (0 .. begin_info.clearValueCount) {
    args.ClearValues[i] = clear_values[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBeginRenderPass))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBeginRenderPass[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdBeginRenderPass, mapPos)
}

@internal class
vkCmdNextSubpassArgs {
  VkSubpassContents Contents
}

sub void dovkCmdNextSubpass(ref!vkCmdNextSubpassArgs Unused) {
  lastDrawInfo().LastSubpass += 1
  if lastDrawInfo().LastSubpass < len(lastDrawInfo().RenderPass.SubpassDescriptions) {
    subpass := lastDrawInfo().RenderPass.SubpassDescriptions[lastDrawInfo().LastSubpass]
    for _ , _ , a in subpass.InputAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    for _ , _ , a in subpass.ColorAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    for _ , _ , a in subpass.ResolveAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    if subpass.DepthStencilAttachment != null {
      dsRef := subpass.DepthStencilAttachment
      lastDrawInfo().Framebuffer.ImageAttachments[dsRef.Attachment].Image.Info.Layout = dsRef.Layout
    }
  }
  popAndPushMarkerForNextSubpass(lastDrawInfo().LastSubpass)
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdNextSubpass(
    VkCommandBuffer   commandBuffer,
    VkSubpassContents contents) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdNextSubpassArgs(contents)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdNextSubpass))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdNextSubpass[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdNextSubpass, mapPos)
}

@internal class
vkCmdEndRenderPassArgs {
}

sub void dovkCmdEndRenderPass(ref!vkCmdEndRenderPassArgs unused) {
  for _ , i , a in lastDrawInfo().RenderPass.AttachmentDescriptions {
    lastDrawInfo().Framebuffer.ImageAttachments[i].Image.Info.Layout = a.finalLayout
  }
  lastDrawInfo().InRenderPass = false
  popRenderPassMarker()
  if (len(lastDrawInfo().RenderPass.SubpassDescriptions) > 1) {
    popRenderPassMarker()
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdEndRenderPassArgs()

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdEndRenderPass))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdEndRenderPass[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdEndRenderPass, mapPos)
}

@internal
class vkCmdExecuteCommandsArgs {
  map!(u32, VkCommandBuffer) CommandBuffers
}

sub void dovkCmdExecuteCommands(ref!vkCmdExecuteCommandsArgs cmds) {
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdExecuteCommands(
    VkCommandBuffer        commandBuffer,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  cmd_buffers := pCommandBuffers[0:commandBufferCount]
  args := new!vkCmdExecuteCommandsArgs()
  for i in (0 .. commandBufferCount) {
    if !(cmd_buffers[i] in CommandBuffers) { vkErrorInvalidCommandBuffer(cmd_buffers[i]) }
    args.CommandBuffers[as!u32(i)] = cmd_buffers[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdExecuteCommands))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdExecuteCommands[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdExecuteCommands, mapPos)
}

// ----------------------------------------------------------------------------
// VK_KHR_surface
// ----------------------------------------------------------------------------

@extension("VK_KHR_surface")
enum VkColorSpaceKHR {
  VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0x00000000,
}

@extension("VK_KHR_surface")
enum VkPresentModeKHR {
  VK_PRESENT_MODE_IMMEDIATE_KHR    = 0x00000000,
  VK_PRESENT_MODE_MAILBOX_KHR      = 0x00000001,
  VK_PRESENT_MODE_FIFO_KHR         = 0x00000002,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 0x00000003,
}

@extension("VK_KHR_surface")
bitfield VkSurfaceTransformFlagBitsKHR {
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     = 0x00000001,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    = 0x00000002,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   = 0x00000004,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   = 0x00000008,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            = 0x00000010,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  = 0x00000020,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                      = 0x00000100,
}
@extension("VK_KHR_surface")
type VkFlags VkSurfaceTransformFlagsKHR

@extension("VK_KHR_surface")
bitfield VkCompositeAlphaFlagBitsKHR {
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          = 0x00000001,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  = 0x00000002,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         = 0x00000008,
}

@extension("VK_KHR_surface")
type VkFlags VkCompositeAlphaFlagsKHR

@extension("VK_KHR_surface")
class VkSurfaceCapabilitiesKHR {
  u32                           minImageCount
  u32                           maxImageCount
  VkExtent2D                    currentExtent
  VkExtent2D                    minImageExtent
  VkExtent2D                    maxImageExtent
  u32                           maxImageArrayLayers
  VkSurfaceTransformFlagsKHR    supportedTransforms
  VkSurfaceTransformFlagBitsKHR currentTransform
  VkCompositeAlphaFlagsKHR      supportedCompositeAlpha
  VkImageUsageFlags             supportedUsageFlags
}

@extension("VK_KHR_surface")
class VkSurfaceFormatKHR {
  VkFormat        format
  VkColorSpaceKHR colorSpace
}

@extension("VK_KHR_surface")
@indirect("VkInstance")
cmd void vkDestroySurfaceKHR(
    VkInstance                   instance,
    VkSurfaceKHR                 surface,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
  delete(Surfaces, surface)
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    u32              queueFamilyIndex,
    VkSurfaceKHR     surface,
    VkBool32*        pSupported) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pSupported == null { vkErrorNullPointer("VkBool32") }
  pSupported[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice          physicalDevice,
    VkSurfaceKHR              surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if !(surface in Surfaces) { vkErrorInvalidSurface(surface) }
  if pSurfaceCapabilities == null { vkErrorNullPointer("VkSurfaceCapabilitiesKHR") }
  pSurfaceCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice    physicalDevice,
    VkSurfaceKHR        surface,
    u32*                pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if !(surface in Surfaces) { vkErrorInvalidSurface(surface) }
  if pSurfaceFormatCount == null { vkErrorNullPointer("uint32_t") }
  _ = pSurfaceFormatCount[0]

  if pSurfaceFormats == null {
    pSurfaceFormatCount[0] = ?
  } else {
    count := as!u32(?)
    formats := pSurfaceFormats[0:count]
    for i in (0 .. count) {
      formats[i] = ?
    }
    pSurfaceFormatCount[0] = count
  }

  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice  physicalDevice,
    VkSurfaceKHR      surface,
    u32*              pPresentModeCount,
    VkPresentModeKHR* pPresentModes) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if !(surface in Surfaces) { vkErrorInvalidSurface(surface) }
  if pPresentModeCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPresentModeCount[0]

  if pPresentModes == null {
    pPresentModeCount[0] = ?
  } else {
    count := as!u32(?)
    modes := pPresentModes[0:count]
    for i in (0 .. count) {
      modes[i] = ?
    }
    pPresentModeCount[0] = count
  }

  return ?
}


// ----------------------------------------------------------------------------
// VK_KHR_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_swapchain")
@reserved_flags
type VkFlags VkSwapchainCreateFlagsKHR

@extension("VK_KHR_swapchain")
class VkSwapchainCreateInfoKHR {
  VkStructureType               sType
  const void*                   pNext
  VkSwapchainCreateFlagsKHR     flags
  VkSurfaceKHR                  surface
  u32                           minImageCount
  VkFormat                      imageFormat
  VkColorSpaceKHR               imageColorSpace
  VkExtent2D                    imageExtent
  u32                           imageArrayLayers
  VkImageUsageFlags             imageUsage
  VkSharingMode                 imageSharingMode
  u32                           queueFamilyIndexCount
  const u32*                    pQueueFamilyIndices
  VkSurfaceTransformFlagBitsKHR preTransform
  VkCompositeAlphaFlagBitsKHR   compositeAlpha
  VkPresentModeKHR              presentMode
  VkBool32                      clipped
  VkSwapchainKHR                oldSwapchain
}

@extension("VK_KHR_swapchain")
class VkPresentInfoKHR {
  VkStructureType       sType
  const void*           pNext
  u32                   waitSemaphoreCount
  const VkSemaphore*    pWaitSemaphores
  u32                   swapchainCount
  const VkSwapchainKHR* pSwapchains
  const u32*            pImageIndices
  VkResult*             pResults
}

@custom
@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@override
cmd VkResult vkCreateSwapchainKHR(
    VkDevice                        device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchain) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkSwapchainCreateInfoKHR") }
  create_info := pCreateInfo[0]
  queueFamilyIndices := create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount]
  // TODO: pAllocator

  swapchainObject := new!SwapchainObject(Device: device,
    Info:                   ImageInfo(
      ImageType:    VK_IMAGE_TYPE_2D,
      Format:       create_info.imageFormat,
      Extent:       VkExtent3D(create_info.imageExtent.Width, create_info.imageExtent.Height, 1),
      MipLevels:    1,
      ArrayLayers:  create_info.imageArrayLayers,
      Samples:      VK_SAMPLE_COUNT_1_BIT,
      Tiling:       VK_IMAGE_TILING_OPTIMAL,
      Usage:        create_info.imageUsage,
      SharingMode:  create_info.imageSharingMode,
      Layout:       VK_IMAGE_LAYOUT_UNDEFINED
    ),
    Surface:         Surfaces[create_info.surface],
    ColorSpace:      create_info.imageColorSpace,
    PreTransform:    create_info.preTransform,
    CompositeAlpha:  create_info.compositeAlpha,
    PresentMode:     create_info.presentMode,
    Clipped:         create_info.clipped
  )

  for i in (0 .. create_info.queueFamilyIndexCount) {
    swapchainObject.Info.QueueFamilyIndices[i] =
    queueFamilyIndices[i]
  }

  handle := ?
  if pSwapchain == null { vkErrorNullPointer("VkSwapchain") }
  pSwapchain[0] = handle
  swapchainObject.VulkanHandle = handle
  Swapchains[handle] = swapchainObject

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd void vkDestroySwapchainKHR(
    VkDevice                     device,
    VkSwapchainKHR               swapchain,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  swapObject := Swapchains[swapchain]
  if swapObject != null {
    for _ , _ , v in swapObject.SwapchainImages {
      delete(Images, v.VulkanHandle)
    }
    delete(Swapchains, swapchain)
  }
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd VkResult vkGetSwapchainImagesKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u32*           pSwapchainImageCount,
    VkImage*       pSwapchainImages) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(swapchain in Swapchains) { vkErrorInvalidSwapchain(swapchain) }

  swapchainObject := Swapchains[swapchain]
  // Need to do a read observation of the image count as the number of images
  // requested from users might be different from the number offered by the
  // swapchain. Besides, the virtual swapchain creates swapchain images
  // depends on this number.
  if pSwapchainImages != null {
    _ = pSwapchainImageCount[0]
  }
  fence
  if pSwapchainImages == null {
    pSwapchainImageCount[0] = ?
  } else {
    count := pSwapchainImageCount[0]
    images := pSwapchainImages[0:count]
    for i in (0 .. count) {
      images[i] = ?
      if !(images[i] in Images) {
        object := new!ImageObject(BoundMemory:  null,
          Device:             device,
          VulkanHandle:       images[i],
          BoundMemoryOffset:  0,
          Info:               swapchainObject.Info,
          ImageAspect:        as!VkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT)
        )
        object.IsSwapchainImage = true
        width := swapchainObject.Info.Extent.Width
        height := swapchainObject.Info.Extent.Height
        format := swapchainObject.Info.Format
        layer := new!ImageLayer()
        level := new!ImageLevel(Width: width,Height:  height,Depth:  1)
        elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
        // Roundup the width and height in the number of blocks.
        widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
        heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
        size := widthInBlocks * heightInBlocks * elementAndTexelBlockSize.ElementSize
        level.Data = make!u8(size)
        object.Layers[0] = layer
        object.Layers[0].Levels[0] = level
        Images[images[i]] = object
      }
      swapchainObject.SwapchainImages[i] = Images[images[i]]
    }
    pSwapchainImageCount[0] = count
  }

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@custom
@blocking
cmd VkResult vkAcquireNextImageKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u64            timeout,
    VkSemaphore    semaphore,
    VkFence        fence,
    u32*           pImageIndex) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(swapchain in Swapchains) { vkErrorInvalidSwapchain(swapchain) }
  if pImageIndex == null { vkErrorNullPointer("uint32_t") }
  _ = pImageIndex[0]
  pImageIndex[0] = ?
  if (semaphore != as!VkSemaphore(0)) {
    Semaphores[semaphore].Signaled = true
  }
  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkQueue", "VkDevice")
@frame_end
cmd VkResult vkQueuePresentKHR(
    VkQueue                 queue,
    const VkPresentInfoKHR* pPresentInfo) {
  if !(queue in Queues) { vkErrorInvalidQueue(queue) }
  LastSubmission = PRESENT
  LastBoundQueue = Queues[queue]
  for i in (0 .. LastPresentInfo.PresentImageCount) {
    delete(LastPresentInfo.PresentImages, i)
  }
  LastPresentInfo.PresentImageCount = 0


  info := pPresentInfo[0]
  // TODO: handle pNext

  if (info.pWaitSemaphores != null) {
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for i in (0 .. info.waitSemaphoreCount) {
      Semaphores[wait_semaphores[i]].Signaled = false
    }
  }
  swapchains := info.pSwapchains[0:info.swapchainCount]
  imageIndices := info.pImageIndices[0:info.swapchainCount]
  for i in (0 .. info.swapchainCount) {
    if !(swapchains[i] in Swapchains) { vkErrorInvalidSwapchain(swapchains[i]) }
    swapchain := Swapchains[swapchains[i]]
    image := swapchain.SwapchainImages[imageIndices[i]]
    LastPresentInfo.PresentImages[LastPresentInfo.PresentImageCount] =
    image
    LastPresentInfo.PresentImageCount = LastPresentInfo.PresentImageCount + 1
    image.LastBoundQueue = Queues[queue]
  }
  fence
  if (info.pResults != null) {
    // TODO(qining): Remove the use of fence once the inference can be done
    // correctly for arrays specified as struct members.
    read(info.pResults[0:info.swapchainCount])
    /*results := info.pResults[0:info.swapchainCount]
        for i in (0 .. info.swapchainCount) {
            result := as!VkResult(?)
            results[i] = result
        }*/
  }
  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display
// ----------------------------------------------------------------------------

@extension("VK_KHR_display")
bitfield VkDisplayPlaneAlphaFlagBitsKHR {
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  = 0x00000001,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  = 0x00000002,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               = 0x00000004,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
}
@extension("VK_KHR_display")
type VkFlags VkDisplayPlaneAlphaFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplayModeCreateFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplaySurfaceCreateFlagsKHR

@extension("VK_KHR_display")
class VkDisplayPropertiesKHR {
  VkDisplayKHR               display
  char*                      displayName
  VkExtent2D                 physicalDimensions
  VkExtent2D                 physicalResolution
  VkSurfaceTransformFlagsKHR supportedTransforms
  VkBool32                   planeReorderPossible
  VkBool32                   persistentContent
}

@extension("VK_KHR_display")
class VkDisplayModeParametersKHR {
  VkExtent2D visibleRegion
  u32        refreshRate
}

@extension("VK_KHR_display")
class VkDisplayModePropertiesKHR {
  VkDisplayModeKHR           displayMode
  VkDisplayModeParametersKHR parameters
}

@extension("VK_KHR_display")
class VkDisplayModeCreateInfoKHR {
  VkStructureType             sType
  const void*                 pNext
  VkDisplayModeCreateFlagsKHR flags
  VkDisplayModeParametersKHR  parameters
}

@extension("VK_KHR_display")
class VkDisplayPlaneCapabilitiesKHR {
  VkDisplayPlaneAlphaFlagsKHR supportedAlpha
  VkOffset2D                  minSrcPosition
  VkOffset2D                  maxSrcPosition
  VkExtent2D                  minSrcExtent
  VkExtent2D                  maxSrcExtent
  VkOffset2D                  minDstPosition
  VkOffset2D                  maxDstPosition
  VkExtent2D                  minDstExtent
  VkExtent2D                  maxDstExtent
}

@extension("VK_KHR_display")
class VkDisplayPlanePropertiesKHR {
  VkDisplayKHR currentDisplay
  u32          currentStackIndex
}

@extension("VK_KHR_display")
class VkDisplaySurfaceCreateInfoKHR {
  VkStructureType                sType
  const void*                    pNext
  VkDisplaySurfaceCreateFlagsKHR flags
  VkDisplayModeKHR               displayMode
  u32                            planeIndex
  u32                            planeStackIndex
  VkSurfaceTransformFlagBitsKHR  transform
  f32                            globalAlpha
  VkDisplayPlaneAlphaFlagBitsKHR alphaMode
  VkExtent2D                     imageExtent
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice        physicalDevice,
    u32*                    pPropertyCount,
    VkDisplayPropertiesKHR* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: also need to observe VkDisplayPropertiesKHR.displayName
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice             physicalDevice,
    u32*                         pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    u32              planeIndex,
    u32*             pDisplayCount,
    VkDisplayKHR*    pDisplays) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pDisplayCount == null { vkErrorNullPointer("uint32_t") }
  _ = pDisplayCount[0]

  if pDisplays == null {
    pDisplayCount[0] = ?
  } else {
    count := as!u32(?)
    displays := pDisplays[0:count]
    for i in (0 .. count) {
      displays[i] = ?
    }
    pDisplayCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice            physicalDevice,
    VkDisplayKHR                display,
    u32*                        pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice                  physicalDevice,
    VkDisplayKHR                      display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDisplayModeKHR*                 pMode) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pCreateInfo == null { vkErrorNullPointer("VkDisplayModeCreateInfo") }
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  if pMode == null { vkErrorNullPointer("VkDisplayModeKHR") }
  pMode[0] = handle
  modeObject := new!DisplayModeObject(PhysicalDevice: physicalDevice,
    Display:                          display,
    VulkanHandle:                     handle)
  DisplayModes[handle] = modeObject

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice               physicalDevice,
    VkDisplayModeKHR               mode,
    u32                            planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if !(mode in DisplayModes) { vkErrorInvalidDisplayMode(mode) }
  if pCapabilities == null { vkErrorNullPointer("VkDisplayPlaneCapabilitiesKHR") }
  pCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_display")
@indirect("VkInstance")
cmd VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                           instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*         pAllocator,
    VkSurfaceKHR*                        pSurface) {
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
  if pCreateInfo == null { vkErrorNullPointer("VkDisplaySurfaceCreateInfoKHR") }
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  if pSurface == null { vkErrorNullPointer("VkSurfaceKHR") }
  pSurface[0] = handle
  surfaceObject := new!SurfaceObject(Instance: instance,
    VulkanHandle:           handle)
  Surfaces[handle] = surfaceObject

  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_display_swapchain")
class VkDisplayPresentInfoKHR {
  VkStructureType sType
  const void*     pNext
  VkRect2D        srcRect
  VkRect2D        dstRect
  VkBool32        persistent
}

@extension("VK_KHR_display_swapchain")
@indirect("VkDevice")
cmd VkResult vkCreateSharedSwapchainsKHR(
    VkDevice                        device,
    u32                             swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchains) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  create_infos := pCreateInfos[0:swapchainCount]
  fence
  if pSwapchains == null { vkErrorNullPointer("VkSwapchainKHR") }
  swapchains := pSwapchains[0:swapchainCount]
  for i in (0 .. swapchainCount) {
    create_info := create_infos[i]
    queueFamilyIndices := create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount]
    // TODO: pAllocator

    swapchainObject := new!SwapchainObject(Device: device,
      Info:                 ImageInfo(
        ImageType:    VK_IMAGE_TYPE_2D,
        Format:       create_info.imageFormat,
        Extent:       VkExtent3D(create_info.imageExtent.Width, create_info.imageExtent.Height, 1),
        MipLevels:    1,
        ArrayLayers:  create_info.imageArrayLayers,
        Samples:      VK_SAMPLE_COUNT_1_BIT,
        Tiling:       VK_IMAGE_TILING_OPTIMAL,
        Usage:        create_info.imageUsage,
        SharingMode:  create_info.imageSharingMode,
        Layout:       VK_IMAGE_LAYOUT_UNDEFINED
      ),
      Surface:         Surfaces[create_info.surface],
      ColorSpace:      create_info.imageColorSpace,
      PreTransform:    create_info.preTransform,
      CompositeAlpha:  create_info.compositeAlpha,
      PresentMode:     create_info.presentMode,
      Clipped:         create_info.clipped
    )

    for j in (0 .. create_info.queueFamilyIndexCount) {
      swapchainObject.Info.QueueFamilyIndices[j] =
      queueFamilyIndices[j]
    }

    handle := ?
    swapchains[i] = handle
    swapchainObject.VulkanHandle = handle
    Swapchains[handle] = swapchainObject
  }
  return ?
}

// ----------------------------------------------------------------------------
// VK_EXT_debug_report
// ----------------------------------------------------------------------------

@extension("VK_EXT_debug_report")
enum VkDebugReportObjectTypeEXT {
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT               = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT              = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT       = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                 = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT             = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT        = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                 = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT         = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                 = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                 = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT            = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT           = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT            = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT         = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT        = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT       = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT           = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT              = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT               = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT       = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT        = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT           = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT          = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT           = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT         = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT          = 28,
}

@extension("VK_EXT_debug_report")
@unused
enum VkDebugReportErrorEXT {
  VK_DEBUG_REPORT_ERROR_NONE_EXT         = 0,
  VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
}

@extension("VK_EXT_debug_report")
@unused
bitfield VkDebugReportFlagBitsEXT {
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT         = 0x00000001,
  VK_DEBUG_REPORT_WARNING_BIT_EXT             = 0x00000002,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
  VK_DEBUG_REPORT_ERROR_BIT_EXT               = 0x00000008,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT               = 0x00000010,
}
@extension("VK_EXT_debug_report")
type VkFlags VkDebugReportFlagsEXT

@extension("VK_EXT_debug_report")
@external type void* PFN_vkDebugReportCallbackEXT

@extension("VK_EXT_debug_report")
@pfn cmd VkBool32 vkDebugReportCallbackEXT(
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    const char*                pLayerPrefix,
    const char*                pMessage,
    void*                      pUserData) {

  _ = as!string(pLayerPrefix)
  _ = as!string(pMessage)
  return ?
}

@extension("VK_EXT_debug_report")
class VkDebugReportCallbackCreateInfoEXT {
  VkStructureType              sType
  const void*                  pNext
  VkDebugReportFlagsEXT        flags
  PFN_vkDebugReportCallbackEXT pfnCallback
  void*                        pUserData
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
@no_replay
cmd VkResult vkCreateDebugReportCallbackEXT(
    VkInstance                                instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks*              pAllocator,
    VkDebugReportCallbackEXT*                 pCallback) {
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
  return ?
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
@no_replay
cmd void vkDestroyDebugReportCallbackEXT(
    VkInstance                   instance,
    VkDebugReportCallbackEXT     callback,
    const VkAllocationCallbacks* pAllocator) {
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
@no_replay
cmd void vkDebugReportMessageEXT(
    VkInstance                 instance,
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    const char*                pLayerPrefix,
    const char*                pMessage) {

  _ = as!string(pLayerPrefix)
  _ = as!string(pMessage)
  if !(instance in Instances) { vkErrorInvalidInstance(instance) }
}
extern void validate(string layerName, bool condition, string message)

// ----------------------------------------------------------------------------
// VK_EXT_debug_marker
// ----------------------------------------------------------------------------
@extension("VK_EXT_debug_marker")
class VkDebugMarkerObjectNameInfoEXT {
  VkStructureType            sType
  const void*                pNext
  VkDebugReportObjectTypeEXT objectType
  u64                        object
  const char*                pObjectName
}

@extension("VK_EXT_debug_marker")
class VkDebugMarkerObjectTagInfoEXT {
  VkStructureType            sType
  const void*                pNext
  VkDebugReportObjectTypeEXT objectType
  u64                        object
  u64                        tagName
  size                       tagSize
  const void*                pTag
}

@extension("VK_EXT_debug_marker")
class VkDebugMarkerMarkerInfoEXT {
  VkStructureType  sType
  const void*      pNext
  const char*      pMarkerName
  @readonly f32[4] color
}

sub ref!VulkanDebugMarkerInfo updateDebugMarkerObjectName(
    ref!VulkanDebugMarkerInfo      origInfo,
    VkDebugMarkerObjectNameInfoEXT nameInfo) {
  newInfo := switch (origInfo == null) {
    case true:
      new!VulkanDebugMarkerInfo()
    case false:
      origInfo
  }
  newInfo.ObjectName = as!string(nameInfo.pObjectName)
  return newInfo
}

sub ref!VulkanDebugMarkerInfo updateDebugMarkerObjectTag(
    ref!VulkanDebugMarkerInfo     origInfo,
    VkDebugMarkerObjectTagInfoEXT tagInfo) {
  newInfo := switch (origInfo == null) {
    case true:
      new!VulkanDebugMarkerInfo()
    case false:
      origInfo
  }
  newInfo.TagName = tagInfo.tagName
  newInfo.Tag = clone(as!u8*(tagInfo.pTag)[0:tagInfo.tagSize])
  return newInfo
}

sub void setDebugMarkerObjectTag(VkDebugMarkerObjectTagInfoEXT tagInfo) {
  objTy := tagInfo.objectType
  obj := tagInfo.object
  switch objTy {
    case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
      Instances[as!VkInstance(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Instances[as!VkInstance(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
      PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo = updateDebugMarkerObjectTag(
        PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
      Devices[as!VkDevice(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Devices[as!VkDevice(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
      Queues[as!VkQueue(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Queues[as!VkQueue(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
      Semaphores[as!VkSemaphore(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Semaphores[as!VkSemaphore(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
      CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
        CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
      Fences[as!VkFence(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Fences[as!VkFence(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
      DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
      Buffers[as!VkBuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Buffers[as!VkBuffer(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
      Images[as!VkImage(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Images[as!VkImage(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
      Events[as!VkEvent(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Events[as!VkEvent(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
      QueryPools[as!VkQueryPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
        QueryPools[as!VkQueryPool(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
      BufferViews[as!VkBufferView(obj)].DebugInfo = updateDebugMarkerObjectTag(
        BufferViews[as!VkBufferView(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
      ImageViews[as!VkImageView(obj)].DebugInfo = updateDebugMarkerObjectTag(
        ImageViews[as!VkImageView(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
      ShaderModules[as!VkShaderModule(obj)].DebugInfo = updateDebugMarkerObjectTag(
        ShaderModules[as!VkShaderModule(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
      PipelineCaches[as!VkPipelineCache(obj)].DebugInfo = updateDebugMarkerObjectTag(
        PipelineCaches[as!VkPipelineCache(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
      PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo = updateDebugMarkerObjectTag(
        PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
      RenderPasses[as!VkRenderPass(obj)].DebugInfo = updateDebugMarkerObjectTag(
        RenderPasses[as!VkRenderPass(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
      if (as!VkPipeline(obj) in GraphicsPipelines) {
        GraphicsPipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectTag(
          GraphicsPipelines[as!VkPipeline(obj)].DebugInfo, tagInfo)
      } else if (as!VkPipeline(obj) in ComputePipelines) {
          ComputePipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectTag(
            ComputePipelines[as!VkPipeline(obj)].DebugInfo, tagInfo)
        }
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
      DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
      Samplers[as!VkSampler(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Samplers[as!VkSampler(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
      DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
      DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
      Framebuffers[as!VkFramebuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Framebuffers[as!VkFramebuffer(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
      CommandPools[as!VkCommandPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
        CommandPools[as!VkCommandPool(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
      Surfaces[as!VkSurfaceKHR(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Surfaces[as!VkSurfaceKHR(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
      Swapchains[as!VkSwapchainKHR(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Swapchains[as!VkSwapchainKHR(obj)].DebugInfo, tagInfo)
  }
}

sub void setDebugMarkerObjectName(VkDebugMarkerObjectNameInfoEXT nameInfo) {
  objTy := nameInfo.objectType
  obj := nameInfo.object
  switch objTy {
    case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
      Instances[as!VkInstance(obj)].DebugInfo = updateDebugMarkerObjectName(
        Instances[as!VkInstance(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
      PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo = updateDebugMarkerObjectName(
        PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
      Devices[as!VkDevice(obj)].DebugInfo = updateDebugMarkerObjectName(
        Devices[as!VkDevice(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
      Queues[as!VkQueue(obj)].DebugInfo = updateDebugMarkerObjectName(
        Queues[as!VkQueue(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
      Semaphores[as!VkSemaphore(obj)].DebugInfo = updateDebugMarkerObjectName(
        Semaphores[as!VkSemaphore(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
      CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
        CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
      Fences[as!VkFence(obj)].DebugInfo = updateDebugMarkerObjectName(
        Fences[as!VkFence(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
      DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo = updateDebugMarkerObjectName(
        DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
      Buffers[as!VkBuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
        Buffers[as!VkBuffer(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
      Images[as!VkImage(obj)].DebugInfo = updateDebugMarkerObjectName(
        Images[as!VkImage(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
      Events[as!VkEvent(obj)].DebugInfo = updateDebugMarkerObjectName(
        Events[as!VkEvent(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
      QueryPools[as!VkQueryPool(obj)].DebugInfo = updateDebugMarkerObjectName(
        QueryPools[as!VkQueryPool(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
      BufferViews[as!VkBufferView(obj)].DebugInfo = updateDebugMarkerObjectName(
        BufferViews[as!VkBufferView(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
      ImageViews[as!VkImageView(obj)].DebugInfo = updateDebugMarkerObjectName(
        ImageViews[as!VkImageView(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
      ShaderModules[as!VkShaderModule(obj)].DebugInfo = updateDebugMarkerObjectName(
        ShaderModules[as!VkShaderModule(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
      PipelineCaches[as!VkPipelineCache(obj)].DebugInfo = updateDebugMarkerObjectName(
        PipelineCaches[as!VkPipelineCache(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
      PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo = updateDebugMarkerObjectName(
        PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
      RenderPasses[as!VkRenderPass(obj)].DebugInfo = updateDebugMarkerObjectName(
        RenderPasses[as!VkRenderPass(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
      if (as!VkPipeline(obj) in GraphicsPipelines) {
        GraphicsPipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectName(
          GraphicsPipelines[as!VkPipeline(obj)].DebugInfo, nameInfo)
      } else if (as!VkPipeline(obj) in ComputePipelines) {
          ComputePipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectName(
            ComputePipelines[as!VkPipeline(obj)].DebugInfo, nameInfo)
        }
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
      DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
      Samplers[as!VkSampler(obj)].DebugInfo = updateDebugMarkerObjectName(
        Samplers[as!VkSampler(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
      DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
      DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
      Framebuffers[as!VkFramebuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
        Framebuffers[as!VkFramebuffer(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
      CommandPools[as!VkCommandPool(obj)].DebugInfo = updateDebugMarkerObjectName(
        CommandPools[as!VkCommandPool(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
      Surfaces[as!VkSurfaceKHR(obj)].DebugInfo = updateDebugMarkerObjectName(
        Surfaces[as!VkSurfaceKHR(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
      Swapchains[as!VkSwapchainKHR(obj)].DebugInfo = updateDebugMarkerObjectName(
        Swapchains[as!VkSwapchainKHR(obj)].DebugInfo, nameInfo)
  }
}

@threadSafety("app")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@indirect("VkDevice")
@override
@no_replay
cmd VkResult vkDebugMarkerSetObjectTagEXT(
    VkDevice                       device,
    VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  tagInfo := pTagInfo[0]
  setDebugMarkerObjectTag(tagInfo)
  return ?
}

@threadSafety("app")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@indirect("VkDevice")
@override
@no_replay
cmd VkResult vkDebugMarkerSetObjectNameEXT(
    VkDevice                        device,
    VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  nameInfo := pNameInfo[0]
  setDebugMarkerObjectName(nameInfo)
  return ?
}

@internal class
vkCmdDebugMarkerBeginEXTArgs {
  @unused string MarkerName,
  @unused f32[4] Color     ,
}

sub void dovkCmdDebugMarkerBeginEXT(ref!vkCmdDebugMarkerBeginEXTArgs args) {
  pushDebugMarker(args.MarkerName)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer             commandBuffer,
    VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  markerInfo := pMarkerInfo[0]
  args := new!vkCmdDebugMarkerBeginEXTArgs(
    MarkerName: as!string(markerInfo.pMarkerName),
  )
  args.Color[0] = markerInfo.color[0]
  args.Color[1] = markerInfo.color[1]
  args.Color[2] = markerInfo.color[2]
  args.Color[3] = markerInfo.color[3]

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerBeginEXT))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerBeginEXT[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDebugMarkerBeginEXT, mapPos)
}

@internal class
vkCmdDebugMarkerEndEXTArgs {}

sub void dovkCmdDebugMarkerEndEXT(ref!vkCmdDebugMarkerEndEXTArgs draw) {
  popDebugMarker()
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerEndEXT(
    VkCommandBuffer commandBuffer) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdDebugMarkerEndEXTArgs()

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerEndEXT))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerEndEXT[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDebugMarkerEndEXT, mapPos)
}

@internal class
vkCmdDebugMarkerInsertEXTArgs {
  @unused string MarkerName,
  @unused f32[4] Color     ,
}

sub void dovkCmdDebugMarkerInsertEXT(ref!vkCmdDebugMarkerInsertEXTArgs draw) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer             commandBuffer,
    VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  markerInfo := pMarkerInfo[0]
  args := new!vkCmdDebugMarkerInsertEXTArgs(
    MarkerName: as!string(markerInfo.pMarkerName),
  )
  args.Color[0] = markerInfo.color[0]
  args.Color[1] = markerInfo.color[1]
  args.Color[2] = markerInfo.color[2]
  args.Color[3] = markerInfo.color[3]

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerInsertEXT))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdDebugMarkerInsertEXT[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdDebugMarkerInsertEXT, mapPos)
}

/////////////////////////////
// Struct subroutines      //
/////////////////////////////

// Marks the fields that need to be observed in a VkApplicationInfo struct and returns the API version.
sub u32 readVkApplicationInfo(const VkApplicationInfo* applicationInfo) {
  info := applicationInfo[0]

  // TODO: handle pNext
  if (info.pApplicationName != null) {
    _ = as!string(info.pApplicationName)
  }
  if (info.pEngineName != null) {
    _ = as!string(info.pEngineName)
  }
  return info.apiVersion
}

@internal
class ExtensionSet {
  map!(string, bool) ExtensionNames
}

// Marks the fields that need to be observed in a VkInstanceCreateInfo struct and populates and returns an InstanceObject.
sub ref!InstanceObject createInstanceObject(const VkInstanceCreateInfo* createInfo) {
  object := new!InstanceObject()
  if createInfo == null { vkErrorNullPointer("VkInstanceCreateInfo") }
  info := createInfo[0]

  // TODO: handle pNext
  if (info.pApplicationInfo != null) {
    object.ApiVersion = readVkApplicationInfo(info.pApplicationInfo)
  } else {
    object.ApiVersion = 0
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    // We do not need to store off the list of enabled layers, since
    // a layer's presence should not affect any other calls in the API,
    // only an enabled extension that is provided by a layer.
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  // Recognized instance extensions
  supportedExtensions := new!ExtensionSet()
  supportedExtensions.ExtensionNames["VK_KHR_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_display"] = true
  supportedExtensions.ExtensionNames["VK_EXT_debug_report"] = true
  supportedExtensions.ExtensionNames["VK_KHR_xlib_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_xcb_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_wayland_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_mir_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_android_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_win32_surface"] = true
  supportedExtensions.ExtensionNames["VK_KHR_get_physical_device_properties2"] = true
  supportedExtensions.ExtensionNames["Vk_KHR_get_surface_capabilities2"] = true

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    ext := as!string(extensionNames[i])
    if !(ext in supportedExtensions.ExtensionNames) { vkErrorUnrecognizedExtension(extensionNames[i]) }
    object.EnabledExtensions[i] = ext
  }

  return object
}

// Marks the fields that need to be observed in a VkDeviceCreateInfo struct and populates and returns a DeviceObject.
sub ref!DeviceObject createDeviceObject(const VkDeviceCreateInfo* data) {
  object := new!DeviceObject()
  if data == null { vkErrorNullPointer("VkDeviceCreateInfo") }
  info := data[0]

  // TODO: pNext
  queueCreateInfos := info.pQueueCreateInfos[0:info.queueCreateInfoCount]
  for i in (0 .. info.queueCreateInfoCount) {
    queue_info := queueCreateInfos[i]
    queue_priorities := queue_info.pQueuePriorities[0:queue_info.queueCount]
    for j in (0 .. queue_info.queueCount) {
      object.Queues[len(object.Queues)] =
      QueueInfo(QueueFamilyIndex: queue_info.queueFamilyIndex,
        QueueIndex:               j,
        Priority:                 queue_priorities[j])
    }
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  // Recognized device extensions
  supportedExtensions := new!ExtensionSet()
  supportedExtensions.ExtensionNames["VK_KHR_swapchain"] = true
  supportedExtensions.ExtensionNames["VK_KHR_display_swapchain"] = true
  supportedExtensions.ExtensionNames["VK_EXT_debug_marker"] = true
  supportedExtensions.ExtensionNames["VK_KHR_ANDROID_native_buffer"] = true
  supportedExtensions.ExtensionNames["VK_NV_dedicated_allocation"] = true
  supportedExtensions.ExtensionNames["VK_KHR_get_memory_requirements2"] = true
  supportedExtensions.ExtensionNames["VK_KHR_dedicated_allocation"] = true

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    ext := as!string(extensionNames[i])
    if !(ext in supportedExtensions.ExtensionNames) { vkErrorUnrecognizedExtension(extensionNames[i]) }
    object.EnabledExtensions[i] = ext
  }

  if info.pEnabledFeatures != null {
    object.EnabledFeatures = info.pEnabledFeatures[0]
  }

  return object
}


// This contains the draw command parameters. Only one of the draw data should be
// valid at a time. Others should be null.
@internal class DrawParameters {
  ref!vkCmdDrawArgs                Draw
  ref!vkCmdDrawIndexedArgs         DrawIndexed
  ref!vkCmdDrawIndirectArgs        DrawIndirect
  ref!vkCmdDrawIndexedIndirectArgs DrawIndexedIndirect
}

// This contains the information about a draw
@internal class DrawInfo {
  ref!FramebufferObject Framebuffer
  // A mapping from the descriptor set bound numbers to descriptor set objects
  map!(u32, ref!DescriptorSetObject) DescriptorSets
  // The Last subpass number used in the draw
  @hidden u32 LastSubpass
  // The graphics pipeline used for the draw
  ref!GraphicsPipelineObject GraphicsPipeline
  // The vertex buffers used for the draw. This is a map of binding number to
  // buffer bound do that binding.
  map!(u32, BoundBuffer) BoundVertexBuffers
  // The index buffer used for the draw
  ref!BoundIndexBuffer BoundIndexBuffer
  // The draw parameters used for the draw
  DrawParameters CommandParameters
  // The render pass in which this draw takes place
  ref!RenderPassObject RenderPass
  // Whether or not we are in an unclosed render pass
  @hidden bool InRenderPass
}


@internal class PresentInfo {
  // The number of images presented last present
  u32 PresentImageCount
  // The images presented in the last present
  map!(u32, ref!ImageObject) PresentImages
}

enum LastSubmissionType {
  SUBMIT  = 0
  PRESENT = 1
}

/////////////////////////////
// Internal State Tracking //
/////////////////////////////

// Dispatchable objects.
@serialize map!(VkInstance, ref!InstanceObject)             Instances
@serialize map!(VkPhysicalDevice, ref!PhysicalDeviceObject) PhysicalDevices
@serialize map!(VkDevice, ref!DeviceObject)                 Devices
@serialize map!(VkQueue, ref!QueueObject)                   Queues
@serialize map!(VkCommandBuffer, ref!CommandBufferObject)   CommandBuffers
// Non-dispatchable objects.
@serialize map!(VkDeviceMemory, ref!DeviceMemoryObject)               DeviceMemories
@serialize map!(VkBuffer, ref!BufferObject)                           Buffers
@serialize map!(VkBufferView, ref!BufferViewObject)                   BufferViews
@serialize map!(VkImage, ref!ImageObject)                             Images
@serialize map!(VkImageView, ref!ImageViewObject)                     ImageViews
@serialize map!(VkShaderModule, ref!ShaderModuleObject)               ShaderModules
@serialize map!(VkPipeline, ref!GraphicsPipelineObject)               GraphicsPipelines
@serialize map!(VkPipeline, ref!ComputePipelineObject)                ComputePipelines
@serialize map!(VkPipelineLayout, ref!PipelineLayoutObject)           PipelineLayouts
@serialize map!(VkSampler, ref!SamplerObject)                         Samplers
@serialize map!(VkDescriptorSet, ref!DescriptorSetObject)             DescriptorSets
@serialize map!(VkDescriptorSetLayout, ref!DescriptorSetLayoutObject) DescriptorSetLayouts
@serialize map!(VkDescriptorPool, ref!DescriptorPoolObject)           DescriptorPools
@serialize map!(VkFence, ref!FenceObject)                             Fences
@serialize map!(VkSemaphore, ref!SemaphoreObject)                     Semaphores
@serialize map!(VkEvent, ref!EventObject)                             Events
@serialize map!(VkQueryPool, ref!QueryPoolObject)                     QueryPools
@serialize map!(VkFramebuffer, ref!FramebufferObject)                 Framebuffers
@serialize map!(VkRenderPass, ref!RenderPassObject)                   RenderPasses
@serialize map!(VkPipelineCache, ref!PipelineCacheObject)             PipelineCaches
@serialize map!(VkCommandPool, ref!CommandPoolObject)                 CommandPools
@serialize map!(VkSurfaceKHR, ref!SurfaceObject)                      Surfaces
@serialize map!(VkSwapchainKHR, ref!SwapchainObject)                  Swapchains
@serialize map!(VkDisplayModeKHR, ref!DisplayModeObject)              DisplayModes
// Other state Tracking
@hidden @serialize map!(VkDevice, VkMemoryRequirements) TransferBufferMemoryRequirements
@serialize ref!QueueObject                              LastBoundQueue
@serialize ref!ComputePipelineObject                    CurrentComputePipeline
@serialize map!(VkQueue, ref!DrawInfo)                  LastDrawInfos
@serialize PresentInfo                                  LastPresentInfo
@serialize LastSubmissionType                           LastSubmission

sub ref!DrawInfo lastDrawInfo() {
  if LastBoundQueue != null {
    if !(LastBoundQueue.VulkanHandle in LastDrawInfos) {
      LastDrawInfos[LastBoundQueue.VulkanHandle] = new!DrawInfo()
    }
  }

  ldi := switch (LastBoundQueue == null) {
    case false:
      LastDrawInfos[LastBoundQueue.VulkanHandle]
    case true:
      new!DrawInfo()
  }
  return ldi
}

// Clear the recorded descriptor sets in the last draw
sub void clearLastDrawInfoDescriptorSets() {
  for i in (0 .. len(lastDrawInfo().DescriptorSets)) {
    lastDrawInfo().DescriptorSets[as!u32(i)] = null
  }
}

// Clear the draw command parameters in the last draw info
sub void clearLastDrawInfoDrawCommandParameters() {
  lastDrawInfo().CommandParameters.Draw = null
  lastDrawInfo().CommandParameters.DrawIndexed = null
  lastDrawInfo().CommandParameters.DrawIndirect = null
  lastDrawInfo().CommandParameters.DrawIndexedIndirect = null
}

@internal class VulkanDebugMarkerInfo {
  @unused string   ObjectName
  @unused u64      TagName
  @internal u8[]   Tag
  @unused VkDevice SetDevice
}

// Internal struct for holding useful instance level information from VkInstanceCreateInfo.
@internal class InstanceObject {
  @unused u32                       ApiVersion        // The api version the app requested when setting up the instance
  @unused map!(u32, string)         EnabledExtensions // Map from enabled extension index to extension name
  @unused map!(u32, string)         EnabledLayers
  @unused VkInstance                VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

@internal class PhysicalDeviceObject {
  @unused VkInstance               Instance
  @unused u32                      Index
  VkPhysicalDeviceMemoryProperties MemoryProperties
  @unused VkPhysicalDevice         VulkanHandle
  // A map of queue family indices to queue properties.
  @unused map!(u32, VkQueueFamilyProperties) QueueFamilyProperties
  @unused ref!VulkanDebugMarkerInfo          DebugInfo
  @unused VkPhysicalDeviceProperties         PhysicalDeviceProperties
}

@intenral class QueueInfo {
  u32 QueueFamilyIndex
  u32 QueueIndex
  f32 Priority
}

@internal class DeviceObject {
  VkPhysicalDevice                  PhysicalDevice
  @unused map!(u32, string)         EnabledExtensions
  @unused map!(u32, string)         EnabledLayers
  @unused map!(u32, QueueInfo)      Queues
  @unused map!(u32, ref!QueueObject)    QueueObjects
  @unused VkPhysicalDeviceFeatures  EnabledFeatures
  @unused VkDevice                  VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class QueueObject {
  @unused VkDevice                       Device
  @unused u32                            Family
  @unused u32                            Index
  @unused VkQueue                        VulkanHandle
  map!(VkEvent, ref!EventObject)         PendingEvents
  map!(VkSemaphore, ref!SemaphoreObject) PendingSemaphores
  @unused ref!VulkanDebugMarkerInfo      DebugInfo
  map!(u32, ref!CommandReference)        PendingCommands
}

enum RecordingState {
  NOT_STARTED = 0,
  RECORDING   = 1,
  COMPLETED   = 2
}

@internal class CommandBufferBegin {
  VkCommandBufferUsageFlags     Flags
  bool                          Inherited
  VkRenderPass                  InheritedRenderPass
  u32                           InheritedSubpass
  VkFramebuffer                 InheritedFramebuffer
  VkBool32                      InheritedOcclusionQuery
  VkQueryControlFlags           InheritedQueryFlags
  VkQueryPipelineStatisticFlags InheritedPipelineStatsFlags
}

enum CommandType {
  cmd_vkCmdBindPipeline           = 0,
  cmd_vkCmdSetViewport            = 1,
  cmd_vkCmdSetScissor             = 2,
  cmd_vkCmdSetLineWidth           = 3,
  cmd_vkCmdSetDepthBias           = 4,
  cmd_vkCmdSetBlendConstants      = 5,
  cmd_vkCmdSetDepthBounds         = 6,
  cmd_vkCmdSetStencilCompareMask  = 7,
  cmd_vkCmdSetStencilWriteMask    = 8,
  cmd_vkCmdSetStencilReference    = 9,
  cmd_vkCmdBindDescriptorSets     = 10,
  cmd_vkCmdBindIndexBuffer        = 11,
  cmd_vkCmdBindVertexBuffers      = 12,
  cmd_vkCmdDraw                   = 13,
  cmd_vkCmdDrawIndexed            = 14,
  cmd_vkCmdDrawIndirect           = 15,
  cmd_vkCmdDrawIndexedIndirect    = 16,
  cmd_vkCmdDispatch               = 17,
  cmd_vkCmdDispatchIndirect       = 18,
  cmd_vkCmdCopyBuffer             = 19,
  cmd_vkCmdCopyImage              = 20,
  cmd_vkCmdBlitImage              = 21,
  cmd_vkCmdCopyBufferToImage      = 22,
  cmd_vkCmdCopyImageToBuffer      = 23,
  cmd_vkCmdUpdateBuffer           = 24,
  cmd_vkCmdFillBuffer             = 25,
  cmd_vkCmdClearColorImage        = 26,
  cmd_vkCmdClearDepthStencilImage = 27,
  cmd_vkCmdClearAttachments       = 28,
  cmd_vkCmdResolveImage           = 29,
  cmd_vkCmdSetEvent               = 30,
  cmd_vkCmdResetEvent             = 31,
  cmd_vkCmdWaitEvents             = 32,
  cmd_vkCmdPipelineBarrier        = 33,
  cmd_vkCmdBeginQuery             = 34,
  cmd_vkCmdEndQuery               = 35,
  cmd_vkCmdResetQueryPool         = 36,
  cmd_vkCmdWriteTimestamp         = 37,
  cmd_vkCmdCopyQueryPoolResults   = 38,
  cmd_vkCmdPushConstants          = 39,
  cmd_vkCmdBeginRenderPass        = 40,
  cmd_vkCmdNextSubpass            = 41,
  cmd_vkCmdEndRenderPass          = 42,
  cmd_vkCmdExecuteCommands        = 43,
  cmd_vkCmdDebugMarkerBeginEXT    = 44,
  cmd_vkCmdDebugMarkerEndEXT      = 45,
  cmd_vkCmdDebugMarkerInsertEXT   = 46,
  cmd_vkNoCommand                 = 0xFFFFFFFF
}

enum SemaphoreUpdate {
  None     = 0,
  Unsignal = 1,
  Signal   = 2
}

@internal class SparseMemoryBinds {
  @unused map!(u32, VkSparseMemoryBind) SparseMemoryBinds
}

@internal class SparseImageMemoryBinds {
  @unused map!(u32, VkSparseImageMemoryBind) SparseImageMemoryBinds
}

@internal class QueuedSparseBinds {
  @unused map!(VkBuffer, ref!SparseMemoryBinds)     BufferBinds
  @unused map!(VkImage, ref!SparseMemoryBinds)      OpaqueImageBinds
  @unused map!(VkImage, ref!SparseImageMemoryBinds) ImageBinds
}

@internal class CommandReference {
  @unused VkCommandBuffer       Buffer
  @unused u32                   CommandIndex
  @unused CommandType           Type
  @unused u32                   MapIndex
  @unused SemaphoreUpdate       SemaphoreUpdate
  @unused VkSemaphore           Semaphore
  @unused ref!QueuedSparseBinds SparseBinds
}

@internal class BufferCommands {
  map!(u32, ref!vkCmdBindPipelineArgs)           vkCmdBindPipeline
  map!(u32, ref!vkCmdSetViewportArgs)            vkCmdSetViewport
  map!(u32, ref!vkCmdSetScissorArgs)             vkCmdSetScissor
  map!(u32, ref!vkCmdSetLineWidthArgs)           vkCmdSetLineWidth
  map!(u32, ref!vkCmdSetDepthBiasArgs)           vkCmdSetDepthBias
  map!(u32, ref!vkCmdSetBlendConstantsArgs)      vkCmdSetBlendConstants
  map!(u32, ref!vkCmdSetDepthBoundsArgs)         vkCmdSetDepthBounds
  map!(u32, ref!vkCmdSetStencilCompareMaskArgs)  vkCmdSetStencilCompareMask
  map!(u32, ref!vkCmdSetStencilWriteMaskArgs)    vkCmdSetStencilWriteMask
  map!(u32, ref!vkCmdSetStencilReferenceArgs)    vkCmdSetStencilReference
  map!(u32, ref!vkCmdBindDescriptorSetsArgs)     vkCmdBindDescriptorSets
  map!(u32, ref!vkCmdBindIndexBufferArgs)        vkCmdBindIndexBuffer
  map!(u32, ref!vkCmdBindVertexBuffersArgs)      vkCmdBindVertexBuffers
  map!(u32, ref!vkCmdDrawArgs)                   vkCmdDraw
  map!(u32, ref!vkCmdDrawIndexedArgs)            vkCmdDrawIndexed
  map!(u32, ref!vkCmdDrawIndirectArgs)           vkCmdDrawIndirect
  map!(u32, ref!vkCmdDrawIndexedIndirectArgs)    vkCmdDrawIndexedIndirect
  map!(u32, ref!vkCmdDispatchArgs)               vkCmdDispatch
  map!(u32, ref!vkCmdDispatchIndirectArgs)       vkCmdDispatchIndirect
  map!(u32, ref!vkCmdCopyBufferArgs)             vkCmdCopyBuffer
  map!(u32, ref!vkCmdCopyImageArgs)              vkCmdCopyImage
  map!(u32, ref!vkCmdBlitImageArgs)              vkCmdBlitImage
  map!(u32, ref!vkCmdCopyBufferToImageArgs)      vkCmdCopyBufferToImage
  map!(u32, ref!vkCmdCopyImageToBufferArgs)      vkCmdCopyImageToBuffer
  map!(u32, ref!vkCmdUpdateBufferArgs)           vkCmdUpdateBuffer
  map!(u32, ref!vkCmdFillBufferArgs)             vkCmdFillBuffer
  map!(u32, ref!vkCmdClearColorImageArgs)        vkCmdClearColorImage
  map!(u32, ref!vkCmdClearDepthStencilImageArgs) vkCmdClearDepthStencilImage
  map!(u32, ref!vkCmdClearAttachmentsArgs)       vkCmdClearAttachments
  map!(u32, ref!vkCmdResolveImageArgs)           vkCmdResolveImage
  map!(u32, ref!vkCmdSetEventArgs)               vkCmdSetEvent
  map!(u32, ref!vkCmdResetEventArgs)             vkCmdResetEvent
  map!(u32, ref!vkCmdWaitEventsArgs)             vkCmdWaitEvents
  map!(u32, ref!vkCmdPipelineBarrierArgs)        vkCmdPipelineBarrier
  map!(u32, ref!vkCmdBeginQueryArgs)             vkCmdBeginQuery
  map!(u32, ref!vkCmdEndQueryArgs)               vkCmdEndQuery
  map!(u32, ref!vkCmdResetQueryPoolArgs)         vkCmdResetQueryPool
  map!(u32, ref!vkCmdWriteTimestampArgs)         vkCmdWriteTimestamp
  map!(u32, ref!vkCmdCopyQueryPoolResultsArgs)   vkCmdCopyQueryPoolResults
  map!(u32, ref!vkCmdPushConstantsArgs)          vkCmdPushConstants
  map!(u32, ref!vkCmdBeginRenderPassArgs)        vkCmdBeginRenderPass
  map!(u32, ref!vkCmdNextSubpassArgs)            vkCmdNextSubpass
  map!(u32, ref!vkCmdEndRenderPassArgs)          vkCmdEndRenderPass
  map!(u32, ref!vkCmdExecuteCommandsArgs)        vkCmdExecuteCommands
  map!(u32, ref!vkCmdDebugMarkerBeginEXTArgs)    vkCmdDebugMarkerBeginEXT
  map!(u32, ref!vkCmdDebugMarkerEndEXTArgs)      vkCmdDebugMarkerEndEXT
  map!(u32, ref!vkCmdDebugMarkerInsertEXTArgs)   vkCmdDebugMarkerInsertEXT
}

@internal class CommandBufferObject {
  @unused VkDevice                        Device
  @unused RecordingState                  Recording
  @unused VkCommandBuffer                 VulkanHandle
  @unused VkCommandPool                   Pool
  @unused VkCommandBufferLevel            Level
  @unused map!(u32, ref!CommandReference) CommandReferences
  @unused BufferCommands                  BufferCommands
  @unused ref!CommandBufferBegin          BeginInfo
  @unused ref!VulkanDebugMarkerInfo       DebugInfo
}

@internal class DeviceMemoryObject {
  VkDevice                Device
  @unused VkDeviceMemory  VulkanHandle
  VkDeviceSize            AllocationSize
  map!(u64, VkDeviceSize) BoundObjects
  VkDeviceSize            MappedOffset
  VkDeviceSize            MappedSize
  void*                   MappedLocation
  u32                     MemoryTypeIndex
  @spy_disabled
  @hidden @nobox @internal u8[]     Data
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  ref!MemoryDedicatedAllocationInfo DedicatedAllocationNV
  ref!MemoryDedicatedAllocationInfo DedicatedAllocationKHR
}

@internal class BufferInfo {
  @unused VkBufferCreateFlags                    CreateFlags
  @unused VkDeviceSize                           Size
  @unused VkBufferUsageFlags                     Usage
  @unused VkSharingMode                          SharingMode
  @unused map!(u32, u32)                         QueueFamilyIndices
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@internal class BufferObject {
  @unused VkDevice                  Device
  @unused VkBuffer                  VulkanHandle
  @unused BufferInfo                Info
  ref!DeviceMemoryObject            Memory
  VkDeviceSize                      MemoryOffset
  map!(u64, VkSparseMemoryBind)     SparseMemoryBindings
  @unused ref!QueueObject           LastBoundQueue
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  VkMemoryRequirements              MemoryRequirements
  ref!DedicatedRequirementsKHR      DedicatedRequirementsKHR
}

@internal class BufferViewObject {
  @unused VkDevice                  Device
  @unused VkBufferView              VulkanHandle
  @unused ref!BufferObject          Buffer
  @unused VkFormat                  Format
  @unused VkDeviceSize              Offset
  @unused VkDeviceSize              Range
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class ImageInfo {
  VkImageCreateFlags                             Flags
  VkImageType                                    ImageType
  VkFormat                                       Format
  VkExtent3D                                     Extent
  u32                                            MipLevels
  u32                                            ArrayLayers
  VkSampleCountFlagBits                          Samples
  VkImageTiling                                  Tiling
  VkImageUsageFlags                              Usage
  VkSharingMode                                  SharingMode
  map!(u32, u32)                                 QueueFamilyIndices
  VkImageLayout                                  Layout
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@resource
@internal class ImageObject {
  @unused VkDevice        Device
  @unused ref!QueueObject LastBoundQueue
  ref!DeviceMemoryObject  BoundMemory
  VkDeviceSize            BoundMemoryOffset
  // mapping from the resource offsets to the sparse bindings in the unit of sparse blocks
  map!(u64, VkSparseMemoryBind) OpaqueSparseMemoryBindings
  // mapping from image aspect flags to binding info
  map!(u32, ref!SparseBoundImageAspectInfo)  SparseImageMemoryBindings
  @unused bool                               IsSwapchainImage
  VkImage                                    VulkanHandle
  ImageInfo                                  Info
  VkImageAspectFlags                         ImageAspect
  map!(u32, ref!ImageLayer)                  Layers
  @unused ref!VulkanDebugMarkerInfo          DebugInfo
  VkMemoryRequirements                       MemoryRequirements
  map!(u32, VkSparseImageMemoryRequirements) SparseMemoryRequirements
  ref!DedicatedRequirementsKHR               DedicatedRequirementsKHR
}

@internal class ImageLayer {
  map!(u32, ref!ImageLevel) Levels
}

@internal class ImageLevel {
  u32         Width
  u32         Height
  @unused u32 Depth
  @spy_disabled
  @hidden @nobox @internal u8[] Data
  @unused u32                   Size
}

@internal class SparseBoundImageAspectInfo {
  map!(u32, ref!SparseBoundImageLayerInfo) Layers
}

@internal class SparseBoundImageLayerInfo {
  map!(u32, ref!SparseBoundImageLevelInfo) Levels
}

@internal class SparseBoundImageLevelInfo {
  map!(u64, ref!SparseBoundImageBlockInfo) Blocks
}

@internal class SparseBoundImageBlockInfo {
  VkOffset3D              Offset
  VkExtent3D              Extent
  VkDeviceMemory          Memory
  VkDeviceSize            MemoryOffset
  VkDeviceSize            Size
  VkSparseMemoryBindFlags Flags
}

@internal class ImageViewObject {
  @unused VkDevice                  Device
  @unused VkImageView               VulkanHandle
  @unused VkImageViewType           Type
  @unused VkFormat                  Format
  @unused VkComponentMapping        Components
  @unused VkImageSubresourceRange   SubresourceRange
  ref!ImageObject                   Image
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@resource
@internal class ShaderModuleObject {
  @unused VkDevice                  Device
  @unused u32[]                     Words
  @unused VkShaderModule            VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class SpecializationInfo {
  map!(u32, VkSpecializationMapEntry) Specializations
  u8[]                                Data
}

@internal class StageData {
  @unused VkShaderStageFlagBits  Stage
  @unused ref!ShaderModuleObject Module
  @unused string                 EntryPoint
  @unused ref!SpecializationInfo Specialization
}

@internal class VertexData {
  @unused map!(u32, VkVertexInputBindingDescription)   BindingDescriptions
  @unused map!(u32, VkVertexInputAttributeDescription) AttributeDescriptions
}

@internal class InputAssemblyData {
  @unused VkPrimitiveTopology Topology
  @unused VkBool32            PrimitiveRestartEnable
}

@internal class TessellationStateData {
  @unused u32 PatchControlPoints
}

@internal class ViewportData {
  @unused u32                   ViewportCount
  @unused map!(u32, VkViewport) Viewports
  @unused u32                   ScissorCount
  @unused map!(u32, VkRect2D)   Scissors
}

@internal class RasterizationData {
  @unused VkBool32        DepthClampEnable
  @unused VkBool32        RasterizerDiscardEnable
  @unused VkPolygonMode   PolygonMode
  @unused VkCullModeFlags CullMode
  @unused VkFrontFace     FrontFace
  @unused VkBool32        DepthBiasEnable
  @unused f32             DepthBiasConstantFactor
  @unused f32             DepthBiasClamp
  @unused f32             DepthBiasSlopeFactor
  @unused f32             LineWidth
}

@internal class MultisampleData {
  @unused VkSampleCountFlagBits   RasterizationSamples
  @unused VkBool32                SampleShadingEnable
  @unused f32                     MinSampleShading
  @unused map!(u32, VkSampleMask) SampleMask
  @unused VkBool32                AlphaToCoverageEnable
  @unused VkBool32                AlphaToOneEnable
}

@internal class DepthData {
  @unused VkBool32         DepthTestEnable
  @unused VkBool32         DepthWriteEnable
  @unused VkCompareOp      DepthCompareOp
  @unused VkBool32         DepthBoundsTestEnable
  @unused VkBool32         StencilTestEnable
  @unused VkStencilOpState Front
  @unused VkStencilOpState Back
  @unused f32              MinDepthBounds
  @unused f32              MaxDepthBounds
}

@internal class ColorBlendData {
  @unused VkBool32                                       LogicOpEnable
  @unused VkLogicOp                                      LogicOp
  @unused map!(u32, VkPipelineColorBlendAttachmentState) Attachments
  @unused f32[4]                                         BlendConstants
}

@internal class DynamicData {
  @unused map!(u32, VkDynamicState) DynamicStates
}

@internal class GraphicsPipelineObject {
  @unused VkDevice                  Device
  @unused ref!PipelineCacheObject   PipelineCache
  @unused VkPipelineCreateFlags     Flags
  @unused VkPipeline                VulkanHandle
  @unused map!(u32, StageData)      Stages
  @unused VertexData                VertexInputState
  @unused InputAssemblyData         InputAssemblyState
  @unused ref!TessellationStateData TessellationState
  @unused ref!ViewportData          ViewportState
  @unused RasterizationData         RasterizationState
  @unused ref!MultisampleData       MultisampleState
  @unused ref!DepthData             DepthState
  @unused ref!ColorBlendData        ColorBlendState
  @unused ref!DynamicData           DynamicState
  @unused ref!PipelineLayoutObject  Layout
  @unused ref!RenderPassObject      RenderPass
  @unused u32                       Subpass
  @unused VkPipeline                BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                       BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class ComputePipelineObject {
  @unused VkDevice                 Device
  @unused VkPipeline               VulkanHandle
  @unused ref!PipelineCacheObject  PipelineCache
  @unused VkPipelineCreateFlags    Flags
  @unused StageData                Stage
  @unused ref!PipelineLayoutObject PipelineLayout
  @unused VkPipeline               BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                       BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class PipelineLayoutObject {
  @unused VkDevice                                 Device
  @unused VkPipelineLayout                         VulkanHandle
  @unused map!(u32, ref!DescriptorSetLayoutObject) SetLayouts
  @unused map!(u32, VkPushConstantRange)           PushConstantRanges
  @unused ref!VulkanDebugMarkerInfo                DebugInfo
}

@internal class SamplerObject {
  @unused VkDevice                  Device
  @unused VkSampler                 VulkanHandle
  @unused VkFilter                  MagFilter
  @unused VkFilter                  MinFilter
  @unused VkSamplerMipmapMode       MipMapMode
  @unused VkSamplerAddressMode      AddressModeU
  @unused VkSamplerAddressMode      AddressModeV
  @unused VkSamplerAddressMode      AddressModeW
  @unused f32                       MipLodBias
  @unused VkBool32                  AnisotropyEnable
  @unused f32                       MaxAnisotropy
  @unused VkBool32                  CompareEnable
  @unused VkCompareOp               CompareOp
  @unused f32                       MinLod
  @unused f32                       MaxLod
  @unused VkBorderColor             BorderColor
  @unsued VkBool32                  UnnormalizedCoordinates
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class DescriptorBinding {
  VkDescriptorType                      BindingType
  map!(u32, ref!VkDescriptorBufferInfo) BufferBinding
  map!(u32, ref!VkDescriptorImageInfo)  ImageBinding
  map!(u32, VkBufferView)               BufferViewBindings
}

@internal class DescriptorSetObject {
  @unused VkDevice         Device
  @unused VkDescriptorSet  VulkanHandle
  @unused VkDescriptorPool DescriptorPool
  // Map from a binding number to its bound array of buffers.
  map!(u32, DescriptorBinding)      Bindings
  ref!DescriptorSetLayoutObject     Layout
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class DescriptorSetLayoutBinding {
  VkDescriptorType                     Type
  @unused u32                          Count
  @unused VkShaderStageFlags           Stages
  @unused map!(u32, ref!SamplerObject) ImmutableSamplers
}

@internal class DescriptorSetLayoutObject {
  @unused VkDevice              Device
  @unused VkDescriptorSetLayout VulkanHandle
  u32                           MaximumBinding
  // Map of binding numbers to binding information
  map!(u32, DescriptorSetLayoutBinding) Bindings
  @unused ref!VulkanDebugMarkerInfo     DebugInfo
}

@internal class DescriptorPoolObject {
  @unused VkDevice                                       Device
  @unused VkDescriptorPool                               VulkanHandle
  @unused VkDescriptorPoolCreateFlags                    Flags
  @unused u32                                            MaxSets
  @unused map!(u32, VkDescriptorPoolSize)                Sizes
  @unused map!(VkDescriptorSet, ref!DescriptorSetObject) DescriptorSets
  @unused ref!VulkanDebugMarkerInfo                      DebugInfo
}

@internal class FenceObject {
  @unused VkDevice                  Device
  @unused VkFence                   VulkanHandle
  @unused bool                      Signaled
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}


@internal class SemaphoreObject {
  @unused VkDevice                  Device
  @unused VkSemaphore               VulkanHandle
  @unused VkQueue                   LastQueue
  @unused bool                      Signaled
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @unused VkQueue                   WaitingQueue
}

@internal class EventObject {
  @unused VkDevice                  Device
  @unused VkEvent                   VulkanHandle
  @unused bool                      Signaled
  @unused VkQueue                   SubmitQueue
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

enum QueryStatus {
  QUERY_STATUS_INACTIVE = 0
  QUERY_STATUS_ACTIVE   = 1
  QUERY_STATUS_COMPLETE = 2
}

@internal class QueryPoolObject {
  @unused VkDevice                      Device
  @unused VkQueryPool                   VulkanHandle
  @unused VkQueryType                   QueryType
  @unused u32                           QueryCount
  @unused VkQueryPipelineStatisticFlags PipelineStatistics
  @unused map!(u32, QueryStatus)        Status
  @unused ref!VulkanDebugMarkerInfo     DebugInfo
}

@internal class FramebufferObject {
  @unused VkDevice                  Device
  @unused VkFramebuffer             VulkanHandle
  @unused ref!RenderPassObject      RenderPass
  map!(u32, ref!ImageViewObject)    ImageAttachments
  @unused u32                       Width
  @unused u32                       Height
  @unused u32                       Layers
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class SubpassDescription {
  @unused VkSubpassDescriptionFlags        Flags
  @unused VkPipelineBindPoint              PipelineBindPoint
  @unused map!(u32, VkAttachmentReference) InputAttachments
  @unused map!(u32, VkAttachmentReference) ColorAttachments
  @unused map!(u32, VkAttachmentReference) ResolveAttachments
  @unused ref!VkAttachmentReference        DepthStencilAttachment
  @unused map!(u32, u32)                   PreserveAttachments
}

@internal class RenderPassObject {
  @unused VkDevice                           Device
  @unused VkRenderPass                       VulkanHandle
  @unused map!(u32, VkAttachmentDescription) AttachmentDescriptions
  @unused map!(u32, SubpassDescription)      SubpassDescriptions
  @unused map!(u32, VkSubpassDependency)     SubpassDependencies
  @unused ref!VulkanDebugMarkerInfo          DebugInfo
}

@internal class PipelineCacheObject {
  @unused VkDevice                  Device
  @unused VkPipelineCache           VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class CommandPoolObject {
  @unused VkDevice                                       Device
  @unused VkCommandPool                                  VulkanHandle
  @unsued VkCommandPoolCreateFlags                       Flags
  @unused u32                                            QueueFamilyIndex
  @unused map!(VkCommandBuffer, ref!CommandBufferObject) CommandBuffers
  @unused ref!VulkanDebugMarkerInfo                      DebugInfo
}

enum SurfaceType {
  SURFACE_TYPE_UNKNOWN = 0
  SURFACE_TYPE_XCB     = 1
  SURFACE_TYPE_ANDROID = 2
  SURFACE_TYPE_WIN32   = 3
  SURFACE_TYPE_WAYLAND = 4
  SURFACE_TYPE_XLIB    = 5
  SURFACE_TYPE_MIR     = 6
}

@internal class SurfaceObject {
  @unused VkInstance                Instance
  @unused VkSurfaceKHR              VulkanHandle
  @unused SurfaceType               Type
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class SwapchainObject {
  @unused VkDevice                      Device
  @unused VkSwapchainKHR                VulkanHandle
  @unused ImageInfo                     Info
  @unused ref!SurfaceObject             Surface
  @unused VkColorSpaceKHR               ColorSpace
  @unused VkSurfaceTransformFlagBitsKHR PreTransform
  @unused VkCompositeAlphaFlagBitsKHR   CompositeAlpha
  @unused VkPresentModeKHR              PresentMode
  @unused VkBool32                      Clipped
  map!(u32, ref!ImageObject)            SwapchainImages
  @unused ref!VulkanDebugMarkerInfo     DebugInfo
}

@internal class DisplayModeObject {
  @unused VkPhysicalDevice          PhysicalDevice
  @unused VkDisplayKHR              Display
  @unused VkDisplayModeKHR          VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

sub VkQueueFlags AddQueueFlag(VkQueueFlags flags, VkQueueFlagBits bit) {
  return as!VkQueueFlags(as!u32(flags) | as!u32(bit))
}

class VulkanStructHeader {
  VkStructureType SType
  void*           PNext
}

@internal class DedicatedAllocationBufferImageCreateInfoNV {
  VkBool32 DedicatedAllocation
}

@internal class MemoryDedicatedAllocationInfo {
  VkImage  Image
  VkBuffer Buffer
}

@internal class DedicatedRequirementsKHR {
  VkBool32 PrefersDedicatedAllocation
  VkBool32 RequiresDedicatedAllocation
}

@internal class queueMap {
  map!(u32, VkQueue) m
}

class MutableBool {
  bool b
}

sub void execPendingCommands(VkQueue queue) {
  q := Queues[queue]
  newCmds := emptyMap().m
  signaledQueues := queueMap().m
  processSubcommand := MutableBool()
  processSubcommand.b = true

  for i in (0 .. len(q.PendingCommands)) {
    cmd := q.PendingCommands[as!u32(i)]
    if ((len(q.PendingEvents) != 0) || (len(q.PendingSemaphores) != 0)) {
      newCmds[len(newCmds)] = cmd
    } else {
      onPreProcessCommand(cmd)
      if (cmd.SemaphoreUpdate == Signal) {
        semaphore := Semaphores[cmd.Semaphore]
        semaphore.Signaled = true
        if semaphore.WaitingQueue != as!VkQueue(0) {
          delete(Queues[semaphore.WaitingQueue].PendingSemaphores, cmd.Semaphore)
          signaledQueues[len(signaledQueues)] = semaphore.WaitingQueue
          semaphore.WaitingQueue = as!VkQueue(0)
        }
      } else if (cmd.SemaphoreUpdate == Unsignal) {
          semaphore := Semaphores[cmd.Semaphore]
          if !semaphore.Signaled {
            semaphore.WaitingQueue = queue
            q.PendingSemaphores[cmd.Semaphore] = semaphore
            onDeferSubcommand(cmd)
            newCmds[len(newCmds)] = cmd
            processSubcommand.b = false
          } else {
            Semaphores[cmd.Semaphore].Signaled = false
          }
        }
      if processSubcommand.b {
        // Handle sparse image binding.
        if (cmd.SparseBinds != null) {
          for _ , buf , binds in cmd.SparseBinds.BufferBinds {
            if !(buf in Buffers) { vkErrorInvalidBuffer(buf) }
            buffer := Buffers[buf]
            blockSize := buffer.MemoryRequirements.alignment
            for _ , _ , bind in binds.SparseMemoryBinds {
              numBlocks := (bind.size + blockSize - 1) / blockSize
              memOffset := bind.memoryOffset
              resOffset := bind.resourceOffset
              for j in (0 .. numBlocks) {
                buffer.SparseMemoryBindings[as!u64(resOffset)] =
                VkSparseMemoryBind(resOffset + (j * blockSize),
                  blockSize,       bind.memory,                 memOffset + (j * blockSize),
                  bind.flags)
              }
            }
          }

          for _ , img , binds in cmd.SparseBinds.OpaqueImageBinds {
            if (!img in Images) { vkErrorInvalidImage(img) }
            image := Images[img]
            blockSize := image.MemoryRequirements.alignment
            for _ , _ , bind in binds.SparseMemoryBinds {
              numBlocks := (bind.size + blockSize - 1) / blockSize
              memOffset := bind.memoryOffset
              resOffset := bind.resourceOffset
              for j in (0 .. numBlocks) {
                image.OpaqueSparseMemoryBindings[as!u64(resOffset)] =
                VkSparseMemoryBind(resOffset + (j * blockSize),
                  blockSize,       bind.memory,                 memOffset + (j * blockSize),
                  bind.flags)
              }
            }
          }

          for _ , img , binds in cmd.SparseBinds.ImageBinds {
            if (!img in Images) { vkErrorInvalidImage(img) }
            for _ , _ , bind in binds.SparseImageMemoryBinds {
              addSparseImageMemoryBinding(img, bind)
            }
          }

          postBindSparse(cmd.SparseBinds)
        } // Done sparse images

        if ((cmd.Buffer != as!VkCommandBuffer(0))) {
          onPreSubcommand(cmd)
          callCommand(cmd)

          if len(q.PendingEvents) != 0 {
            // Make sure that the VkCmdWaitEvents also gets added to the pending list.
            // We have to do some things when it is called.
            newCmds[len(newCmds)] = cmd
            onDeferSubcommand(cmd)
          } else {
            onPostSubcommand(cmd)
          }
        }
      }
    }
  }
  q.PendingCommands = newCmds

  resetSubcontext()
  for i in (0 .. len(signaledQueues)) {
    execPendingCommands(signaledQueues[as!u32(i)])
  }
}

sub void callCommand(ref!CommandReference reference) {
  switch reference.Type {
    case cmd_vkCmdBindPipeline:
      dovkCmdBindPipeline(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBindPipeline[reference.MapIndex])
    case cmd_vkCmdSetViewport:
      dovkCmdSetViewport(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetViewport[reference.MapIndex])
    case cmd_vkCmdSetScissor:
      dovkCmdSetScissor(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetScissor[reference.MapIndex])
    case cmd_vkCmdSetLineWidth:
      dovkCmdSetLineWidth(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetLineWidth[reference.MapIndex])
    case cmd_vkCmdSetDepthBias:
      dovkCmdSetDepthBias(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetDepthBias[reference.MapIndex])
    case cmd_vkCmdSetBlendConstants:
      dovkCmdSetBlendConstants(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetBlendConstants[reference.MapIndex])
    case cmd_vkCmdSetDepthBounds:
      dovkCmdSetDepthBounds(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetDepthBounds[reference.MapIndex])
    case cmd_vkCmdSetStencilCompareMask:
      dovkCmdSetStencilCompareMask(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetStencilCompareMask[reference.MapIndex])
    case cmd_vkCmdSetStencilWriteMask:
      dovkCmdSetStencilWriteMask(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetStencilWriteMask[reference.MapIndex])
    case cmd_vkCmdSetStencilReference:
      dovkCmdSetStencilReference(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetStencilReference[reference.MapIndex])
    case cmd_vkCmdBindDescriptorSets:
      dovkCmdBindDescriptorSets(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBindDescriptorSets[reference.MapIndex])
    case cmd_vkCmdBindIndexBuffer:
      dovkCmdBindIndexBuffer(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBindIndexBuffer[reference.MapIndex])
    case cmd_vkCmdBindVertexBuffers:
      dovkCmdBindVertexBuffers(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBindVertexBuffers[reference.MapIndex])
    case cmd_vkCmdDraw:
      dovkCmdDraw(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDraw[reference.MapIndex])
    case cmd_vkCmdDrawIndexed:
      dovkCmdDrawIndexed(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDrawIndexed[reference.MapIndex])
    case cmd_vkCmdDrawIndirect:
      dovkCmdDrawIndirect(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDrawIndirect[reference.MapIndex])
    case cmd_vkCmdDrawIndexedIndirect:
      dovkCmdDrawIndexedIndirect(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDrawIndexedIndirect[reference.MapIndex])
    case cmd_vkCmdDispatch:
      dovkCmdDispatch(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDispatch[reference.MapIndex])
    case cmd_vkCmdDispatchIndirect:
      dovkCmdDispatchIndirect(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDispatchIndirect[reference.MapIndex])
    case cmd_vkCmdCopyBuffer:
      dovkCmdCopyBuffer(CommandBuffers[reference.Buffer].BufferCommands.vkCmdCopyBuffer[reference.MapIndex])
    case cmd_vkCmdCopyImage:
      dovkCmdCopyImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdCopyImage[reference.MapIndex])
    case cmd_vkCmdBlitImage:
      dovkCmdBlitImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBlitImage[reference.MapIndex])
    case cmd_vkCmdCopyBufferToImage:
      dovkCmdCopyBufferToImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdCopyBufferToImage[reference.MapIndex])
    case cmd_vkCmdCopyImageToBuffer:
      dovkCmdCopyImageToBuffer(CommandBuffers[reference.Buffer].BufferCommands.vkCmdCopyImageToBuffer[reference.MapIndex])
    case cmd_vkCmdUpdateBuffer:
      dovkCmdUpdateBuffer(CommandBuffers[reference.Buffer].BufferCommands.vkCmdUpdateBuffer[reference.MapIndex])
    case cmd_vkCmdFillBuffer:
      dovkCmdFillBuffer(CommandBuffers[reference.Buffer].BufferCommands.vkCmdFillBuffer[reference.MapIndex])
    case cmd_vkCmdClearColorImage:
      dovkCmdClearColorImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdClearColorImage[reference.MapIndex])
    case cmd_vkCmdClearDepthStencilImage:
      dovkCmdClearDepthStencilImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdClearDepthStencilImage[reference.MapIndex])
    case cmd_vkCmdClearAttachments:
      dovkCmdClearAttachments(CommandBuffers[reference.Buffer].BufferCommands.vkCmdClearAttachments[reference.MapIndex])
    case cmd_vkCmdResolveImage:
      dovkCmdResolveImage(CommandBuffers[reference.Buffer].BufferCommands.vkCmdResolveImage[reference.MapIndex])
    case cmd_vkCmdSetEvent:
      dovkCmdSetEvent(CommandBuffers[reference.Buffer].BufferCommands.vkCmdSetEvent[reference.MapIndex])
    case cmd_vkCmdResetEvent:
      dovkCmdResetEvent(CommandBuffers[reference.Buffer].BufferCommands.vkCmdResetEvent[reference.MapIndex])
    case cmd_vkCmdWaitEvents:
      dovkCmdWaitEvents(CommandBuffers[reference.Buffer].BufferCommands.vkCmdWaitEvents[reference.MapIndex])
    case cmd_vkCmdPipelineBarrier:
      dovkCmdPipelineBarrier(CommandBuffers[reference.Buffer].BufferCommands.vkCmdPipelineBarrier[reference.MapIndex])
    case cmd_vkCmdBeginQuery:
      dovkCmdBeginQuery(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBeginQuery[reference.MapIndex])
    case cmd_vkCmdEndQuery:
      dovkCmdEndQuery(CommandBuffers[reference.Buffer].BufferCommands.vkCmdEndQuery[reference.MapIndex])
    case cmd_vkCmdResetQueryPool:
      dovkCmdResetQueryPool(CommandBuffers[reference.Buffer].BufferCommands.vkCmdResetQueryPool[reference.MapIndex])
    case cmd_vkCmdWriteTimestamp:
      dovkCmdWriteTimestamp(CommandBuffers[reference.Buffer].BufferCommands.vkCmdWriteTimestamp[reference.MapIndex])
    case cmd_vkCmdCopyQueryPoolResults:
      dovkCmdCopyQueryPoolResults(CommandBuffers[reference.Buffer].BufferCommands.vkCmdCopyQueryPoolResults[reference.MapIndex])
    case cmd_vkCmdPushConstants:
      dovkCmdPushConstants(CommandBuffers[reference.Buffer].BufferCommands.vkCmdPushConstants[reference.MapIndex])
    case cmd_vkCmdBeginRenderPass:
      dovkCmdBeginRenderPass(CommandBuffers[reference.Buffer].BufferCommands.vkCmdBeginRenderPass[reference.MapIndex])
    case cmd_vkCmdNextSubpass:
      dovkCmdNextSubpass(CommandBuffers[reference.Buffer].BufferCommands.vkCmdNextSubpass[reference.MapIndex])
    case cmd_vkCmdEndRenderPass:
      dovkCmdEndRenderPass(CommandBuffers[reference.Buffer].BufferCommands.vkCmdEndRenderPass[reference.MapIndex])
    case cmd_vkCmdExecuteCommands:
      dovkCmdExecuteCommands(CommandBuffers[reference.Buffer].BufferCommands.vkCmdExecuteCommands[reference.MapIndex])
    case cmd_vkCmdDebugMarkerBeginEXT:
      dovkCmdDebugMarkerBeginEXT(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDebugMarkerBeginEXT[reference.MapIndex])
    case cmd_vkCmdDebugMarkerEndEXT:
      dovkCmdDebugMarkerEndEXT(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDebugMarkerEndEXT[reference.MapIndex])
    case cmd_vkCmdDebugMarkerInsertEXT:
      dovkCmdDebugMarkerInsertEXT(CommandBuffers[reference.Buffer].BufferCommands.vkCmdDebugMarkerInsertEXT[reference.MapIndex])
    default:
      vkErrorInvalidCommandBuffer(reference.Buffer)
  }
}