// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

api_index 2

import "android/vulkan_android.api"
import "linux/vulkan_linux.api"
import "windows/vulkan_windows.api"
import "synthetic.api"

///////////////
// Constants //
///////////////

// API version (major.minor.patch)
define VERSION_MAJOR 1
define VERSION_MINOR 0
define VERSION_PATCH 3

// API limits
define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
define VK_UUID_SIZE                     16

define VK_MAX_EXTENSION_NAME_SIZE 256
define VK_MAX_DESCRIPTION_SIZE    256
define VK_MAX_MEMORY_TYPES        32
define VK_MAX_MEMORY_HEAPS        16 /// The maximum number of unique memory heaps, each of which supporting 1 or more memory types.

// API keywords
define VK_TRUE  1
define VK_FALSE 0

// API keyword, but needs special handling by some templates
define NULL_HANDLE 0

@extension("VK_KHR_surface") define VK_KHR_SURFACE_SPEC_VERSION   25
@extension("VK_KHR_surface") define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"

@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_SPEC_VERSION   67
@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"

@extension("VK_KHR_display") define VK_KHR_DISPLAY_SPEC_VERSION   21
@extension("VK_KHR_display") define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"

@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION   9
@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_SPEC_VERSION   1
@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"

@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_SPEC_VERSION   4
@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"

/////////////
//  Types  //
/////////////

type u32 VkFlags
type u32 VkBool32
type u64 VkDeviceSize
type u32 VkSampleMask

/// Dispatchable handle types.
@replay_remap @dispatchHandle type size VkInstance
@replay_remap @dispatchHandle type size VkPhysicalDevice
@replay_remap @dispatchHandle type size VkDevice
@replay_remap @dispatchHandle type size VkQueue
@replay_remap @dispatchHandle type size VkCommandBuffer

/// Non dispatchable handle types.
@replay_remap @nonDispatchHandle type u64 VkSemaphore
@replay_remap @nonDispatchHandle type u64 VkFence
@replay_remap @nonDispatchHandle type u64 VkDeviceMemory
@replay_remap @nonDispatchHandle type u64 VkBuffer
@replay_remap @nonDispatchHandle type u64 VkImage
@replay_remap @nonDispatchHandle type u64 VkEvent
@replay_remap @nonDispatchHandle type u64 VkQueryPool
@replay_remap @nonDispatchHandle type u64 VkBufferView
@replay_remap @nonDispatchHandle type u64 VkImageView
@replay_remap @nonDispatchHandle type u64 VkShaderModule
@replay_remap @nonDispatchHandle type u64 VkPipelineCache
@replay_remap @nonDispatchHandle type u64 VkPipelineLayout
@replay_remap @nonDispatchHandle type u64 VkRenderPass
@replay_remap @nonDispatchHandle type u64 VkPipeline
@replay_remap @nonDispatchHandle type u64 VkDescriptorSetLayout
@replay_remap @nonDispatchHandle type u64 VkSampler
@replay_remap @nonDispatchHandle type u64 VkDescriptorPool
@replay_remap @nonDispatchHandle type u64 VkDescriptorSet
@replay_remap @nonDispatchHandle type u64 VkFramebuffer
@replay_remap @nonDispatchHandle type u64 VkCommandPool

@extension("VK_KHR_surface") @replay_remap @nonDispatchHandle type u64 VkSurfaceKHR

@extension("VK_KHR_swapchain") @replay_remap @nonDispatchHandle type u64 VkSwapchainKHR

@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayKHR
@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayModeKHR

@extension("VK_EXT_debug_report") @replay_remap @nonDispatchHandle type u64 VkDebugReportCallbackEXT


/////////////
//  Enums  //
/////////////

extern void mapMemory(void** mem, u8[] slice)
extern void unmapMemory(u8[] slice)
extern void trackMappedCoherentMemory(u64 start, size size)
extern void readMappedCoherentMemory(VkDeviceMemory memory, u64 offset_in_mapped, size readSize)
extern void untrackMappedCoherentMemory(u64 start, size size)

@unused
enum VkPipelineCacheHeaderVersion {
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

@lastUnused(-11)
/// Error and return codes
enum VkResult {
  // Return codes for successful operation execution (positive values)
  VK_SUCCESS     = 0,
  VK_NOT_READY   = 1,
  VK_TIMEOUT     = 2,
  VK_EVENT_SET   = 3,
  VK_EVENT_RESET = 4,
  VK_INCOMPLETE  = 5,

  // Error codes (negative values)
  VK_ERROR_OUT_OF_HOST_MEMORY    = 0xFFFFFFFF, // -1
  VK_ERROR_OUT_OF_DEVICE_MEMORY  = 0xFFFFFFFE, // -2
  VK_ERROR_INITIALIZATION_FAILED = 0xFFFFFFFD, // -3
  VK_ERROR_DEVICE_LOST           = 0xFFFFFFFC, // -4
  VK_ERROR_MEMORY_MAP_FAILED     = 0xFFFFFFFB, // -5
  VK_ERROR_LAYER_NOT_PRESENT     = 0xFFFFFFFA, // -6
  VK_ERROR_EXTENSION_NOT_PRESENT = 0xFFFFFFF9, // -7
  VK_ERROR_FEATURE_NOT_PRESENT   = 0xFFFFFFF8, // -8
  VK_ERROR_INCOMPATIBLE_DRIVER   = 0xFFFFFFF7, // -9
  VK_ERROR_TOO_MANY_OBJECTS      = 0xFFFFFFF6, // -10
  VK_ERROR_FORMAT_NOT_SUPPORTED  = 0xFFFFFFF5, // -11

  //@extension("VK_KHR_surface")
  VK_ERROR_SURFACE_LOST_KHR = 0xC4653600, // -1000000000

  //@extension("VK_KHR_surface")
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = 0xC46535FF, // -1000008001

  //@extension("VK_KHR_swapchain")
  VK_SUBOPTIMAL_KHR = 1000001003,

  //@extension("VK_KHR_swapchain")
  VK_ERROR_OUT_OF_DATE_KHR = 0xC4653214, // -1000001004

  //@extension("VK_KHR_display_swapchain")
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = 0xC4652A47, // -1000003001

  //@extension("VK_EXT_debug_report")
  VK_ERROR_VALIDATION_FAILED_EXT = 0xC4650B07, // -1000011001

  VK_ERROR_INVALID_SHADER_NV = 0x3B9AF8E0, // -1000012000
}

/// Structure type enumerant
enum VkStructureType {
  VK_STRUCTURE_TYPE_APPLICATION_INFO                          = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                      = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                  = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                        = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO                               = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                      = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                       = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                          = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                         = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                     = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                         = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                    = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                        = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                   = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                         = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                    = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                 = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO         = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO   = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO   = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO       = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO  = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO    = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO  = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO    = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO        = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO             = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO              = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO               = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                       = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO         = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO               = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO              = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                      = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                       = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                   = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                   = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                  = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO              = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO           = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                 = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                    = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                     = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                      = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER                            = 46,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO               = 47,
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                 = 48,

  //@extension("VK_KHR_swapchain")
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR          = 1000001001,

  //@extension("VK_KHR_display")
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR    = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,

  //@extension("VK_KHR_display_swapchain")
  VK_STRUCTURE_TYPE_DISPLAY_DISPLAY_PRESENT_INFO_KHR = 1000003000,

  //@extension("VK_KHR_xlib_surface")
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,

  //@extension("VK_KHR_xcb_surface")
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,

  //@extension("VK_KHR_wayland_surface")
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,

  //@extension("VK_KHR_mir_surface")
  VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,

  //@extension("VK_KHR_android_surface")
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,

  //@extension("VK_KHR_win32_surface")
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,

  //@extension("VK_ANDROID_native_buffer")
  VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,

  //@extension("VK_EXT_debug_report")
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,

  //@extension("VK_EXT_debug_marker")
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT  = 1000022001
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT      = 1000022002

  //@extension("VK_NV_dedicated_allocation")
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV    = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV   = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
}

enum VkSystemAllocationScope {
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND  = 0x00000000,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT   = 0x00000001,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE    = 0x00000002,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE   = 0x00000003,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 0x00000004,
}

enum VkInternalAllocationType {
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0x00000000,
}

/// Vulkan format definitions
enum VkFormat {
  VK_FORMAT_UNDEFINED                  = 0,
  VK_FORMAT_R4G4_UNORM_PACK8           = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16      = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16      = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16        = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16        = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16      = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16      = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16      = 8,
  VK_FORMAT_R8_UNORM                   = 9,
  VK_FORMAT_R8_SNORM                   = 10,
  VK_FORMAT_R8_USCALED                 = 11,
  VK_FORMAT_R8_SSCALED                 = 12,
  VK_FORMAT_R8_UINT                    = 13,
  VK_FORMAT_R8_SINT                    = 14,
  VK_FORMAT_R8_SRGB                    = 15,
  VK_FORMAT_R8G8_UNORM                 = 16,
  VK_FORMAT_R8G8_SNORM                 = 17,
  VK_FORMAT_R8G8_USCALED               = 18,
  VK_FORMAT_R8G8_SSCALED               = 19,
  VK_FORMAT_R8G8_UINT                  = 20,
  VK_FORMAT_R8G8_SINT                  = 21,
  VK_FORMAT_R8G8_SRGB                  = 22,
  VK_FORMAT_R8G8B8_UNORM               = 23,
  VK_FORMAT_R8G8B8_SNORM               = 24,
  VK_FORMAT_R8G8B8_USCALED             = 25,
  VK_FORMAT_R8G8B8_SSCALED             = 26,
  VK_FORMAT_R8G8B8_UINT                = 27,
  VK_FORMAT_R8G8B8_SINT                = 28,
  VK_FORMAT_R8G8B8_SRGB                = 29,
  VK_FORMAT_B8G8R8_UNORM               = 30,
  VK_FORMAT_B8G8R8_SNORM               = 31,
  VK_FORMAT_B8G8R8_USCALED             = 32,
  VK_FORMAT_B8G8R8_SSCALED             = 33,
  VK_FORMAT_B8G8R8_UINT                = 34,
  VK_FORMAT_B8G8R8_SINT                = 35,
  VK_FORMAT_B8G8R8_SRGB                = 36,
  VK_FORMAT_R8G8B8A8_UNORM             = 37,
  VK_FORMAT_R8G8B8A8_SNORM             = 38,
  VK_FORMAT_R8G8B8A8_USCALED           = 39,
  VK_FORMAT_R8G8B8A8_SSCALED           = 40,
  VK_FORMAT_R8G8B8A8_UINT              = 41,
  VK_FORMAT_R8G8B8A8_SINT              = 42,
  VK_FORMAT_R8G8B8A8_SRGB              = 43,
  VK_FORMAT_B8G8R8A8_UNORM             = 44,
  VK_FORMAT_B8G8R8A8_SNORM             = 45,
  VK_FORMAT_B8G8R8A8_USCALED           = 46,
  VK_FORMAT_B8G8R8A8_SSCALED           = 47,
  VK_FORMAT_B8G8R8A8_UINT              = 48,
  VK_FORMAT_B8G8R8A8_SINT              = 49,
  VK_FORMAT_B8G8R8A8_SRGB              = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32      = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32      = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32    = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32    = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32       = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32       = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32       = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32   = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32   = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32    = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32    = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32   = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32   = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32    = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32    = 69,
  VK_FORMAT_R16_UNORM                  = 70,
  VK_FORMAT_R16_SNORM                  = 71,
  VK_FORMAT_R16_USCALED                = 72,
  VK_FORMAT_R16_SSCALED                = 73,
  VK_FORMAT_R16_UINT                   = 74,
  VK_FORMAT_R16_SINT                   = 75,
  VK_FORMAT_R16_SFLOAT                 = 76,
  VK_FORMAT_R16G16_UNORM               = 77,
  VK_FORMAT_R16G16_SNORM               = 78,
  VK_FORMAT_R16G16_USCALED             = 79,
  VK_FORMAT_R16G16_SSCALED             = 80,
  VK_FORMAT_R16G16_UINT                = 81,
  VK_FORMAT_R16G16_SINT                = 82,
  VK_FORMAT_R16G16_SFLOAT              = 83,
  VK_FORMAT_R16G16B16_UNORM            = 84,
  VK_FORMAT_R16G16B16_SNORM            = 85,
  VK_FORMAT_R16G16B16_USCALED          = 86,
  VK_FORMAT_R16G16B16_SSCALED          = 87,
  VK_FORMAT_R16G16B16_UINT             = 88,
  VK_FORMAT_R16G16B16_SINT             = 89,
  VK_FORMAT_R16G16B16_SFLOAT           = 90,
  VK_FORMAT_R16G16B16A16_UNORM         = 91,
  VK_FORMAT_R16G16B16A16_SNORM         = 92,
  VK_FORMAT_R16G16B16A16_USCALED       = 93,
  VK_FORMAT_R16G16B16A16_SSCALED       = 94,
  VK_FORMAT_R16G16B16A16_UINT          = 95,
  VK_FORMAT_R16G16B16A16_SINT          = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT        = 97,
  VK_FORMAT_R32_UINT                   = 98,
  VK_FORMAT_R32_SINT                   = 99,
  VK_FORMAT_R32_SFLOAT                 = 100,
  VK_FORMAT_R32G32_UINT                = 101,
  VK_FORMAT_R32G32_SINT                = 102,
  VK_FORMAT_R32G32_SFLOAT              = 103,
  VK_FORMAT_R32G32B32_UINT             = 104,
  VK_FORMAT_R32G32B32_SINT             = 105,
  VK_FORMAT_R32G32B32_SFLOAT           = 106,
  VK_FORMAT_R32G32B32A32_UINT          = 107,
  VK_FORMAT_R32G32B32A32_SINT          = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT        = 109,
  VK_FORMAT_R64_UINT                   = 110,
  VK_FORMAT_R64_SINT                   = 111,
  VK_FORMAT_R64_SFLOAT                 = 112,
  VK_FORMAT_R64G64_UINT                = 113,
  VK_FORMAT_R64G64_SINT                = 114,
  VK_FORMAT_R64G64_SFLOAT              = 115,
  VK_FORMAT_R64G64B64_UINT             = 116,
  VK_FORMAT_R64G64B64_SINT             = 117,
  VK_FORMAT_R64G64B64_SFLOAT           = 118,
  VK_FORMAT_R64G64B64A64_UINT          = 119,
  VK_FORMAT_R64G64B64A64_SINT          = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT        = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32    = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32     = 123,
  VK_FORMAT_D16_UNORM                  = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32        = 125,
  VK_FORMAT_D32_SFLOAT                 = 126,
  VK_FORMAT_S8_UINT                    = 127,
  VK_FORMAT_D16_UNORM_S8_UINT          = 128,
  VK_FORMAT_D24_UNORM_S8_UINT          = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT         = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK        = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK         = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK       = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK        = 134,
  VK_FORMAT_BC2_UNORM_BLOCK            = 135,
  VK_FORMAT_BC2_SRGB_BLOCK             = 136,
  VK_FORMAT_BC3_UNORM_BLOCK            = 137,
  VK_FORMAT_BC3_SRGB_BLOCK             = 138,
  VK_FORMAT_BC4_UNORM_BLOCK            = 139,
  VK_FORMAT_BC4_SNORM_BLOCK            = 140,
  VK_FORMAT_BC5_UNORM_BLOCK            = 141,
  VK_FORMAT_BC5_SNORM_BLOCK            = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK          = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK          = 144,
  VK_FORMAT_BC7_UNORM_BLOCK            = 145,
  VK_FORMAT_BC7_SRGB_BLOCK             = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK    = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK     = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK  = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK   = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK  = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK   = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK        = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK        = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK     = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK     = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK       = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK        = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK       = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK        = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK       = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK        = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK       = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK        = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK       = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK        = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK       = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK        = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK       = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK        = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK       = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK        = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK      = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK       = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK      = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK       = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK      = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK       = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK     = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK      = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK     = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK      = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK     = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK      = 184,
}

enum VkImageType {
  VK_IMAGE_TYPE_1D = 0x00000000,
  VK_IMAGE_TYPE_2D = 0x00000001,
  VK_IMAGE_TYPE_3D = 0x00000002,
}

enum VkImageTiling {
  VK_IMAGE_TILING_OPTIMAL = 0x00000000,
  VK_IMAGE_TILING_LINEAR  = 0x00000001,
}

enum VkPhysicalDeviceType {
  VK_PHYSICAL_DEVICE_TYPE_OTHER          = 0x00000000,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 0x00000001,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   = 0x00000002,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    = 0x00000003,
  VK_PHYSICAL_DEVICE_TYPE_CPU            = 0x00000004,
}

enum VkQueryType {
  VK_QUERY_TYPE_OCCLUSION           = 0x00000000,
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 0x00000001, /// Optional
  VK_QUERY_TYPE_TIMESTAMP           = 0x00000002,
}

enum VkSharingMode {
  VK_SHARING_MODE_EXCLUSIVE  = 0x00000000,
  VK_SHARING_MODE_CONCURRENT = 0x00000001,
}

enum VkImageLayout {
  VK_IMAGE_LAYOUT_UNDEFINED                        = 0x00000000, /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
  VK_IMAGE_LAYOUT_GENERAL                          = 0x00000001, /// General layout when image can be used for any kind of access
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL         = 0x00000002, /// Optimal layout when image is only used for color attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 0x00000003, /// Optimal layout when image is only used for depth/stencil attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL  = 0x00000004, /// Optimal layout when image is used for read only depth/stencil attachment and shader access
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL         = 0x00000005, /// Optimal layout when image is used for read only shader access
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL             = 0x00000006, /// Optimal layout when image is used only as source of transfer operations
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL             = 0x00000007, /// Optimal layout when image is used only as destination of transfer operations
  VK_IMAGE_LAYOUT_PREINITIALIZED                   = 0x00000008, /// Initial layout used when the data is populated by the CPU

  //@extension("VK_KHR_swapchain")
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
}

enum VkImageViewType {
  VK_IMAGE_VIEW_TYPE_1D         = 0x00000000,
  VK_IMAGE_VIEW_TYPE_2D         = 0x00000001,
  VK_IMAGE_VIEW_TYPE_3D         = 0x00000002,
  VK_IMAGE_VIEW_TYPE_CUBE       = 0x00000003,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY   = 0x00000004,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY   = 0x00000005,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 0x00000006,
}

enum VkComponentSwizzle {
  VK_COMPONENT_SWIZZLE_IDENTITY = 0x00000000,
  VK_COMPONENT_SWIZZLE_ZERO     = 0x00000001,
  VK_COMPONENT_SWIZZLE_ONE      = 0x00000002,
  VK_COMPONENT_SWIZZLE_R        = 0x00000003,
  VK_COMPONENT_SWIZZLE_G        = 0x00000004,
  VK_COMPONENT_SWIZZLE_B        = 0x00000005,
  VK_COMPONENT_SWIZZLE_A        = 0x00000006,
}

enum VkVertexInputRate {
  VK_VERTEX_INPUT_RATE_VERTEX   = 0x00000000,
  VK_VERTEX_INPUT_RATE_INSTANCE = 0x00000001,
}

enum VkPrimitiveTopology {
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST                    = 0x00000000,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST                     = 0x00000001,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                    = 0x00000002,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 = 0x00000003,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                = 0x00000004,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  = 0x00000005,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      = 0x00000006,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     = 0x00000007,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  = 0x00000008,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 0x00000009,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    = 0x0000000a,
}

enum VkPolygonMode {
  VK_POLYGON_MODE_FILL  = 0x00000000,
  VK_POLYGON_MODE_LINE  = 0x00000001,
  VK_POLYGON_MODE_POINT = 0x00000002,
}

enum VkFrontFace {
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0x00000000,
  VK_FRONT_FACE_CLOCKWISE         = 0x00000001,
}

enum VkCompareOp {
  VK_COMPARE_OP_NEVER            = 0x00000000,
  VK_COMPARE_OP_LESS             = 0x00000001,
  VK_COMPARE_OP_EQUAL            = 0x00000002,
  VK_COMPARE_OP_LESS_OR_EQUAL    = 0x00000003,
  VK_COMPARE_OP_GREATER          = 0x00000004,
  VK_COMPARE_OP_NOT_EQUAL        = 0x00000005,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 0x00000006,
  VK_COMPARE_OP_ALWAYS           = 0x00000007,
}

enum VkStencilOp {
  VK_STENCIL_OP_KEEP                = 0x00000000,
  VK_STENCIL_OP_ZERO                = 0x00000001,
  VK_STENCIL_OP_REPLACE             = 0x00000002,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 0x00000003,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 0x00000004,
  VK_STENCIL_OP_INVERT              = 0x00000005,
  VK_STENCIL_OP_INCREMENT_AND_WRAP  = 0x00000006,
  VK_STENCIL_OP_DECREMENT_AND_WRAP  = 0x00000007,
}

enum VkLogicOp {
  VK_LOGIC_OP_CLEAR         = 0x00000000,
  VK_LOGIC_OP_AND           = 0x00000001,
  VK_LOGIC_OP_AND_REVERSE   = 0x00000002,
  VK_LOGIC_OP_COPY          = 0x00000003,
  VK_LOGIC_OP_AND_INVERTED  = 0x00000004,
  VK_LOGIC_OP_NO_OP         = 0x00000005,
  VK_LOGIC_OP_XOR           = 0x00000006,
  VK_LOGIC_OP_OR            = 0x00000007,
  VK_LOGIC_OP_NOR           = 0x00000008,
  VK_LOGIC_OP_EQUIVALENT    = 0x00000009,
  VK_LOGIC_OP_INVERT        = 0x0000000a,
  VK_LOGIC_OP_OR_REVERSE    = 0x0000000b,
  VK_LOGIC_OP_COPY_INVERTED = 0x0000000c,
  VK_LOGIC_OP_OR_INVERTED   = 0x0000000d,
  VK_LOGIC_OP_NAND          = 0x0000000e,
  VK_LOGIC_OP_SET           = 0x0000000f,
}

enum VkBlendFactor {
  VK_BLEND_FACTOR_ZERO                     = 0x00000000,
  VK_BLEND_FACTOR_ONE                      = 0x00000001,
  VK_BLEND_FACTOR_SRC_COLOR                = 0x00000002,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      = 0x00000003,
  VK_BLEND_FACTOR_DST_COLOR                = 0x00000004,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      = 0x00000005,
  VK_BLEND_FACTOR_SRC_ALPHA                = 0x00000006,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      = 0x00000007,
  VK_BLEND_FACTOR_DST_ALPHA                = 0x00000008,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      = 0x00000009,
  VK_BLEND_FACTOR_CONSTANT_COLOR           = 0x0000000a,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 0x0000000b,
  VK_BLEND_FACTOR_CONSTANT_ALPHA           = 0x0000000c,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 0x0000000d,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       = 0x0000000e,
  VK_BLEND_FACTOR_SRC1_COLOR               = 0x0000000f,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     = 0x00000010,
  VK_BLEND_FACTOR_SRC1_ALPHA               = 0x00000011,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     = 0x00000012,
}

enum VkBlendOp {
  VK_BLEND_OP_ADD              = 0x00000000,
  VK_BLEND_OP_SUBTRACT         = 0x00000001,
  VK_BLEND_OP_REVERSE_SUBTRACT = 0x00000002,
  VK_BLEND_OP_MIN              = 0x00000003,
  VK_BLEND_OP_MAX              = 0x00000004,
}

enum VkDynamicState {
  VK_DYNAMIC_STATE_VIEWPORT             = 0x00000000,
  VK_DYNAMIC_STATE_SCISSOR              = 0x00000001,
  VK_DYNAMIC_STATE_LINE_WIDTH           = 0x00000002,
  VK_DYNAMIC_STATE_DEPTH_BIAS           = 0x00000003,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS      = 0x00000004,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS         = 0x00000005,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 0x00000006,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK   = 0x00000007,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE    = 0x00000008,
}

enum VkFilter {
  VK_FILTER_NEAREST   = 0x00000000,
  VK_FILTER_LINEAR    = 0x00000001,
  VK_FILTER_CUBIC_IMG = 0x3B9B0498
}

enum VkSamplerMipmapMode {
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0x00000000, /// Choose nearest mip level
  VK_SAMPLER_MIPMAP_MODE_LINEAR  = 0x00000001, /// Linear filter between mip levels
}

enum VkSamplerAddressMode {
  VK_SAMPLER_ADDRESS_MODE_REPEAT               = 0x00000000,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      = 0x00000001,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        = 0x00000002,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      = 0x00000003,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 0x00000004,
}

enum VkBorderColor {
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0x00000000,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   = 0x00000001,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      = 0x00000002,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK        = 0x00000003,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      = 0x00000004,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE        = 0x00000005,
}

// NOTE: when updating this enum, be sure to update vkUpdateDescriptorSets
// in sync.
enum VkDescriptorType {
  VK_DESCRIPTOR_TYPE_SAMPLER                = 0x00000000,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 0x00000001,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE          = 0x00000002,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          = 0x00000003,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   = 0x00000004,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   = 0x00000005,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         = 0x00000006,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         = 0x00000007,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 0x00000008,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 0x00000009,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT       = 0x0000000a,
}

enum VkAttachmentLoadOp {
  VK_ATTACHMENT_LOAD_OP_LOAD      = 0x00000000,
  VK_ATTACHMENT_LOAD_OP_CLEAR     = 0x00000001,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 0x00000002,
}

enum VkAttachmentStoreOp {
  VK_ATTACHMENT_STORE_OP_STORE     = 0x00000000,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 0x00000001,
}

enum VkPipelineBindPoint {
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0x00000000,
  VK_PIPELINE_BIND_POINT_COMPUTE  = 0x00000001,
}

enum VkCommandBufferLevel {
  VK_COMMAND_BUFFER_LEVEL_PRIMARY   = 0x00000000,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 0x00000001,
}

enum VkIndexType {
  VK_INDEX_TYPE_UINT16 = 0x00000000,
  VK_INDEX_TYPE_UINT32 = 0x00000001,
}

enum VkSubpassContents {
  VK_SUBPASS_CONTENTS_INLINE                    = 0x00000000,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 0x00000001,
}



/////////////////
//  Bitfields  //
/////////////////

@reserved_flags
type VkFlags VkInstanceCreateFlags

/// Format capability flags
@unused
bitfield VkFormatFeatureFlagBits {
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                  = 0x00000001, /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                  = 0x00000002, /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT           = 0x00000004, /// Format supports atomic operations in case it's used for storage images
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT           = 0x00000008, /// Format can be used for uniform texel buffers (TBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT           = 0x00000010, /// Format can be used for storage texel buffers (IBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT    = 0x00000020, /// Format supports atomic operations in case it's used for storage texel buffers
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                  = 0x00000040, /// Format can be used for vertex buffers (VBOs)
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT               = 0x00000080, /// Format can be used for color attachment images
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT         = 0x00000100, /// Format supports blending in case it's used for color attachment images
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT       = 0x00000200, /// Format can be used for depth/stencil attachment images
  VK_FORMAT_FEATURE_BLIT_SRC_BIT                       = 0x00000400, /// Format can be used as the source image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_BLIT_DST_BIT                       = 0x00000800, /// Format can be used as the destination image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT    = 0x00001000,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
}
type VkFlags VkFormatFeatureFlags

/// Image usage flags
@unused
bitfield VkImageUsageFlagBits {
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT             = 0x00000001, /// Can be used as a source of transfer operations
  VK_IMAGE_USAGE_TRANSFER_DST_BIT             = 0x00000002, /// Can be used as a destination of transfer operations
  VK_IMAGE_USAGE_SAMPLED_BIT                  = 0x00000004, /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_IMAGE_USAGE_STORAGE_BIT                  = 0x00000008, /// Can be used as storage image (STORAGE_IMAGE descriptor type)
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT         = 0x00000010, /// Can be used as framebuffer color attachment
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020, /// Can be used as framebuffer depth/stencil attachment
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     = 0x00000040, /// Image data not needed outside of rendering
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         = 0x00000080, /// Can be used as framebuffer input attachment
}
type VkFlags VkImageUsageFlags

/// Image creation flags
@unused
bitfield VkImageCreateFlagBits {
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Image should support sparse backing
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Image should support sparse backing with partial residency
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT   = 0x00000008, /// Allows image views to have different format than the base image
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT  = 0x00000010, /// Allows creating image views with cube type from the created image
}
type VkFlags VkImageCreateFlags

bitfield VkSampleCountFlagBits {
  VK_SAMPLE_COUNT_1_BIT  = 0x00000001,
  VK_SAMPLE_COUNT_2_BIT  = 0x00000002,
  VK_SAMPLE_COUNT_4_BIT  = 0x00000004,
  VK_SAMPLE_COUNT_8_BIT  = 0x00000008,
  VK_SAMPLE_COUNT_16_BIT = 0x00000010,
  VK_SAMPLE_COUNT_32_BIT = 0x00000020,
  VK_SAMPLE_COUNT_64_BIT = 0x00000040,
}
type VkFlags VkSampleCountFlags

bitfield VkQueueFlagBits {
  VK_QUEUE_GRAPHICS_BIT       = 0x00000001, /// Queue supports graphics operations
  VK_QUEUE_COMPUTE_BIT        = 0x00000002, /// Queue supports compute operations
  VK_QUEUE_TRANSFER_BIT       = 0x00000004, /// Queue supports transfer operations
  VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008, /// Queue supports sparse resource memory management operations
}
type VkFlags VkQueueFlags

bitfield VkMemoryPropertyFlagBits {
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT     = 0x00000001,
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT     = 0x00000002,
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT    = 0x00000004,
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT      = 0x00000008,
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
}
type VkFlags VkMemoryPropertyFlags

@unused
bitfield VkMemoryHeapFlagBits {
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
}
type VkFlags VkMemoryHeapFlags
@reserved_flags
type VkFlags VkDeviceCreateFlags
@reserved_flags
type VkFlags VkDeviceQueueCreateFlags

/// Pipeline stages
bitfield VkPipelineStageFlagBits {
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                    = 0x00000001, /// Before subsequent commands are processed
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  = 0x00000002, /// Draw/DispatchIndirect command fetch
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   = 0x00000004, /// Vertex/index fetch
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  = 0x00000008, /// Vertex shading
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    = 0x00000010, /// Tessellation control shading
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, /// Tessellation evaluation shading
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                = 0x00000040, /// Geometry shading
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                = 0x00000080, /// Fragment shading
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           = 0x00000100, /// Early fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            = 0x00000200, /// Late fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        = 0x00000400, /// Color attachment writes
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                 = 0x00000800, /// Compute shading
  VK_PIPELINE_STAGE_TRANSFER_BIT                       = 0x00001000, /// Transfer/copy operations
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 = 0x00002000,
  VK_PIPELINE_STAGE_HOST_BIT                           = 0x00004000, /// Indicates host (CPU) is a source/sink of the dependency
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                   = 0x00008000, /// All stages of the graphics pipeline
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                   = 0x00010000, /// All graphics, compute, copy, and transition commands
}
type VkFlags VkPipelineStageFlags
@reserved_flags
type VkFlags VkMemoryMapFlags

bitfield VkImageAspectFlagBits {
  VK_IMAGE_ASPECT_COLOR_BIT    = 0x00000001,
  VK_IMAGE_ASPECT_DEPTH_BIT    = 0x00000002,
  VK_IMAGE_ASPECT_STENCIL_BIT  = 0x00000004,
  VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
}
type VkFlags VkImageAspectFlags

@unused
bitfield VkSparseImageFormatFlagBits {
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         = 0x00000001, /// Image uses a single miptail region for all array slices
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       = 0x00000002, /// Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels.
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004, /// Image uses a non-standard sparse block size
}
type VkFlags VkSparseImageFormatFlags

@unused
bitfield VkSparseMemoryBindFlagBits {
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
}
type VkFlags VkSparseMemoryBindFlags

bitfield VkFenceCreateFlagBits {
  VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
}
type VkFlags VkFenceCreateFlags
@reserved_flags
type VkFlags VkSemaphoreCreateFlags
@reserved_flags
type VkFlags VkEventCreateFlags
@reserved_flags
type VkFlags VkQueryPoolCreateFlags

@unused
bitfield VkQueryPipelineStatisticFlagBits {
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    = 0x00000001, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  = 0x00000002, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  = 0x00000004, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                = 0x00000008, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 = 0x00000010, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       = 0x00000020, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        = 0x00000040, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                = 0x00000080, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        = 0x00000100, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 = 0x00000400, /// Optional
}
type VkFlags VkQueryPipelineStatisticFlags

@unused
bitfield VkQueryResultFlagBits {
  VK_QUERY_RESULT_64_BIT                = 0x00000001, /// Results of the queries are written to the destination buffer as 64-bit values
  VK_QUERY_RESULT_WAIT_BIT              = 0x00000002, /// Results of the queries are waited on before proceeding with the result copy
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004, /// Besides the results of the query, the availability of the results is also written
  VK_QUERY_RESULT_PARTIAL_BIT           = 0x00000008, /// Copy the partial results of the query even if the final results aren't available
}
type VkFlags VkQueryResultFlags

@unused
bitfield VkBufferCreateFlagBits {
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Buffer should support sparse backing
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Buffer should support sparse backing with partial residency
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers
}
type VkFlags VkBufferCreateFlags

type VkFlags VkBufferUsageFlags
@unused
bitfield VkBufferUsageFlagBits {
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT         = 0x00000001, /// Can be used as a source of transfer operations
  VK_BUFFER_USAGE_TRANSFER_DST_BIT         = 0x00000002, /// Can be used as a destination of transfer operations
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004, /// Can be used as TBO
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008, /// Can be used as IBO
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT       = 0x00000010, /// Can be used as UBO
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT       = 0x00000020, /// Can be used as SSBO
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT         = 0x00000040, /// Can be used as source of fixed function index fetch (index buffer)
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT        = 0x00000080, /// Can be used as source of fixed function vertex fetch (VBO)
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT      = 0x00000100, /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
}
@reserved_flags
type VkFlags VkBufferViewCreateFlags
@reserved_flags
type VkFlags VkImageViewCreateFlags
@reserved_flags
type VkFlags VkShaderModuleCreateFlags
@reserved_flags
type VkFlags VkPipelineCacheCreateFlags

@unused
bitfield VkPipelineCreateFlagBits {
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT    = 0x00000002,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT           = 0x00000004,
}
type VkFlags VkPipelineCreateFlags
@reserved_flags
type VkFlags VkPipelineShaderStageCreateFlags


bitfield VkShaderStageFlagBits {
  VK_SHADER_STAGE_VERTEX_BIT                  = 0x00000001,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT    = 0x00000002,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
  VK_SHADER_STAGE_GEOMETRY_BIT                = 0x00000008,
  VK_SHADER_STAGE_FRAGMENT_BIT                = 0x00000010,
  VK_SHADER_STAGE_COMPUTE_BIT                 = 0x00000020,
  VK_SHADER_STAGE_ALL_GRAPHICS                = 0x0000001F,
  VK_SHADER_STAGE_ALL                         = 0x7FFFFFFF,
}
type VkFlags VkShaderStageFlags
@reserved_flags
type VkFlags VkPipelineVertexInputStateCreateFlags
@reserved_flags
type VkFlags VkPipelineInputAssemblyStateCreateFlags
@reserved_flags
type VkFlags VkPipelineTessellationStateCreateFlags
@reserved_flags
type VkFlags VkPipelineViewportStateCreateFlags
@reserved_flags
type VkFlags VkPipelineRasterizationStateCreateFlags


@unused
bitfield VkCullModeFlagBits {
  VK_CULL_MODE_NONE           = 0x00000000,
  VK_CULL_MODE_FRONT_BIT      = 0x00000001,
  VK_CULL_MODE_BACK_BIT       = 0x00000002,
  VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkCullModeFlags

@reserved_flags
type VkFlags VkPipelineMultisampleStateCreateFlags
@reserved_flags
type VkFlags VkPipelineDepthStencilStateCreateFlags
@reserved_flags
type VkFlags VkPipelineColorBlendStateCreateFlags

@unused
bitfield VkColorComponentFlagBits {
  VK_COLOR_COMPONENT_R_BIT = 0x00000001,
  VK_COLOR_COMPONENT_G_BIT = 0x00000002,
  VK_COLOR_COMPONENT_B_BIT = 0x00000004,
  VK_COLOR_COMPONENT_A_BIT = 0x00000008,
}
type VkFlags VkColorComponentFlags

@reserved_flags
type VkFlags VkPipelineDynamicStateCreateFlags
@reserved_flags
type VkFlags VkPipelineLayoutCreateFlags
@reserved_flags
type VkFlags VkSamplerCreateFlags
@reserved_flags
type VkFlags VkDescriptorSetLayoutCreateFlags

@unused
bitfield VkDescriptorPoolCreateFlagBits {
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
}
type VkFlags VkDescriptorPoolCreateFlags

@reserved_flags
type VkFlags VkDescriptorPoolResetFlags
@reserved_flags
type VkFlags VkFramebufferCreateFlags
@reserved_flags
type VkFlags VkRenderPassCreateFlags

@unused
bitfield VkAttachmentDescriptionFlagBits {
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001, /// The attachment may alias physical memory of another attachment in the same renderpass
}
type VkFlags VkAttachmentDescriptionFlags

@reserved_flags
type VkFlags VkSubpassDescriptionFlags


@unused
bitfield VkAccessFlagBits {
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT          = 0x00000001,
  VK_ACCESS_INDEX_READ_BIT                     = 0x00000002,
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT          = 0x00000004,
  VK_ACCESS_UNIFORM_READ_BIT                   = 0x00000008,
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT          = 0x00000010,
  VK_ACCESS_SHADER_READ_BIT                    = 0x00000020,
  VK_ACCESS_SHADER_WRITE_BIT                   = 0x00000040,
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT          = 0x00000080,
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT         = 0x00000100,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT  = 0x00000200,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
  VK_ACCESS_TRANSFER_READ_BIT                  = 0x00000800,
  VK_ACCESS_TRANSFER_WRITE_BIT                 = 0x00001000,
  VK_ACCESS_HOST_READ_BIT                      = 0x00002000,
  VK_ACCESS_HOST_WRITE_BIT                     = 0x00004000,
  VK_ACCESS_MEMORY_READ_BIT                    = 0x00008000,
  VK_ACCESS_MEMORY_WRITE_BIT                   = 0x00010000,
}
type VkFlags VkAccessFlags

@unused
bitfield VkDependencyFlagBits {
  VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
}
type VkFlags VkDependencyFlags

@unused
bitfield VkCommandPoolCreateFlagBits {
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT            = 0x00000001, /// Command buffers have a short lifetime
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002, /// Command buffers may release their memory individually
}
type VkFlags VkCommandPoolCreateFlags

@unused
bitfield VkCommandPoolResetFlagBits {
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the pool
}
type VkFlags VkCommandPoolResetFlags

@unused
bitfield VkCommandBufferUsageFlagBits {
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      = 0x00000001,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     = 0x00000004,
}
type VkFlags VkCommandBufferUsageFlags

@unused
bitfield VkQueryControlFlagBits {
  VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
}
type VkFlags VkQueryControlFlags

@unused
bitfield VkCommandBufferResetFlagBits {
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the buffer
}
type VkFlags VkCommandBufferResetFlags

@unused
bitfield VkStencilFaceFlagBits {
  VK_STENCIL_FACE_FRONT_BIT = 0x00000001, /// Front face
  VK_STENCIL_FACE_BACK_BIT  = 0x00000002, /// Back face
  VK_STENCIL_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkStencilFaceFlags



// Function pointers. TODO: add support for function pointers.

@external type void* PFN_vkAllocationFunction
@pfn cmd void* vkAllocationFunction(
    void*                   pUserData,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkReallocationFunction
@pfn cmd void* vkReallocationFunction(
    void*                   pUserData,
    void*                   pOriginal,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkFreeFunction
@pfn cmd void vkFreeFunction(
    void* pUserData,
    void* pMemory) {
}

@external type void* PFN_vkInternalAllocationNotification
@pfn cmd void vkInternalAllocationNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkInternalFreeNotification
@pfn cmd void vkInternalFreeNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkVoidFunction
@pfn cmd void vkVoidFunction() {
}

@serialize
class VkApplicationInfo {
  VkStructureType sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO
  const void*     pNext              /// Next structure in chain
  const char*     pApplicationName
  u32             applicationVersion
  const char*     pEngineName
  u32             engineVersion
  u32             apiVersion
}

@serialize
class VkInstanceCreateInfo {
  VkStructureType          sType                   /// Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
  const void*              pNext                   /// Pointer to next structure
  VkInstanceCreateFlags    flags
  const VkApplicationInfo* pApplicationInfo
  u32                      enabledLayerCount
  const char* const*       ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                      enabledExtensionCount
  const char* const*       ppEnabledExtensionNames /// Extension names to be enabled
}

@serialize
class VkAllocationCallbacks {
  void*                                pUserData
  PFN_vkAllocationFunction             pfnAllocation
  PFN_vkReallocationFunction           pfnReallocation
  PFN_vkFreeFunction                   pfnFree
  PFN_vkInternalAllocationNotification pfnInternalAllocation
  PFN_vkInternalFreeNotification       pfnInternalFree
}

@serialize
class VkPhysicalDeviceFeatures {
  VkBool32 robustBufferAccess                      /// out of bounds buffer accesses are well defined
  VkBool32 fullDrawIndexUint32                     /// full 32-bit range of indices for indexed draw calls
  VkBool32 imageCubeArray                          /// image views which are arrays of cube maps
  VkBool32 independentBlend                        /// blending operations are controlled per-attachment
  VkBool32 geometryShader                          /// geometry stage
  VkBool32 tessellationShader                      /// tessellation control and evaluation stage
  VkBool32 sampleRateShading                       /// per-sample shading and interpolation
  VkBool32 dualSrcBlend                            /// blend operations which take two sources
  VkBool32 logicOp                                 /// logic operations
  VkBool32 multiDrawIndirect                       /// multi draw indirect
  VkBool32 drawIndirectFirstInstance
  VkBool32 depthClamp                              /// depth clamping
  VkBool32 depthBiasClamp                          /// depth bias clamping
  VkBool32 fillModeNonSolid                        /// point and wireframe fill modes
  VkBool32 depthBounds                             /// depth bounds test
  VkBool32 wideLines                               /// lines with width greater than 1
  VkBool32 largePoints                             /// points with size greater than 1
  VkBool32 alphaToOne                              /// The fragment alpha channel can be forced to maximum representable alpha value
  VkBool32 multiViewport
  VkBool32 samplerAnisotropy
  VkBool32 textureCompressionETC2                  /// ETC texture compression formats
  VkBool32 textureCompressionASTC_LDR              /// ASTC LDR texture compression formats
  VkBool32 textureCompressionBC                    /// BC1-7 texture compressed formats
  VkBool32 occlusionQueryPrecise
  VkBool32 pipelineStatisticsQuery                 /// pipeline statistics query
  VkBool32 vertexPipelineStoresAndAtomics
  VkBool32 fragmentStoresAndAtomics
  VkBool32 shaderTessellationAndGeometryPointSize
  VkBool32 shaderImageGatherExtended               /// texture gather with run-time values and independent offsets
  VkBool32 shaderStorageImageExtendedFormats       /// the extended set of formats can be used for storage images
  VkBool32 shaderStorageImageMultisample           /// multisample images can be used for storage images
  VkBool32 shaderStorageImageReadWithoutFormat
  VkBool32 shaderStorageImageWriteWithoutFormat
  VkBool32 shaderUniformBufferArrayDynamicIndexing /// arrays of uniform buffers can be accessed with dynamically uniform indices
  VkBool32 shaderSampledImageArrayDynamicIndexing  /// arrays of sampled images can be accessed with dynamically uniform indices
  VkBool32 shaderStorageBufferArrayDynamicIndexing /// arrays of storage buffers can be accessed with dynamically uniform indices
  VkBool32 shaderStorageImageArrayDynamicIndexing  /// arrays of storage images can be accessed with dynamically uniform indices
  VkBool32 shaderClipDistance                      /// clip distance in shaders
  VkBool32 shaderCullDistance                      /// cull distance in shaders
  VkBool32 shaderFloat64                           /// 64-bit floats (doubles) in shaders
  VkBool32 shaderInt64                             /// 64-bit integers in shaders
  VkBool32 shaderInt16                             /// 16-bit integers in shaders
  VkBool32 shaderResourceResidency                 /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
  VkBool32 shaderResourceMinLod                    /// shader can use texture operations that specify minimum resource LOD
  VkBool32 sparseBinding                           /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
  VkBool32 sparseResidencyBuffer                   /// Sparse resources support: GPU can access partially resident buffers
  VkBool32 sparseResidencyImage2D                  /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images
  VkBool32 sparseResidencyImage3D                  /// Sparse resources support: GPU can access partially resident 3D images
  VkBool32 sparseResidency2Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
  VkBool32 sparseResidency4Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
  VkBool32 sparseResidency8Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
  VkBool32 sparseResidency16Samples                /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
  VkBool32 sparseResidencyAliased                  /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
  VkBool32 variableMultisampleRate
  VkBool32 inheritedQueries
}

@serialize
class VkFormatProperties {
  VkFormatFeatureFlags linearTilingFeatures  /// Format features in case of linear tiling
  VkFormatFeatureFlags optimalTilingFeatures /// Format features in case of optimal tiling
  VkFormatFeatureFlags bufferFeatures        /// Format features supported by buffers
}

@serialize
class VkExtent3D {
  u32 Width
  u32 Height
  u32 Depth
}

@serialize
class VkImageFormatProperties {
  VkExtent3D         maxExtent       /// max image dimensions for this resource type
  u32                maxMipLevels    /// max number of mipmap levels for this resource type
  u32                maxArrayLayers  /// max array layers for this resource type
  VkSampleCountFlags sampleCounts    /// supported sample counts for this resource type
  VkDeviceSize       maxResourceSize /// max size (in bytes) of this resource type
}

@serialize
class VkPhysicalDeviceLimits {
  /// resource maximum sizes
  u32 maxImageDimension1D    /// max 1D image dimension
  u32 maxImageDimension2D    /// max 2D image dimension
  u32 maxImageDimension3D    /// max 3D image dimension
  u32 maxImageDimensionCube  /// max cubemap image dimension
  u32 maxImageArrayLayers    /// max layers for image arrays
  u32 maxTexelBufferElements
  u32 maxUniformBufferRange  /// max uniform buffer size (bytes)
  u32 maxStorageBufferRange  /// max storage buffer size (bytes)
  u32 maxPushConstantsSize   /// max size of the push constants pool (bytes)
  /// memory limits
  u32          maxMemoryAllocationCount  /// max number of device memory allocations supported
  u32          maxSamplerAllocationCount
  VkDeviceSize bufferImageGranularity    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
  VkDeviceSize sparseAddressSpaceSize    /// Total address space available for sparse allocations (bytes)
  /// descriptor set limits
  u32 maxBoundDescriptorSets                /// max number of descriptors sets that can be bound to a pipeline
  u32 maxPerStageDescriptorSamplers         /// max num of samplers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorUniformBuffers   /// max num of uniform buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageBuffers   /// max num of storage buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorSampledImages    /// max num of sampled images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageImages    /// max num of storage images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorInputAttachments
  u32 maxPerStageResources
  u32 maxDescriptorSetSamplers              /// max num of samplers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffers        /// max num of uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffersDynamic /// max num of dynamic uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffers        /// max num of storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffersDynamic /// max num of dynamic storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetSampledImages         /// max num of sampled images allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageImages         /// max num of storage images allowed in all stages in a descriptor set
  u32 maxDescriptorSetInputAttachments
  /// vertex stage limits
  u32 maxVertexInputAttributes      /// max num of vertex input attribute slots
  u32 maxVertexInputBindings        /// max num of vertex input binding slots
  u32 maxVertexInputAttributeOffset /// max vertex input attribute offset added to vertex buffer offset
  u32 maxVertexInputBindingStride   /// max vertex input binding stride
  u32 maxVertexOutputComponents     /// max num of output components written by vertex shader
  /// tessellation control stage limits
  u32 maxTessellationGenerationLevel                  /// max level supported by tess primitive generator
  u32 maxTessellationPatchSize                        /// max patch size (vertices)
  u32 maxTessellationControlPerVertexInputComponents  /// max num of input components per-vertex in TCS
  u32 maxTessellationControlPerVertexOutputComponents /// max num of output components per-vertex in TCS
  u32 maxTessellationControlPerPatchOutputComponents  /// max num of output components per-patch in TCS
  u32 maxTessellationControlTotalOutputComponents     /// max total num of per-vertex and per-patch output components in TCS
  u32 maxTessellationEvaluationInputComponents        /// max num of input components per vertex in TES
  u32 maxTessellationEvaluationOutputComponents       /// max num of output components per vertex in TES
  /// geometry stage limits
  u32 maxGeometryShaderInvocations     /// max invocation count supported in geometry shader
  u32 maxGeometryInputComponents       /// max num of input components read in geometry stage
  u32 maxGeometryOutputComponents      /// max num of output components written in geometry stage
  u32 maxGeometryOutputVertices        /// max num of vertices that can be emitted in geometry stage
  u32 maxGeometryTotalOutputComponents /// max total num of components (all vertices) written in geometry stage
  /// fragment stage limits
  u32 maxFragmentInputComponents         /// max num of input compontents read in fragment stage
  u32 maxFragmentOutputAttachments       /// max num of output attachments written in fragment stage
  u32 maxFragmentDualSrcAttachments      /// max num of output attachments written when using dual source blending
  u32 maxFragmentCombinedOutputResources /// max total num of storage buffers, storage images and output buffers
  /// compute stage limits
  u32    maxComputeSharedMemorySize     /// max total storage size of work group local storage (bytes)
  u32[3] maxComputeWorkGroupCount       /// max num of compute work groups that may be dispatched by a single command (x,y,z)
  u32    maxComputeWorkGroupInvocations /// max total compute invocations in a single local work group
  u32[3] maxComputeWorkGroupSize        /// max local size of a compute work group (x,y,z)

  u32 subPixelPrecisionBits /// num bits of subpixel precision in screen x and y
  u32 subTexelPrecisionBits /// num bits of subtexel precision
  u32 mipmapPrecisionBits   /// num bits of mipmap precision

  u32 maxDrawIndexedIndexValue /// max index value for indexed draw calls (for 32-bit indices)
  u32 maxDrawIndirectCount

  f32 maxSamplerLodBias    /// max absolute sampler level of detail bias
  f32 maxSamplerAnisotropy /// max degree of sampler anisotropy

  u32    maxViewports          /// max number of active viewports
  u32[2] maxViewportDimensions /// max viewport dimensions (x,y)
  f32[2] viewportBoundsRange   /// viewport bounds range (min,max)
  u32    viewportSubPixelBits  /// num bits of subpixel precision for viewport

  size         minMemoryMapAlignment           /// min required alignment of pointers returned by MapMemory (bytes)
  VkDeviceSize minTexelBufferOffsetAlignment   /// min required alignment for texel buffer offsets (bytes)
  VkDeviceSize minUniformBufferOffsetAlignment /// min required alignment for uniform buffer sizes and offsets (bytes)
  VkDeviceSize minStorageBufferOffsetAlignment /// min required alignment for storage buffer offsets (bytes)

  s32 minTexelOffset                  /// min texel offset for OpTextureSampleOffset
  u32 maxTexelOffset                  /// max texel offset for OpTextureSampleOffset
  s32 minTexelGatherOffset            /// min texel offset for OpTextureGatherOffset
  u32 maxTexelGatherOffset            /// max texel offset for OpTextureGatherOffset
  f32 minInterpolationOffset          /// furthest negative offset for interpolateAtOffset
  f32 maxInterpolationOffset          /// furthest positive offset for interpolateAtOffset
  u32 subPixelInterpolationOffsetBits /// num of subpixel bits for interpolateAtOffset

  u32                maxFramebufferWidth                 /// max width for a framebuffer
  u32                maxFramebufferHeight                /// max height for a framebuffer
  u32                maxFramebufferLayers                /// max layer count for a layered framebuffer
  VkSampleCountFlags framebufferColorSampleCounts
  VkSampleCountFlags framebufferDepthSampleCounts
  VkSampleCountFlags framebufferStencilSampleCounts
  VkSampleCountFlags framebufferNoAttachmentSampleCounts
  u32                maxColorAttachments                 /// max num of framebuffer color attachments

  VkSampleCountFlags sampledImageColorSampleCounts
  VkSampleCountFlags sampledImageIntegerSampleCounts
  VkSampleCountFlags sampledImageDepthSampleCounts
  VkSampleCountFlags sampledImageStencilSampleCounts
  VkSampleCountFlags storageImageSampleCounts
  u32                maxSampleMaskWords              /// max num of sample mask words
  VkBool32           timestampComputeAndGraphics

  f32 timestampPeriod

  u32 maxClipDistances                /// max number of clip distances
  u32 maxCullDistances                /// max number of cull distances
  u32 maxCombinedClipAndCullDistances /// max combined number of user clipping

  u32 discreteQueuePriorities

  f32[2]   pointSizeRange          /// range (min,max) of supported point sizes
  f32[2]   lineWidthRange          /// range (min,max) of supported line widths
  f32      pointSizeGranularity    /// granularity of supported point sizes
  f32      lineWidthGranularity    /// granularity of supported line widths
  VkBool32 strictLines
  VkBool32 standardSampleLocations

  VkDeviceSize optimalBufferCopyOffsetAlignment
  VkDeviceSize optimalBufferCopyRowPitchAlignment
  VkDeviceSize nonCoherentAtomSize
}

@serialize
class VkPhysicalDeviceSparseProperties {
  VkBool32 residencyStandard2DBlockShape            /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard2DMultisampleBlockShape /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard3DBlockShape            /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyAlignedMipSize                  /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
  VkBool32 residencyNonResidentStrict               /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

@serialize
class VkPhysicalDeviceProperties {
  u32                                    apiVersion
  u32                                    driverVersion
  u32                                    vendorID
  u32                                    deviceID
  VkPhysicalDeviceType                   deviceType
  char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName
  u8[VK_UUID_SIZE]                       pipelineCacheUUID
  VkPhysicalDeviceLimits                 limits
  VkPhysicalDeviceSparseProperties       sparseProperties
}

@serialize
class VkQueueFamilyProperties {
  VkQueueFlags queueFlags                  /// Queue flags
  u32          queueCount
  u32          timestampValidBits
  VkExtent3D   minImageTransferGranularity
}

@serialize
class VkMemoryType {
  VkMemoryPropertyFlags propertyFlags /// Memory properties of this memory type
  u32                   heapIndex     /// Index of the memory heap allocations of this memory type are taken from
}

@serialize
class VkMemoryHeap {
  VkDeviceSize      size  /// Available memory in the heap
  VkMemoryHeapFlags flags /// Flags for the heap
}

@serialize
class VkPhysicalDeviceMemoryProperties {
  u32                               memoryTypeCount
  VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes
  u32                               memoryHeapCount
  VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps
}

@serialize
class VkDeviceQueueCreateInfo {
  VkStructureType          sType            /// Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkDeviceQueueCreateFlags flags
  u32                      queueFamilyIndex
  u32                      queueCount
  const f32*               pQueuePriorities
}

@serialize
class VkDeviceCreateInfo {
  VkStructureType                 sType                   /// Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
  const void*                     pNext                   /// Pointer to next structure
  VkDeviceCreateFlags             flags
  u32                             queueCreateInfoCount
  const VkDeviceQueueCreateInfo*  pQueueCreateInfos
  u32                             enabledLayerCount
  const char* const*              ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                             enabledExtensionCount
  const char* const*              ppEnabledExtensionNames
  const VkPhysicalDeviceFeatures* pEnabledFeatures
}

@serialize
class VkExtensionProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] extensionName /// extension name
  u32                              specVersion   /// version of the extension specification implemented
}

@serialize
class VkLayerProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] layerName             /// layer name
  u32                              specVersion           /// version of the layer specification implemented
  u32                              implementationVersion /// build or release version of the layer's library
  char[VK_MAX_DESCRIPTION_SIZE]    description           /// Free-form description of the layer
}

@serialize
class VkSubmitInfo {
  VkStructureType             sType                /// Type of structure. Should be VK_STRUCTURE_TYPE_SUBMIT_INFO
  const void*                 pNext                /// Next structure in chain
  u32                         waitSemaphoreCount
  const VkSemaphore*          pWaitSemaphores
  const VkPipelineStageFlags* pWaitDstStageMask
  u32                         commandBufferCount
  const VkCommandBuffer*      pCommandBuffers
  u32                         signalSemaphoreCount
  const VkSemaphore*          pSignalSemaphores
}

@serialize
class VkMemoryAllocateInfo {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
  const void*     pNext           /// Pointer to next structure
  VkDeviceSize    allocationSize  /// Size of memory allocation
  u32             memoryTypeIndex /// Index of the of the memory type to allocate from
}

@serialize
class VkMappedMemoryRange {
  VkStructureType sType  /// Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
  const void*     pNext  /// Pointer to next structure
  VkDeviceMemory  memory /// Mapped memory object
  VkDeviceSize    offset /// Offset within the mapped memory the range starts from
  VkDeviceSize    size   /// Size of the range within the mapped memory
}

@serialize
class VkMemoryRequirements {
  VkDeviceSize size           /// Specified in bytes
  VkDeviceSize alignment      /// Specified in bytes
  u32          memoryTypeBits /// Bitfield of the allowed memory type indices into memoryTypes[] for this object
}

@serialize
class VkSparseImageFormatProperties {
  VkImageAspectFlagBits    aspectMask
  VkExtent3D               imageGranularity
  VkSparseImageFormatFlags flags
}

@serialize
class VkSparseImageMemoryRequirements {
  VkSparseImageFormatProperties formatProperties
  u32                           imageMipTailFirstLod
  VkDeviceSize                  imageMipTailSize     /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailOffset   /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailStride   /// Specified in bytes, must be a multiple of image block size / alignment
}

@serialize
class VkSparseMemoryBind {
  VkDeviceSize            resourceOffset /// Specified in bytes
  VkDeviceSize            size           /// Specified in bytes
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset   /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

@serialize
class VkSparseBufferMemoryBindInfo {
  VkBuffer                  buffer
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

@serialize
class VkSparseImageOpaqueMemoryBindInfo {
  VkImage                   image
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

@serialize
class VkImageSubresource {
  VkImageAspectFlagBits aspectMask
  u32                   mipLevel
  u32                   arrayLayer
}

@serialize
class VkOffset3D {
  s32 x
  s32 y
  s32 z
}

@serialize @unused
class VkSparseImageMemoryBind {
  VkImageSubresource      subresource
  VkOffset3D              offset
  VkExtent3D              extent
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

@serialize
class VkSparseImageMemoryBindInfo {
  VkImage                   image
  u32                       bindCount
  const VkSparseImageMemoryBind* pBinds
}

@serialize
class VkBindSparseInfo {
  VkStructureType                          sType                /// Must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
  const void*                              pNext
  u32                                      waitSemaphoreCount
  const VkSemaphore*                       pWaitSemaphores
  u32                                      bufferBindCount
  const VkSparseBufferMemoryBindInfo*      pBufferBinds
  u32                                      imageOpaqueBindCount
  const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
  u32                                      imageBindCount
  const VkSparseImageMemoryBindInfo*       pImageBinds
  u32                                      signalSemaphoreCount
  const VkSemaphore*                       pSignalSemaphores
}

@serialize
class VkFenceCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkFenceCreateFlags flags /// Fence creation flags
}

@serialize
class VkSemaphoreCreateInfo {
  VkStructureType        sType /// Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
  const void*            pNext /// Pointer to next structure
  VkSemaphoreCreateFlags flags /// Semaphore creation flags
}

@serialize
class VkEventCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkEventCreateFlags flags /// Event creation flags
}

@serialize
class VkQueryPoolCreateInfo {
  VkStructureType               sType              /// Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
  const void*                   pNext              /// Pointer to next structure
  VkQueryPoolCreateFlags        flags
  VkQueryType                   queryType
  u32                           queryCount
  VkQueryPipelineStatisticFlags pipelineStatistics /// Optional
}

@serialize
class VkBufferCreateInfo {
  VkStructureType     sType                 /// Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
  const void*         pNext                 /// Pointer to next structure.
  VkBufferCreateFlags flags                 /// Buffer creation flags
  VkDeviceSize        size                  /// Specified in bytes
  VkBufferUsageFlags  usage                 /// Buffer usage flags
  VkSharingMode       sharingMode
  u32                 queueFamilyIndexCount
  const u32*          pQueueFamilyIndices
}

@serialize
class VkBufferViewCreateInfo {
  VkStructureType         sType  /// Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
  const void*             pNext  /// Pointer to next structure.
  VkBufferViewCreateFlags flags
  VkBuffer                buffer
  VkFormat                format /// Optionally specifies format of elements
  VkDeviceSize            offset /// Specified in bytes
  VkDeviceSize            range  /// View size specified in bytes
}

@serialize
class VkImageCreateInfo {
  VkStructureType       sType                 /// Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
  const void*           pNext                 /// Pointer to next structure.
  VkImageCreateFlags    flags                 /// Image creation flags
  VkImageType           imageType
  VkFormat              format
  VkExtent3D            extent
  u32                   mipLevels
  u32                   arrayLayers
  VkSampleCountFlagBits samples
  VkImageTiling         tiling
  VkImageUsageFlags     usage                 /// Image usage flags
  VkSharingMode         sharingMode           /// Cross-queue-family sharing mode
  u32                   queueFamilyIndexCount /// Number of queue families to share across
  const u32*            pQueueFamilyIndices   /// Array of queue family indices to share across
  VkImageLayout         initialLayout         /// Initial image layout for all subresources
}

@serialize
class VkSubresourceLayout {
  VkDeviceSize offset     /// Specified in bytes
  VkDeviceSize size       /// Specified in bytes
  VkDeviceSize rowPitch   /// Specified in bytes
  VkDeviceSize arrayPitch /// Specified in bytes
  VkDeviceSize depthPitch /// Specified in bytes
}

@serialize
class VkComponentMapping {
  VkComponentSwizzle r
  VkComponentSwizzle g
  VkComponentSwizzle b
  VkComponentSwizzle a
}

@serialize
class VkImageSubresourceRange {
  VkImageAspectFlags aspectMask
  u32                baseMipLevel
  u32                levelCount
  u32                baseArrayLayer
  u32                layerCount
}

@serialize
class VkImageViewCreateInfo {
  VkStructureType         sType            /// Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
  const void*             pNext            /// Pointer to next structure
  VkImageViewCreateFlags  flags
  VkImage                 image
  VkImageViewType         viewType
  VkFormat                format
  VkComponentMapping      components
  VkImageSubresourceRange subresourceRange
}

@serialize
class VkShaderModuleCreateInfo {
  VkStructureType           sType    /// Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
  const void*               pNext    /// Pointer to next structure
  VkShaderModuleCreateFlags flags    /// Reserved
  size                      codeSize /// Specified in bytes
  const u32*                pCode    /// Binary code of size codeSize
}

@serialize
class VkPipelineCacheCreateInfo {
  VkStructureType            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
  const void*                pNext           /// Pointer to next structure
  VkPipelineCacheCreateFlags flags
  size                       initialDataSize /// Size of initial data to populate cache, in bytes
  const void*                pInitialData    /// Initial data to populate cache
}

@serialize
class VkSpecializationMapEntry {
  u32  constantID /// The SpecConstant ID specified in the BIL
  u32  offset     /// Offset of the value in the data block
  size size       /// Size in bytes of the SpecConstant
}

@serialize
class VkSpecializationInfo {
  u32                             mapEntryCount /// Number of entries in the map
  const VkSpecializationMapEntry* pMapEntries   /// Array of map entries
  size                            dataSize      /// Size in bytes of pData
  const void*                     pData         /// Pointer to SpecConstant data
}

@serialize
class VkPipelineShaderStageCreateInfo {
  VkStructureType                  sType               /// Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
  const void*                      pNext               /// Pointer to next structure
  VkPipelineShaderStageCreateFlags flags
  VkShaderStageFlagBits            stage
  VkShaderModule                   module
  const char*                      pName
  const VkSpecializationInfo*      pSpecializationInfo
}

@serialize
class VkVertexInputBindingDescription {
  u32               binding   /// Vertex buffer binding id
  u32               stride    /// Distance between vertices in bytes (0 = no advancement)
  VkVertexInputRate inputRate /// Rate at which binding is incremented
}

@serialize
class VkVertexInputAttributeDescription {
  u32      location /// location of the shader vertex attrib
  u32      binding  /// Vertex buffer binding id
  VkFormat format   /// format of source data
  u32      offset   /// Offset of first element in bytes from base of vertex
}

@serialize
class VkPipelineVertexInputStateCreateInfo {
  VkStructureType                          sType                           /// Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
  const void*                              pNext                           /// Pointer to next structure
  VkPipelineVertexInputStateCreateFlags    flags
  u32                                      vertexBindingDescriptionCount   /// number of bindings
  const VkVertexInputBindingDescription*   pVertexBindingDescriptions
  u32                                      vertexAttributeDescriptionCount /// number of attributes
  const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
}

@serialize
class VkPipelineInputAssemblyStateCreateInfo {
  VkStructureType                         sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
  const void*                             pNext                  /// Pointer to next structure
  VkPipelineInputAssemblyStateCreateFlags flags
  VkPrimitiveTopology                     topology
  VkBool32                                primitiveRestartEnable
}

@serialize
class VkPipelineTessellationStateCreateInfo {
  VkStructureType                        sType              /// Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
  const void*                            pNext              /// Pointer to next structure
  VkPipelineTessellationStateCreateFlags flags
  u32                                    patchControlPoints
}

@serialize
class VkViewport {
  f32 x
  f32 y
  f32 width
  f32 height
  f32 minDepth
  f32 maxDepth
}

@serialize
class VkOffset2D {
  s32 x
  s32 y
}

@serialize
class VkExtent2D {
  u32 Width
  u32 Height
}

@serialize
class VkRect2D {
  VkOffset2D offset
  VkExtent2D extent
}

@serialize
class VkPipelineViewportStateCreateInfo {
  VkStructureType                    sType         /// Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
  const void*                        pNext         /// Pointer to next structure
  VkPipelineViewportStateCreateFlags flags
  u32                                viewportCount
  const VkViewport*                  pViewports
  u32                                scissorCount
  const VkRect2D*                    pScissors
}

@serialize
class VkPipelineRasterizationStateCreateInfo {
  VkStructureType                         sType                   /// Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
  const void*                             pNext                   /// Pointer to next structure
  VkPipelineRasterizationStateCreateFlags flags
  VkBool32                                depthClampEnable
  VkBool32                                rasterizerDiscardEnable
  VkPolygonMode                           polygonMode             /// optional (GL45)
  VkCullModeFlags                         cullMode
  VkFrontFace                             frontFace
  VkBool32                                depthBiasEnable
  f32                                     depthBiasConstantFactor
  f32                                     depthBiasClamp
  f32                                     depthBiasSlopeFactor
  f32                                     lineWidth
}

@serialize
class VkPipelineMultisampleStateCreateInfo {
  VkStructureType                       sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
  const void*                           pNext                 /// Pointer to next structure
  VkPipelineMultisampleStateCreateFlags flags
  VkSampleCountFlagBits                 rasterizationSamples  /// Number of samples used for rasterization
  VkBool32                              sampleShadingEnable   /// optional (GL45)
  f32                                   minSampleShading      /// optional (GL45)
  const VkSampleMask*                   pSampleMask
  VkBool32                              alphaToCoverageEnable
  VkBool32                              alphaToOneEnable
}

@serialize
class VkStencilOpState {
  VkStencilOp failOp
  VkStencilOp passOp
  VkStencilOp depthFailOp
  VkCompareOp compareOp
  u32         compareMask
  u32         writeMask
  u32         reference
}

@serialize
class VkPipelineDepthStencilStateCreateInfo {
  VkStructureType                        sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
  const void*                            pNext                 /// Pointer to next structure
  VkPipelineDepthStencilStateCreateFlags flags
  VkBool32                               depthTestEnable
  VkBool32                               depthWriteEnable
  VkCompareOp                            depthCompareOp
  VkBool32                               depthBoundsTestEnable /// optional (depth_bounds_test)
  VkBool32                               stencilTestEnable
  VkStencilOpState                       front
  VkStencilOpState                       back
  f32                                    minDepthBounds
  f32                                    maxDepthBounds
}

@serialize
class VkPipelineColorBlendAttachmentState {
  VkBool32              blendEnable
  VkBlendFactor         srcColorBlendFactor
  VkBlendFactor         dstColorBlendFactor
  VkBlendOp             colorBlendOp
  VkBlendFactor         srcAlphaBlendFactor
  VkBlendFactor         dstAlphaBlendFactor
  VkBlendOp             alphaBlendOp
  VkColorComponentFlags colorWriteMask
}

@serialize
class VkPipelineColorBlendStateCreateInfo {
  VkStructureType                            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
  const void*                                pNext           /// Pointer to next structure
  VkPipelineColorBlendStateCreateFlags       flags
  VkBool32                                   logicOpEnable
  VkLogicOp                                  logicOp
  u32                                        attachmentCount /// # of pAttachments
  const VkPipelineColorBlendAttachmentState* pAttachments
  f32[4]                                     blendConstants
}

@serialize
class VkPipelineDynamicStateCreateInfo {
  VkStructureType                   sType             /// Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
  const void*                       pNext             /// Pointer to next structure
  VkPipelineDynamicStateCreateFlags flags
  u32                               dynamicStateCount
  const VkDynamicState*             pDynamicStates
}

@serialize
class VkGraphicsPipelineCreateInfo {
  VkStructureType                               sType               /// Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
  const void*                                   pNext               /// Pointer to next structure
  VkPipelineCreateFlags                         flags               /// Pipeline creation flags
  u32                                           stageCount
  const VkPipelineShaderStageCreateInfo*        pStages             /// One entry for each active shader stage
  const VkPipelineVertexInputStateCreateInfo*   pVertexInputState
  const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
  const VkPipelineTessellationStateCreateInfo*  pTessellationState
  const VkPipelineViewportStateCreateInfo*      pViewportState
  const VkPipelineRasterizationStateCreateInfo* pRasterizationState
  const VkPipelineMultisampleStateCreateInfo*   pMultisampleState
  const VkPipelineDepthStencilStateCreateInfo*  pDepthStencilState
  const VkPipelineColorBlendStateCreateInfo*    pColorBlendState
  const VkPipelineDynamicStateCreateInfo*       pDynamicState
  VkPipelineLayout                              layout              /// Interface layout of the pipeline
  VkRenderPass                                  renderPass
  u32                                           subpass
  VkPipeline                                    basePipelineHandle  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                                           basePipelineIndex   /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

@serialize
class VkComputePipelineCreateInfo {
  VkStructureType                 sType              /// Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
  const void*                     pNext              /// Pointer to next structure
  VkPipelineCreateFlags           flags              /// Pipeline creation flags
  VkPipelineShaderStageCreateInfo stage
  VkPipelineLayout                layout             /// Interface layout of the pipeline
  VkPipeline                      basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                             basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

@serialize
class VkPushConstantRange {
  VkShaderStageFlags stageFlags /// Which stages use the range
  u32                offset     /// Start of the range, in bytes
  u32                size       /// Length of the range, in bytes
}

@serialize
class VkPipelineLayoutCreateInfo {
  VkStructureType              sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
  const void*                  pNext                  /// Pointer to next structure
  VkPipelineLayoutCreateFlags  flags
  u32                          setLayoutCount         /// Number of descriptor sets interfaced by the pipeline
  const VkDescriptorSetLayout* pSetLayouts            /// Array of <setCount> number of descriptor set layout objects defining the layout of the
  u32                          pushConstantRangeCount /// Number of push-constant ranges used by the pipeline
  const VkPushConstantRange*   pPushConstantRanges    /// Array of pushConstantRangeCount number of ranges used by various shader stages
}

@serialize
class VkSamplerCreateInfo {
  VkStructureType      sType                   /// Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
  const void*          pNext                   /// Pointer to next structure
  VkSamplerCreateFlags flags
  VkFilter             magFilter               /// Filter mode for magnification
  VkFilter             minFilter               /// Filter mode for minifiation
  VkSamplerMipmapMode  mipmapMode              /// Mipmap selection mode
  VkSamplerAddressMode addressModeU
  VkSamplerAddressMode addressModeV
  VkSamplerAddressMode addressModeW
  f32                  mipLodBias
  VkBool32             anisotropyEnable
  f32                  maxAnisotropy
  VkBool32             compareEnable
  VkCompareOp          compareOp
  f32                  minLod
  f32                  maxLod
  VkBorderColor        borderColor
  VkBool32             unnormalizedCoordinates
}

@serialize
class VkDescriptorSetLayoutBinding {
  u32                binding
  VkDescriptorType   descriptorType     /// Type of the descriptors in this binding
  u32                descriptorCount    /// Number of descriptors in this binding
  VkShaderStageFlags stageFlags         /// Shader stages this binding is visible to
  const VkSampler*   pImmutableSamplers /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains <count> number of elements)
}

@serialize
class VkDescriptorSetLayoutCreateInfo {
  VkStructureType                     sType        /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
  const void*                         pNext        /// Pointer to next structure
  VkDescriptorSetLayoutCreateFlags    flags
  u32                                 bindingCount /// Number of bindings in the descriptor set layout
  const VkDescriptorSetLayoutBinding* pBindings    /// Array of descriptor set layout bindings
}

@serialize
class VkDescriptorPoolSize {
  VkDescriptorType type
  u32              descriptorCount
}

@serialize
class VkDescriptorPoolCreateInfo {
  VkStructureType             sType         /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
  const void*                 pNext         /// Pointer to next structure
  VkDescriptorPoolCreateFlags flags
  u32                         maxSets
  u32                         poolSizeCount
  const VkDescriptorPoolSize* pPoolSizes
}

@serialize
class VkDescriptorSetAllocateInfo {
  VkStructureType              sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
  const void*                  pNext              /// Pointer to next structure
  VkDescriptorPool             descriptorPool
  u32                          descriptorSetCount
  const VkDescriptorSetLayout* pSetLayouts
}

@serialize
class VkDescriptorImageInfo {
  VkSampler     Sampler
  VkImageView   ImageView
  VkImageLayout ImageLayout
}

@serialize
class VkDescriptorBufferInfo {
  VkBuffer     Buffer /// Buffer used for this descriptor when the descriptor is UNIFORM_BUFFER[_DYNAMIC]
  VkDeviceSize Offset /// Base offset from buffer start in bytes to update in the descriptor set.
  VkDeviceSize Range  /// Size in bytes of the buffer resource for this descriptor update.
}

@serialize
class VkWriteDescriptorSet {
  VkStructureType               sType            /// Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
  const void*                   pNext            /// Pointer to next structure
  VkDescriptorSet               dstSet           /// Destination descriptor set
  u32                           dstBinding       /// Binding within the destination descriptor set to write
  u32                           dstArrayElement  /// Array element within the destination binding to write
  u32                           descriptorCount  /// Number of descriptors to write (determines the size of the array pointed by <pDescriptors>)
  VkDescriptorType              descriptorType   /// Descriptor type to write (determines which fields of the array pointed by <pDescriptors> are going to be used)
  const VkDescriptorImageInfo*  pImageInfo
  const VkDescriptorBufferInfo* pBufferInfo
  const VkBufferView*           pTexelBufferView
}

@serialize
class VkCopyDescriptorSet {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
  const void*     pNext           /// Pointer to next structure
  VkDescriptorSet srcSet          /// Source descriptor set
  u32             srcBinding      /// Binding within the source descriptor set to copy from
  u32             srcArrayElement /// Array element within the source binding to copy from
  VkDescriptorSet dstSet          /// Destination descriptor set
  u32             dstBinding      /// Binding within the destination descriptor set to copy to
  u32             dstArrayElement /// Array element within the destination binding to copy to
  u32             descriptorCount /// Number of descriptors to copy
}

@serialize
class VkFramebufferCreateInfo {
  VkStructureType          sType           /// Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
  const void*              pNext           /// Pointer to next structure
  VkFramebufferCreateFlags flags
  VkRenderPass             renderPass
  u32                      attachmentCount
  const VkImageView*       pAttachments
  u32                      width
  u32                      height
  u32                      layers
}

@serialize
class VkAttachmentDescription {
  VkAttachmentDescriptionFlags flags
  VkFormat                     format
  VkSampleCountFlagBits        samples
  VkAttachmentLoadOp           loadOp         /// Load op for color or depth data
  VkAttachmentStoreOp          storeOp        /// Store op for color or depth data
  VkAttachmentLoadOp           stencilLoadOp  /// Load op for stencil data
  VkAttachmentStoreOp          stencilStoreOp /// Store op for stencil data
  VkImageLayout                initialLayout
  VkImageLayout                finalLayout
}

@serialize
class VkAttachmentReference {
  u32           Attachment // We have capitalized these so we can manipulate
  VkImageLayout Layout     // them in Go
}

@serialize
class VkSubpassDescription {
  VkSubpassDescriptionFlags    flags
  VkPipelineBindPoint          pipelineBindPoint       /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
  u32                          inputAttachmentCount
  const VkAttachmentReference* pInputAttachments
  u32                          colorAttachmentCount
  const VkAttachmentReference* pColorAttachments
  const VkAttachmentReference* pResolveAttachments
  const VkAttachmentReference* pDepthStencilAttachment
  u32                          preserveAttachmentCount
  const u32*                   pPreserveAttachments
}

@serialize
class VkSubpassDependency {
  u32                  srcSubpass
  u32                  dstSubpass
  VkPipelineStageFlags srcStageMask
  VkPipelineStageFlags dstStageMask
  VkAccessFlags        srcAccessMask
  VkAccessFlags        dstAccessMask
  VkDependencyFlags    dependencyFlags
}

@serialize
class VkRenderPassCreateInfo {
  VkStructureType                sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
  const void*                    pNext           /// Pointer to next structure
  VkRenderPassCreateFlags        flags
  u32                            attachmentCount
  const VkAttachmentDescription* pAttachments
  u32                            subpassCount
  const VkSubpassDescription*    pSubpasses
  u32                            dependencyCount
  const VkSubpassDependency*     pDependencies
}

@serialize
class VkCommandPoolCreateInfo {
  VkStructureType          sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkCommandPoolCreateFlags flags            /// Command pool creation flags
  u32                      queueFamilyIndex
}

@serialize
class VkCommandBufferAllocateInfo {
  VkStructureType      sType              /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
  const void*          pNext              /// Pointer to next structure
  VkCommandPool        commandPool
  VkCommandBufferLevel level
  u32                  commandBufferCount
}

@serialize
class VkCommandBufferInheritanceInfo {
  VkStructureType               sType                /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
  const void*                   pNext                /// Pointer to next structure
  VkRenderPass                  renderPass           /// Render pass for secondary command buffers
  u32                           subpass
  VkFramebuffer                 framebuffer          /// Framebuffer for secondary command buffers
  VkBool32                      occlusionQueryEnable
  VkQueryControlFlags           queryFlags
  VkQueryPipelineStatisticFlags pipelineStatistics
}

@serialize
class VkCommandBufferBeginInfo {
  VkStructureType                       sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
  const void*                           pNext            /// Pointer to next structure
  VkCommandBufferUsageFlags             flags            /// Command buffer usage flags
  const VkCommandBufferInheritanceInfo* pInheritanceInfo
}

@serialize
class VkBufferCopy {
  VkDeviceSize srcOffset /// Specified in bytes
  VkDeviceSize dstOffset /// Specified in bytes
  VkDeviceSize size      /// Specified in bytes
}

@serialize
class VkImageSubresourceLayers {
  VkImageAspectFlags aspectMask
  u32                mipLevel
  u32                baseArrayLayer
  u32                layerCount
}

@serialize
class VkImageCopy {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset      /// Specified in pixels for both compressed and uncompressed images
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset      /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               extent         /// Specified in pixels for both compressed and uncompressed images
}

@serialize
class VkImageBlit {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D[2]            srcOffsets
  VkImageSubresourceLayers dstSubresource
  VkOffset3D[2]            dstOffsets
}

@serialize
class VkBufferImageCopy {
  VkDeviceSize             bufferOffset      /// Specified in bytes
  u32                      bufferRowLength   /// Specified in texels
  u32                      bufferImageHeight
  VkImageSubresourceLayers imageSubresource
  VkOffset3D               imageOffset       /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               imageExtent       /// Specified in pixels for both compressed and uncompressed images
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
@serialize
class VkClearColorValue {
  //f32[4]                                      float32
  //s32[4]                                      int32
  u32[4] uint32
}

@serialize
class VkClearDepthStencilValue {
  f32 depth
  u32 stencil
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.
@serialize
class VkClearValue {
  VkClearColorValue color
//    VkClearDepthStencilValue                    depthStencil
}

@serialize
class VkClearAttachment {
  VkImageAspectFlags aspectMask
  u32                colorAttachment
  VkClearValue       clearValue
}

@serialize
class VkClearRect {
  VkRect2D rect
  u32      baseArrayLayer
  u32      layerCount
}

@serialize
class VkImageResolve {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset
  VkExtent3D               extent
}

@serialize
class VkMemoryBarrier {
  VkStructureType sType         /// Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
  const void*     pNext         /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
}

@serialize
class VkBufferMemoryBarrier {
  VkStructureType sType               /// Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
  const void*     pNext               /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
  u32             srcQueueFamilyIndex /// Queue family to transition ownership from
  u32             dstQueueFamilyIndex /// Queue family to transition ownership to
  VkBuffer        buffer              /// Buffer to sync
  VkDeviceSize    offset              /// Offset within the buffer to sync
  VkDeviceSize    size                /// Amount of bytes to sync
}

@serialize
class VkImageMemoryBarrier {
  VkStructureType         sType               /// Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
  const void*             pNext               /// Pointer to next structure.
  VkAccessFlags           srcAccessMask
  VkAccessFlags           dstAccessMask
  VkImageLayout           oldLayout           /// Current layout of the image
  VkImageLayout           newLayout           /// New layout to transition the image to
  u32                     srcQueueFamilyIndex /// Queue family to transition ownership from
  u32                     dstQueueFamilyIndex /// Queue family to transition ownership to
  VkImage                 image               /// Image to sync
  VkImageSubresourceRange subresourceRange    /// Subresource range to sync
}

@serialize
class VkRenderPassBeginInfo {
  VkStructureType     sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
  const void*         pNext           /// Pointer to next structure
  VkRenderPass        renderPass
  VkFramebuffer       framebuffer
  VkRect2D            renderArea
  u32                 clearValueCount
  const VkClearValue* pClearValues
}

@serialize @unused
class VkDispatchIndirectCommand {
  u32 x
  u32 y
  u32 z
}

@serialize @unused
class VkDrawIndexedIndirectCommand {
  u32 indexCount
  u32 instanceCount
  u32 firstIndex
  s32 vertexOffset
  u32 firstInstance
}

@serialize @unused
class VkDrawIndirectCommand {
  u32 vertexCount
  u32 instanceCount
  u32 firstVertex
  u32 firstInstance
}

////////////////////////////////////////////////////////////////////////////////
////////// Extensions //////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// VK_NV_dedicated_allocation

/// Format capability flags
@unused
bitfield VkExternalMemoryHandleTypeFlagBitsNV {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV     = 0x00000001,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV      = 0x00000004,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV  = 0x00000008,
}
@unused
type VkFlags VkExternalMemoryHandleTypeFlagsNV

@serialize
class VkDedicatedAllocationImageCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@serialize
class VkDedicatedAllocationBufferCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@serialize
class VkDedicatedAllocationMemoryAllocateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  VkImage                 image
  VkBuffer                buffer
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@internal class MutableVoidPtr {
  void* Ptr
}

type void* VoidPtr
// Declare the type so external function: numberOfPNext can use the type.
type const void** ConstVoidPtrPtr
// Returns the number of structs in the linked list pointed by the pNext pointer.
extern u32 numberOfPNext(const void* pNext)

@override
@custom
@no_replay
cmd void RecreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    VkInstance*                 pInstance) {

  info := pCreateInfo[0]

  // TODO: handle pNext
  if (info.pApplicationInfo != null) {
    _ = readVkApplicationInfo(info.pApplicationInfo)
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    _ = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    _ = as!string(extensionNames[i])
  }

  fence
  write(pInstance[0:1])
}

@custom
@threadSafety("system")
@override
cmd VkResult vkCreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance*                  pInstance) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkInstance() in synthetic.api. Change both together.

  instance := createInstanceObject(pCreateInfo)
  // TODO: pAllocator
  handle := ?
  pInstance[0] = handle
  instance.VulkanHandle = handle
  Instances[handle] = instance
  return ?
}

@threadSafety("system")
@indirect("VkInstance")
@override
@custom
cmd void vkDestroyInstance(
    VkInstance                   instance,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Instances, instance)
}

@override
@custom
@no_replay
cmd void RecreatePhysicalDevices(
    VkInstance        instance,
    u32*              count,
    VkPhysicalDevice* pPhysicalDevices
    VkPhysicalDeviceProperties* pProperties) {
  read(count[0:1])
  physicalDeviceCount := count[0]
  fence
  write(pPhysicalDevices[0:physicalDeviceCount])
  write(pProperties[0:physicalDeviceCount])
}

@override
@custom
@no_replay
cmd void RecreatePhysicalDeviceProperties(
    VkPhysicalDevice                  physicalDevice,
    u32*                              pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*          pQueueFamilyProperties,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  count := pQueueFamilyPropertyCount[0]
  read(pQueueFamilyProperties[0:count])
  write(pQueueFamilyPropertyCount[0:1])
  write(pMemoryProperties[0:1])
}

@threadSafety("system")
@override
@no_replay
cmd void prefetchPhysicalDeviceProperties(
    VkInstance instance,
    VkPhysicalDevice physicalDevice,
    VkPhysicalDeviceProperties* pProperties) {
  pProperties[0] = ?
  numEnumerated := len(Instances[instance].EnumeratedPhysicalDevices)
  switch (PhysicalDevices[physicalDevice] == null) {
    case true:
      // First time see the physical device, save the order.
      Instances[instance].EnumeratedPhysicalDevices[as!u32(numEnumerated)] = physicalDevice
  }
  object := switch (PhysicalDevices[physicalDevice] == null) {
    case true:
      new!PhysicalDeviceObject()
    case false:
      PhysicalDevices[physicalDevice]
  }
  object.PhysicalDeviceProperties = pProperties[0]
  PhysicalDevices[physicalDevice] = object
}

@threadSafety("system")
@override
@no_replay
cmd void prefetchPhysicalDeviceQueueFamilyProperties(
    VkInstance instance,
    VkPhysicalDevice physicalDevice,
    u32* pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
  _ = pQueueFamilyPropertyCount[0]
  fence
  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pQueueFamilyPropertyCount[0] = count
    object := switch (PhysicalDevices[physicalDevice] == null) {
      case true:
        new!PhysicalDeviceObject()
      case false:
        PhysicalDevices[physicalDevice]
    }
    for i in (0 .. count) {
      object.QueueFamilyProperties[i] = properties[i]
    }
    PhysicalDevices[physicalDevice] = object
  }
}

@threadSafety("system")
@indirect("VkInstance")
@override
cmd VkResult vkEnumeratePhysicalDevices(
    VkInstance        instance,
    u32*              pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices) {
  _ = pPhysicalDeviceCount[0]

  fence
  if pPhysicalDevices == null {
    pPhysicalDeviceCount[0] = ?
  } else {
    count := as!u32(?)
    devices := pPhysicalDevices[0:count]
    for i in (0 .. count) {
      device := ?
      devices[i] = device
    }
    pPhysicalDeviceCount[0] = count

    for i in (0 .. count) {
      object := switch (PhysicalDevices[devices[i]] == null) {
        case true:
          new!PhysicalDeviceObject()
        case false:
          PhysicalDevices[devices[i]]
      }
      object.Instance = instance
      object.Index = i
      object.VulkanHandle = devices[i]
      PhysicalDevices[devices[i]] = object
    }
  }

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice          physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures) {
  pFeatures[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice    physicalDevice,
    VkFormat            format,
    VkFormatProperties* pFormatProperties) {
  pFormatProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice         physicalDevice,
    VkFormat                 format,
    VkImageType              type,
    VkImageTiling            tiling,
    VkImageUsageFlags        usage,
    VkImageCreateFlags       flags,
    VkImageFormatProperties* pImageFormatProperties) {
  pImageFormatProperties[0] = ?
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice            physicalDevice,
    VkPhysicalDeviceProperties* pProperties) {
  pProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice         physicalDevice,
    u32*                     pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pQueueFamilyPropertyCount[0] = count
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i]
    }
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                  physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  memoryProperties := ?
  pMemoryProperties[0] = memoryProperties

  dev := PhysicalDevices[physicalDevice]
  dev.MemoryProperties = memoryProperties
  PhysicalDevices[physicalDevice] = dev

}

@indirect("VkInstance")
@override
cmd PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance instance,
    string     pName) {
  return ?
}

@indirect("VkDevice")
@override
cmd PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice device,
    string   pName) {
  return ?
}

@override
@custom
@no_replay
cmd void RecreateDevice(
    VkPhysicalDevice          physicalDevice,
    const VkDeviceCreateInfo* pCreateInfo,
    VkDevice*                 pDevice) {
  device := createDeviceObject(pCreateInfo)
  handle := ?

  pDevice[0] = handle
  device.PhysicalDevice = physicalDevice
  device.VulkanHandle = handle
  if (!(handle in Devices)) {
    Devices[handle] = device
  }
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@override
@custom
cmd VkResult vkCreateDevice(
    VkPhysicalDevice             physicalDevice,
    const VkDeviceCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice*                    pDevice) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkDevice() in synthetic.api. Change both together.

  device := createDeviceObject(pCreateInfo)
  device.PhysicalDevice = physicalDevice
  // TODO: pAllocator

  handle := ?
  pDevice[0] = handle
  device.VulkanHandle = handle
  Devices[handle] = device

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@override
@custom
cmd void vkDestroyDevice(
    VkDevice                     device,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Devices, device)
}

sub void queryExtensionProperties(u32* pPropertyCount, VkExtensionProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceExtensionProperties(
    string                 pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice       physicalDevice,
    string                 pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

sub void queryLayerProperties(u32* pPropertyCount, VkLayerProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceLayerProperties(
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice   physicalDevice,
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)

  return ?
}

@override
@custom
@no_replay
cmd void RecreateQueue(VkDevice device,
                       u32      queueFamilyIndex,
                       u32      queueIndex,
                       VkQueue* pQueue) {

  handle := ?
  pQueue[0] = handle
  if (!(handle in Queues)) {
    Queues[handle] = new!QueueObject(Device: device,Family:  queueFamilyIndex,Index:  queueIndex,VulkanHandle:  handle)
  }
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkGetDeviceQueue(
    VkDevice device,
    u32      queueFamilyIndex,
    u32      queueIndex,
    VkQueue* pQueue) {
  id := ?
  Queues[id] = new!QueueObject(Device: device,Family:  queueFamilyIndex,Index:  queueIndex,VulkanHandle:  id)
  pQueue[0] = id
}

// TODO: Not all vkQueueSubmit calls submit vkCmdDrawXXX commands. Need better
// a way so that only those recorded with draw commands will be labelled as
// draw call.
@draw_call
@threadSafety("app")
@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueSubmit(
    VkQueue             queue,
    u32                 submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence             fence) {
  LastSubmission = SUBMIT
  submitInfo := pSubmits[0:submitCount]
  LastBoundQueue = Queues[queue]

  enterSubcontext()
  for i in (0 .. submitCount) {
    info := submitInfo[i]
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for j in (0 .. info.waitSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
        = CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
            Unsignal, wait_semaphores[j], null)
    }
    read(info.pWaitDstStageMask[0:info.waitSemaphoreCount])

    command_buffers := info.pCommandBuffers[0:info.commandBufferCount]

    enterSubcontext()
    for j in (0 .. info.commandBufferCount) {
      enterSubcontext()
      cb := CommandBuffers[command_buffers[j]]
      for k in (0 .. len(cb.CommandReferences)) {
        LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
          = cb.CommandReferences[as!u32(k)]
        notifyPendingCommandAdded(queue)
        ref := cb.CommandReferences[as!u32(k)]
        if ref.Type == cmd_vkCmdExecuteCommands {
          enterSubcontext()
          ec := cb.BufferCommands.vkCmdExecuteCommands[ref.MapIndex]
          for l in (0 .. len(ec.CommandBuffers)) {
            scb := CommandBuffers[ec.CommandBuffers[as!u32(l)]]
            enterSubcontext()
            for c in (0 .. len(scb.CommandReferences)) {
              LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
                = scb.CommandReferences[as!u32(c)]
              notifyPendingCommandAdded(queue)
            }
            leaveSubcontext()
            nextSubcontext()
          }
          leaveSubcontext()
        }
      }
      leaveSubcontext()
      nextSubcontext()
    }
    leaveSubcontext()

    signal_semaphores := info.pSignalSemaphores[0:info.signalSemaphoreCount]
    for j in (0 .. info.signalSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
        = CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
            Signal, signal_semaphores[j], null)
    }
    nextSubcontext()
  }
  leaveSubcontext()
  execPendingCommands(queue)
  fence
  return ?
}

@threadSafety("system")
@indirect("VkQueue", "VkDevice")
@blocking
cmd VkResult vkQueueWaitIdle(
    VkQueue queue) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkDeviceWaitIdle(
    VkDevice device) {
  return ?
}

sub bool IsMemoryCoherent(ref!DeviceMemoryObject memory) {
  physical_device := PhysicalDevices[Devices[memory.Device].PhysicalDevice]
  return 0 != (as!u32(physical_device.MemoryProperties.memoryTypes[memory.MemoryTypeIndex].propertyFlags) &
  as!u32(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))
}

@override
@custom
@no_replay
cmd void RecreateDeviceMemory(
    VkDevice                    device,
    const VkMemoryAllocateInfo* pAllocateInfo,
    VkDeviceSize                mappedOffset,
    VkDeviceSize                mappedSize,
    void**                      ppData,
    VkDeviceMemory*             pMemory) {
  allocateInfo := pAllocateInfo[0]

  // Handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
          _ = as!VkDedicatedAllocationMemoryAllocateInfoNV*(next.Ptr)[0:1][0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  if (mappedSize > as!VkDeviceSize(0)) {
    read(ppData[0:1])
  }

  fence
  if (mappedSize > 0) {
    write(ppData[0:1])
  }
  memory := pMemory[0:1][0]

  memoryObject := DeviceMemories[memory]
  if (IsMemoryCoherent(memoryObject)) {
    trackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkAllocateMemory(
    VkDevice                     device,
    const VkMemoryAllocateInfo*  pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory*              pMemory) {
  allocateInfo := pAllocateInfo[0]

  memoryObject := new!DeviceMemoryObject(
    Device:           device,
    VulkanHandle:     0,
    AllocationSize:   allocateInfo.allocationSize,
    MappedOffset:     0,
    MappedSize:       0,
    MappedLocation:   null,
    MemoryTypeIndex:  allocateInfo.memoryTypeIndex
  )
  memoryObject.Data = make!u8(allocateInfo.allocationSize)

  // Handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
          ext := as!VkDedicatedAllocationMemoryAllocateInfoNV*(next.Ptr)[0:1][0]
          memoryObject.DedicatedAllocationNV = new!DedicatedAllocationMemoryAllocateInfoNV(
            Image:   ext.image,
            Buffer:  ext.buffer,
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  memory := ?
  pMemory[0] = memory

  memoryObject.VulkanHandle = memory
  DeviceMemories[memory] = memoryObject
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkFreeMemory(
    VkDevice                     device,
    VkDeviceMemory               memory,
    const VkAllocationCallbacks* pAllocator) {
  if (memory != as!VkDeviceMemory(0)) {
    memoryObject := DeviceMemories[memory]

    if (memoryObject.MappedSize != 0) {
      mappedLocation := as!u8*(memoryObject.MappedLocation)
      unmapMemory(mappedLocation[0:memoryObject.MappedSize])
    }
    delete(DeviceMemories, memory)
  }
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkMapMemory(
    VkDevice         device,
    VkDeviceMemory   memory,
    VkDeviceSize     offset,
    VkDeviceSize     size,
    VkMemoryMapFlags flags,
    void**           ppData) {
  // TODO(awoloszyn): Figure out why we need the read/write here
  // in order for the replay to allocate the memory we need.
  // see: b/32300796
  memoryObject := DeviceMemories[memory]
  memoryObject.MappedOffset = offset
  if (size == 0xFFFFFFFFFFFFFFFF) {
    memoryObject.MappedSize = memoryObject.AllocationSize - offset
  } else {
    memoryObject.MappedSize = size
  }
  read(ppData[0:1])
  memoryLocation := ?
  ppData[0] = memoryLocation

  mapMemory(ppData, as!u8*(memoryLocation)[0:memoryObject.MappedSize])
  memoryObject.MappedLocation = memoryLocation
  DeviceMemories[memory] = memoryObject
  if (IsMemoryCoherent(memoryObject)) {
    trackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  return ?
}

@threadSafety("app")
@indirect("VkDevice")
cmd void vkUnmapMemory(
    VkDevice       device,
    VkDeviceMemory memory) {
  memoryObject := DeviceMemories[memory]
  mappedLocation := as!u8*(memoryObject.MappedLocation)
  if (IsMemoryCoherent(memoryObject)) {
    readCoherentMemory(memoryObject, memoryObject.MappedOffset, memoryObject.MappedSize)
    untrackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  unmapMemory(mappedLocation[0:memoryObject.MappedSize])
  memoryObject.MappedSize = 0
  memoryObject.MappedLocation = null
}

@indirect("VkDevice")
cmd VkResult vkFlushMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount
    const VkMappedMemoryRange* pMemoryRanges) {
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    flushRange := memoryRanges[i]
    memoryObject := DeviceMemories[flushRange.memory]
    mappedLocation := as!u8*(memoryObject.MappedLocation)
    flushStart := flushRange.offset - memoryObject.MappedOffset
    // TODO: Log errors if flush offset - mapped offset is negative or
    // flushRange.size is out of bounds.

    if (IsMemoryCoherent(memoryObject)) {
      readCoherentMemory(memoryObject, flushRange.offset, flushRange.size)
    } else {
      if (flushRange.size == 0xFFFFFFFFFFFFFFFF) {
        // copy() contains an implicit read observation
        copy(memoryObject.Data[flushRange.offset:memoryObject.MappedOffset + memoryObject.MappedSize], (mappedLocation)[flushStart:memoryObject.MappedSize])
      } else {
        // copy() contains an implicit read observation
        copy(memoryObject.Data[flushRange.offset:flushRange.offset + flushRange.size], (mappedLocation)[flushStart:flushStart + flushRange.size])
      }
    }
  }
  return ?
}

@internal
class MemoryRangeArray {
  map!(u32, void*) PData
  map!(u32, u64)   Start
  map!(u32, u64)   End
}

@indirect("VkDevice")
cmd VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges) {
  ranges := new!MemoryRangeArray()
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    invalidateRange := memoryRanges[i]
    invalidateOffset := invalidateRange.offset
    mappedLocation := DeviceMemories[invalidateRange.memory].MappedLocation
    mappedOffset := DeviceMemories[invalidateRange.memory].MappedOffset
    mappedSize := DeviceMemories[invalidateRange.memory].MappedSize
    ranges.PData[i] = mappedLocation
    ranges.Start[i] = as!u64(invalidateOffset - mappedOffset)
    // TODO: Log errors if invalidate offset - mapped offset is negative or
    // invalidateRange.size is out of bounds.
    if (invalidateRange.size == 0xFFFFFFFFFFFFFFFF) {
      ranges.End[i] = as!u64(mappedSize)
    } else {
      ranges.End[i] = ranges.Start[i] + as!u64(invalidateRange.size)
    }
  }
  for i in (0 .. memoryRangeCount) {
    write(ranges.PData[i][ranges.Start[i]:ranges.End[i]])
  }
  return ?
}


// Memory management API functions

@indirect("VkDevice")
cmd void vkGetDeviceMemoryCommitment(
    VkDevice       device,
    VkDeviceMemory memory,
    VkDeviceSize*  pCommittedMemoryInBytes) {
  _ = pCommittedMemoryInBytes[0]
}


@override
@custom
@no_replay
cmd void RecreateState() {
}

@override
@custom
@no_replay
cmd void RecreateBufferData(
    VkDevice device,
    VkBuffer buffer,
    u32      hostBufferMemoryIndex,
    VkQueue  lastBoundQueue,
    void*    data) {
  read(as!u8*(data)[0:Buffers[buffer].Info.Size])
}

@override
@custom
@no_replay
cmd void RecreateBindBufferMemory(
    VkDevice       device,
    VkBuffer       buffer,
    VkDeviceMemory memory,
    VkDeviceSize   offset,
    u32            sparseBindCount,
    const VkSparseMemoryBind* pSparseBinds) {
    if sparseBindCount > 0 {
      read(pSparseBinds[0:sparseBindCount])
    }
}

@indirect("VkDevice")
cmd VkResult vkBindBufferMemory(
    VkDevice       device,
    VkBuffer       buffer,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  Buffers[buffer].Memory = DeviceMemories[memory]
  Buffers[buffer].MemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(buffer)] = memoryOffset
  return ?
}

@override
@custom
@no_replay
cmd void RecreateImageData(
    VkDevice      device,
    VkImage       image,
    VkImageLayout lastLayout,
    u32           hostMemoryIndex,
    VkQueue       lastBoundQueue,
    VkDeviceSize  dataSize,
    void*         data) {
  read(as!u8*(data)[0:dataSize])
}

@override
@custom
@no_replay
cmd void RecreateBindImageMemory(
    VkDevice       device,
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   offset,
    u32            opaqueSparseBindCount,
    const VkSparseMemoryBind* pOpaqueSparseBinds) {
    if opaqueSparseBindCount > 0 {
      read(pOpaqueSparseBinds[0:opaqueSparseBindCount])
    }
}

@indirect("VkDevice")
cmd VkResult vkBindImageMemory(
    VkDevice       device,
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  Images[image].BoundMemory = DeviceMemories[memory]
  Images[image].BoundMemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(image)] = memoryOffset
  return ?
}

@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements(
    VkDevice              device,
    VkBuffer              buffer,
    VkMemoryRequirements* pMemoryRequirements) {
  requirements := ?
  pMemoryRequirements[0] = requirements
}

@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements(
    VkDevice              device,
    VkImage               image,
    VkMemoryRequirements* pMemoryRequirements) {
  requirements := ?
  pMemoryRequirements[0] = requirements
}

@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements(
    VkDevice                         device,
    VkImage                          image,
    u32*                             pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
  read(pSparseMemoryRequirementCount[0:1])

  if pSparseMemoryRequirements == null {
    pSparseMemoryRequirementCount[0] = ?
  } else {
    count := as!u32(?)
    requirements := pSparseMemoryRequirements[0:count]
    for i in (0 .. count) {
      requirements[i] = ?
    }
    pSparseMemoryRequirementCount[0] = count
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice               physicalDevice,
    VkFormat                       format,
    VkImageType                    type,
    VkSampleCountFlagBits          samples,
    VkImageUsageFlags              usage,
    VkImageTiling                  tiling,
    u32*                           pPropertyCount,
    VkSparseImageFormatProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueBindSparse(
    VkQueue                 queue,
    u32                     bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence                 fence) {
  LastBoundQueue = Queues[queue]
  infos := pBindInfo[0:bindInfoCount]
  enterSubcontext()
  for i in (0 .. bindInfoCount) {
    info := infos[i]
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for j in (0 .. info.waitSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
        = CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
            Unsignal, wait_semaphores[j], null)
    }

    queuedBinds := new!QueuedSparseBinds()

    bufferBinds := info.pBufferBinds[0:info.bufferBindCount]
    for j in (0 .. info.bufferBindCount) {
      bufferBindInfo := bufferBinds[j]
      bindsToQueue := new!SparseMemoryBinds()
      memoryBinds := bufferBindInfo.pBinds[0:bufferBindInfo.bindCount]
      for k in (0 .. bufferBindInfo.bindCount) {
        bindsToQueue.SparseMemoryBinds[k] = memoryBinds[k]
      }
      queuedBinds.BufferBinds[bufferBindInfo.buffer] = bindsToQueue
    }

    opaqueBinds := info.pImageOpaqueBinds[0:info.imageOpaqueBindCount]
    for j in (0 .. info.imageOpaqueBindCount) {
      opaqueBindInfo := opaqueBinds[j]
      bindsToQueue := new!SparseMemoryBinds()
      memoryBinds := opaqueBindInfo.pBinds[0:opaqueBindInfo.bindCount]
      for k in (0 .. opaqueBindInfo.bindCount) {
        bindsToQueue.SparseMemoryBinds[k] = memoryBinds[k]
      }
      queuedBinds.OpaqueImageBinds[opaqueBindInfo.image] = bindsToQueue
    }

    imageBinds := info.pImageBinds[0:info.imageBindCount]
    for j in (0 .. info.imageBindCount) {
      imageBindInfo := imageBinds[j]
      bindsToQueue := new!SparseImageMemoryBinds()
      imageMemoryBinds := imageBindInfo.pBinds[0:imageBindInfo.bindCount]
      for k in (0 .. imageBindInfo.bindCount) {
        bindsToQueue.SparseImageMemoryBinds[k] = imageMemoryBinds[k]
      }
      queuedBinds.ImageBinds[imageBindInfo.image] = bindsToQueue
    }

    LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
      = CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
          None, as!VkSemaphore(0), queuedBinds)

    signal_semaphores := info.pSignalSemaphores[0:info.signalSemaphoreCount]
    for j in (0 .. info.signalSemaphoreCount) {
      LastBoundQueue.PendingCommands[len(LastBoundQueue.PendingCommands)]
        = CommandReference(as!VkCommandBuffer(0), 0, cmd_vkNoCommand, 0,
            Signal, signal_semaphores[j], null)
    }
  }
  leaveSubcontext()
  execPendingCommands(queue)
  fence
  return ?
}

@override
@custom
@no_replay
cmd void RecreateFence(
    VkDevice                 device,
    const VkFenceCreateInfo* pCreateInfo
    VkFence*                 pFence) {
  read(pCreateInfo[0:1])
  write(pFence[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFence(
    VkDevice                     device,
    const VkFenceCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence*                     pFence) {

  f := new!FenceObject()
  create_info := pCreateInfo[0]
  f.Device = device

  if ((as!u32(create_info.flags) & as!u32(VK_FENCE_CREATE_SIGNALED_BIT)) != 0) {
    f.Signaled = true
  } else {
    f.Signaled = false
  }
  handle := ?
  pFence[0] = handle
  f.VulkanHandle = handle
  Fences[handle] = f
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFence(
    VkDevice                     device,
    VkFence                      fence,
    const VkAllocationCallbacks* pAllocator) {
  delete(Fences, fence)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences) {
  read(pFences[0:fenceCount])
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetFenceStatus(
    VkDevice device,
    VkFence  fence) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkWaitForFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences,
    VkBool32       waitAll,
    u64            timeout) { /// timeout in nanoseconds
  read(pFences[0:fenceCount])
  return ?
}

@override
@custom
@no_replay
cmd void RecreateSemaphore(
    VkDevice                     device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    VkBool32                     signaled,
    VkSemaphore*                 pSemaphore) {
  read(pCreateInfo[0:1])
  write(pSemaphore[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSemaphore(
    VkDevice                     device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore*                 pSemaphore) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  semaphoreObject := new!SemaphoreObject(Device: device,
    VulkanHandle:           handle)
  pSemaphore[0] = handle
  Semaphores[handle] = semaphoreObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySemaphore(
    VkDevice                     device,
    VkSemaphore                  semaphore,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Semaphores, semaphore)
}

@override
@custom
@no_replay
cmd void RecreateEvent(
    VkDevice                 device,
    const VkEventCreateInfo* pCreateInfo,
    VkBool32                 signaled,
    VkEvent*                 pEvent) {
  read(pCreateInfo[0:1])
  write(pEvent[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateEvent(
    VkDevice                     device,
    const VkEventCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent*                     pEvent) {
  read(pCreateInfo[0:1])
  event := new!EventObject()
  event.Device = device
  event.Signaled = false
  event.SubmitQueue = as!VkQueue(0)
  handle := ?
  pEvent[0] = handle
  event.VulkanHandle = handle
  Events[handle] = event
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyEvent(
    VkDevice                     device,
    VkEvent                      event,
    const VkAllocationCallbacks* pAllocator) {
  delete(Events, event)
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetEventStatus(
    VkDevice device,
    VkEvent  event) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkSetEvent(
    VkDevice device,
    VkEvent  event) {
  e := Events[event]
  e.Signaled = true
  queue := e.SubmitQueue
  if queue != as!VkQueue(0) {
    q := Queues[queue]
    if e.VulkanHandle in q.PendingEvents {
      delete(q.PendingEvents, e.VulkanHandle)
    }
    // If all pending events are signaled, so all removed from the pending
    // event list in the queue object, we should roll out the pending commands
    if len(q.PendingEvents) == 0 {
      LastBoundQueue = Queues[queue]
      execPendingCommands(queue)
    }
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetEvent(
    VkDevice device,
    VkEvent  event) {
  Events[event].Signaled = false
  return ?
}

@override
@custom
@no_replay
cmd void RecreateQueryPool(
    VkDevice                     device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const QueryStatus*           pQueryStatuses
    VkQueryPool*                 pPool) {
  create_info := pCreateInfo[0]
  read(pQueryStatuses[0:create_info.queryCount])
  write(pPool[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateQueryPool(
    VkDevice                     device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool*                 pQueryPool) {
  info := pCreateInfo[0]

  handle := ?
  pool := new!QueryPoolObject(
    Device:              device,
    VulkanHandle:        handle,
    QueryType:           info.queryType,
    QueryCount:          info.queryCount,
    PipelineStatistics:  info.pipelineStatistics)
  for i in (0 .. info.queryCount) {
    pool.Status[i] = QUERY_STATUS_INACTIVE
  }

  QueryPools[handle] = pool
  pQueryPool[0] = handle

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyQueryPool(
    VkDevice                     device,
    VkQueryPool                  queryPool,
    const VkAllocationCallbacks* pAllocator) {
  delete(QueryPools, queryPool)
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
@no_replay
// GetQueryPoolResults has no semantic impact
// on replay, so avoid replaying it. It can cause
// hangs depending on the state of the query pool
// TODO(awoloszyn): Work out all of the cases where this
// may cause hangs, and fix it for replay.
cmd VkResult vkGetQueryPoolResults(
    VkDevice           device,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    size               dataSize,
    void*              pData,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  write(as!u8*(pData)[0:dataSize])
  return ?
}

@override
@custom
@no_replay
cmd void RecreateBuffer(
    VkDevice                  device,
    const VkBufferCreateInfo* pCreateInfo,
    VkBuffer*                 pBuffer) {
  create_info := pCreateInfo[0]
  if (create_info.queueFamilyIndexCount > 0) {
    read(create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount])
  }
  // Handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
          _ = as!VkDedicatedAllocationBufferCreateInfoNV*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
  write(pBuffer[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateBuffer(
    VkDevice                     device,
    const VkBufferCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer*                    pBuffer) {
  buffer_create_info := pCreateInfo[0]

  queueFamilyIndices := buffer_create_info.pQueueFamilyIndices[
  0:buffer_create_info.queueFamilyIndexCount]

  bufferInfo := BufferInfo(
    CreateFlags:  buffer_create_info.flags,
    Size:         buffer_create_info.size,
    Usage:        buffer_create_info.usage,
    SharingMode:  buffer_create_info.sharingMode,
  )
  for i in (0 .. buffer_create_info.queueFamilyIndexCount) {
    bufferInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  // Handle pNext
  if buffer_create_info.pNext != null {
    numPNext := numberOfPNext(buffer_create_info.pNext)
    next := MutableVoidPtr(as!void*(buffer_create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationBufferCreateInfoNV*(next.Ptr)[0]
          bufferInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
            DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  bufferObject := new!BufferObject(Device: device,
    Memory:              null,
    MemoryOffset:        0,
    Info:                bufferInfo,
  )

  buffer := ?
  pBuffer[0] = buffer
  bufferObject.VulkanHandle = buffer
  Buffers[buffer] = bufferObject
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBuffer(
    VkDevice                     device,
    VkBuffer                     buffer,
    const VkAllocationCallbacks* pAllocator) {
  if (buffer != as!VkBuffer(0)) {
    bufferObject := Buffers[buffer]
    if (bufferObject.Memory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(bufferObject.Memory.BoundObjects,
      as!u64(buffer))
    }
    delete(Buffers, buffer)
  }
}



@override
@custom
@no_replay
cmd void RecreateBufferView(
    VkDevice                      device,
    const VkBufferViewCreateInfo* pCreateInfo,
    VkBufferView*                 pBufferView) {
  read(pCreateInfo[0:1])
  write(pBufferView[0:1])
}

// Buffer view functions
@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateBufferView(
    VkDevice                      device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkBufferView*                 pView) {
  buffer_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  bufferViewObject := new!BufferViewObject(
    Device:        device,
    VulkanHandle:  handle,
    Buffer:        Buffers[buffer_view_create_info.buffer],
    Format:        buffer_view_create_info.format,
    Offset:        buffer_view_create_info.offset,
    Range:         buffer_view_create_info.range)
  pView[0] = handle
  BufferViews[handle] = bufferViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBufferView(
    VkDevice                     device,
    VkBufferView                 bufferView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(BufferViews, bufferView)
}

sub u32 getMipSize(u32 original, u32 level) {
  value := original / (1 << level)
  return switch (value) {
    case 0:  1
    default: value
  }
}

sub u32 roundUpTo(u32 dividend, u32 divisor) {
  return (dividend + divisor - 1) / divisor
}

@override
@custom
@no_replay
cmd void RecreateImage(
    VkDevice                         device,
    const VkImageCreateInfo*         pCreateInfo,
    VkImage*                         pImage,
    VkMemoryRequirements*            pMemoryRequirements,
    u32                              sparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
  info := pCreateInfo[0]

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          _ = as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  write(pImage[0:1])
  if pMemoryRequirements != null {
    write(pMemoryRequirements[0:1])
  }
  if (sparseMemoryRequirementCount > 0) && (pSparseMemoryRequirements != null) {
    write(pSparseMemoryRequirements[0:sparseMemoryRequirementCount])
  }
}

@threadSafety("system")
@override
@no_replay
cmd VkResult createImageAndCacheMemoryRequirements(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage* pImage,
    VkMemoryRequirements* pMemoryRequirements) {

  // TODO: pAllocator
  info := pCreateInfo[0]
  read(info.pQueueFamilyIndices[0:info.queueFamilyIndexCount])
  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          read(as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0:1])
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
  handle := ?
  pImage[0] = handle
  object := new!ImageObject()
  object.MemoryRequirements = pMemoryRequirements[0]
  Images[handle] = object
  return ?
}

@threadSafety("system")
@override
@no_replay
cmd void cacheImageSparseMemoryRequirements(
    VkDevice device,
    VkImage image,
    u32 count,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
  if (count > 0) && (pSparseMemoryRequirements != null) {
  reqs := pSparseMemoryRequirements[0:count]
  for i in (0 .. count) {
    Images[image].SparseMemoryRequirements[i] = reqs[i]
  }
  }
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateImage(
    VkDevice                     device,
    const VkImageCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage*                     pImage) {
  // TODO: pAllocator

  info := pCreateInfo[0]
  queueFamilyIndices := info.pQueueFamilyIndices[0:info.queueFamilyIndexCount]

  imageInfo := ImageInfo(
    Flags:        info.flags,
    ImageType:    info.imageType,
    Format:       info.format,
    Extent:       info.extent,
    MipLevels:    info.mipLevels,
    ArrayLayers:  info.arrayLayers,
    Samples:      info.samples,
    Tiling:       info.tiling,
    Usage:        info.usage,
    SharingMode:  info.sharingMode,
    Layout:       info.initialLayout,
  )

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
          imageInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
            DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  for i in (0 .. info.queueFamilyIndexCount) {
    imageInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  imageAspect := as!VkImageAspectFlags(
    switch info.format {
      case VK_FORMAT_D16_UNORM,
          VK_FORMAT_X8_D24_UNORM_PACK32,
          VK_FORMAT_D32_SFLOAT:
        VK_IMAGE_ASPECT_DEPTH_BIT
      case VK_FORMAT_S8_UINT:
        VK_IMAGE_ASPECT_STENCIL_BIT
      case VK_FORMAT_D16_UNORM_S8_UINT,
          VK_FORMAT_D24_UNORM_S8_UINT,
          VK_FORMAT_D32_SFLOAT_S8_UINT:
        VK_IMAGE_ASPECT_DEPTH_BIT |
        VK_IMAGE_ASPECT_COLOR_BIT
      default:
        VK_IMAGE_ASPECT_COLOR_BIT
    })

  handle := ?
  pImage[0] = handle
  object := switch (Images[handle] == null) {
    case true:
      new!ImageObject()
    case false:
      Images[handle]
  }

  object.Device = device
  object.IsSwapchainImage = false
  object.VulkanHandle = handle
  object.Info = imageInfo
  object.ImageAspect = imageAspect

  for j in (0 .. info.arrayLayers) {
    layer := new!ImageLayer()
    object.Layers[j] = layer
    for i in (0 .. info.mipLevels) {
      width := getMipSize(info.extent.Width, i)
      height := getMipSize(info.extent.Height, i)
      depth := getMipSize(info.extent.Depth, i)
      level := new!ImageLevel(Width: width,Height:  height,Depth:  depth)
      elementAndTexelBlockSize := getElementAndTexelBlockSize(object.Info.Format)
      // Roundup the width and height in the number of blocks.
      widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
      heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
      size := widthInBlocks * heightInBlocks * depth * elementAndTexelBlockSize.ElementSize
      level.Data = make!u8(size)
      object.Layers[j].Levels[i] = level
    }
  }
  Images[handle] = object

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImage(
    VkDevice                     device,
    VkImage                      image,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if (image != as!VkImage(0)) {
    imageObject := Images[image]
    if (imageObject.BoundMemory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(imageObject.BoundMemory.BoundObjects, as!u64(image))
    }
    delete(Images, image)
  }

}

@indirect("VkDevice")
cmd void vkGetImageSubresourceLayout(
    VkDevice                  device,
    VkImage                   image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout*      pLayout) {
  _ = pSubresource[0]

  pLayout[0] = ?
}

@override
@custom
@no_replay
cmd void RecreateImageView(
    VkDevice                     device,
    const VkImageViewCreateInfo* pCreateInfo,
    VkImageView*                 pImageView) {
  read(pCreateInfo[0:1])
  write(pImageView[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateImageView(
    VkDevice                     device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView*                 pView) {
  image_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  imageViewObject := new!ImageViewObject(Device: device,
    VulkanHandle:           handle,
    Image:                  Images[image_view_create_info.image],
    Type:                   image_view_create_info.viewType,
    Format:                 image_view_create_info.format,
    Components:             image_view_create_info.components,
    SubresourceRange:       image_view_create_info.subresourceRange
  )
  pView[0] = handle
  ImageViews[handle] = imageViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImageView(
    VkDevice                     device,
    VkImageView                  imageView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(ImageViews, imageView)
}

@override
@custom
@no_replay
cmd void RecreateShaderModule(VkDevice                        device,
                              const VkShaderModuleCreateInfo* pCreateInfo,
                              VkShaderModule*                 pShaderModule) {
  create_info := pCreateInfo[0]

  num_words := as!u64(create_info.codeSize) / 4
  read(create_info.pCode[0:num_words])
  write(pShaderModule[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateShaderModule(
    VkDevice                        device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkShaderModule*                 pShaderModule) {
  create_info := pCreateInfo[0]

  num_words := as!u64(create_info.codeSize) / 4
  object := new!ShaderModuleObject(device, clone(create_info.pCode[0:num_words]))

  handle := ?
  pShaderModule[0] = handle
  object.VulkanHandle = handle
  ShaderModules[handle] = object

  return ?
}

@override
@custom
@no_replay
cmd void RecreateDestroyShaderModule(
    VkDevice       device,
    VkShaderModule shaderModule) { }

@override
@custom
@no_replay
cmd void RecreateDestroyRenderPass(
    VkDevice     device,
    VkRenderPass renderPass) { }


@indirect("VkDevice")
cmd void vkDestroyShaderModule(
    VkDevice                     device,
    VkShaderModule               shaderModule,
    const VkAllocationCallbacks* pAllocator) {
  delete(ShaderModules, shaderModule)
}

@override
@custom
@no_replay
cmd void RecreatePipelineCache(VkDevice                         device,
                               const VkPipelineCacheCreateInfo* pCreateInfo,
                               VkPipelineCache*                 pPipelineCache) {
  info := pCreateInfo[0]
  if info.pInitialData != null {
    read(info.pInitialData[0:info.initialDataSize])
  }
  write(pPipelineCache[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreatePipelineCache(
    VkDevice                         device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*     pAllocator,
    VkPipelineCache*                 pPipelineCache) {
  //TODO(awoloszyn): Add Allocator support
  create_info := pCreateInfo[0]
  read(as!u8*(create_info.pInitialData)[0:create_info.initialDataSize])
  handle := ?
  pPipelineCache[0] = handle
  PipelineCaches[handle] = new!PipelineCacheObject(device, handle)
  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipelineCache(
    VkDevice                     device,
    VkPipelineCache              pipelineCache,
    const VkAllocationCallbacks* pAllocator) {
  delete(PipelineCaches, pipelineCache)
}

@indirect("VkDevice")
cmd VkResult vkGetPipelineCacheData(
    VkDevice        device,
    VkPipelineCache pipelineCache,
    size*           pDataSize,
    void*           pData) {
  _ = pDataSize[0]

  writeDataSize := ?
  pDataSize[0] = writeDataSize
  if pData != null {
    write(as!u8*(pData)[0:writeDataSize])
  }
  return ?
}

@indirect("VkDevice")
cmd VkResult vkMergePipelineCaches(
    VkDevice               device,
    VkPipelineCache        dstCache,
    u32                    srcCacheCount,
    const VkPipelineCache* pSrcCaches) {
  read(pSrcCaches[0:srcCacheCount])
  return ?
}

extern bool hasDynamicProperty(const VkPipelineDynamicStateCreateInfo* info,
                               VkDynamicState                          state)

@internal
class CreatedGraphicsPipelines {
  map!(u32, ref!GraphicsPipelineObject) Objects
}

@override
@custom
@no_replay
cmd void RecreateGraphicsPipeline(
    VkDevice                            device,
    VkPipelineCache                     pipelineCache,
    const VkGraphicsPipelineCreateInfo* pCreateInfo,
    VkPipeline*                         pPipeline) {
  create_info := pCreateInfo[0]
  pipeline_shader_stage_create_infos :=
  create_info.pStages[0:create_info.stageCount]
  for j in (0 .. create_info.stageCount) {
    stage_create_info := pipeline_shader_stage_create_infos[j]
    _ = as!string(stage_create_info.pName)
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      read(spec_info.pMapEntries[0:spec_info.mapEntryCount])
      read(as!char*(spec_info.pData)[0:spec_info.dataSize])
    }
  }

  vertex_input_state := create_info.pVertexInputState[0]
  read(vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount])
  read(vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount])

  read(create_info.pInputAssemblyState[0:1])

  if (create_info.pTessellationState != null) {
    read(create_info.pTessellationState[0:1])
  }
  if (create_info.pViewportState != null) {
    pipeline_viewport_state_create_info := create_info.pViewportState[0]
    if (!hasDynamicProperty(
          create_info.pDynamicState,
          VK_DYNAMIC_STATE_VIEWPORT)) {
      read(pipeline_viewport_state_create_info.pViewports[0:
        pipeline_viewport_state_create_info.viewportCount])
    }
    if (!hasDynamicProperty(
          create_info.pDynamicState,
          VK_DYNAMIC_STATE_SCISSOR)) {
      read(pipeline_viewport_state_create_info.pScissors[0:
        pipeline_viewport_state_create_info.scissorCount])
    }
  }
  read(create_info.pRasterizationState[0:1])

  if (create_info.pMultisampleState != null) {
    multisample_state := create_info.pMultisampleState[0]
    if (multisample_state.pSampleMask != null) {
      num_samples := as!u32(multisample_state.rasterizationSamples)
      sizeof_samplemask := (num_samples + 31) / 32
      read(multisample_state.pSampleMask[0:sizeof_samplemask])
    }
  }

  if (create_info.pDepthStencilState != null) {
    read(create_info.pDepthStencilState[0:1])
  }
  if (create_info.pColorBlendState != null) {
    color_blend_state := create_info.pColorBlendState[0]
    read(color_blend_state.pAttachments[0:
      color_blend_state.attachmentCount])
  }
  if (create_info.pDynamicState != null) {
    dynamic_state_info := create_info.pDynamicState[0]
    read(dynamic_state_info.pDynamicStates[0:
      dynamic_state_info.dynamicStateCount])
  }

  write(pPipeline[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateGraphicsPipelines(
    VkDevice                            device,
    VkPipelineCache                     pipelineCache,
    u32                                 createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*        pAllocator,
    VkPipeline*                         pPipelines) {
  // TODO(awoloszyn): Figure out what fields we want to store off
  //    in the state block.
  infos := pCreateInfos[0:createInfoCount]
  pipelines := pPipelines[0:createInfoCount]

  createdPipelines := CreatedGraphicsPipelines()

  for i in (0 .. createInfoCount) {
    obj := new!GraphicsPipelineObject(
      PipelineCache: PipelineCaches[pipelineCache]
    )
    obj.Device = device
    create_info := infos[i]
    // TODO: create_info.pNext
    obj.Flags = create_info.flags

    pipeline_shader_stage_create_infos :=
    create_info.pStages[0:create_info.stageCount]
    for j in (0 .. create_info.stageCount) {
      stage_create_info := pipeline_shader_stage_create_infos[j]
      stage_data := StageData(
        Stage:       stage_create_info.stage,
        Module:      ShaderModules[stage_create_info.module],
        EntryPoint:  as!string(stage_create_info.pName),
      )
      if (stage_create_info.pSpecializationInfo != null) {
        spec_info := stage_create_info.pSpecializationInfo[0]
        spec_data := new!SpecializationInfo()
        spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
        for k in (0 .. spec_info.mapEntryCount) {
          spec_data.Specializations[k] = spec_map[k]
        }
        spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
        stage_data.Specialization = spec_data
      }
      obj.Stages[j] = stage_data
    }

    vertex_input_state := create_info.pVertexInputState[0]
    vertex_descriptions := vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount]
    // TODO: vertex_input_state.pNext
    for b in (0 .. vertex_input_state.vertexBindingDescriptionCount) {
      vertex_binding := vertex_descriptions[b]
      obj.VertexInputState.BindingDescriptions[vertex_binding.binding] = vertex_binding
    }

    vertex_attributes := vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount]

    for b in (0 .. vertex_input_state.vertexAttributeDescriptionCount) {
      attribute := vertex_attributes[b]
      obj.VertexInputState.AttributeDescriptions[b] = attribute
    }

    input_assembly_state := create_info.pInputAssemblyState[0]
    obj.InputAssemblyState.Topology = input_assembly_state.topology
    obj.InputAssemblyState.PrimitiveRestartEnable = input_assembly_state.primitiveRestartEnable

    // TODO: pInputAssemblypNext
    if (create_info.pTessellationState != null) {
      tessellation_state := create_info.pTessellationState[0]
      obj.TessellationState = new!TessellationStateData(
        PatchControlPoints: tessellation_state.patchControlPoints
      )
    }
    if (create_info.pViewportState != null) {

      // TODO: pViewportpNext
      pipeline_viewport_state_create_info := create_info.pViewportState[0]

      viewport_data := new!ViewportData()

      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_VIEWPORT)) {

        viewports := pipeline_viewport_state_create_info.pViewports[0:
        pipeline_viewport_state_create_info.viewportCount]
        for k in (0 .. pipeline_viewport_state_create_info.viewportCount) {
          viewport_data.Viewports[k] = viewports[k]
        }
      }
      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_SCISSOR)) {
        scissors := pipeline_viewport_state_create_info.pScissors[0:
        pipeline_viewport_state_create_info.scissorCount]
        for k in (0 .. pipeline_viewport_state_create_info.scissorCount) {
          viewport_data.Scissors[k] = scissors[k]
        }
      }
      obj.ViewportState = viewport_data
    }
    rasterization_state := create_info.pRasterizationState[0]

    obj.RasterizationState.DepthClampEnable = rasterization_state.depthClampEnable
    obj.RasterizationState.RasterizerDiscardEnable = rasterization_state.rasterizerDiscardEnable
    obj.RasterizationState.PolygonMode = rasterization_state.polygonMode
    obj.RasterizationState.CullMode = rasterization_state.cullMode
    obj.RasterizationState.FrontFace = rasterization_state.frontFace
    obj.RasterizationState.DepthBiasEnable = rasterization_state.depthBiasEnable
    obj.RasterizationState.DepthBiasConstantFactor = rasterization_state.depthBiasConstantFactor
    obj.RasterizationState.DepthBiasClamp = rasterization_state.depthBiasClamp
    obj.RasterizationState.DepthBiasSlopeFactor = rasterization_state.depthBiasSlopeFactor
    obj.RasterizationState.LineWidth = rasterization_state.lineWidth

    // TODO _.pNext

    if (create_info.pMultisampleState != null) {
      multisample_state := create_info.pMultisampleState[0]
      multisample_data := new!MultisampleData(
        RasterizationSamples:   multisample_state.rasterizationSamples,
        SampleShadingEnable:    multisample_state.sampleShadingEnable,
        MinSampleShading:       multisample_state.minSampleShading,
        AlphaToCoverageEnable:  multisample_state.alphaToCoverageEnable,
        AlphaToOneEnable:       multisample_state.alphaToOneEnable
      )
      // TODO: multisample_state.pNext
      if (multisample_state.pSampleMask != null) {
        num_samples := as!u32(multisample_state.rasterizationSamples)
        sizeof_samplemask := (num_samples + 31) / 32
        sample_masks := multisample_state.pSampleMask[0:sizeof_samplemask]
        for k in (0 .. sizeof_samplemask) {
          multisample_data.SampleMask[k] = sample_masks[k]
        }
      }
      obj.MultisampleState = multisample_data
    }

    if (create_info.pDepthStencilState != null) {
      // TODO: pDepthStencilpNext
      depth_stencil_state := create_info.pDepthStencilState[0]
      obj.DepthState = new!DepthData(
        DepthTestEnable:        depth_stencil_state.depthTestEnable,
        DepthWriteEnable:       depth_stencil_state.depthWriteEnable,
        DepthCompareOp:         depth_stencil_state.depthCompareOp,
        DepthBoundsTestEnable:  depth_stencil_state.depthBoundsTestEnable,
        StencilTestEnable:      depth_stencil_state.stencilTestEnable,
        Front:                  depth_stencil_state.front,
        Back:                   depth_stencil_state.back,
        MinDepthBounds:         depth_stencil_state.minDepthBounds,
        MaxDepthBounds:         depth_stencil_state.maxDepthBounds)
    }
    if (create_info.pColorBlendState != null) {
      color_blend_state := create_info.pColorBlendState[0]
      color_blend_data := new!ColorBlendData(
        LogicOpEnable:   color_blend_state.logicOpEnable,
        LogicOp:         color_blend_state.logicOp,
        BlendConstants:  color_blend_state.blendConstants
      )
      // TODO: color_blend_state.pNext
      attachments := color_blend_state.pAttachments[0:
      color_blend_state.attachmentCount]
      for k in (0 .. color_blend_state.attachmentCount) {
        color_blend_data.Attachments[k] = attachments[k]
      }
      obj.ColorBlendState = color_blend_data
    }
    if (create_info.pDynamicState != null) {
      dynamic_state_info := create_info.pDynamicState[0]
      dynamic_data := new!DynamicData()
      // TODO: dynamic_state_info.pNext
      states := dynamic_state_info.pDynamicStates[0:
      dynamic_state_info.dynamicStateCount]
      for k in (0 .. dynamic_state_info.dynamicStateCount) {
        dynamic_data.DynamicStates[k] = states[k]
      }
      obj.DynamicState = dynamic_data
    }
    obj.Layout = PipelineLayouts[create_info.layout]
    obj.RenderPass = RenderPasses[create_info.renderPass]
    obj.Subpass = create_info.subpass
    if ((as!u32(create_info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (create_info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = create_info.basePipelineIndex
      } else {
        obj.BasePipeline = create_info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    createdPipelines.Objects[i] = obj
  }

  fence

  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    createdPipelines.Objects[i].VulkanHandle = pipeline
    if (createdPipelines.Objects[i].BasePipelineIndex != -1) {
      createdPipelines.Objects[i].BasePipeline = pipelines[createdPipelines.Objects[i].BasePipelineIndex]
    }
    GraphicsPipelines[pipeline] = createdPipelines.Objects[i]
  }

  return ?
}

@internal
class CreatedComputePipelines {
  map!(u32, ref!ComputePipelineObject) Objects
}

@override
@custom
@no_replay
cmd void RecreateComputePipeline(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    const VkComputePipelineCreateInfo* pCreateInfo,
    VkPipeline*                        pPipeline) {
  create_info := pCreateInfo[0]
  _ = as!string(create_info.stage.pName)
  if (create_info.stage.pSpecializationInfo != null) {
    spec_info := create_info.stage.pSpecializationInfo[0]
    read(spec_info.pMapEntries[0:spec_info.mapEntryCount])
    read(as!char*(spec_info.pData)[0:spec_info.dataSize])
  }
  write(pPipeline[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateComputePipelines(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    u32                                createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*       pAllocator,
    VkPipeline*                        pPipelines) {
  created_pipelines := CreatedComputePipelines()
  infos := pCreateInfos[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    info := infos[i]
    obj := new!ComputePipelineObject(
      PipelineCache:   PipelineCaches[pipelineCache],
      Device:          device,
      Flags:           info.flags,
      PipelineLayout:  PipelineLayouts[info.layout]
    )
    stage_create_info := infos[i].stage
    stage_data := StageData(
      Stage:       stage_create_info.stage,
      Module:      ShaderModules[stage_create_info.module],
      EntryPoint:  as!string(stage_create_info.pName),
    )
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      spec_data := new!SpecializationInfo()
      spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
      for k in (0 .. spec_info.mapEntryCount) {
        spec_data.Specializations[k] = spec_map[k]
      }
      spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
      stage_data.Specialization = spec_data
    }
    obj.Stage = stage_data
    if ((as!u32(info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = info.basePipelineIndex
      } else {
        obj.BasePipeline = info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    created_pipelines.Objects[i] = obj
  }
  // TODO: pAllocator

  pipelines := pPipelines[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    created_pipelines.Objects[i].VulkanHandle = pipeline
    if (created_pipelines.Objects[i].BasePipelineIndex != -1) {
      created_pipelines.Objects[i].BasePipeline = pipelines[created_pipelines.Objects[i].BasePipelineIndex]
    }
    ComputePipelines[pipeline] = created_pipelines.Objects[i]
  }

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipeline(
    VkDevice                     device,
    VkPipeline                   pipeline,
    const VkAllocationCallbacks* pAllocator) {
  if pipeline in GraphicsPipelines {
    delete(GraphicsPipelines, pipeline)
  }
  if pipeline in ComputePipelines {
    delete(ComputePipelines, pipeline)
  }
}

@override
@custom
@no_replay
cmd void RecreatePipelineLayout(VkDevice                          device,
                                const VkPipelineLayoutCreateInfo* pCreateInfo,
                                VkPipelineLayout*                 pPipelineLayout) {
  info := pCreateInfo[0]
  read(info.pSetLayouts[0:info.setLayoutCount])
  read(info.pPushConstantRanges[0:info.pushConstantRangeCount])
  write(pPipelineLayout[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreatePipelineLayout(
    VkDevice                          device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkPipelineLayout*                 pPipelineLayout) {

  info := pCreateInfo[0]
  pipelineLayout := new!PipelineLayoutObject(Device: device)
  // TODO: info.pNext
  // TODO: pAllocator

  layoutCount := info.setLayoutCount
  layouts := info.pSetLayouts[0:layoutCount]
  for i in (0 .. layoutCount) {
    pipelineLayout.SetLayouts[i] = DescriptorSetLayouts[layouts[i]]
  }
  pushConstantCount := info.pushConstantRangeCount
  pushConstants := info.pPushConstantRanges[0:pushConstantCount]
  for i in (0 .. pushConstantCount) {
    pipelineLayout.PushConstantRanges[i] = pushConstants[i]
  }

  handle := ?
  pPipelineLayout[0] = handle
  pipelineLayout.VulkanHandle = handle
  PipelineLayouts[handle] = pipelineLayout
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipelineLayout(
    VkDevice                     device,
    VkPipelineLayout             pipelineLayout,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(PipelineLayouts, pipelineLayout)
}

@override
@custom
@no_replay
cmd void RecreateSampler(VkDevice                   device,
                         const VkSamplerCreateInfo* pCreateInfo,
                         VkSampler*                 pSampler) {
  read(pCreateInfo[0:1])
  write(pSampler[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSampler(
    VkDevice                     device,
    const VkSamplerCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler*                   pSampler) {
  create_info := pCreateInfo[0]
  sampler := new!SamplerObject(
    Device:                   device,
    MagFilter:                create_info.magFilter,
    MinFilter:                create_info.minFilter,
    MipMapMode:               create_info.mipmapMode,
    AddressModeU:             create_info.addressModeU,
    AddressModeV:             create_info.addressModeV,
    AddressModeW:             create_info.addressModeW,
    MipLodBias:               create_info.mipLodBias,
    AnisotropyEnable:         create_info.anisotropyEnable,
    MaxAnisotropy:            create_info.maxAnisotropy,
    CompareEnable:            create_info.compareEnable,
    CompareOp:                create_info.compareOp,
    MinLod:                   create_info.minLod,
    MaxLod:                   create_info.maxLod,
    BorderColor:              create_info.borderColor,
    UnnormalizedCoordinates:  create_info.unnormalizedCoordinates
  )
  handle := ?
  pSampler[0] = handle
  sampler.VulkanHandle = handle
  Samplers[handle] = sampler
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySampler(
    VkDevice                     device,
    VkSampler                    sampler,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Samplers, sampler)
}

@internal class MutableU32 {
  u32 Val
}

@override
@custom
@no_replay
cmd void RecreateDescriptorSetLayout(VkDevice                               device,
                                     const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                     VkDescriptorSetLayout*                 pSetLayout) {
  info := pCreateInfo[0]
  count := info.bindingCount
  bindings := info.pBindings[0:count]
  for i in (0 .. count) {
    if (bindings[i].pImmutableSamplers != null) {
      c := bindings[i].descriptorCount
      read(bindings[i].pImmutableSamplers[0:c])
    }
  }
  write(pSetLayout[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorSetLayout(
    VkDevice                               device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*           pAllocator,
    VkDescriptorSetLayout*                 pSetLayout) {
  info := pCreateInfo[0]
  // TODO: info.pNext
  count := info.bindingCount
  bindings := info.pBindings[0:count]
  descriptorSetLayout := new!DescriptorSetLayoutObject()
  descriptorSetLayout.Device = device
  largestBinding := MutableU32(0)

  for i in (0 .. count) {
    descriptorBinding := DescriptorSetLayoutBinding(
      Type:    bindings[i].descriptorType,
      Count:   bindings[i].descriptorCount,
      Stages:  bindings[i].stageFlags
    )
    c := bindings[i].descriptorCount
    if (c != 0) && (bindings[i].pImmutableSamplers != null) {
      samplers := bindings[i].pImmutableSamplers[0:c]
      for j in (0 .. c) {
        sampler := samplers[j]
        descriptorBinding.ImmutableSamplers[j] = Samplers[sampler]
      }
    }
    descriptorSetLayout.Bindings[bindings[i].binding] = descriptorBinding
    if (bindings[i].binding > largestBinding.Val) {
      largestBinding.Val = bindings[i].binding
    }
  }
  descriptorSetLayout.MaximumBinding = largestBinding.Val

  // TODO: pAllocator

  handle := ?
  pSetLayout[0] = handle
  descriptorSetLayout.VulkanHandle = handle
  DescriptorSetLayouts[handle] = descriptorSetLayout

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorSetLayout(
    VkDevice                     device,
    VkDescriptorSetLayout        descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(DescriptorSetLayouts, descriptorSetLayout)
}


@override
@custom
@no_replay
cmd void RecreateDescriptorPool(VkDevice                          device,
                                const VkDescriptorPoolCreateInfo* pCreateInfo,
                                VkDescriptorPool*                 pDescriptorPool) {
  info := pCreateInfo[0]
  read(info.pPoolSizes[0:info.poolSizeCount])
  write(pDescriptorPool[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorPool(
    VkDevice                          device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDescriptorPool*                 pDescriptorPool) {
  info := pCreateInfo[0]
  pool := new!DescriptorPoolObject(
    Device:   device,
    Flags:    info.flags,
    MaxSets:  info.maxSets)

  sizes := info.pPoolSizes[0:info.poolSizeCount]
  for i in (0 .. info.poolSizeCount) {
    pool.Sizes[i] = sizes[i]
  }
  // TODO: info.pNext

  // TODO: pAllocator

  handle := ?
  pDescriptorPool[0] = handle
  pool.VulkanHandle = handle
  DescriptorPools[handle] = pool

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorPool(
    VkDevice                     device,
    VkDescriptorPool             descriptorPool,
    const VkAllocationCallbacks* pAllocator) {
  delete(DescriptorPools, descriptorPool)
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkResetDescriptorPool(
    VkDevice                   device,
    VkDescriptorPool           descriptorPool,
    VkDescriptorPoolResetFlags flags) {
  // We need to iterate through all the descriptor sets in the descriptor pool
  // and remove them from the pool. The following line will makes a copy of
  // the map in the generated C++ code, to prevent us from deleting an item
  // while iterating the map. However, in the generated Go code, this does not
  // make a copy of the map but a reference. But according to the examples in
  // Effective Go (https://golang.org/doc/effective_go.html#for), deleting
  // while iterating is safe for Go. So the code here should behave as we
  // expect.
  sets := DescriptorPools[descriptorPool].DescriptorSets
  for _ , s , _ in sets {
    delete(DescriptorSets, s)
    delete(DescriptorPools[descriptorPool].DescriptorSets, s)
  }
  return ?
}

@override
@custom
@no_replay // allocateInfo.descriptorSetCount MUST be 1
cmd void RecreateDescriptorSet(
    VkDevice                           device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    u32                                descriptorWriteCount,
    const VkWriteDescriptorSet*        pDescriptorWrites,
    VkDescriptorSet*                   pDescriptorSet) {
  info := pAllocateInfo[0]
  read(info.pSetLayouts[0:info.descriptorSetCount])
  descriptorWrites := pDescriptorWrites[0:descriptorWriteCount]
  for i in (0 .. descriptorWriteCount) {
    write := descriptorWrites[i]
    switch write.descriptorType {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
        read(write.pImageInfo[0:write.descriptorCount])
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
        read(write.pTexelBufferView[0:write.descriptorCount])
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
        read(write.pBufferInfo[0:write.descriptorCount])
    }
  }

  write(pDescriptorSet[0:1])
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkAllocateDescriptorSets(
    VkDevice                           device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet*                   pDescriptorSets) {
  info := pAllocateInfo[0]
  // TODO: info.pNext
  count := info.descriptorSetCount

  layouts := info.pSetLayouts[0:count]
  read(info.pSetLayouts[0:count])
  sets := pDescriptorSets[0:count]

  for i in (0 .. count) {
    handle := ?
    sets[i] = handle
    object := new!DescriptorSetObject(device, handle,
      info.descriptorPool)
    pool := DescriptorPools[info.descriptorPool]
    pool.DescriptorSets[handle] = object
    object.Layout = DescriptorSetLayouts[layouts[i]]
    for j in (0 .. object.Layout.MaximumBinding + 1) {
      if j in object.Layout.Bindings {
        binding := object.Layout.Bindings[j]
        descriptorBinding := DescriptorBinding(
          BindingType: binding.Type)
        imageInfos := descriptorBinding.ImageBinding
        bufferInfos := descriptorBinding.BufferBinding
        bufferViews := descriptorBinding.BufferViewBindings
        for k in (0 .. binding.Count) {
          switch binding.Type {
            case VK_DESCRIPTOR_TYPE_SAMPLER,
                VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
                VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
              imageInfos[k] = new!VkDescriptorImageInfo()
            case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
                VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
              bufferViews[k] = as!VkBufferView(0)
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              bufferInfos[k] = new!VkDescriptorBufferInfo()
          }
        }
        descriptorBinding.ImageBinding = imageInfos
        descriptorBinding.BufferBinding = bufferInfos
        descriptorBinding.BufferViewBindings = bufferViews
        object.Bindings[j] = descriptorBinding
      }
    }
    DescriptorSets[handle] = object
  }

  return ?
}

@indirect("VkDevice")
cmd VkResult vkFreeDescriptorSets(
    VkDevice               device,
    VkDescriptorPool       descriptorPool,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets) {
  sets := pDescriptorSets[0:descriptorSetCount]
  for i in (0 .. descriptorSetCount) {
    pool := DescriptorPools[DescriptorSets[sets[i]].DescriptorPool]
    delete(pool.DescriptorSets, sets[i])
    delete(DescriptorSets, sets[i])
  }

  return ?
}

@internal class ProcessedDescriptorSet {
  u32 Binding
  u32 ArrayIndex
  u32 BindingElementCount
  u32 BindingIndex
}

@internal class DescriptorSetWrite {
  u32                        Binding
  u32                        BindingArrayIndex
  VkDescriptorType           Type
  VkDescriptorSet            DstSet
  ref!VkDescriptorImageInfo  ImageInfo
  ref!VkDescriptorBufferInfo BufferInfo
  VkBufferView               BufferView
}

@internal class WriteReturnMap {
  map!(u32, DescriptorSetWrite) Map
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetWrite) RewriteWriteDescriptorSets
    (u32                         descriptorWriteCount,
     const VkWriteDescriptorSet* pDescriptorWrites) {
  descriptor_set := ProcessedDescriptorSet(0, 0, 0)
  descriptor_writes := pDescriptorWrites[0:descriptorWriteCount]
  ret_val := WriteReturnMap()
  for i in (0 .. descriptorWriteCount) {
    write := descriptor_writes[i]
    count := write.descriptorCount
    set := DescriptorSets[write.dstSet]
    descriptor_set.Binding = write.dstBinding
    descriptor_set.ArrayIndex = write.dstArrayElement
    descriptor_set.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      descriptor_set.BindingElementCount =
      len(set.Bindings[descriptor_set.Binding].ImageBinding) +
      len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
      len(set.Bindings[descriptor_set.Binding].BufferBinding)
      base_binding := descriptor_set.Binding
      for k in (base_binding .. len(set.Bindings)) {
        if (descriptor_set.ArrayIndex > descriptor_set.BindingElementCount - 1) {
          descriptor_set.ArrayIndex = 0
          descriptor_set.Binding = descriptor_set.Binding + 1
          descriptor_set.BindingElementCount =
          len(set.Bindings[descriptor_set.Binding].ImageBinding) +
          len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
          len(set.Bindings[descriptor_set.Binding].BufferBinding)
        }
      }
      switch (write.descriptorType) {
        case VK_DESCRIPTOR_TYPE_SAMPLER,
            VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
          imageInfos := write.pImageInfo[0:descriptor_set.BindingIndex + 1]
          imageInfo := imageInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            DstSet:             write.dstSet,
            Type:               write.descriptorType,
            ImageInfo:          new!VkDescriptorImageInfo(
              Sampler:      imageInfo.Sampler,
              ImageView:    imageInfo.ImageView,
              ImageLayout:  imageInfo.ImageLayout
            )
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
          bufferViews := write.pTexelBufferView[0:descriptor_set.BindingIndex + 1]
          bufferView := bufferViews[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            Type:               write.descriptorType,
            DstSet:             write.dstSet,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            BufferView:         bufferView
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
          bufferInfos := write.pBufferInfo[0:descriptor_set.BindingIndex + 1]
          bufferInfo := bufferInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding:            descriptor_set.Binding,
            Type:               write.descriptorType,
            DstSet:             write.dstSet,
            BindingArrayIndex:  descriptor_set.ArrayIndex,
            BufferInfo:         new!VkDescriptorBufferInfo(
              Buffer:  bufferInfo.Buffer,
              Offset:  bufferInfo.Offset,
              Range:   bufferInfo.Range
            )
          )
        }
        default: {
          // Do nothing, we should also never get here
        }
      }
      descriptor_set.BindingIndex =
      descriptor_set.BindingIndex + 1
      descriptor_set.ArrayIndex = descriptor_set.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@internal class CopyReturnMap {
  map!(u32, DescriptorSetCopy) Map
}

@internal class DescriptorSetCopy {
  u32             SrcBinding
  u32             DstBinding
  u32             SrcArrayIndex
  u32             DstArrayIndex
  VkDescriptorSet SrcSet
  VkDescriptorSet DstSet
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetCopy) RewriteWriteDescriptorCopies
    (u32                        descriptorCopyCount,
     const VkCopyDescriptorSet* pDescriptorCopies) {
  srcDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  dstDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  descriptorCopies := pDescriptorCopies[0:descriptorCopyCount]
  ret_val := CopyReturnMap()
  for i in (0 .. descriptorCopyCount) {
    copy := descriptorCopies[i]
    count := copy.descriptorCount
    srcSet := DescriptorSets[copy.srcSet]
    dstSet := DescriptorSets[copy.dstSet]

    srcDescriptorSet.Binding = copy.srcBinding
    srcDescriptorSet.ArrayIndex = copy.srcArrayElement
    srcDescriptorSet.BindingIndex = 0

    dstDescriptorSet.Binding = copy.dstBinding
    dstDescriptorSet.ArrayIndex = copy.dstArrayElement
    dstDescriptorSet.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      srcDescriptorSet.BindingElementCount =
      len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
      len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
      len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
      dstDescriptorSet.BindingElementCount =
      len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
      len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
      len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
      srcBaseBinding := srcDescriptorSet.Binding
      dstBaseBinding := dstDescriptorSet.Binding

      for k in (srcBaseBinding .. len(srcSet.Bindings)) {
        if (srcDescriptorSet.ArrayIndex > srcDescriptorSet.BindingElementCount - 1) {
          srcDescriptorSet.ArrayIndex = 0
          srcDescriptorSet.Binding = srcDescriptorSet.Binding + 1
          srcDescriptorSet.BindingElementCount =
          len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
          len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
          len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
        }
      }

      for k in (dstBaseBinding .. len(dstSet.Bindings)) {
        if (dstDescriptorSet.ArrayIndex > dstDescriptorSet.BindingElementCount - 1) {
          dstDescriptorSet.ArrayIndex = 0
          dstDescriptorSet.Binding = dstDescriptorSet.Binding + 1
          dstDescriptorSet.BindingElementCount =
          len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
          len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
          len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
        }
      }


      ret_val.Map[len(ret_val.Map)] = DescriptorSetCopy(
        SrcBinding:     srcDescriptorSet.Binding,
        DstBinding:     dstDescriptorSet.Binding,
        SrcArrayIndex:  srcDescriptorSet.ArrayIndex,
        DstArrayIndex:  dstDescriptorSet.ArrayIndex,
        SrcSet:         copy.srcSet,
        DstSet:         copy.dstSet)

      srcDescriptorSet.BindingIndex =
      srcDescriptorSet.BindingIndex + 1
      srcDescriptorSet.ArrayIndex = srcDescriptorSet.ArrayIndex + 1
      dstDescriptorSet.BindingIndex =
      dstDescriptorSet.BindingIndex + 1
      dstDescriptorSet.ArrayIndex = dstDescriptorSet.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@indirect("VkDevice")
cmd void vkUpdateDescriptorSets(
    VkDevice                    device,
    u32                         descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    u32                         descriptorCopyCount,
    const VkCopyDescriptorSet*  pDescriptorCopies) {

  writes := RewriteWriteDescriptorSets(
    descriptorWriteCount,
    pDescriptorWrites)
  for _ , _ , w in writes {
    set := DescriptorSets[w.DstSet]
    binding := w.Binding
    arrayIndex := w.BindingArrayIndex
    setBinding := set.Bindings[binding]
    switch w.Type {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
        imageBinding := setBinding.ImageBinding
        imageBinding[arrayIndex] = w.ImageInfo
        setBinding.ImageBinding = imageBinding
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
        viewBindings := setBinding.BufferViewBindings
        viewBindings[arrayIndex] = w.BufferView
        setBinding.BufferViewBindings = viewBindings
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
        bufferBindings := setBinding.BufferBinding
        bufferBindings[arrayIndex] = w.BufferInfo
        setBinding.BufferBinding = bufferBindings
      }
    }
    set.Bindings[binding] = setBinding
  }

  copies := RewriteWriteDescriptorCopies(
    descriptorCopyCount,
    pDescriptorCopies)
  for _ , _ , c in copies {
    srcSet := DescriptorSets[c.SrcSet]
    dstSet := DescriptorSets[c.DstSet]
    srcBinding := srcSet.Bindings[c.SrcBinding]
    dstBinding := dstSet.Bindings[c.DstBinding]
    switch (srcBinding.BindingType) {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
        imageBinding := dstBinding.ImageBinding
        imageBinding[c.DstArrayIndex] =
        srcBinding.ImageBinding[c.SrcArrayIndex]
        dstBinding.ImageBinding = imageBinding
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
        bufferViews := dstBinding.BufferViewBindings
        bufferViews[c.DstArrayIndex] =
        srcBinding.BufferViewBindings[c.SrcArrayIndex]
        dstBinding.BufferViewBindings = bufferViews
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
        bufferBinding := dstBinding.BufferBinding
        bufferBinding[c.DstArrayIndex] =
        srcBinding.BufferBinding[c.SrcArrayIndex]
        dstBinding.BufferBinding = bufferBinding
      }
    }
    dstSet.Bindings[c.DstBinding] = dstBinding
  }
}

@override
@custom
@no_replay
cmd void RecreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    VkFramebuffer*                 pFramebuffer) {
  create_info := pCreateInfo[0]
  read(create_info.pAttachments[0:create_info.attachmentCount])
  write(pFramebuffer[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkFramebuffer*                 pFramebuffer) {
  create_info := pCreateInfo[0]
  attachments := create_info.pAttachments[0:create_info.attachmentCount]

  framebufferObject := new!FramebufferObject(Device: device,
    Width:                    create_info.width,
    Height:                   create_info.height,
    Layers:                   create_info.layers,
    RenderPass:               RenderPasses[create_info.renderPass])
  for i in (0 .. create_info.attachmentCount) {
    framebufferObject.ImageAttachments[i] = ImageViews[attachments[i]]
  }

  handle := ?
  pFramebuffer[0] = handle
  framebufferObject.VulkanHandle = handle
  Framebuffers[handle] = framebufferObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFramebuffer(
    VkDevice                     device,
    VkFramebuffer                framebuffer,
    const VkAllocationCallbacks* pAllocator) {
  delete(Framebuffers, framebuffer)
}

@override
@custom
@no_replay
cmd void RecreateRenderPass(VkDevice                      device,
                            const VkRenderPassCreateInfo* pCreateInfo,
                            VkRenderPass*                 pRenderPass) {
  info := pCreateInfo[0]
  read(info.pAttachments[0:info.attachmentCount])
  subpasses := info.pSubpasses[0:info.subpassCount]
  for i in (0 .. info.subpassCount) {
    description := subpasses[i]
    read(description.pInputAttachments[0:description.inputAttachmentCount])
    read(description.pColorAttachments[0:description.colorAttachmentCount])
    if description.pResolveAttachments != null {
      read(description.pResolveAttachments[0:description.colorAttachmentCount])
    }
    if description.pDepthStencilAttachment != null {
      read(description.pDepthStencilAttachment[0:1])
    }

    read(description.pPreserveAttachments[0:description.preserveAttachmentCount])
  }
  read(info.pDependencies[0:info.dependencyCount])
  write(pRenderPass[0:1])
}


@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateRenderPass(
    VkDevice                      device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkRenderPass*                 pRenderPass) {
  renderPass := new!RenderPassObject()
  renderPass.Device = device
  info := pCreateInfo[0]

  attachments := info.pAttachments[0:info.attachmentCount]
  for i in (0 .. info.attachmentCount) {
    renderPass.AttachmentDescriptions[i] = attachments[i]
  }
  subpasses := info.pSubpasses[0:info.subpassCount]
  read(subpasses)
  for i in (0 .. info.subpassCount) {
    subpass := subpasses[i]
    description := SubpassDescription(
      PipelineBindPoint: subpass.pipelineBindPoint,
    )
    inputAttachments := subpass.pInputAttachments[0:subpass.inputAttachmentCount]
    for j in (0 .. subpass.inputAttachmentCount) {
      description.InputAttachments[j] = inputAttachments[j]
    }
    colorAttachments := subpass.pColorAttachments[0:subpass.colorAttachmentCount]
    for j in (0 .. subpass.colorAttachmentCount) {
      description.ColorAttachments[j] = colorAttachments[j]
    }
    if subpass.pResolveAttachments != null {
      resolveAttachments := subpass.pResolveAttachments[0:subpass.colorAttachmentCount]
      for j in (0 .. subpass.colorAttachmentCount) {
        description.ResolveAttachments[j] = resolveAttachments[j]
      }
    }
    if (subpass.pDepthStencilAttachment != null) {
      depth_attachment := subpass.pDepthStencilAttachment[0]
      description.DepthStencilAttachment = new!VkAttachmentReference(
        Attachment: depth_attachment.Attachment,
        Layout:     depth_attachment.Layout)
    }
    preserveAttachments := subpass.pPreserveAttachments[0:subpass.preserveAttachmentCount]
    for j in (0 .. subpass.preserveAttachmentCount) {
      description.PreserveAttachments[j] = preserveAttachments[j]
    }
    renderPass.SubpassDescriptions[i] = description
  }
  dependencies := info.pDependencies[0:info.dependencyCount]
  for i in (0 .. info.dependencyCount) {
    renderPass.SubpassDependencies[i] = dependencies[i]
  }
  handle := ?
  pRenderPass[0] = handle
  renderPass.VulkanHandle = pRenderPass[0]
  RenderPasses[handle] = renderPass
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyRenderPass(
    VkDevice                     device,
    VkRenderPass                 renderPass,
    const VkAllocationCallbacks* pAllocator) {
  delete(RenderPasses, renderPass)
}

@indirect("VkDevice")
cmd void vkGetRenderAreaGranularity(
    VkDevice     device,
    VkRenderPass renderPass,
    VkExtent2D*  pGranularity) {
  write(pGranularity[0:1])
}

@override
@custom
@no_replay
cmd void RecreateCommandPool(VkDevice                       device,
                             const VkCommandPoolCreateInfo* pCreateInfo,
                             VkCommandPool*                 pCommandPool) {
  read(pCreateInfo[0:1])
  write(pCommandPool[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateCommandPool(
    VkDevice                       device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkCommandPool*                 pCommandPool) {
  create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pCommandPool[0] = handle
  commandPoolObject := new!CommandPoolObject(Device: device,
    VulkanHandle:             handle,
    Flags:                    create_info.flags,
    QueueFamilyIndex:         create_info.queueFamilyIndex)
  CommandPools[handle] = commandPoolObject

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyCommandPool(
    VkDevice                     device,
    VkCommandPool                commandPool,
    const VkAllocationCallbacks* pAllocator) {
  fence
  for _ , k , _ in CommandPools[commandPool].CommandBuffers {
    delete(CommandBuffers, k)
  }
  delete(CommandPools, commandPool)
}

sub void resetCommandBuffer(ref!CommandBufferObject obj) {
  obj.BufferCommands = BufferCommands()
}

@indirect("VkDevice")
cmd VkResult vkResetCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolResetFlags flags) {
  pool := CommandPools[commandPool]
  for _ , k , b in pool.CommandBuffers {
    b.BeginInfo = null
    b.Recording = NOT_STARTED
    resetCommandBuffer(b)
    resetCmd(k)
  }
  return ?
}

@override
@custom
@no_replay
cmd void RecreateAndBeginCommandBuffer(
    VkDevice                           device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    const VkCommandBufferBeginInfo*    pBeginInfo,
    VkCommandBuffer*                   pCommandBuffer
) {
  read(pAllocateInfo[0:1])
  if pBeginInfo != null {
    beginInfo := pBeginInfo[0]
    if beginInfo.pInheritanceInfo != null {
      read(beginInfo.pInheritanceInfo[0:1])
    }
  }

  write(pCommandBuffer[0:1])
}


@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkAllocateCommandBuffers(
    VkDevice                           device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer*                   pCommandBuffers) {
  allocateInfo := pAllocateInfo[0]
  count := allocateInfo.commandBufferCount

  fence
  cb := pCommandBuffers[0:count]

  for i in (0 .. count) {
    command_buffer := ?
    cb[i] = command_buffer
    CommandBuffers[command_buffer] = new!CommandBufferObject(
      Device:        device,
      VulkanHandle:  command_buffer,
      Recording:     NOT_STARTED,
      Pool:          allocateInfo.commandPool,
      Level:         allocateInfo.level)
    command_pool := CommandPools[allocateInfo.commandPool]
    command_pool.CommandBuffers[command_buffer] = CommandBuffers[command_buffer]
    CommandPools[allocateInfo.commandPool] = command_pool
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd void vkFreeCommandBuffers(
    VkDevice               device,
    VkCommandPool          commandPool,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  cb := pCommandBuffers[0:commandBufferCount]
  for i in (0 .. commandBufferCount) {
    buffer := cb[i]
    buffer_object := CommandBuffers[buffer]
    pool := buffer_object.Pool
    pool_object := CommandPools[pool]
    delete(pool_object.CommandBuffers, buffer)
    CommandPools[pool] = pool_object
    delete(CommandBuffers, buffer)
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkBeginCommandBuffer(
    VkCommandBuffer                 commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo) {
  info := pBeginInfo[0]
  begin := new!CommandBufferBegin(Flags: info.flags,Inherited:  false)

  // TODO: pBeginInfo->pNext
  if info.pInheritanceInfo != null {
    inheritanceInfo := info.pInheritanceInfo[0]
    begin.Inherited = true
    begin.InheritedRenderPass = inheritanceInfo.renderPass
    begin.InheritedSubpass = inheritanceInfo.subpass
    begin.InheritedFramebuffer = inheritanceInfo.framebuffer
    begin.InheritedOcclusionQuery = inheritanceInfo.occlusionQueryEnable
    begin.InheritedQueryFlags = inheritanceInfo.queryFlags
    begin.InheritedPipelineStatsFlags = inheritanceInfo.pipelineStatistics
    // TODO: pBeginInfo->pInheritanceInfo->pNext
  }
  buff := CommandBuffers[commandBuffer]
  buff.BeginInfo = begin
  buff.Recording = RECORDING
  CommandBuffers[commandBuffer] = buff
  resetCommandBuffer(buff)
  resetCmd(commandBuffer)
  return ?
}

@override
@custom
@no_replay
cmd void RecreateEndCommandBuffer(VkCommandBuffer commandBuffer) { }

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkEndCommandBuffer(
    VkCommandBuffer commandBuffer) {
  buff := CommandBuffers[commandBuffer]
  buff.Recording = COMPLETED
  CommandBuffers[commandBuffer] = buff
  return ?
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkResetCommandBuffer(
    VkCommandBuffer           commandBuffer,
    VkCommandBufferResetFlags flags) {
  buff := CommandBuffers[commandBuffer]
  buff.Recording = NOT_STARTED
  buff.BeginInfo = null
  CommandBuffers[commandBuffer] = buff
  resetCommandBuffer(buff)
  return ?
}

@internal class vkCmdBindPipelineArgs {
  VkPipelineBindPoint PipelineBindPoint
  VkPipeline          Pipeline
}

sub void dovkCmdBindPipeline(ref!vkCmdBindPipelineArgs args) {
  switch args.PipelineBindPoint {
    case VK_PIPELINE_BIND_POINT_COMPUTE:
      CurrentComputePipeline = ComputePipelines[args.Pipeline]
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
      lastDrawInfo().GraphicsPipeline = GraphicsPipelines[args.Pipeline]
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindPipeline(
    VkCommandBuffer     commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline          pipeline) {
  args := new!vkCmdBindPipelineArgs(
      PipelineBindPoint: pipelineBindPoint,
      Pipeline:          pipeline)

  addCmd(commandBuffer, args, dovkCmdBindPipeline)
}

extern void addCmd(VkCommandBuffer cmdbuf, any data, any func)
extern void resetCmd(VkCommandBuffer cmdBuf)
extern void notifyPendingCommandAdded(VkQueue queue)
extern void execPendingCommands(VkQueue queue)
extern void enterSubcontext()
extern void nextSubcontext()
extern void leaveSubcontext()
extern void recordUpdateSemaphoreSignal(VkSemaphore semaphore, bool Signaled)
extern void pushDebugMarker(string name)
extern void popDebugMarker()
extern void pushRenderPassMarker(VkRenderPass renderPass)
extern void popRenderPassMarker()
extern void popAndPushMarkerForNextSubpass(u32 nextSubpass)

@internal class vkCmdSetViewportArgs {
  u32                   FirstViewport
  map!(u32, VkViewport) Viewports
}

sub void dovkCmdSetViewport(ref!vkCmdSetViewportArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetViewport(
    VkCommandBuffer   commandBuffer,
    u32               firstViewport,
    u32               viewportCount,
    const VkViewport* pViewports) {
  viewports := pViewports[0:viewportCount]
  args := new!vkCmdSetViewportArgs(
    firstViewport
  )
  for i in (0 .. viewportCount) {
    args.Viewports[i] = viewports[i]
  }

  addCmd(commandBuffer, args, dovkCmdSetViewport)
}

@internal class vkCmdSetScissorArgs {
  u32                 FirstScissor
  map!(u32, VkRect2D) Scissors
}

sub void dovkCmdSetScissor(ref!vkCmdSetScissorArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    u32             firstScissor,
    u32             scissorCount,
    const VkRect2D* pScissors) {
  scissors := pScissors[0:scissorCount]
  args := new!vkCmdSetScissorArgs(
    firstScissor
  )
  for i in (0 .. scissorCount) {
    args.Scissors[i] = scissors[i]
  }

  addCmd(commandBuffer, args, dovkCmdSetScissor)
}

@internal class vkCmdSetLineWidthArgs {
  f32             LineWidth
}

sub void dovkCmdSetLineWidth(ref!vkCmdSetLineWidthArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    f32             lineWidth) {

  args := new!vkCmdSetLineWidthArgs(lineWidth)

  addCmd(commandBuffer, args, dovkCmdSetLineWidth)
}

@internal class vkCmdSetDepthBiasArgs {
  f32 DepthBiasConstantFactor
  f32 DepthBiasClamp
  f32 DepthBiasSlopeFactor
}

sub void dovkCmdSetDepthBias(ref!vkCmdSetDepthBiasArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    f32             depthBiasConstantFactor,
    f32             depthBiasClamp,
    f32             depthBiasSlopeFactor) {

  args := new!vkCmdSetDepthBiasArgs(
      depthBiasConstantFactor,
      depthBiasClamp,
      depthBiasSlopeFactor
    )

  addCmd(commandBuffer, args, dovkCmdSetDepthBias)
}

@internal class vkCmdSetBlendConstantsArgs {
  f32 R
  f32 G
  f32 B
  f32 A
}

sub void dovkCmdSetBlendConstants(ref!vkCmdSetBlendConstantsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetBlendConstants(
              VkCommandBuffer commandBuffer,
    @readonly f32[4]          blendConstants) {

  args := new!vkCmdSetBlendConstantsArgs(
      blendConstants[0],
      blendConstants[1],
      blendConstants[2],
      blendConstants[3])

  addCmd(commandBuffer,
    args, dovkCmdSetBlendConstants)
}

@internal class vkCmdSetDepthBoundsArgs {
  f32 MinDepthBounds
  f32 MaxDepthBounds
}

sub void dovkCmdSetDepthBounds(ref!vkCmdSetDepthBoundsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    f32             minDepthBounds,
    f32             maxDepthBounds) {
  args := new!vkCmdSetDepthBoundsArgs(
      minDepthBounds,
      maxDepthBounds)

  addCmd(commandBuffer,
    args, dovkCmdSetDepthBounds)
}

@internal class vkCmdSetStencilCompareMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                CompareMask
}

sub void dovkCmdSetStencilCompareMask(ref!vkCmdSetStencilCompareMaskArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilCompareMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                compareMask) {
  args := new!vkCmdSetStencilCompareMaskArgs(
      faceMask,
      compareMask
    )

  addCmd(commandBuffer, args, dovkCmdSetStencilCompareMask)
}

@internal class vkCmdSetStencilWriteMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                WriteMask
}

sub void dovkCmdSetStencilWriteMask(ref!vkCmdSetStencilWriteMaskArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilWriteMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                writeMask) {
  args := new!vkCmdSetStencilWriteMaskArgs(
    faceMask,
    writeMask
  )

  addCmd(commandBuffer, args, dovkCmdSetStencilWriteMask)
}

@internal class vkCmdSetStencilReferenceArgs {
  VkStencilFaceFlags FaceMask
  u32                Reference
}

sub void dovkCmdSetStencilReference(ref!vkCmdSetStencilReferenceArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilReference(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                reference) {
  args :=
  new!vkCmdSetStencilReferenceArgs(
    faceMask,
    reference
  )

  addCmd(commandBuffer, args, dovkCmdSetStencilReference)
}

@internal class
vkCmdBindDescriptorSetsArgs {
  VkPipelineBindPoint        PipelineBindPoint
  VkPipelineLayout           Layout
  u32                        FirstSet
  map!(u32, VkDescriptorSet) DescriptorSets
  map!(u32, u32)             DynamicOffsets
}

sub void dovkCmdBindDescriptorSets(ref!vkCmdBindDescriptorSetsArgs args) {
 dynamic_offset_index := MutableU32(0)

  for i , _ , set in args.DescriptorSets {
    lastDrawInfo().DescriptorSets[args.FirstSet + as!u32(i)] = DescriptorSets[set]
  }

  for i in (0 .. len(args.DescriptorSets)) {
    if args.DescriptorSets[as!u32(i)] in DescriptorSets {
      set := DescriptorSets[args.DescriptorSets[as!u32(i)]]

      // Since the pDynamicOffsets point into the bindings in order of
      // binding index, and then array index, we have to loop over all
      // of the BoundBuffers in order of the binding number.

      // Since `for _, k, v in set.BoundBuffers` loops over in an
      // arbitrary order, instead we loop over all bindings for the layout
      // and see if it is a buffer.
      for j in (0 .. len(set.Bindings)) {
        binding := set.Bindings[as!u32(j)]
        for k in (0 .. len(binding.BufferBinding)) {
          bufferBinding := binding.BufferBinding[as!u32(k)]

          binding_offset := switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              as!VkDeviceSize(args.DynamicOffsets[dynamic_offset_index.Val]) + bufferBinding.Offset
            default:
              bufferBinding.Offset
          }
          dynamic_offset_index.Val = switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              dynamic_offset_index.Val + 1
            default:
              dynamic_offset_index.Val
          }
          if (bufferBinding.Buffer in Buffers) {
            bufferObject := Buffers[bufferBinding.Buffer]
            readCoherentMemoryInBuffer(bufferObject, binding_offset, bufferBinding.Range)
          }
        }
        for k in (0 .. len(binding.BufferViewBindings)) {
          buffer_view := binding.BufferViewBindings[as!u32(k)]
          if (buffer_view != as!VkBufferView(0)) {
            buffer_view_object := BufferViews[buffer_view]
            readCoherentMemoryInBuffer(buffer_view_object.Buffer, buffer_view_object.Offset, buffer_view_object.Range)
          }
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindDescriptorSets(
    VkCommandBuffer        commandBuffer,
    VkPipelineBindPoint    pipelineBindPoint,
    VkPipelineLayout       layout,
    u32                    firstSet,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    u32                    dynamicOffsetCount,
    const u32*             pDynamicOffsets) {
  sets := pDescriptorSets[0:descriptorSetCount]
  args := new!vkCmdBindDescriptorSetsArgs(
    PipelineBindPoint: pipelineBindPoint,
    Layout:            layout,
    FirstSet:          firstSet
  )

  dynamic_offsets := pDynamicOffsets[0:dynamicOffsetCount]
  for i in (0 .. dynamicOffsetCount) {
    args.DynamicOffsets[i] = dynamic_offsets[i]
  }
  for i in (0 .. descriptorSetCount) {
    args.DescriptorSets[i] = sets[i]
  }

  addCmd(commandBuffer, args, dovkCmdBindDescriptorSets)
}

@internal
class BoundBuffer {
  ref!BufferObject Buffer
  VkDeviceSize     Offset
  VkDeviceSize     Range
}

@internal
class BoundIndexBuffer {
  VkIndexType Type
  BoundBuffer BoundBuffer
}

@internal class
vkCmdBindIndexBufferArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  VkIndexType  IndexType
}


sub void dovkCmdBindIndexBuffer(ref!vkCmdBindIndexBufferArgs buffer) {
  lastDrawInfo().BoundIndexBuffer = new!BoundIndexBuffer(buffer.IndexType,
    BoundBuffer(Buffers[buffer.Buffer], buffer.Offset, 0))
  Buffers[buffer.Buffer].LastBoundQueue = LastBoundQueue
}


@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    VkIndexType     indexType) {

  args := new!vkCmdBindIndexBufferArgs(
    Buffer:     buffer,
    Offset:     offset,
    IndexType:  indexType
  )

  addCmd(commandBuffer,
    args,
    dovkCmdBindIndexBuffer)
}

@internal class
vkCmdBindVertexBuffersArgs {
  u32                     FirstBinding
  u32                     BindingCount
  map!(u32, VkBuffer)     Buffers
  map!(u32, VkDeviceSize) Offsets
}

@internal
class CmdBindBuffer {
  map!(u32, BoundBuffer) BoundBuffers
}

sub void dovkCmdBindVertexBuffers(ref!vkCmdBindVertexBuffersArgs bind) {
  for i , _ , v in bind.Buffers {
    lastDrawInfo().BoundVertexBuffers[as!u32(i)] = BoundBuffer(
        Buffers[v], bind.Offsets[as!u32(i)],
        Buffers[v].Info.Size - bind.Offsets[as!u32(i)])
    Buffers[v].LastBoundQueue = LastBoundQueue
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindVertexBuffers(
    VkCommandBuffer     commandBuffer,
    u32                 firstBinding,
    u32                 bindingCount,
    const VkBuffer*     pBuffers,
    const VkDeviceSize* pOffsets) {
  args := new!vkCmdBindVertexBuffersArgs(
    FirstBinding:  firstBinding,
    BindingCount:  bindingCount
  )
  buffers := pBuffers[0:bindingCount]
  offsets := pOffsets[0:bindingCount]
  for i in (0 .. bindingCount) {
    args.Buffers[i] = buffers[i]
    args.Offsets[i] = offsets[i]
  }

  addCmd(commandBuffer, args, dovkCmdBindVertexBuffers)
}

sub void readCoherentMemory(ref!DeviceMemoryObject memory, VkDeviceSize readOffset, VkDeviceSize readSize) {
  if IsMemoryCoherent(memory) && (memory.MappedLocation != null) {
    if (as!VkDeviceSize(readOffset) >= memory.MappedOffset) && (as!VkDeviceSize(readOffset) < memory.MappedOffset + memory.MappedSize) {
      offset_in_mapped := as!u64(readOffset) - as!u64(memory.MappedOffset)
      read_size_in_mapped := switch ((as!u64(readSize) == 0xFFFFFFFFFFFFFFFF) || ((offset_in_mapped + as!u64(readSize)) > as!u64(memory.MappedSize))) {
        case true:
          memory.MappedSize - as!VkDeviceSize(offset_in_mapped)
        case false:
          readSize
      }
      if ((offset_in_mapped + as!u64(read_size_in_mapped)) > offset_in_mapped) {
        readMappedCoherentMemory(memory.VulkanHandle, offset_in_mapped, as!size(read_size_in_mapped))
      }
    }
  }
}

sub void readCoherentMemoryInBuffer(ref!BufferObject buffer, VkDeviceSize readOffset, VkDeviceSize readSize) {
  mem := buffer.Memory
  if mem != null {
    if as!u64(readSize) == 0xFFFFFFFFFFFFFFFF {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, buffer.Info.Size - readOffset)
    } else {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, readSize)
    }
  }
}

sub void readCoherentMemoryInImage(ref!ImageObject image) {
  mem := image.BoundMemory
  if mem != null {
    // Host access to image memory is only well-defined for images created with
    // VK_IMAGE_TILING_LINEAR tiling and for image subresources of those images
    // which are currently in either VK_IMAGE_LAYOUT_PREINITIALIZED or
    // VK_IMAGE_LAYOUT_GENERAL layout.
    // TODO: Complete the layout tracking logic then update this if statement
    // to check the layout of the underlying image.
    if image.Info.Tiling == VK_IMAGE_TILING_LINEAR {
      readCoherentMemory(mem, image.BoundMemoryOffset, inferImageSize(image))
    }
  }
}

sub void readCoherentMemoryInCurrentPipelineBoundVertexBuffers(u32 vertexCount, u32 instanceCount, u32 firstVertex, u32 firstInstance) {
  for _ , _ , vertex_binding in lastDrawInfo().GraphicsPipeline.VertexInputState.BindingDescriptions {
    if vertex_binding.binding in lastDrawInfo().BoundVertexBuffers {
      bound_vertex_buffer := lastDrawInfo().BoundVertexBuffers[vertex_binding.binding]
      backing_buf := bound_vertex_buffer.Buffer
      if ((backing_buf.Memory != null) && IsMemoryCoherent(backing_buf.Memory)) {
        start_vertex := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            firstVertex
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            firstInstance
        }
        num_vertices := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            vertexCount
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            instanceCount
        }
        start_offset := bound_vertex_buffer.Offset + as!VkDeviceSize(start_vertex * vertex_binding.stride)
        num := switch vertexCount == 0xFFFFFFFF {
          case true:
            backing_buf.Info.Size - start_offset
          case false:
            as!VkDeviceSize(num_vertices * vertex_binding.stride)
        }
        readCoherentMemoryInBuffer(backing_buf, start_offset, num)
      }
    }
  }
}

@internal class vkCmdDrawArgs {
  u32 VertexCount
  u32 InstanceCount
  u32 FirstVertex
  u32 FirstInstance
}


sub void dovkCmdDraw(ref!vkCmdDrawArgs draw) {
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(draw.VertexCount, draw.InstanceCount, draw.FirstVertex, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  lastDrawInfo().CommandParameters.Draw = draw
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDraw(
    VkCommandBuffer commandBuffer,
    u32             vertexCount,
    u32             instanceCount,
    u32             firstVertex,
    u32             firstInstance) {

  args :=  new!vkCmdDrawArgs(vertexCount, instanceCount, firstVertex, firstInstance)

  addCmd(commandBuffer, args, dovkCmdDraw)
}

@internal class
vkCmdDrawIndexedArgs {
  u32 IndexCount
  u32 InstanceCount
  u32 FirstIndex
  s32 VertexOffset
  u32 FirstInstance
}

sub void dovkCmdDrawIndexed(ref!vkCmdDrawIndexedArgs draw) {
  // Loop through the index buffer, and find the low and high
  // vertices. Then read all of the applicable vertex buffers.
  lastDraw := lastDrawInfo()
  indexBuffer := lastDraw.BoundIndexBuffer.BoundBuffer.Buffer
  indexSize := switch (lastDraw.BoundIndexBuffer.Type) {
    case VK_INDEX_TYPE_UINT16:
      as!VkDeviceSize(2)
    case VK_INDEX_TYPE_UINT32:
      as!VkDeviceSize(4)
  }

  numBytes := as!VkDeviceSize(draw.IndexCount) * indexSize
  startOffset := lastDrawInfo().BoundIndexBuffer.BoundBuffer.Offset + (indexSize * as!VkDeviceSize(draw.FirstIndex))

  // Read the data of the index buffer if the index buffer is backed with coherent memory.
  readCoherentMemoryInBuffer(indexBuffer, startOffset, numBytes)
  // Read the whole vertex buffer if a buffer is backed with coherent memory.
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, draw.InstanceCount, 0, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  lastDrawInfo().CommandParameters.DrawIndexed = draw
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    u32             indexCount,
    u32             instanceCount,
    u32             firstIndex,
    s32             vertexOffset,
    u32             firstInstance) {

  args := new!vkCmdDrawIndexedArgs(
      IndexCount:     indexCount,
      InstanceCount:  instanceCount,
      FirstIndex:     firstIndex,
      VertexOffset:   vertexOffset,
      FirstInstance:  firstInstance
  )

  addCmd(commandBuffer, args, dovkCmdDrawIndexed)
}

@internal class vkCmdDrawIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  u32          DrawCount
  u32          Stride
}

sub void dovkCmdDrawIndirect(ref!vkCmdDrawIndirectArgs draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through all the vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    lastDrawInfo().CommandParameters.DrawIndirect = draw
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  args := new!vkCmdDrawIndirectArgs(buffer, offset, drawCount, stride)

  addCmd(commandBuffer, args,  dovkCmdDrawIndirect)
}

@internal class vkCmdDrawIndexedIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
  u32          DrawCount
  u32          Stride
}

sub void dovkCmdDrawIndexedIndirect(ref!vkCmdDrawIndexedIndirectArgs draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through the whole index buffer if it uses coherent menory.
    indexBuffer := lastDrawInfo().BoundIndexBuffer.BoundBuffer.Buffer
    readCoherentMemoryInBuffer(indexBuffer, 0, indexBuffer.Info.Size)
    // Read through all the coherent memory vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    lastDrawInfo().CommandParameters.DrawIndexedIndirect = draw
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  args := new!vkCmdDrawIndexedIndirectArgs(buffer, offset, drawCount, stride)

  addCmd(commandBuffer, args, dovkCmdDrawIndexedIndirect)
}

@internal class vkCmdDispatchArgs {
  u32 GroupCountX,
  u32 GroupCountY,
  u32 GroupCountZ
}

sub void dovkCmdDispatch(ref!vkCmdDispatchArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    u32             groupCountX,
    u32             groupCountY,
    u32             groupCountZ) {
  args :=
    new!vkCmdDispatchArgs(groupCountX, groupCountY, groupCountZ)

  addCmd(commandBuffer, args, dovkCmdDispatch)
}

@internal
class vkCmdDispatchIndirectArgs {
  VkBuffer     Buffer
  VkDeviceSize Offset
}

sub void dovkCmdDispatchIndirect(ref!vkCmdDispatchIndirectArgs dispatch) {
  command_size := as!VkDeviceSize(12)
  readCoherentMemoryInBuffer(Buffers[dispatch.Buffer], dispatch.Offset, command_size)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset) {
  args := new!vkCmdDispatchIndirectArgs(buffer, offset)

  addCmd(commandBuffer, args, dovkCmdDispatchIndirect)
}

@internal class vkCmdCopyBufferArgs {
  VkBuffer                SrcBuffer  ,
  VkBuffer                DstBuffer  ,
  map!(u32, VkBufferCopy) CopyRegions
}

sub void dovkCmdCopyBuffer(ref!vkCmdCopyBufferArgs buffer) {
  sourceBuffer := Buffers[buffer.SrcBuffer]
  destBuffer := Buffers[buffer.DstBuffer]
  for _ , _ , region in buffer.CopyRegions {
    srcMemoryOffset := sourceBuffer.MemoryOffset + region.srcOffset
    dstMemoryOffset := destBuffer.MemoryOffset + region.dstOffset
    readCoherentMemoryInBuffer(sourceBuffer, region.srcOffset, region.size)
    copy(destBuffer.Memory.Data[dstMemoryOffset:dstMemoryOffset + region.size],
      sourceBuffer.Memory.Data[srcMemoryOffset:srcMemoryOffset + region.size])
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBuffer(
    VkCommandBuffer     commandBuffer,
    VkBuffer            srcBuffer,
    VkBuffer            dstBuffer,
    u32                 regionCount,
    const VkBufferCopy* pRegions) {
  args := new!vkCmdCopyBufferArgs(
    SrcBuffer:  srcBuffer,
    DstBuffer:  dstBuffer
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.CopyRegions[i] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdCopyBuffer)
}

@internal
class vkCmdCopyImageArgs {
  VkImage                SrcImage
  VkImageLayout          SrcImageLayout
  VkImage                DstImage
  VkImageLayout          DstImageLayout
  map!(u32, VkImageCopy) Regions
}

sub void dovkCmdCopyImage(ref!vkCmdCopyImageArgs args) {
  srcImageObject := Images[args.SrcImage]
  dstImageObject := Images[args.DstImage]

  // The following read on coherent memory of the source image does not affect the data in imageLevel.Data, as they are different memory spaces.
  // But such a read is necessary if the backing memory of the source image is coherent, as we need the read observations on all memory changes
  // in order to replay correctly. However, as the UI's texture data comes from imageLevel.Data, just using the following call will not bring
  // the changes in coherent memory to the UI's texture view.
  readCoherentMemoryInImage(srcImageObject)

  srcFormat := srcImageObject.Info.Format
  srcElementAndTexelBlockSize := getElementAndTexelBlockSize(srcFormat)
  dstFormat := dstImageObject.Info.Format
  dstElementAndTexelBlockSize := getElementAndTexelBlockSize(dstFormat)
  for r in (0 .. len(args.Regions)) {
    // TODO: (qining) Handle the apsect mask
    region := args.Regions[as!u32(r)]
    srcBaseLayer := region.srcSubresource.baseArrayLayer
    dstBaseLayer := region.srcSubresource.baseArrayLayer
    srcMipLevel := region.srcSubresource.mipLevel
    dstMipLevel := region.dstSubresource.mipLevel

    srcElementSize := as!u64(srcElementAndTexelBlockSize.ElementSize)
    srcBlockWidth := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Width)
    srcBlockHeight := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Height)
    dstElementSize := as!u64(dstElementAndTexelBlockSize.ElementSize)
    dstBlockWidth := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Width)
    dstBlockHeight := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Height)

    srcXStartInBlocks := as!u64(as!u64(region.srcOffset.x) / srcBlockWidth)
    srcYStartInBlocks := as!u64(as!u64(region.srcOffset.y) / srcBlockHeight)
    srcZStart := as!u64(region.srcOffset.z)
    dstXStartInBlocks := as!u64(as!u64(region.dstOffset.x) / dstBlockWidth)
    dstYStartInBlocks := as!u64(as!u64(region.dstOffset.y) / dstBlockHeight)
    dstZStart := as!u64(region.dstOffset.z)

    extentXInBlocks := roundUpTo(region.extent.Width, as!u32(srcBlockWidth))
    extentYInBlocks := roundUpTo(region.extent.Height, as!u32(srcBlockHeight))
    extentZ := region.extent.Depth

    for l in (0 .. region.srcSubresource.layerCount) {
      srcImageLevel := srcImageObject.Layers[srcBaseLayer + l].Levels[srcMipLevel]
      dstImageLevel := dstImageObject.Layers[dstBaseLayer + l].Levels[dstMipLevel]

      srcImageLevelWidthInBlocks := as!u64(roundUpTo(srcImageLevel.Width, as!u32(srcBlockWidth)))
      srcImageLevelHeightInBlocks := as!u64(roundUpTo(srcImageLevel.Height, as!u32(srcBlockHeight)))
      dstImageLevelWidthInBlocks := as!u64(roundUpTo(dstImageLevel.Width, as!u32(dstBlockWidth)))
      dstImageLevelHeightInBlocks := as!u64(roundUpTo(dstImageLevel.Height, as!u32(dstBlockHeight)))

      for z in (0 .. extentZ) {
        for y in (0 .. extentYInBlocks) {
          copySize := as!u64(extentXInBlocks) * srcElementSize
          dstY := dstYStartInBlocks + as!u64(y)
          dstZ := dstZStart + as!u64(z)
          srcY := srcYStartInBlocks + as!u64(y)
          srcZ := srcZStart + as!u64(z)
          dstStart := ((((dstZ * dstImageLevelHeightInBlocks) + dstY) * dstImageLevelWidthInBlocks) + dstXStartInBlocks) * dstElementSize
          srcStart := ((((srcZ * srcImageLevelHeightInBlocks) + srcY) * srcImageLevelWidthInBlocks) + srcXStartInBlocks) * srcElementSize
          copy(dstImageLevel.Data[dstStart:dstStart + copySize], srcImageLevel.Data[srcStart:srcStart + copySize])
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageCopy* pRegions) {
  args := new!vkCmdCopyImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdCopyImage)
}

@internal
class vkCmdBlitImageArgs {
  VkImage                SrcImage
  VkImageLayout          SrcImageLayout
  VkImage                DstImage
  VkImageLayout          DstImageLayout
  map!(u32, VkImageBlit) Regions
  VkFilter               Filter
}

sub void dovkCmdBlitImage(ref!vkCmdBlitImageArgs dispatch) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBlitImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageBlit* pRegions,
    VkFilter           filter) {
  args := new!vkCmdBlitImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout,
    Filter:          filter
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdBlitImage)
}

@internal
class TexelBlockSizePair {
  u32 Width
  u32 Height
}

@internal
class ElementAndTexelBlockSize {
  u32                ElementSize
  TexelBlockSizePair TexelBlockSize
}

// This should roughly correspond to "Compatible formats" in the Vulkan spec
sub ElementAndTexelBlockSize getElementAndTexelBlockSize(VkFormat format) {
  return switch (format) {
    case VK_FORMAT_R4G4_UNORM_PACK8,
        VK_FORMAT_R8_UNORM,
        VK_FORMAT_R8_SNORM,
        VK_FORMAT_R8_USCALED,
        VK_FORMAT_R8_SSCALED,
        VK_FORMAT_R8_UINT,
        VK_FORMAT_R8_SINT,
        VK_FORMAT_R8_SRGB:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R4G4B4A4_UNORM_PACK16,
        VK_FORMAT_B4G4R4A4_UNORM_PACK16,
        VK_FORMAT_R5G6B5_UNORM_PACK16,
        VK_FORMAT_B5G6R5_UNORM_PACK16,
        VK_FORMAT_R5G5B5A1_UNORM_PACK16,
        VK_FORMAT_B5G5R5A1_UNORM_PACK16,
        VK_FORMAT_A1R5G5B5_UNORM_PACK16,
        VK_FORMAT_R8G8_UNORM,
        VK_FORMAT_R8G8_SNORM,
        VK_FORMAT_R8G8_USCALED,
        VK_FORMAT_R8G8_SSCALED,
        VK_FORMAT_R8G8_UINT,
        VK_FORMAT_R8G8_SINT,
        VK_FORMAT_R8G8_SRGB,
        VK_FORMAT_R16_UNORM,
        VK_FORMAT_R16_SNORM,
        VK_FORMAT_R16_USCALED,
        VK_FORMAT_R16_SSCALED,
        VK_FORMAT_R16_UINT,
        VK_FORMAT_R16_SINT,
        VK_FORMAT_R16_SFLOAT:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8_UNORM,
        VK_FORMAT_R8G8B8_SNORM,
        VK_FORMAT_R8G8B8_USCALED,
        VK_FORMAT_R8G8B8_SSCALED,
        VK_FORMAT_R8G8B8_UINT,
        VK_FORMAT_R8G8B8_SINT,
        VK_FORMAT_R8G8B8_SRGB,
        VK_FORMAT_B8G8R8_UNORM,
        VK_FORMAT_B8G8R8_SNORM,
        VK_FORMAT_B8G8R8_USCALED,
        VK_FORMAT_B8G8R8_SSCALED,
        VK_FORMAT_B8G8R8_UINT,
        VK_FORMAT_B8G8R8_SINT,
        VK_FORMAT_B8G8R8_SRGB:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8A8_UNORM,
        VK_FORMAT_R8G8B8A8_SNORM,
        VK_FORMAT_R8G8B8A8_USCALED,
        VK_FORMAT_R8G8B8A8_SSCALED,
        VK_FORMAT_R8G8B8A8_UINT,
        VK_FORMAT_R8G8B8A8_SINT,
        VK_FORMAT_R8G8B8A8_SRGB,
        VK_FORMAT_B8G8R8A8_UNORM,
        VK_FORMAT_B8G8R8A8_SNORM,
        VK_FORMAT_B8G8R8A8_USCALED,
        VK_FORMAT_B8G8R8A8_SSCALED,
        VK_FORMAT_B8G8R8A8_UINT,
        VK_FORMAT_B8G8R8A8_SINT,
        VK_FORMAT_B8G8R8A8_SRGB,
        VK_FORMAT_A8B8G8R8_UNORM_PACK32,
        VK_FORMAT_A8B8G8R8_SNORM_PACK32,
        VK_FORMAT_A8B8G8R8_USCALED_PACK32,
        VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
        VK_FORMAT_A8B8G8R8_UINT_PACK32,
        VK_FORMAT_A8B8G8R8_SINT_PACK32,
        VK_FORMAT_A8B8G8R8_SRGB_PACK32,
        VK_FORMAT_A2R10G10B10_UNORM_PACK32,
        VK_FORMAT_A2R10G10B10_SNORM_PACK32,
        VK_FORMAT_A2R10G10B10_USCALED_PACK32,
        VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
        VK_FORMAT_A2R10G10B10_UINT_PACK32,
        VK_FORMAT_A2R10G10B10_SINT_PACK32,
        VK_FORMAT_A2B10G10R10_UNORM_PACK32,
        VK_FORMAT_A2B10G10R10_SNORM_PACK32,
        VK_FORMAT_A2B10G10R10_USCALED_PACK32,
        VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
        VK_FORMAT_A2B10G10R10_UINT_PACK32,
        VK_FORMAT_A2B10G10R10_SINT_PACK32,
        VK_FORMAT_R16G16_UNORM,
        VK_FORMAT_R16G16_SNORM,
        VK_FORMAT_R16G16_USCALED,
        VK_FORMAT_R16G16_SSCALED,
        VK_FORMAT_R16G16_UINT,
        VK_FORMAT_R16G16_SINT,
        VK_FORMAT_R16G16_SFLOAT,
        VK_FORMAT_R32_UINT,
        VK_FORMAT_R32_SINT,
        VK_FORMAT_R32_SFLOAT,
        VK_FORMAT_B10G11R11_UFLOAT_PACK32,
        VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16_UNORM,
        VK_FORMAT_R16G16B16_SNORM,
        VK_FORMAT_R16G16B16_USCALED,
        VK_FORMAT_R16G16B16_SSCALED,
        VK_FORMAT_R16G16B16_UINT,
        VK_FORMAT_R16G16B16_SINT,
        VK_FORMAT_R16G16B16_SFLOAT:
      ElementAndTexelBlockSize(6, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16A16_UNORM,
        VK_FORMAT_R16G16B16A16_SNORM,
        VK_FORMAT_R16G16B16A16_USCALED,
        VK_FORMAT_R16G16B16A16_SSCALED,
        VK_FORMAT_R16G16B16A16_UINT,
        VK_FORMAT_R16G16B16A16_SINT,
        VK_FORMAT_R16G16B16A16_SFLOAT,
        VK_FORMAT_R32G32_UINT,
        VK_FORMAT_R32G32_SINT,
        VK_FORMAT_R32G32_SFLOAT,
        VK_FORMAT_R64_UINT,
        VK_FORMAT_R64_SINT,
        VK_FORMAT_R64_SFLOAT:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32_UINT,
        VK_FORMAT_R32G32B32_SINT,
        VK_FORMAT_R32G32B32_SFLOAT:
      ElementAndTexelBlockSize(12, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32A32_UINT,
        VK_FORMAT_R32G32B32A32_SINT,
        VK_FORMAT_R32G32B32A32_SFLOAT,
        VK_FORMAT_R64G64_UINT,
        VK_FORMAT_R64G64_SINT,
        VK_FORMAT_R64G64_SFLOAT:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64_UINT,
        VK_FORMAT_R64G64B64_SINT,
        VK_FORMAT_R64G64B64_SFLOAT:
      ElementAndTexelBlockSize(24, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64A64_UINT,
        VK_FORMAT_R64G64B64A64_SINT,
        VK_FORMAT_R64G64B64A64_SFLOAT:
      ElementAndTexelBlockSize(32, TexelBlockSizePair(1, 1))
    case VK_FORMAT_BC1_RGB_UNORM_BLOCK,
        VK_FORMAT_BC1_RGB_SRGB_BLOCK,
        VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
        VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC2_UNORM_BLOCK,
        VK_FORMAT_BC2_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC3_UNORM_BLOCK,
        VK_FORMAT_BC3_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC4_UNORM_BLOCK,
        VK_FORMAT_BC4_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC5_UNORM_BLOCK,
        VK_FORMAT_BC5_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC6H_UFLOAT_BLOCK,
        VK_FORMAT_BC6H_SFLOAT_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC7_UNORM_BLOCK,
        VK_FORMAT_BC7_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
        VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11_UNORM_BLOCK,
        VK_FORMAT_EAC_R11_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
        VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
        VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
        VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 4))
    case VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 5))
    case VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 5))
    case VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 6))
    case VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 5))
    case VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 6))
    case VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 8))
    case VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 5))
    case VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 6))
    case VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 8))
    case VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
        VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 10))
    case VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
        VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 10))
    case VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
        VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 12))
    case VK_FORMAT_D16_UNORM:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_X8_D24_UNORM_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_S8_UINT:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D16_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D24_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT_S8_UINT:
      ElementAndTexelBlockSize(5, TexelBlockSizePair(1, 1))
    default:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
  }
}

@internal
class RowLengthAndImageHeight {
  u32 RowLength
  u32 ImageHeight
}

sub RowLengthAndImageHeight getRowLengthAndImageHeight(VkBufferImageCopy region) {
  rowLength := switch region.bufferRowLength == 0 {
    case true:  region.imageExtent.Width
    case false: region.bufferRowLength
  }
  imageHeight := switch region.bufferImageHeight == 0 {
    case true:  region.imageExtent.Height
    case false: region.bufferImageHeight
  }
  return RowLengthAndImageHeight(rowLength, imageHeight)
}

@interal
class MutableVkDeviceSize {
  VkDeviceSize Val
}

sub VkDeviceSize inferImageSize(ref!ImageObject img) {
  img_info := img.Info
  img_size := MutableVkDeviceSize(0)
  for m in (0 .. img_info.MipLevels) {
    img_size.Val += inferImageLevelSize(img, m)
  }
  return img_size.Val
}

sub VkDeviceSize inferImageLevelSize(ref!ImageObject img, u32 level) {
  img_info := img.Info
  level_size := MutableVkDeviceSize(0)
  if level < img_info.MipLevels {
    block_info := getElementAndTexelBlockSize(img_info.Format)
    width := getMipSize(img_info.Extent.Width, level)
    height := getMipSize(img_info.Extent.Height, level)
    depth := getMipSize(img_info.Extent.Depth, level)
    width_in_blocks := roundUpTo(width, block_info.TexelBlockSize.Width)
    height_in_blocks := roundUpTo(height, block_info.TexelBlockSize.Height)
    level_size.Val += as!VkDeviceSize(width_in_blocks * height_in_blocks * depth * block_info.ElementSize * img_info.ArrayLayers)
  }
  return level_size.Val
}

@internal
class vkCmdCopyBufferToImageArgs {
  VkBuffer                     SrcBuffer
  VkImage                      DstImage
  VkImageLayout                Layout
  map!(u64, VkBufferImageCopy) Regions
}

sub void dovkCmdCopyBufferToImage(ref!vkCmdCopyBufferToImageArgs args) {
  bufferObject := Buffers[args.SrcBuffer]
  imageObject := Images[args.DstImage]
  format := imageObject.Info.Format
  elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
  // Iterate through regions
  for i in (0 .. len(args.Regions)) {
    region := args.Regions[as!u64(i)]
    rowLengthAndImageHeight := getRowLengthAndImageHeight(region)
    rowLength := as!u64(rowLengthAndImageHeight.RowLength / elementAndTexelBlockSize.TexelBlockSize.Width)
    imageHeight := as!u64(rowLengthAndImageHeight.ImageHeight / elementAndTexelBlockSize.TexelBlockSize.Height)
    elementSize := as!u64(elementAndTexelBlockSize.ElementSize)
    layerSize := rowLength * imageHeight * elementSize
    zStart := as!u64(region.imageOffset.z)
    zEnd := zStart + as!u64(region.imageExtent.Depth)
    yStart := as!u64(as!u32(region.imageOffset.y) / elementAndTexelBlockSize.TexelBlockSize.Height)
    yEnd := yStart + as!u64(region.imageExtent.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
    xStart := as!u64(as!u32(region.imageOffset.x) / elementAndTexelBlockSize.TexelBlockSize.Width)
    xEnd := xStart + as!u64(region.imageExtent.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
    // When multiple layers are specified in the buffer image copy region,
    // Vulkan assumes the data of all the layers are placed continuously in
    // the source buffer memory.
    // TODO: (qining) Handle aspect mask
    for j in (0 .. region.imageSubresource.layerCount) {
      layerIndex := region.imageSubresource.baseArrayLayer + j
      bufferLayerOffset := as!u64(j) * layerSize
      imageLevel := imageObject.Layers[layerIndex].Levels[region.imageSubresource.mipLevel]
      imageLevelWidthInBlocks := as!u64(imageLevel.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
      imageLevelHeightInBlocks := as!u64(imageLevel.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
      // Iterate through depths and rows to copy
      for z in (zStart .. zEnd) {
        for y in (yStart .. yEnd) {
          copySize := (xEnd - xStart) * elementSize
          dstStart := ((((z * imageLevelHeightInBlocks) + y) * imageLevelWidthInBlocks) + xStart) * elementSize
          dstEnd := dstStart + copySize
          zInExtent := z - zStart
          yInExtent := y - yStart
          rowStartInExtent := (((zInExtent * imageHeight) + yInExtent) * rowLength) * elementSize
          srcStart := as!u64(bufferObject.MemoryOffset) + as!u64(region.bufferOffset) + bufferLayerOffset + rowStartInExtent
          srcEnd := srcStart + copySize
          readCoherentMemoryInBuffer(bufferObject, region.bufferOffset + as!VkDeviceSize(bufferLayerOffset + rowStartInExtent), as!VkDeviceSize(copySize))
          copy(imageLevel.Data[dstStart:dstEnd], bufferObject.Memory.Data[srcStart:srcEnd])
        }
      }
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBufferToImage(
    VkCommandBuffer          commandBuffer,
    VkBuffer                 srcBuffer,
    VkImage                  dstImage,
    VkImageLayout            dstImageLayout,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  regions := pRegions[0:regionCount]
  read(regions)
  args := new!vkCmdCopyBufferToImageArgs(srcBuffer, dstImage, dstImageLayout)
  for i in (0 .. regionCount) {
    args.Regions[as!u64(i)] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdCopyBufferToImage)
}

@internal
class vkCmdCopyImageToBufferArgs {
  VkImage                      SrcImage
  VkImageLayout                SrcImageLayout
  VkBuffer                     DstBuffer
  map!(u32, VkBufferImageCopy) Regions
}

sub void dovkCmdCopyImageToBuffer(ref!vkCmdCopyImageToBufferArgs dispatch) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImageToBuffer(
    VkCommandBuffer          commandBuffer,
    VkImage                  srcImage,
    VkImageLayout            srcImageLayout,
    VkBuffer                 dstBuffer,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  regions := pRegions[0:regionCount]
  args := new!vkCmdCopyImageToBufferArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstBuffer:       dstBuffer,
  )
  for i in (0 .. regionCount) {
    args.Regions[as!u32(i)] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdCopyImageToBuffer)
}

@internal class vkCmdUpdateBufferArgs {
  VkBuffer     DstBuffer
  VkDeviceSize DstOffset
  VkDeviceSize DataSize
  u8[]         Data
}

sub void dovkCmdUpdateBuffer(ref!vkCmdUpdateBufferArgs args) {
  Buffers[args.DstBuffer].LastBoundQueue = LastBoundQueue
  buff := Buffers[args.DstBuffer]
  start := buff.MemoryOffset+args.DstOffset
  copy(buff.Memory.Data[start:start + args.DataSize],
     args.Data[0:args.DataSize])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    dataSize,
    const void*     pData) {
  args := new!vkCmdUpdateBufferArgs(
      dstBuffer,
      dstOffset,
      dataSize,
  )
  args.Data = clone(as!u8*(pData)[0:dataSize])

  addCmd(commandBuffer, args,
    dovkCmdUpdateBuffer)
}

@internal
class vkCmdFillBufferArgs {
  VkBuffer     Buffer
  VkDeviceSize DstOffset,
  VkDeviceSize Size
  u32          Data
}

sub void dovkCmdFillBuffer(ref!vkCmdFillBufferArgs args) {
// DO NOT CHECK IN: IMPLEMENT THIS
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    size,
    u32             data) {

  args := new!vkCmdFillBufferArgs(
      dstBuffer,
      dstOffset,
      size,
      data
  )

  addCmd(commandBuffer, args, dovkCmdFillBuffer)
}

@internal
class vkCmdClearColorImageArgs {
  VkImage                            Image
  VkImageLayout                      ImageLayout
  VkClearColorValue                  Color
  map!(u32, VkImageSubresourceRange) Ranges
}

sub void dovkCmdClearColorImage(ref!vkCmdClearColorImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearColorImage(
    VkCommandBuffer                commandBuffer,
    VkImage                        image,
    VkImageLayout                  imageLayout,
    const VkClearColorValue*       pColor,
    u32                            rangeCount,
    const VkImageSubresourceRange* pRanges) {
  color := pColor[0]
  ranges := pRanges[0:rangeCount]
  args := new!vkCmdClearColorImageArgs(
    Image:        image,
    ImageLayout:  imageLayout,
    Color:        color,
  )
  for i in (0 .. rangeCount) {
    args.Ranges[as!u32(i)] = ranges[i]
  }

  addCmd(commandBuffer, args, dovkCmdClearColorImage)
}

@internal
class vkCmdClearDepthStencilImageArgs {
  VkImage                            Image
  VkImageLayout                      ImageLayout
  VkClearDepthStencilValue           DepthStencil
  map!(u32, VkImageSubresourceRange) Ranges
}

sub void dovkCmdClearDepthStencilImage(ref!vkCmdClearDepthStencilImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearDepthStencilImage(
    VkCommandBuffer                 commandBuffer,
    VkImage                         image,
    VkImageLayout                   imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    u32                             rangeCount,
    const VkImageSubresourceRange*  pRanges) {
  depthStencil := pDepthStencil[0]
  ranges := pRanges[0:rangeCount]
  args := new!vkCmdClearDepthStencilImageArgs(
    Image:         image,
    ImageLayout:   imageLayout,
    DepthStencil:  depthStencil,
  )
  for i in (0 .. rangeCount) {
    args.Ranges[as!u32(i)] = ranges[i]
  }

  addCmd(commandBuffer, args, dovkCmdClearDepthStencilImage)
}

@internal
class vkCmdClearAttachmentsArgs {
  map!(u32, VkClearAttachment) Attachments
  map!(u32, VkClearRect)       Rects
}

sub void dovkCmdClearAttachments(ref!vkCmdClearAttachmentsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearAttachments(
    VkCommandBuffer          commandBuffer,
    u32                      attachmentCount,
    const VkClearAttachment* pAttachments,
    u32                      rectCount,
    const VkClearRect*       pRects) {
  args := new!vkCmdClearAttachmentsArgs()
  attachments := pAttachments[0:attachmentCount]
  rects := pRects[0:rectCount]
  for i in (0 .. attachmentCount) {
    args.Attachments[as!u32(i)] = attachments[i]
  }
  for i in (0 .. rectCount) {
    args.Rects[as!u32(i)] = rects[i]
  }

  addCmd(commandBuffer, args, dovkCmdClearAttachments)
}

@internal class vkCmdResolveImageArgs {
  VkImage                   SrcImage      ,
  VkImageLayout             SrcImageLayout,
  VkImage                   DstImage      ,
  VkImageLayout             DstImageLayout,
  map!(u32, VkImageResolve) ResolveRegions
}

sub void dovkCmdResolveImage(ref!vkCmdResolveImageArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResolveImage(
    VkCommandBuffer       commandBuffer,
    VkImage               srcImage,
    VkImageLayout         srcImageLayout,
    VkImage               dstImage,
    VkImageLayout         dstImageLayout,
    u32                   regionCount,
    const VkImageResolve* pRegions) {
  args := new!vkCmdResolveImageArgs(
    SrcImage:        srcImage,
    SrcImageLayout:  srcImageLayout,
    DstImage:        dstImage,
    DstImageLayout:  dstImageLayout
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    args.ResolveRegions[as!u32(i)] = regions[i]
  }

  addCmd(commandBuffer, args, dovkCmdResolveImage)
}

@internal class vkCmdSetEventArgs {
  VkEvent              Event
  VkPipelineStageFlags StageMask
}

sub void dovkCmdSetEvent(ref!vkCmdSetEventArgs event) {
  Events[event.Event].Signaled = true
  Events[event.Event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  args := new!vkCmdSetEventArgs(
    Event:      event,
    StageMask:  stageMask
  )

  addCmd(commandBuffer, args, dovkCmdSetEvent)
}

@internal class vkCmdResetEventArgs {
  VkEvent              Event
  VkPipelineStageFlags StageMask
}

sub void dovkCmdResetEvent(ref!vkCmdResetEventArgs event) {
  Events[event.Event].Signaled = false
  Events[event.Event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  args := new!vkCmdResetEventArgs(
    Event:      event,
    StageMask:  stageMask,
  )

  addCmd(commandBuffer, args, dovkCmdResetEvent)
}

@internal class vkCmdWaitEventsArgs {
  map!(u32, VkEvent)               Events
  VkPipelineStageFlags             SrcStageMask
  VkPipelineStageFlags             DstStageMask
  map!(u32, VkMemoryBarrier)       MemoryBarriers
  map!(u32, VkBufferMemoryBarrier) BufferMemoryBarriers
  map!(u32, VkImageMemoryBarrier)  ImageMemoryBarriers
}


sub void dovkCmdWaitEvents(ref!vkCmdWaitEventsArgs args) {
  for _ , _ , e in args.Events {
    event := Events[e]
    event.SubmitQueue = LastBoundQueue.VulkanHandle
    if event.Signaled != true {
      LastBoundQueue.PendingEvents[e] = event
    }
  }
  if len(LastBoundQueue.PendingEvents) == 0 {
    for _ , _ , b in args.ImageMemoryBarriers {
      image := Images[b.image]
      image.Info.Layout = b.newLayout
      image.LastBoundQueue = LastBoundQueue
    }
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWaitEvents(
    VkCommandBuffer              commandBuffer,
    u32                          eventCount,
    const VkEvent*               pEvents,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  args := new!vkCmdWaitEventsArgs(
    SrcStageMask:  srcStageMask,
    DstStageMask:  dstStageMask,
  )
  events := pEvents[0:eventCount]
  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. eventCount) {
    args.Events[i] = events[i]
  }
  for i in (0 .. memoryBarrierCount) {
    args.MemoryBarriers[i] = memoryBarriers[i]
  }
  for i in (0 .. bufferMemoryBarrierCount) {
    args.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }
  for i in (0 .. imageMemoryBarrierCount) {
    args.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }

  addCmd(commandBuffer, args, dovkCmdWaitEvents)
}

@internal class vkCmdPipelineBarrierArgs {
  VkPipelineStageFlags             SrcStageMask        ,
  VkPipelineStageFlags             DstStageMask        ,
  VkDependencyFlags                DependencyFlags     ,
  map!(u32, VkMemoryBarrier)       MemoryBarriers      ,
  map!(u32, VkBufferMemoryBarrier) BufferMemoryBarriers,
  map!(u32, VkImageMemoryBarrier)  ImageMemoryBarriers
}

sub void dovkCmdPipelineBarrier(ref!vkCmdPipelineBarrierArgs args) {
  for _ , _ , v in args.ImageMemoryBarriers {
    image := Images[v.image]
    image.Info.Layout = v.newLayout
    image.LastBoundQueue = LastBoundQueue
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPipelineBarrier(
    VkCommandBuffer              commandBuffer,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    VkDependencyFlags            dependencyFlags,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  args := new!vkCmdPipelineBarrierArgs(
    SrcStageMask:     srcStageMask,
    DstStageMask:     dstStageMask,
    DependencyFlags:  dependencyFlags
  )
  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  for i in (0 .. memoryBarrierCount) {
    args.MemoryBarriers[i] = memoryBarriers[i]
  }

  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  for i in (0 .. bufferMemoryBarrierCount) {
    args.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }

  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. imageMemoryBarrierCount) {
    args.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }

  addCmd(commandBuffer, args, dovkCmdPipelineBarrier)
}

@internal class vkCmdBeginQueryArgs {
  VkQueryPool         QueryPool
  u32                 Query
  VkQueryControlFlags Flags
}

sub void dovkCmdBeginQuery(ref!vkCmdBeginQueryArgs args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_ACTIVE
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginQuery(
    VkCommandBuffer     commandBuffer,
    VkQueryPool         queryPool,
    u32                 query,
    VkQueryControlFlags flags) {

  args := new!vkCmdBeginQueryArgs(
    queryPool,              query, flags
  )

  addCmd(commandBuffer, args, dovkCmdBeginQuery)
}

@internal class
vkCmdEndQueryArgs {
  VkQueryPool QueryPool
  u32         Query
}

sub void dovkCmdEndQuery(ref!vkCmdEndQueryArgs args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_COMPLETE
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             query) {
  args := new!vkCmdEndQueryArgs(
    queryPool,            query
  )

  addCmd(commandBuffer, args, dovkCmdEndQuery)
}

@internal class
vkCmdResetQueryPoolArgs {
  VkQueryPool QueryPool
  u32         FirstQuery
  u32         QueryCount
}

sub void dovkCmdResetQueryPool(ref!vkCmdResetQueryPoolArgs args) {
  pool := QueryPools[args.QueryPool]
  for i in (0 .. args.QueryCount) {
    pool.Status[args.FirstQuery + i] = QUERY_STATUS_INACTIVE
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             firstQuery,
    u32             queryCount) {
  args := new!vkCmdResetQueryPoolArgs(
    queryPool,                  firstQuery, queryCount
  )

  addCmd(commandBuffer, args, dovkCmdResetQueryPool)
}

@internal class vkCmdWriteTimestampArgs {
  VkPipelineStageFlagBits PipelineStage,
  VkQueryPool             QueryPool    ,
  u32                     Query
}

sub void dovkCmdWriteTimestamp(ref!vkCmdWriteTimestampArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWriteTimestamp(
    VkCommandBuffer         commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool             queryPool,
    u32                     query) {
  args := new!vkCmdWriteTimestampArgs(
    pipelineStage,              queryPool, query
  )

  addCmd(commandBuffer, args, dovkCmdWriteTimestamp)
}

@internal
class vkCmdCopyQueryPoolResultsArgs {
  VkQueryPool        QueryPool
  u32                FirstQuery
  u32                QueryCount
  VkBuffer           DstBuffer
  VkDeviceSize       DstOffset
  VkDeviceSize       Stride
  VkQueryResultFlags Flags
}

sub void dovkCmdCopyQueryPoolResults(ref!vkCmdCopyQueryPoolResultsArgs args) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyQueryPoolResults(
    VkCommandBuffer    commandBuffer,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    VkBuffer           dstBuffer,
    VkDeviceSize       dstOffset,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  args := new!vkCmdCopyQueryPoolResultsArgs(
    QueryPool:   queryPool,
    FirstQuery:  firstQuery,
    QueryCount:  queryCount,
    DstBuffer:   dstBuffer,
    DstOffset:   dstOffset,
    Stride:      stride,
    Flags:       flags
  )

  addCmd(commandBuffer, args, dovkCmdCopyQueryPoolResults)
}

@internal class
vkCmdPushConstantsArgs {
  VkPipelineLayout   Layout
  VkShaderStageFlags StageFlags
  u32                Offset
  u32                Size
  u8[]               Data
}

sub void dovkCmdPushConstants(ref!vkCmdPushConstantsArgs args) {
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPushConstants(
    VkCommandBuffer    commandBuffer,
    VkPipelineLayout   layout,
    VkShaderStageFlags stageFlags,
    u32                offset,
    u32                size,
    const void*        pValues) {
  args := new!vkCmdPushConstantsArgs(
    layout,           stageFlags, offset, size, clone(as!u8*(pValues)[0:size])
  )

  addCmd(commandBuffer, args, dovkCmdPushConstants)
}

@internal class
vkCmdBeginRenderPassArgs {
  VkSubpassContents       Contents
  VkRenderPass            RenderPass
  VkFramebuffer           Framebuffer
  VkRect2D                RenderArea
  map!(u32, VkClearValue) ClearValues
}

sub void dovkCmdBeginRenderPass(ref!vkCmdBeginRenderPassArgs args) {
  VK_ATTACHMENT_UNUSED := as!u32(0xFFFFFFFF)
  lastDrawInfo().Framebuffer = Framebuffers[args.Framebuffer]
  lastDrawInfo().LastSubpass = 0
  lastDrawInfo().RenderPass = RenderPasses[args.RenderPass]
  lastDrawInfo().InRenderPass = true
  for _ , _ , v in lastDrawInfo().Framebuffer.ImageAttachments {
    v.Image.LastBoundQueue = LastBoundQueue
  }
  subpass := lastDrawInfo().RenderPass.SubpassDescriptions[0]
  for _ , _ , a in subpass.InputAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  for _ , _ , a in subpass.ColorAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  for _ , _ , a in subpass.ResolveAttachments {
    if a.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
  }
  if subpass.DepthStencilAttachment != null {
    dsRef := subpass.DepthStencilAttachment
    if dsRef.Attachment != VK_ATTACHMENT_UNUSED {
      lastDrawInfo().Framebuffer.ImageAttachments[dsRef.Attachment].Image.Info.Layout = dsRef.Layout
    }
  }

  pushRenderPassMarker(args.RenderPass)

  // switch RenderPasses[args.RenderPass].DebugInfo == null {
  //   case true:
  //     pushRenderPassMarker("<RenderPass>")
  //   case false:{
  //   switch len(RenderPasses[args.RenderPass].DebugInfo.ObjectName) == 0 {
  //     case true:
  //       pushRenderPassMarker("<RenderPass>")
  //     case false:
  //       pushRenderPassMarker(RenderPasses[args.RenderPass].DebugInfo.ObjectName)
  //   }
  //   }
  // }

  // switch len(RenderPasses[args.RenderPass].SubpassDescriptions) > 1 {
  //   case true:
  //     pushRenderPassMarker("<Subpass>")
  // }
}


@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginRenderPass(
    VkCommandBuffer              commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents            contents) {
  begin_info := pRenderPassBegin[0]
  args := new!vkCmdBeginRenderPassArgs(
    Contents:     contents,
    RenderPass:   begin_info.renderPass,
    Framebuffer:  begin_info.framebuffer,
    RenderArea:   begin_info.renderArea
  )
  clear_values := begin_info.pClearValues[0:begin_info.clearValueCount]
  for i in (0 .. begin_info.clearValueCount) {
    args.ClearValues[i] = clear_values[i]
  }

  addCmd(commandBuffer, args, dovkCmdBeginRenderPass)
}

@internal class
vkCmdNextSubpassArgs {
  VkSubpassContents Contents
}

sub void dovkCmdNextSubpass(ref!vkCmdNextSubpassArgs Unused) {
  lastDrawInfo().LastSubpass += 1
  if lastDrawInfo().LastSubpass < len(lastDrawInfo().RenderPass.SubpassDescriptions) {
    subpass := lastDrawInfo().RenderPass.SubpassDescriptions[lastDrawInfo().LastSubpass]
    for _ , _ , a in subpass.InputAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    for _ , _ , a in subpass.ColorAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    for _ , _ , a in subpass.ResolveAttachments {
      lastDrawInfo().Framebuffer.ImageAttachments[a.Attachment].Image.Info.Layout = a.Layout
    }
    if subpass.DepthStencilAttachment != null {
      dsRef := subpass.DepthStencilAttachment
      lastDrawInfo().Framebuffer.ImageAttachments[dsRef.Attachment].Image.Info.Layout = dsRef.Layout
    }
  }
  popAndPushMarkerForNextSubpass(lastDrawInfo().LastSubpass)
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdNextSubpass(
    VkCommandBuffer   commandBuffer,
    VkSubpassContents contents) {
  args := new!vkCmdNextSubpassArgs(contents)

  addCmd(commandBuffer, args, dovkCmdNextSubpass)
}

@internal class
vkCmdEndRenderPassArgs {
}

sub void dovkCmdEndRenderPass(ref!vkCmdEndRenderPassArgs unused) {
  lastDrawInfo().InRenderPass = false
  popRenderPassMarker()
  switch len(lastDrawInfo().RenderPass.SubpassDescriptions) > 1 {
    case true:
    popRenderPassMarker()
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer) {

  args := new!vkCmdEndRenderPassArgs()

  addCmd(commandBuffer, args, dovkCmdEndRenderPass)
}

@internal
class vkCmdExecuteCommandsArgs {
  map!(u32, VkCommandBuffer) CommandBuffers
}

sub void dovkCmdExecuteCommands(ref!vkCmdExecuteCommandsArgs cmds) {
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdExecuteCommands(
    VkCommandBuffer        commandBuffer,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  cmd_buffers := pCommandBuffers[0:commandBufferCount]
  args := new!vkCmdExecuteCommandsArgs()
  for i in (0 .. commandBufferCount) {
    args.CommandBuffers[as!u32(i)] = cmd_buffers[i]
  }

  addCmd(commandBuffer, args, dovkCmdExecuteCommands)
}

// ----------------------------------------------------------------------------
// VK_KHR_surface
// ----------------------------------------------------------------------------

@extension("VK_KHR_surface")
enum VkColorSpaceKHR {
  VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0x00000000,
}

@extension("VK_KHR_surface")
enum VkPresentModeKHR {
  VK_PRESENT_MODE_IMMEDIATE_KHR    = 0x00000000,
  VK_PRESENT_MODE_MAILBOX_KHR      = 0x00000001,
  VK_PRESENT_MODE_FIFO_KHR         = 0x00000002,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 0x00000003,
}

@extension("VK_KHR_surface")
bitfield VkSurfaceTransformFlagBitsKHR {
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     = 0x00000001,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    = 0x00000002,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   = 0x00000004,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   = 0x00000008,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            = 0x00000010,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  = 0x00000020,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                      = 0x00000100,
}
@extension("VK_KHR_surface")
type VkFlags VkSurfaceTransformFlagsKHR

@extension("VK_KHR_surface")
bitfield VkCompositeAlphaFlagBitsKHR {
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          = 0x00000001,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  = 0x00000002,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         = 0x00000008,
}

@extension("VK_KHR_surface")
type VkFlags VkCompositeAlphaFlagsKHR

@extension("VK_KHR_surface")
@serialize
class VkSurfaceCapabilitiesKHR {
  u32                           minImageCount
  u32                           maxImageCount
  VkExtent2D                    currentExtent
  VkExtent2D                    minImageExtent
  VkExtent2D                    maxImageExtent
  u32                           maxImageArrayLayers
  VkSurfaceTransformFlagsKHR    supportedTransforms
  VkSurfaceTransformFlagBitsKHR currentTransform
  VkCompositeAlphaFlagsKHR      supportedCompositeAlpha
  VkImageUsageFlags             supportedUsageFlags
}

@extension("VK_KHR_surface")
@serialize
class VkSurfaceFormatKHR {
  VkFormat        format
  VkColorSpaceKHR colorSpace
}

@extension("VK_KHR_surface")
@indirect("VkInstance")
cmd void vkDestroySurfaceKHR(
    VkInstance                   instance,
    VkSurfaceKHR                 surface,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Surfaces, surface)
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    u32              queueFamilyIndex,
    VkSurfaceKHR     surface,
    VkBool32*        pSupported) {
  pSupported[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice          physicalDevice,
    VkSurfaceKHR              surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities) {
  pSurfaceCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice    physicalDevice,
    VkSurfaceKHR        surface,
    u32*                pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats) {
  _ = pSurfaceFormatCount[0]

  if pSurfaceFormats == null {
    pSurfaceFormatCount[0] = ?
  } else {
    count := as!u32(?)
    formats := pSurfaceFormats[0:count]
    for i in (0 .. count) {
      formats[i] = ?
    }
    pSurfaceFormatCount[0] = count
  }

  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice  physicalDevice,
    VkSurfaceKHR      surface,
    u32*              pPresentModeCount,
    VkPresentModeKHR* pPresentModes) {
  _ = pPresentModeCount[0]

  if pPresentModes == null {
    pPresentModeCount[0] = ?
  } else {
    count := as!u32(?)
    modes := pPresentModes[0:count]
    for i in (0 .. count) {
      modes[i] = ?
    }
    pPresentModeCount[0] = count
  }

  return ?
}


// ----------------------------------------------------------------------------
// VK_KHR_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_swapchain")
@reserved_flags
type VkFlags VkSwapchainCreateFlagsKHR

@extension("VK_KHR_swapchain")
@serialize
class VkSwapchainCreateInfoKHR {
  VkStructureType               sType
  const void*                   pNext
  VkSwapchainCreateFlagsKHR     flags
  VkSurfaceKHR                  surface
  u32                           minImageCount
  VkFormat                      imageFormat
  VkColorSpaceKHR               imageColorSpace
  VkExtent2D                    imageExtent
  u32                           imageArrayLayers
  VkImageUsageFlags             imageUsage
  VkSharingMode                 imageSharingMode
  u32                           queueFamilyIndexCount
  const u32*                    pQueueFamilyIndices
  VkSurfaceTransformFlagBitsKHR preTransform
  VkCompositeAlphaFlagBitsKHR   compositeAlpha
  VkPresentModeKHR              presentMode
  VkBool32                      clipped
  VkSwapchainKHR                oldSwapchain
}

@extension("VK_KHR_swapchain")
@serialize
class VkPresentInfoKHR {
  VkStructureType       sType
  const void*           pNext
  u32                   waitSemaphoreCount
  const VkSemaphore*    pWaitSemaphores
  u32                   swapchainCount
  const VkSwapchainKHR* pSwapchains
  const u32*            pImageIndices
  VkResult*             pResults
}

@override
@custom
@no_replay
cmd void RecreateSwapchain(VkDevice                  device,
                           VkSwapchainCreateInfoKHR* pCreateInfo,
                           VkImage*                  pSwapchainImages,
                           const VkImageLayout*      pSwapchainLayouts,
                           const VkQueue*            pInitialQueues,
                           VkSwapchainKHR*           pSwapchain) {
  create_info := pCreateInfo[0]
  read(create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount])
  read(pSwapchainLayouts[0:create_info.minImageCount])
  read(pInitialQueues[0:create_info.minImageCount])
  write(pSwapchainImages[0:create_info.minImageCount])
  write(pSwapchain[0:1])
}

@custom
@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@override
cmd VkResult vkCreateSwapchainKHR(
    VkDevice                        device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchain) {
  create_info := pCreateInfo[0]
  queueFamilyIndices := create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount]
  // TODO: pAllocator

  swapchainObject := new!SwapchainObject(Device: device,
    Info:                   ImageInfo(
      ImageType:    VK_IMAGE_TYPE_2D,
      Format:       create_info.imageFormat,
      Extent:       VkExtent3D(create_info.imageExtent.Width, create_info.imageExtent.Height, 1),
      MipLevels:    1,
      ArrayLayers:  create_info.imageArrayLayers,
      Samples:      VK_SAMPLE_COUNT_1_BIT,
      Tiling:       VK_IMAGE_TILING_OPTIMAL,
      Usage:        create_info.imageUsage,
      SharingMode:  create_info.imageSharingMode,
      Layout:       VK_IMAGE_LAYOUT_UNDEFINED
    ),
    Surface:         Surfaces[create_info.surface],
    ColorSpace:      create_info.imageColorSpace,
    PreTransform:    create_info.preTransform,
    CompositeAlpha:  create_info.compositeAlpha,
    PresentMode:     create_info.presentMode,
    Clipped:         create_info.clipped
  )

  for i in (0 .. create_info.queueFamilyIndexCount) {
    swapchainObject.Info.QueueFamilyIndices[i] =
    queueFamilyIndices[i]
  }

  handle := ?
  pSwapchain[0] = handle
  swapchainObject.VulkanHandle = handle
  Swapchains[handle] = swapchainObject

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd void vkDestroySwapchainKHR(
    VkDevice                     device,
    VkSwapchainKHR               swapchain,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  swapObject := Swapchains[swapchain]
  if swapObject != null {
    for _ , _ , v in swapObject.SwapchainImages {
      delete(Images, v.VulkanHandle)
    }
    delete(Swapchains, swapchain)
  }
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd VkResult vkGetSwapchainImagesKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u32*           pSwapchainImageCount,
    VkImage*       pSwapchainImages) {
  swapchainObject := Swapchains[swapchain]
  // Need to do a read observation of the image count as the number of images
  // requested from users might be different from the number offered by the
  // swapchain. Besides, the virtual swapchain creates swapchain images
  // depends on this number.
  if pSwapchainImages != null {
    _ = pSwapchainImageCount[0]
  }
  fence
  if pSwapchainImages == null {
    pSwapchainImageCount[0] = ?
  } else {
    count := pSwapchainImageCount[0]
    images := pSwapchainImages[0:count]
    for i in (0 .. count) {
      images[i] = ?
      if !(images[i] in Images) {
        object := new!ImageObject(BoundMemory: null,
          Device:              device,
          VulkanHandle:        images[i],
          BoundMemoryOffset:   0,
          Info:                swapchainObject.Info,
          ImageAspect:         as!VkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT)
        )
        object.IsSwapchainImage = true
        width := swapchainObject.Info.Extent.Width
        height := swapchainObject.Info.Extent.Height
        format := swapchainObject.Info.Format
        layer := new!ImageLayer()
        level := new!ImageLevel(Width: width,Height:  height,Depth:  1)
        elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
        // Roundup the width and height in the number of blocks.
        widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
        heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
        size := widthInBlocks * heightInBlocks * elementAndTexelBlockSize.ElementSize
        level.Data = make!u8(size)
        object.Layers[0] = layer
        object.Layers[0].Levels[0] = level
        Images[images[i]] = object
      }
      swapchainObject.SwapchainImages[i] = Images[images[i]]
    }
    pSwapchainImageCount[0] = count
  }

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@custom
@blocking
cmd VkResult vkAcquireNextImageKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u64            timeout,
    VkSemaphore    semaphore,
    VkFence        fence,
    u32*           pImageIndex) {
  _ = pImageIndex[0]
  pImageIndex[0] = ?
  if (semaphore != as!VkSemaphore(0)) {
    Semaphores[semaphore].Signaled = true
  }
  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkQueue", "VkDevice")
@frame_end
cmd VkResult vkQueuePresentKHR(
    VkQueue                 queue,
    const VkPresentInfoKHR* pPresentInfo) {
  LastSubmission = PRESENT
  LastBoundQueue = Queues[queue]
  for i in (0 .. LastPresentInfo.PresentImageCount) {
    delete(LastPresentInfo.PresentImages, i)
  }
  LastPresentInfo.PresentImageCount = 0


  info := pPresentInfo[0]
  // TODO: handle pNext

  if (info.pWaitSemaphores != null) {
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for i in (0 .. info.waitSemaphoreCount) {
      Semaphores[wait_semaphores[i]].Signaled = false
    }
  }
  swapchains := info.pSwapchains[0:info.swapchainCount]
  imageIndices := info.pImageIndices[0:info.swapchainCount]
  for i in (0 .. info.swapchainCount) {
    swapchain := Swapchains[swapchains[i]]
    image := swapchain.SwapchainImages[imageIndices[i]]
    LastPresentInfo.PresentImages[LastPresentInfo.PresentImageCount] =
    image
    LastPresentInfo.PresentImageCount = LastPresentInfo.PresentImageCount + 1
    image.LastBoundQueue = Queues[queue]
  }
  fence
  if (info.pResults != null) {
    // TODO(qining): Remove the use of fence once the inference can be done
    // correctly for arrays specified as struct members.
    read(info.pResults[0:info.swapchainCount])
    /*results := info.pResults[0:info.swapchainCount]
        for i in (0 .. info.swapchainCount) {
            result := as!VkResult(?)
            results[i] = result
        }*/
  }
  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display
// ----------------------------------------------------------------------------

@extension("VK_KHR_display")
bitfield VkDisplayPlaneAlphaFlagBitsKHR {
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  = 0x00000001,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  = 0x00000002,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               = 0x00000004,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
}
@extension("VK_KHR_display")
type VkFlags VkDisplayPlaneAlphaFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplayModeCreateFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplaySurfaceCreateFlagsKHR

@extension("VK_KHR_display")
@serialize
class VkDisplayPropertiesKHR {
  VkDisplayKHR               display
  string                     displayName
  VkExtent2D                 physicalDimensions
  VkExtent2D                 physicalResolution
  VkSurfaceTransformFlagsKHR supportedTransforms
  VkBool32                   planeReorderPossible
  VkBool32                   persistentContent
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModeParametersKHR {
  VkExtent2D visibleRegion
  u32        refreshRate
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModePropertiesKHR {
  VkDisplayModeKHR           displayMode
  VkDisplayModeParametersKHR parameters
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModeCreateInfoKHR {
  VkStructureType             sType
  const void*                 pNext
  VkDisplayModeCreateFlagsKHR flags
  VkDisplayModeParametersKHR  parameters
}

@extension("VK_KHR_display")
@serialize
class VkDisplayPlaneCapabilitiesKHR {
  VkDisplayPlaneAlphaFlagsKHR supportedAlpha
  VkOffset2D                  minSrcPosition
  VkOffset2D                  maxSrcPosition
  VkExtent2D                  minSrcExtent
  VkExtent2D                  maxSrcExtent
  VkOffset2D                  minDstPosition
  VkOffset2D                  maxDstPosition
  VkExtent2D                  minDstExtent
  VkExtent2D                  maxDstExtent
}

@extension("VK_KHR_display")
@serialize
class VkDisplayPlanePropertiesKHR {
  VkDisplayKHR currentDisplay
  u32          currentStackIndex
}

@extension("VK_KHR_display")
@serialize
class VkDisplaySurfaceCreateInfoKHR {
  VkStructureType                sType
  const void*                    pNext
  VkDisplaySurfaceCreateFlagsKHR flags
  VkDisplayModeKHR               displayMode
  u32                            planeIndex
  u32                            planeStackIndex
  VkSurfaceTransformFlagBitsKHR  transform
  f32                            globalAlpha
  VkDisplayPlaneAlphaFlagBitsKHR alphaMode
  VkExtent2D                     imageExtent
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice        physicalDevice,
    u32*                    pPropertyCount,
    VkDisplayPropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: also need to observe VkDisplayPropertiesKHR.displayName
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice             physicalDevice,
    u32*                         pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    u32              planeIndex,
    u32*             pDisplayCount,
    VkDisplayKHR*    pDisplays) {
  _ = pDisplayCount[0]

  if pDisplays == null {
    pDisplayCount[0] = ?
  } else {
    count := as!u32(?)
    displays := pDisplays[0:count]
    for i in (0 .. count) {
      displays[i] = ?
    }
    pDisplayCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice            physicalDevice,
    VkDisplayKHR                display,
    u32*                        pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice                  physicalDevice,
    VkDisplayKHR                      display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDisplayModeKHR*                 pMode) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pMode[0] = handle
  modeObject := new!DisplayModeObject(PhysicalDevice: physicalDevice,
    Display:                          display,
    VulkanHandle:                     handle)
  DisplayModes[handle] = modeObject

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice               physicalDevice,
    VkDisplayModeKHR               mode,
    u32                            planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities) {
  pCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_display")
@indirect("VkInstance")
cmd VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                           instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*         pAllocator,
    VkSurfaceKHR*                        pSurface) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pSurface[0] = handle
  surfaceObject := new!SurfaceObject(Instance: instance,
    VulkanHandle:           handle)
  Surfaces[handle] = surfaceObject

  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_display_swapchain")
@serialize @unused
class VkDisplayPresentInfoKHR {
  VkStructureType sType
  const void*     pNext
  VkRect2D        srcRect
  VkRect2D        dstRect
  VkBool32        persistent
}

@extension("VK_KHR_display_swapchain")
@indirect("VkDevice")
cmd VkResult vkCreateSharedSwapchainsKHR(
    VkDevice                        device,
    u32                             swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchains) {
  create_infos := pCreateInfos[0:swapchainCount]
  fence
  swapchains := pSwapchains[0:swapchainCount]
  for i in (0 .. swapchainCount) {
    create_info := create_infos[i]
    queueFamilyIndices := create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount]
    // TODO: pAllocator

    swapchainObject := new!SwapchainObject(Device: device,
      Info:                   ImageInfo(
        ImageType:    VK_IMAGE_TYPE_2D,
        Format:       create_info.imageFormat,
        Extent:       VkExtent3D(create_info.imageExtent.Width, create_info.imageExtent.Height, 1),
        MipLevels:    1,
        ArrayLayers:  create_info.imageArrayLayers,
        Samples:      VK_SAMPLE_COUNT_1_BIT,
        Tiling:       VK_IMAGE_TILING_OPTIMAL,
        Usage:        create_info.imageUsage,
        SharingMode:  create_info.imageSharingMode,
        Layout:       VK_IMAGE_LAYOUT_UNDEFINED
      ),
      Surface:         Surfaces[create_info.surface],
      ColorSpace:      create_info.imageColorSpace,
      PreTransform:    create_info.preTransform,
      CompositeAlpha:  create_info.compositeAlpha,
      PresentMode:     create_info.presentMode,
      Clipped:         create_info.clipped
    )

    for j in (0 .. create_info.queueFamilyIndexCount) {
      swapchainObject.Info.QueueFamilyIndices[j] =
      queueFamilyIndices[j]
    }

    handle := ?
    swapchains[i] = handle
    swapchainObject.VulkanHandle = handle
    Swapchains[handle] = swapchainObject
  }
  return ?
}

// ----------------------------------------------------------------------------
// VK_EXT_debug_report
// ----------------------------------------------------------------------------

@extension("VK_EXT_debug_report")
enum VkDebugReportObjectTypeEXT {
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT               = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT              = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT       = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                 = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT             = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT        = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                 = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT         = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                 = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                 = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT            = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT           = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT            = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT         = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT        = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT       = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT           = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT              = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT               = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT       = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT        = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT           = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT          = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT           = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT         = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT          = 28,
}

@extension("VK_EXT_debug_report")
@unused
enum VkDebugReportErrorEXT {
  VK_DEBUG_REPORT_ERROR_NONE_EXT         = 0,
  VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
}

@extension("VK_EXT_debug_report")
@unused
bitfield VkDebugReportFlagBitsEXT {
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT         = 0x00000001,
  VK_DEBUG_REPORT_WARNING_BIT_EXT             = 0x00000002,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
  VK_DEBUG_REPORT_ERROR_BIT_EXT               = 0x00000008,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT               = 0x00000010,
}
@extension("VK_EXT_debug_report")
type VkFlags VkDebugReportFlagsEXT

@extension("VK_EXT_debug_report")
@external type void* PFN_vkDebugReportCallbackEXT

@extension("VK_EXT_debug_report")
@pfn cmd VkBool32 vkDebugReportCallbackEXT(
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    string                     pLayerPrefix,
    string                     pMessage,
    void*                      pUserData) {
  return ?
}

@extension("VK_EXT_debug_report")
@serialize
class VkDebugReportCallbackCreateInfoEXT {
  VkStructureType              sType
  const void*                  pNext
  VkDebugReportFlagsEXT        flags
  PFN_vkDebugReportCallbackEXT pfnCallback
  void*                        pUserData
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd VkResult vkCreateDebugReportCallbackEXT(
    VkInstance                                instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks*              pAllocator,
    VkDebugReportCallbackEXT*                 pCallback) {
  return ?
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd void vkDestroyDebugReportCallbackEXT(
    VkInstance                   instance,
    VkDebugReportCallbackEXT     callback,
    const VkAllocationCallbacks* pAllocator) {
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd void vkDebugReportMessageEXT(
    VkInstance                 instance,
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    string                     pLayerPrefix,
    string                     pMessage) {
}
extern void validate(string layerName, bool condition, string message)

// ----------------------------------------------------------------------------
// VK_EXT_debug_marker
// ----------------------------------------------------------------------------
@extension("VK_EXT_debug_marker")
@serialize
class VkDebugMarkerObjectNameInfoEXT {
  VkStructureType             sType
  const void*                 pNext
  VkDebugReportObjectTypeEXT  objectType
  u64                         object
  const char*                 pObjectName
}

@extension("VK_EXT_debug_marker")
@serialize
class VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType
    const void*                   pNext
    VkDebugReportObjectTypeEXT    objectType
    u64                           object
    u64                           tagName
    size                          tagSize
    const void*                   pTag
}

@extension("VK_EXT_debug_marker")
@serialize
class VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType
    const void*        pNext
    const char*        pMarkerName
    @readonly f32[4]   color
}

sub ref!VulkanDebugMarkerInfo updateDebugMarkerObjectName(
  ref!VulkanDebugMarkerInfo origInfo,
  VkDebugMarkerObjectNameInfoEXT nameInfo) {
    newInfo := switch (origInfo == null) {
      case true:
        new!VulkanDebugMarkerInfo()
      case false:
        origInfo
    }
    newInfo.ObjectName = as!string(nameInfo.pObjectName)
    return newInfo
}

sub ref!VulkanDebugMarkerInfo updateDebugMarkerObjectTag(
  ref!VulkanDebugMarkerInfo origInfo,
  VkDebugMarkerObjectTagInfoEXT tagInfo) {
    newInfo := switch (origInfo == null) {
      case true:
        new!VulkanDebugMarkerInfo()
      case false:
        origInfo
    }
    newInfo.TagName = tagInfo.tagName
    newInfo.Tag = clone(as!u8*(tagInfo.pTag)[0:tagInfo.tagSize])
    return newInfo
}

sub void setDebugMarkerObjectTag(VkDebugMarkerObjectTagInfoEXT tagInfo) {
  objTy := tagInfo.objectType
  obj := tagInfo.object
  switch objTy {
    case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
      Instances[as!VkInstance(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Instances[as!VkInstance(obj)].DebugInfo, tagInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
		  PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo = updateDebugMarkerObjectTag(
          PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
	  	Devices[as!VkDevice(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Devices[as!VkDevice(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
	  	Queues[as!VkQueue(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Queues[as!VkQueue(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
	  	Semaphores[as!VkSemaphore(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Semaphores[as!VkSemaphore(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
	  	CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
          CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
	  	Fences[as!VkFence(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Fences[as!VkFence(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
	  	DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo = updateDebugMarkerObjectTag(
          DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
	  	Buffers[as!VkBuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Buffers[as!VkBuffer(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
	  	Images[as!VkImage(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Images[as!VkImage(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
	  	Events[as!VkEvent(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Events[as!VkEvent(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
	  	QueryPools[as!VkQueryPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
          QueryPools[as!VkQueryPool(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
	  	BufferViews[as!VkBufferView(obj)].DebugInfo = updateDebugMarkerObjectTag(
          BufferViews[as!VkBufferView(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
	  	ImageViews[as!VkImageView(obj)].DebugInfo = updateDebugMarkerObjectTag(
          ImageViews[as!VkImageView(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
	  	ShaderModules[as!VkShaderModule(obj)].DebugInfo = updateDebugMarkerObjectTag(
          ShaderModules[as!VkShaderModule(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
	  	PipelineCaches[as!VkPipelineCache(obj)].DebugInfo = updateDebugMarkerObjectTag(
          PipelineCaches[as!VkPipelineCache(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
	  	PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo = updateDebugMarkerObjectTag(
          PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
	  	RenderPasses[as!VkRenderPass(obj)].DebugInfo = updateDebugMarkerObjectTag(
          RenderPasses[as!VkRenderPass(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
      if (as!VkPipeline(obj) in GraphicsPipelines) {
        GraphicsPipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectTag(
            GraphicsPipelines[as!VkPipeline(obj)].DebugInfo, tagInfo)
      } else if (as!VkPipeline(obj) in ComputePipelines) {
        ComputePipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectTag(
            ComputePipelines[as!VkPipeline(obj)].DebugInfo, tagInfo)
      }
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
	  	DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
	  	Samplers[as!VkSampler(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Samplers[as!VkSampler(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
	  	DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
	  	DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo = updateDebugMarkerObjectTag(
        DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
	  	Framebuffers[as!VkFramebuffer(obj)].DebugInfo = updateDebugMarkerObjectTag(
        Framebuffers[as!VkFramebuffer(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
	  	CommandPools[as!VkCommandPool(obj)].DebugInfo = updateDebugMarkerObjectTag(
        CommandPools[as!VkCommandPool(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
	  	Surfaces[as!VkSurfaceKHR(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Surfaces[as!VkSurfaceKHR(obj)].DebugInfo, tagInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
	  	Swapchains[as!VkSwapchainKHR(obj)].DebugInfo = updateDebugMarkerObjectTag(
          Swapchains[as!VkSwapchainKHR(obj)].DebugInfo, tagInfo)
  }
}

sub void setDebugMarkerObjectName(VkDebugMarkerObjectNameInfoEXT nameInfo) {
  objTy := nameInfo.objectType
  obj := nameInfo.object
  switch objTy {
    case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
      Instances[as!VkInstance(obj)].DebugInfo = updateDebugMarkerObjectName(
          Instances[as!VkInstance(obj)].DebugInfo, nameInfo)
    case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
		  PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo = updateDebugMarkerObjectName(
          PhysicalDevices[as!VkPhysicalDevice(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
	  	Devices[as!VkDevice(obj)].DebugInfo = updateDebugMarkerObjectName(
          Devices[as!VkDevice(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
	  	Queues[as!VkQueue(obj)].DebugInfo = updateDebugMarkerObjectName(
          Queues[as!VkQueue(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
	  	Semaphores[as!VkSemaphore(obj)].DebugInfo = updateDebugMarkerObjectName(
          Semaphores[as!VkSemaphore(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
	  	CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
          CommandBuffers[as!VkCommandBuffer(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
	  	Fences[as!VkFence(obj)].DebugInfo = updateDebugMarkerObjectName(
          Fences[as!VkFence(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
	  	DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo = updateDebugMarkerObjectName(
          DeviceMemories[as!VkDeviceMemory(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
	  	Buffers[as!VkBuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
          Buffers[as!VkBuffer(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
	  	Images[as!VkImage(obj)].DebugInfo = updateDebugMarkerObjectName(
          Images[as!VkImage(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
	  	Events[as!VkEvent(obj)].DebugInfo = updateDebugMarkerObjectName(
          Events[as!VkEvent(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
	  	QueryPools[as!VkQueryPool(obj)].DebugInfo = updateDebugMarkerObjectName(
          QueryPools[as!VkQueryPool(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
	  	BufferViews[as!VkBufferView(obj)].DebugInfo = updateDebugMarkerObjectName(
          BufferViews[as!VkBufferView(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
	  	ImageViews[as!VkImageView(obj)].DebugInfo = updateDebugMarkerObjectName(
          ImageViews[as!VkImageView(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
	  	ShaderModules[as!VkShaderModule(obj)].DebugInfo = updateDebugMarkerObjectName(
          ShaderModules[as!VkShaderModule(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
	  	PipelineCaches[as!VkPipelineCache(obj)].DebugInfo = updateDebugMarkerObjectName(
          PipelineCaches[as!VkPipelineCache(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
	  	PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo = updateDebugMarkerObjectName(
          PipelineLayouts[as!VkPipelineLayout(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
	  	RenderPasses[as!VkRenderPass(obj)].DebugInfo = updateDebugMarkerObjectName(
          RenderPasses[as!VkRenderPass(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
      if (as!VkPipeline(obj) in GraphicsPipelines) {
        GraphicsPipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectName(
            GraphicsPipelines[as!VkPipeline(obj)].DebugInfo, nameInfo)
      } else if (as!VkPipeline(obj) in ComputePipelines) {
        ComputePipelines[as!VkPipeline(obj)].DebugInfo = updateDebugMarkerObjectName(
            ComputePipelines[as!VkPipeline(obj)].DebugInfo, nameInfo)
      }
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
	  	DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorSetLayouts[as!VkDescriptorSetLayout(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
	  	Samplers[as!VkSampler(obj)].DebugInfo = updateDebugMarkerObjectName(
        Samplers[as!VkSampler(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
	  	DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorPools[as!VkDescriptorPool(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
	  	DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo = updateDebugMarkerObjectName(
        DescriptorSets[as!VkDescriptorSet(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
	  	Framebuffers[as!VkFramebuffer(obj)].DebugInfo = updateDebugMarkerObjectName(
        Framebuffers[as!VkFramebuffer(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
	  	CommandPools[as!VkCommandPool(obj)].DebugInfo = updateDebugMarkerObjectName(
        CommandPools[as!VkCommandPool(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
	  	Surfaces[as!VkSurfaceKHR(obj)].DebugInfo = updateDebugMarkerObjectName(
          Surfaces[as!VkSurfaceKHR(obj)].DebugInfo, nameInfo)
	  case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
	  	Swapchains[as!VkSwapchainKHR(obj)].DebugInfo = updateDebugMarkerObjectName(
          Swapchains[as!VkSwapchainKHR(obj)].DebugInfo, nameInfo)
  }
}

@override
@no_replay
@custom
cmd void RecreateDebugMarkerSetObjectTagEXT(
  VkDevice device,
  VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
  tagInfo := pTagInfo[0]
  read(as!u8*(tagInfo.pTag)[0:tagInfo.tagSize])
}

@threadSafety("app")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@indirect("VkDevice")
@override
@no_replay
cmd VkResult vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectTagInfoEXT*              pTagInfo) {
  tagInfo := pTagInfo[0]
  setDebugMarkerObjectTag(tagInfo)
  return ?
}

@override
@no_replay
@custom
cmd void RecreateDebugMarkerSetObjectNameEXT(
  VkDevice device,
  VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
  nameInfo := pNameInfo[0]
  _ = as!string(nameInfo.pObjectName)
}

@threadSafety("app")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@indirect("VkDevice")
@override
@no_replay
cmd VkResult vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    VkDebugMarkerObjectNameInfoEXT*             pNameInfo) {
  nameInfo := pNameInfo[0]
  setDebugMarkerObjectName(nameInfo)
  return ?
}

@internal class
vkCmdDebugMarkerBeginEXTArgs {
  @unused string MarkerName,
  @unused f32[4] Color     ,
}

sub void dovkCmdDebugMarkerBeginEXT(ref!vkCmdDebugMarkerBeginEXTArgs args) {
  pushDebugMarker(args.MarkerName)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo) {
  markerInfo := pMarkerInfo[0]
  args := new!vkCmdDebugMarkerBeginEXTArgs(
    MarkerName: as!string(markerInfo.pMarkerName),
  )
  args.Color[0] = markerInfo.color[0]
  args.Color[1] = markerInfo.color[1]
  args.Color[2] = markerInfo.color[2]
  args.Color[3] = markerInfo.color[3]

  addCmd(commandBuffer, args, dovkCmdDebugMarkerBeginEXT)
}

@internal class
vkCmdDebugMarkerEndEXTArgs {}

sub void dovkCmdDebugMarkerEndEXT(ref!vkCmdDebugMarkerEndEXTArgs draw) {
  popDebugMarker()
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer) {

  args := new!vkCmdDebugMarkerEndEXTArgs()

  addCmd(commandBuffer, args, dovkCmdDebugMarkerEndEXT)
}

@internal class
vkCmdDebugMarkerInsertEXTArgs {
  @unused string MarkerName,
  @unused f32[4] Color     ,
}

sub void dovkCmdDebugMarkerInsertEXT(ref!vkCmdDebugMarkerInsertEXTArgs draw) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
@extension("VK_EXT_debug_marker")
@extension("VK_EXT_debug_report")
@override
@no_replay
cmd void vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT*                 pMarkerInfo) {
  markerInfo := pMarkerInfo[0]
  args := new!vkCmdDebugMarkerInsertEXTArgs(
    MarkerName: as!string(markerInfo.pMarkerName),
  )
  args.Color[0] = markerInfo.color[0]
  args.Color[1] = markerInfo.color[1]
  args.Color[2] = markerInfo.color[2]
  args.Color[3] = markerInfo.color[3]

  addCmd(commandBuffer, args, dovkCmdDebugMarkerInsertEXT)
}

/////////////////////////////
// Struct subroutines      //
/////////////////////////////

// Marks the fields that need to be observed in a VkApplicationInfo struct and returns the API version.
sub u32 readVkApplicationInfo(const VkApplicationInfo* applicationInfo) {
  info := applicationInfo[0]

  // TODO: handle pNext
  if (info.pApplicationName != null) {
    _ = as!string(info.pApplicationName)
  }
  if (info.pEngineName != null) {
    _ = as!string(info.pEngineName)
  }
  return info.apiVersion
}

// Marks the fields that need to be observed in a VkInstanceCreateInfo struct and populates and returns an InstanceObject.
sub ref!InstanceObject createInstanceObject(const VkInstanceCreateInfo* createInfo) {
  object := new!InstanceObject()
  info := createInfo[0]

  // TODO: handle pNext
  if (info.pApplicationInfo != null) {
    object.ApiVersion = readVkApplicationInfo(info.pApplicationInfo)
  } else {
    object.ApiVersion = 0
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    // We do not need to store off the list of enabled layers, since
    // a layer's presence should not affect any other calls in the API,
    // only an enabled extension that is provided by a layer.
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    object.EnabledExtensions[i] = as!string(extensionNames[i])
  }

  return object
}

// Marks the fields that need to be observed in a VkDeviceCreateInfo struct and populates and returns a DeviceObject.
sub ref!DeviceObject createDeviceObject(const VkDeviceCreateInfo* data) {
  object := new!DeviceObject()
  info := data[0]

  // TODO: pNext
  queueCreateInfos := info.pQueueCreateInfos[0:info.queueCreateInfoCount]
  for i in (0 .. info.queueCreateInfoCount) {
    queue_info := queueCreateInfos[i]
    queue_priorities := queue_info.pQueuePriorities[0:queue_info.queueCount]
    for j in (0 .. queue_info.queueCount) {
      object.Queues[len(object.Queues)] =
      QueueInfo(QueueFamilyIndex: queue_info.queueFamilyIndex,
        QueueIndex:               j,
        Priority:                 queue_priorities[j])
    }
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    object.EnabledExtensions[i] = as!string(extensionNames[i])
  }

  if info.pEnabledFeatures != null {
    object.EnabledFeatures = info.pEnabledFeatures[0]
  }

  return object
}

/////////////////////////////
// Internal State Tracking //
/////////////////////////////

// Dispatchable objects.
map!(VkInstance, ref!InstanceObject)             Instances
map!(VkPhysicalDevice, ref!PhysicalDeviceObject) PhysicalDevices
map!(VkDevice, ref!DeviceObject)                 Devices
map!(VkQueue, ref!QueueObject)                   Queues
map!(VkCommandBuffer, ref!CommandBufferObject)   CommandBuffers
// Non-dispatchable objects.
map!(VkDeviceMemory, ref!DeviceMemoryObject)               DeviceMemories
map!(VkBuffer, ref!BufferObject)                           Buffers
map!(VkBufferView, ref!BufferViewObject)                   BufferViews
map!(VkImage, ref!ImageObject)                             Images
map!(VkImageView, ref!ImageViewObject)                     ImageViews
map!(VkShaderModule, ref!ShaderModuleObject)               ShaderModules
map!(VkPipeline, ref!GraphicsPipelineObject)               GraphicsPipelines
map!(VkPipeline, ref!ComputePipelineObject)                ComputePipelines
map!(VkPipelineLayout, ref!PipelineLayoutObject)           PipelineLayouts
map!(VkSampler, ref!SamplerObject)                         Samplers
map!(VkDescriptorSet, ref!DescriptorSetObject)             DescriptorSets
map!(VkDescriptorSetLayout, ref!DescriptorSetLayoutObject) DescriptorSetLayouts
map!(VkDescriptorPool, ref!DescriptorPoolObject)           DescriptorPools
map!(VkFence, ref!FenceObject)                             Fences
map!(VkSemaphore, ref!SemaphoreObject)                     Semaphores
map!(VkEvent, ref!EventObject)                             Events
map!(VkQueryPool, ref!QueryPoolObject)                     QueryPools
map!(VkFramebuffer, ref!FramebufferObject)                 Framebuffers
map!(VkRenderPass, ref!RenderPassObject)                   RenderPasses
map!(VkPipelineCache, ref!PipelineCacheObject)             PipelineCaches
map!(VkCommandPool, ref!CommandPoolObject)                 CommandPools
map!(VkSurfaceKHR, ref!SurfaceObject)                      Surfaces
map!(VkSwapchainKHR, ref!SwapchainObject)                  Swapchains
map!(VkDisplayModeKHR, ref!DisplayModeObject)              DisplayModes
// Other state Tracking
ref!QueueObject           LastBoundQueue
ref!ComputePipelineObject CurrentComputePipeline

// This contains the draw command parameters. Only one of the draw data should be
// valid at a time. Others should be null.
@internal class DrawParameters {
  ref!vkCmdDrawArgs                Draw
  ref!vkCmdDrawIndexedArgs         DrawIndexed
  ref!vkCmdDrawIndirectArgs        DrawIndirect
  ref!vkCmdDrawIndexedIndirectArgs DrawIndexedIndirect
}

// This contains the information about a draw
@internal class DrawInfo {
  ref!FramebufferObject Framebuffer
  // A mapping from the descriptor set bound numbers to descriptor set objects
  map!(u32, ref!DescriptorSetObject) DescriptorSets
  // The Last subpass number used in the draw
  @hidden u32 LastSubpass
  // The graphics pipeline used for the draw
  ref!GraphicsPipelineObject GraphicsPipeline
  // The vertex buffers used for the draw. This is a map of binding number to
  // buffer bound do that binding.
  map!(u32, BoundBuffer) BoundVertexBuffers
  // The index buffer used for the draw
  ref!BoundIndexBuffer BoundIndexBuffer
  // The draw parameters used for the draw
  DrawParameters CommandParameters
  // The render pass in which this draw takes place
  ref!RenderPassObject RenderPass
  // Whether or not we are in an unclosed render pass
  @hidden bool InRenderPass
}

map!(VkQueue, ref!DrawInfo) LastDrawInfos

@internal class PresentInfo {
  // The number of images presented last present
  u32 PresentImageCount
  // The images presented in the last present
  map!(u32, ref!ImageObject) PresentImages
}

PresentInfo LastPresentInfo

enum LastSubmissionType {
  SUBMIT  = 0
  PRESENT = 1
}

LastSubmissionType LastSubmission

sub ref!DrawInfo lastDrawInfo() {
  if LastBoundQueue != null {
    if !(LastBoundQueue.VulkanHandle in LastDrawInfos) {
      LastDrawInfos[LastBoundQueue.VulkanHandle] = new!DrawInfo()
    }
  }

  ldi := switch (LastBoundQueue == null) {
    case false:
      LastDrawInfos[LastBoundQueue.VulkanHandle]
    case true:
      new!DrawInfo()
  }
  return ldi
}

// Clear the recorded descriptor sets in the last draw
sub void clearLastDrawInfoDescriptorSets() {
  for i in (0 .. len(lastDrawInfo().DescriptorSets)) {
    lastDrawInfo().DescriptorSets[as!u32(i)] = null
  }
}

// Clear the draw command parameters in the last draw info
sub void clearLastDrawInfoDrawCommandParameters() {
  lastDrawInfo().CommandParameters.Draw = null
  lastDrawInfo().CommandParameters.DrawIndexed = null
  lastDrawInfo().CommandParameters.DrawIndirect = null
  lastDrawInfo().CommandParameters.DrawIndexedIndirect = null
}

@internal class VulkanDebugMarkerInfo {
  @unused string ObjectName
  @unused u64    TagName
  @internal u8[] Tag
}

// Internal struct for holding useful instance level information from VkInstanceCreateInfo.
@internal class InstanceObject {
  @unused u32               ApiVersion        // The api version the app requested when setting up the instance
  @unused map!(u32, string) EnabledExtensions // Map from enabled extension index to extension name
  @unused map!(u32, string) EnabledLayers
  @unused VkInstance        VulkanHandle
  @unused ref!VulkanDebugMarkerInfo     DebugInfo
  @hidden @unused map!(u32, VkPhysicalDevice) EnumeratedPhysicalDevices
}

@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

@internal class PhysicalDeviceObject {
  @unused VkInstance               Instance
  @unused u32                      Index
  VkPhysicalDeviceMemoryProperties MemoryProperties
  @unused VkPhysicalDevice         VulkanHandle
  // A map of queue family indices to queue properties.
  @unused map!(u32, VkQueueFamilyProperties) QueueFamilyProperties
  @unused ref!VulkanDebugMarkerInfo             DebugInfo
  @unused VkPhysicalDeviceProperties PhysicalDeviceProperties
}

@intenral class QueueInfo {
  u32 QueueFamilyIndex
  u32 QueueIndex
  f32 Priority
}

@internal class DeviceObject {
  VkPhysicalDevice                 PhysicalDevice
  @unused map!(u32, string)        EnabledExtensions
  @unused map!(u32, string)        EnabledLayers
  @unused map!(u32, QueueInfo)     Queues
  @unused VkPhysicalDeviceFeatures EnabledFeatures
  @unused VkDevice                 VulkanHandle
  @unused ref!VulkanDebugMarkerInfo             DebugInfo
}

@internal class QueueObject {
  @unused VkDevice               Device
  @unused u32                    Family
  @unused u32                    Index
  @unused VkQueue                VulkanHandle
  map!(VkEvent, ref!EventObject) PendingEvents
  map!(VkSemaphore, ref!SemaphoreObject) PendingSemaphores
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  map!(u32, CommandReference) PendingCommands
}

enum RecordingState {
  NOT_STARTED = 0,
  RECORDING   = 1,
  COMPLETED   = 2
}

@internal class CommandBufferBegin {
  VkCommandBufferUsageFlags     Flags
  bool                          Inherited
  VkRenderPass                  InheritedRenderPass
  u32                           InheritedSubpass
  VkFramebuffer                 InheritedFramebuffer
  VkBool32                      InheritedOcclusionQuery
  VkQueryControlFlags           InheritedQueryFlags
  VkQueryPipelineStatisticFlags InheritedPipelineStatsFlags
}

enum CommandType {
  cmd_vkCmdBindPipeline = 0,
  cmd_vkCmdSetViewport = 1,
  cmd_vkCmdSetScissor = 2,
  cmd_vkCmdSetLineWidth = 3,
  cmd_vkCmdSetDepthBias = 4,
  cmd_vkCmdSetBlendConstants = 5,
  cmd_vkCmdSetDepthBounds = 6,
  cmd_vkCmdSetStencilCompareMask = 7,
  cmd_vkCmdSetStencilWriteMask = 8,
  cmd_vkCmdSetStencilReference = 9,
  cmd_vkCmdBindDescriptorSets = 10,
  cmd_vkCmdBindIndexBuffer = 11,
  cmd_vkCmdBindVertexBuffers = 12,
  cmd_vkCmdDraw = 13,
  cmd_vkCmdDrawIndexed = 14,
  cmd_vkCmdDrawIndirect = 15,
  cmd_vkCmdDrawIndexedIndirect = 16,
  cmd_vkCmdDispatch = 17,
  cmd_vkCmdDispatchIndirect = 18,
  cmd_vkCmdCopyBuffer = 19,
  cmd_vkCmdCopyImage = 20,
  cmd_vkCmdBlitImage = 21,
  cmd_vkCmdCopyBufferToImage = 22,
  cmd_vkCmdCopyImageToBuffer = 23,
  cmd_vkCmdUpdateBuffer = 24,
  cmd_vkCmdFillBuffer = 25,
  cmd_vkCmdClearColorImage = 26,
  cmd_vkCmdClearDepthStencilImage = 27,
  cmd_vkCmdClearAttachments = 28,
  cmd_vkCmdResolveImage = 29,
  cmd_vkCmdSetEvent = 30,
  cmd_vkCmdResetEvent = 31,
  cmd_vkCmdWaitEvents = 32,
  cmd_vkCmdPipelineBarrier = 33,
  cmd_vkCmdBeginQuery = 34,
  cmd_vkCmdEndQuery = 35,
  cmd_vkCmdResetQueryPool = 36,
  cmd_vkCmdWriteTimestamp = 37,
  cmd_vkCmdCopyQueryPoolResults = 38,
  cmd_vkCmdPushConstants = 39,
  cmd_vkCmdBeginRenderPass = 40,
  cmd_vkCmdNextSubpass = 41,
  cmd_vkCmdEndRenderPass = 42,
  cmd_vkCmdExecuteCommands = 43,
  cmd_vkCmdDebugMarkerBeginEXT = 44,
  cmd_vkCmdDebugMarkerEndEXT = 45,
  cmd_vkCmdDebugMarkerInsertEXT = 46,
  cmd_vkNoCommand = 0xFFFFFFFF
}

enum SemaphoreUpdate {
  None = 0,
  Unsignal = 1,
  Signal = 2
}

@internal class SparseMemoryBinds {
  @unused map!(u32, VkSparseMemoryBind) SparseMemoryBinds
}

@internal class SparseImageMemoryBinds {
  @unused map!(u32, VkSparseImageMemoryBind) SparseImageMemoryBinds
}

@internal class QueuedSparseBinds {
  @unused map!(VkBuffer, ref!SparseMemoryBinds) BufferBinds
  @unused map!(VkImage, ref!SparseMemoryBinds) OpaqueImageBinds
  @unused map!(VkImage, ref!SparseImageMemoryBinds) ImageBinds
}

@internal class CommandReference {
  @unused VkCommandBuffer Buffer
  @unused u32         CommandIndex
  @unused CommandType Type
  @unused u32         MapIndex
  @unused SemaphoreUpdate SemaphoreUpdate
  @unused VkSemaphore Semaphore
  @unused ref!QueuedSparseBinds SparseBinds
}

@internal class BufferCommands {
  map!(u32,ref!vkCmdBindPipelineArgs) vkCmdBindPipeline
  map!(u32,ref!vkCmdSetViewportArgs) vkCmdSetViewport
  map!(u32,ref!vkCmdSetScissorArgs) vkCmdSetScissor
  map!(u32,ref!vkCmdSetLineWidthArgs) vkCmdSetLineWidth
  map!(u32,ref!vkCmdSetDepthBiasArgs) vkCmdSetDepthBias
  map!(u32,ref!vkCmdSetBlendConstantsArgs) vkCmdSetBlendConstants
  map!(u32,ref!vkCmdSetDepthBoundsArgs) vkCmdSetDepthBounds
  map!(u32,ref!vkCmdSetStencilCompareMaskArgs) vkCmdSetStencilCompareMask
  map!(u32,ref!vkCmdSetStencilWriteMaskArgs) vkCmdSetStencilWriteMask
  map!(u32,ref!vkCmdSetStencilReferenceArgs) vkCmdSetStencilReference
  map!(u32,ref!vkCmdBindDescriptorSetsArgs) vkCmdBindDescriptorSets
  map!(u32,ref!vkCmdBindIndexBufferArgs) vkCmdBindIndexBuffer
  map!(u32,ref!vkCmdBindVertexBuffersArgs) vkCmdBindVertexBuffers
  map!(u32,ref!vkCmdDrawArgs) vkCmdDraw
  map!(u32,ref!vkCmdDrawIndexedArgs) vkCmdDrawIndexed
  map!(u32,ref!vkCmdDrawIndirectArgs) vkCmdDrawIndirect
  map!(u32,ref!vkCmdDrawIndexedIndirectArgs) vkCmdDrawIndexedIndirect
  map!(u32,ref!vkCmdDispatchArgs) vkCmdDispatch
  map!(u32,ref!vkCmdDispatchIndirectArgs) vkCmdDispatchIndirect
  map!(u32,ref!vkCmdCopyBufferArgs) vkCmdCopyBuffer
  map!(u32,ref!vkCmdCopyImageArgs) vkCmdCopyImage
  map!(u32,ref!vkCmdBlitImageArgs) vkCmdBlitImage
  map!(u32,ref!vkCmdCopyBufferToImageArgs) vkCmdCopyBufferToImage
  map!(u32,ref!vkCmdCopyImageToBufferArgs) vkCmdCopyImageToBuffer
  map!(u32,ref!vkCmdUpdateBufferArgs) vkCmdUpdateBuffer
  map!(u32,ref!vkCmdFillBufferArgs) vkCmdFillBuffer
  map!(u32,ref!vkCmdClearColorImageArgs) vkCmdClearColorImage
  map!(u32,ref!vkCmdClearDepthStencilImageArgs) vkCmdClearDepthStencilImage
  map!(u32,ref!vkCmdClearAttachmentsArgs) vkCmdClearAttachments
  map!(u32,ref!vkCmdResolveImageArgs) vkCmdResolveImage
  map!(u32,ref!vkCmdSetEventArgs) vkCmdSetEvent
  map!(u32,ref!vkCmdResetEventArgs) vkCmdResetEvent
  map!(u32,ref!vkCmdWaitEventsArgs) vkCmdWaitEvents
  map!(u32,ref!vkCmdPipelineBarrierArgs) vkCmdPipelineBarrier
  map!(u32,ref!vkCmdBeginQueryArgs) vkCmdBeginQuery
  map!(u32,ref!vkCmdEndQueryArgs) vkCmdEndQuery
  map!(u32,ref!vkCmdResetQueryPoolArgs) vkCmdResetQueryPool
  map!(u32,ref!vkCmdWriteTimestampArgs) vkCmdWriteTimestamp
  map!(u32,ref!vkCmdCopyQueryPoolResultsArgs) vkCmdCopyQueryPoolResults
  map!(u32,ref!vkCmdPushConstantsArgs) vkCmdPushConstants
  map!(u32,ref!vkCmdBeginRenderPassArgs) vkCmdBeginRenderPass
  map!(u32,ref!vkCmdNextSubpassArgs) vkCmdNextSubpass
  map!(u32,ref!vkCmdEndRenderPassArgs) vkCmdEndRenderPass
  map!(u32,ref!vkCmdExecuteCommandsArgs) vkCmdExecuteCommands
  map!(u32,ref!vkCmdDebugMarkerBeginEXTArgs) vkCmdDebugMarkerBeginEXT
  map!(u32,ref!vkCmdDebugMarkerEndEXTArgs) vkCmdDebugMarkerEndEXT
  map!(u32,ref!vkCmdDebugMarkerInsertEXTArgs) vkCmdDebugMarkerInsertEXT
}

@internal class CommandBufferObject {
  @unused VkDevice               Device
  @unused RecordingState         Recording
  @unused VkCommandBuffer        VulkanHandle
  @unused VkCommandPool          Pool
  @unused VkCommandBufferLevel   Level
  @unused map!(u32,CommandReference) CommandReferences
  @unused BufferCommands         BufferCommands
  @unused ref!CommandBufferBegin BeginInfo
  @unused ref!VulkanDebugMarkerInfo          DebugInfo
}

@internal class DeviceMemoryObject {
  VkDevice                                    Device
  @unused VkDeviceMemory                      VulkanHandle
  VkDeviceSize                                AllocationSize
  map!(u64, VkDeviceSize)                     BoundObjects
  VkDeviceSize                                MappedOffset
  VkDeviceSize                                MappedSize
  void*                                       MappedLocation
  u32                                         MemoryTypeIndex
  @spy_disabled
  @hidden @nobox @internal u8[]               Data
  @unused ref!VulkanDebugMarkerInfo           DebugInfo
  ref!DedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationNV
}

@internal class BufferInfo {
  @unused VkBufferCreateFlags                    CreateFlags
  @unused VkDeviceSize                           Size
  @unused VkBufferUsageFlags                     Usage
  @unused VkSharingMode                          SharingMode
  @unused map!(u32, u32)                         QueueFamilyIndices
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@internal class BufferObject {
  @unused VkDevice        Device
  @unused VkBuffer        VulkanHandle
  @unused BufferInfo      Info
  ref!DeviceMemoryObject  Memory
  VkDeviceSize            MemoryOffset
  map!(u32, VkSparseMemoryBind) SparseMemoryBindings
  @unused ref!QueueObject LastBoundQueue
  @unused ref!VulkanDebugMarkerInfo   DebugInfo
}

@internal class BufferViewObject {
  @unused VkDevice         Device
  @unused VkBufferView     VulkanHandle
  @unused ref!BufferObject Buffer
  @unused VkFormat         Format
  @unused VkDeviceSize     Offset
  @unused VkDeviceSize     Range
  @unused ref!VulkanDebugMarkerInfo    DebugInfo
}

@internal class ImageInfo {
  VkImageCreateFlags                             Flags
  VkImageType                                    ImageType
  VkFormat                                       Format
  VkExtent3D                                     Extent
  u32                                            MipLevels
  u32                                            ArrayLayers
  VkSampleCountFlagBits                          Samples
  VkImageTiling                                  Tiling
  VkImageUsageFlags                              Usage
  VkSharingMode                                  SharingMode
  map!(u32, u32)                                 QueueFamilyIndices
  VkImageLayout                                  Layout
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@resource
@internal class ImageObject {
  @unused VkDevice          Device
  @unused ref!QueueObject   LastBoundQueue
  ref!DeviceMemoryObject    BoundMemory
  VkDeviceSize              BoundMemoryOffset
  map!(u32, VkSparseMemoryBind) OpaqueSparseMemoryBindings
  @unused bool              IsSwapchainImage
  VkImage                   VulkanHandle
  ImageInfo                 Info
  VkImageAspectFlags        ImageAspect
  map!(u32, ref!ImageLayer) Layers
  @unused ref!VulkanDebugMarkerInfo     DebugInfo
  VkMemoryRequirements      MemoryRequirements
  map!(u32, VkSparseImageMemoryRequirements) SparseMemoryRequirements
}

@internal class ImageLayer {
  map!(u32, ref!ImageLevel) Levels
}

@internal class ImageLevel {
  u32                           Width
  u32                           Height
  @unused u32                   Depth
  @spy_disabled
  @hidden @nobox @internal u8[] Data
  @unused u32                   Size
}

@internal class ImageViewObject {
  @unused VkDevice                Device
  @unused VkImageView             VulkanHandle
  @unused VkImageViewType         Type
  @unused VkFormat                Format
  @unused VkComponentMapping      Components
  @unused VkImageSubresourceRange SubresourceRange
  ref!ImageObject                 Image
  @unused ref!VulkanDebugMarkerInfo           DebugInfo
}

@resource
@internal class ShaderModuleObject {
  @unused VkDevice       Device
  @unused u32[]          Words
  @unused VkShaderModule VulkanHandle
  @unused ref!VulkanDebugMarkerInfo  DebugInfo
}

@internal class SpecializationInfo {
  map!(u32, VkSpecializationMapEntry) Specializations
  u8[]    Data
}

@internal class StageData {
  @unused VkShaderStageFlagBits  Stage
  @unused ref!ShaderModuleObject Module
  @unused string                 EntryPoint
  @unused ref!SpecializationInfo Specialization
}

@internal class VertexData {
  @unused map!(u32, VkVertexInputBindingDescription)   BindingDescriptions
  @unused map!(u32, VkVertexInputAttributeDescription) AttributeDescriptions
}

@internal class InputAssemblyData {
  @unused VkPrimitiveTopology Topology
  @unused VkBool32            PrimitiveRestartEnable
}

@internal class TessellationStateData {
  @unused u32 PatchControlPoints
}

@internal class ViewportData {
  @unused map!(u32, VkViewport) Viewports
  @unused map!(u32, VkRect2D)   Scissors
}

@internal class RasterizationData {
  @unused VkBool32        DepthClampEnable
  @unused VkBool32        RasterizerDiscardEnable
  @unused VkPolygonMode   PolygonMode
  @unused VkCullModeFlags CullMode
  @unused VkFrontFace     FrontFace
  @unused VkBool32        DepthBiasEnable
  @unused f32             DepthBiasConstantFactor
  @unused f32             DepthBiasClamp
  @unused f32             DepthBiasSlopeFactor
  @unused f32             LineWidth
}

@internal class MultisampleData {
  @unused VkSampleCountFlagBits   RasterizationSamples
  @unused VkBool32                SampleShadingEnable
  @unused f32                     MinSampleShading
  @unused map!(u32, VkSampleMask) SampleMask
  @unused VkBool32                AlphaToCoverageEnable
  @unused VkBool32                AlphaToOneEnable
}

@internal class DepthData {
  @unused VkBool32         DepthTestEnable
  @unused VkBool32         DepthWriteEnable
  @unused VkCompareOp      DepthCompareOp
  @unused VkBool32         DepthBoundsTestEnable
  @unused VkBool32         StencilTestEnable
  @unused VkStencilOpState Front
  @unused VkStencilOpState Back
  @unused f32              MinDepthBounds
  @unused f32              MaxDepthBounds
}

@internal class ColorBlendData {
  @unused VkBool32                                       LogicOpEnable
  @unused VkLogicOp                                      LogicOp
  @unused map!(u32, VkPipelineColorBlendAttachmentState) Attachments
  @unused f32[4]                                         BlendConstants
}

@internal class DynamicData {
  @unused map!(u32, VkDynamicState) DynamicStates
}

@internal class GraphicsPipelineObject {
  @unused VkDevice                  Device
  @unused ref!PipelineCacheObject   PipelineCache
  @unused VkPipelineCreateFlags     Flags
  @unused VkPipeline                VulkanHandle
  @unused map!(u32, StageData)      Stages
  @unused VertexData                VertexInputState
  @unused InputAssemblyData         InputAssemblyState
  @unused ref!TessellationStateData TessellationState
  @unused ref!ViewportData          ViewportState
  @unused RasterizationData         RasterizationState
  @unused ref!MultisampleData       MultisampleState
  @unused ref!DepthData             DepthState
  @unused ref!ColorBlendData        ColorBlendState
  @unused ref!DynamicData           DynamicState
  @unused ref!PipelineLayoutObject  Layout
  @unused ref!RenderPassObject      RenderPass
  @unused u32                       Subpass
  @unused VkPipeline                BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                       BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo             DebugInfo
}

@internal class ComputePipelineObject {
  @unused VkDevice                 Device
  @unused VkPipeline               VulkanHandle
  @unused ref!PipelineCacheObject  PipelineCache
  @unused VkPipelineCreateFlags    Flags
  @unused StageData                Stage
  @unused ref!PipelineLayoutObject PipelineLayout
  @unused VkPipeline               BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                     BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo           DebugInfo
}

@internal class PipelineLayoutObject {
  @unused VkDevice                                 Device
  @unused VkPipelineLayout                         VulkanHandle
  @unused map!(u32, ref!DescriptorSetLayoutObject) SetLayouts
  @unused map!(u32, VkPushConstantRange)           PushConstantRanges
  @unused ref!VulkanDebugMarkerInfo                            DebugInfo
}

@internal class SamplerObject {
  @unused VkDevice             Device
  @unused VkSampler            VulkanHandle
  @unused VkFilter             MagFilter
  @unused VkFilter             MinFilter
  @unused VkSamplerMipmapMode  MipMapMode
  @unused VkSamplerAddressMode AddressModeU
  @unused VkSamplerAddressMode AddressModeV
  @unused VkSamplerAddressMode AddressModeW
  @unused f32                  MipLodBias
  @unused VkBool32             AnisotropyEnable
  @unused f32                  MaxAnisotropy
  @unused VkBool32             CompareEnable
  @unused VkCompareOp          CompareOp
  @unused f32                  MinLod
  @unused f32                  MaxLod
  @unused VkBorderColor        BorderColor
  @unsued VkBool32             UnnormalizedCoordinates
  @unused ref!VulkanDebugMarkerInfo        DebugInfo
}

@internal class DescriptorBinding {
  VkDescriptorType                      BindingType
  map!(u32, ref!VkDescriptorBufferInfo) BufferBinding
  map!(u32, ref!VkDescriptorImageInfo)  ImageBinding
  map!(u32, VkBufferView)               BufferViewBindings
}

@internal class DescriptorSetObject {
  @unused VkDevice                 Device
  @unused VkDescriptorSet          VulkanHandle
  @unused VkDescriptorPool         DescriptorPool
  // Map from a binding number to its bound array of buffers.
  map!(u32, DescriptorBinding)  Bindings
  ref!DescriptorSetLayoutObject Layout
  @unused ref!VulkanDebugMarkerInfo         DebugInfo
}

@internal class DescriptorSetLayoutBinding {
  VkDescriptorType                     Type
  @unused u32                          Count
  @unused VkShaderStageFlags           Stages
  @unused map!(u32, ref!SamplerObject) ImmutableSamplers
}

@internal class DescriptorSetLayoutObject {
  @unused VkDevice              Device
  @unused VkDescriptorSetLayout VulkanHandle
  u32                           MaximumBinding
  // Map of binding numbers to binding information
  map!(u32, DescriptorSetLayoutBinding) Bindings
  @unused ref!VulkanDebugMarkerInfo         DebugInfo
}

@internal class DescriptorPoolObject {
  @unused VkDevice                        Device
  @unused VkDescriptorPool                VulkanHandle
  @unused VkDescriptorPoolCreateFlags     Flags
  @unused u32                             MaxSets
  @unused map!(u32, VkDescriptorPoolSize) Sizes
  @unused map!(VkDescriptorSet, ref!DescriptorSetObject) DescriptorSets
  @unused ref!VulkanDebugMarkerInfo                   DebugInfo
}

@internal class FenceObject {
  @unused VkDevice Device
  @unused VkFence  VulkanHandle
  @unused bool     Signaled
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}


@internal class SemaphoreObject {
  @unused VkDevice    Device
  @unused VkSemaphore VulkanHandle
  @unused VkQueue     LastQueue
  @unused bool        Signaled
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @unused VkQueue WaitingQueue
}

@internal class EventObject {
  @unused VkDevice Device
  @unused VkEvent  VulkanHandle
  @unused bool     Signaled
  @unused VkQueue  SubmitQueue
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

enum QueryStatus {
  QUERY_STATUS_INACTIVE = 0
  QUERY_STATUS_ACTIVE   = 1
  QUERY_STATUS_COMPLETE = 2
}

@internal class QueryPoolObject {
  @unused VkDevice                      Device
  @unused VkQueryPool                   VulkanHandle
  @unused VkQueryType                   QueryType
  @unused u32                           QueryCount
  @unused VkQueryPipelineStatisticFlags PipelineStatistics
  @unused map!(u32, QueryStatus)        Status
  @unused ref!VulkanDebugMarkerInfo                 DebugInfo
}

@internal class FramebufferObject {
  @unused VkDevice               Device
  @unused VkFramebuffer          VulkanHandle
  @unused ref!RenderPassObject   RenderPass
  map!(u32, ref!ImageViewObject) ImageAttachments
  @unused u32                    Width
  @unused u32                    Height
  @unused u32                    Layers
  @unused ref!VulkanDebugMarkerInfo          DebugInfo
}

@internal class SubpassDescription {
  @unused VkSubpassDescriptionFlags        Flags
  @unused VkPipelineBindPoint              PipelineBindPoint
  @unused map!(u32, VkAttachmentReference) InputAttachments
  @unused map!(u32, VkAttachmentReference) ColorAttachments
  @unused map!(u32, VkAttachmentReference) ResolveAttachments
  @unused ref!VkAttachmentReference        DepthStencilAttachment
  @unused map!(u32, u32)                   PreserveAttachments
}

@internal class RenderPassObject {
  @unused VkDevice                           Device
  @unused VkRenderPass                       VulkanHandle
  @unused map!(u32, VkAttachmentDescription) AttachmentDescriptions
  @unused map!(u32, SubpassDescription)      SubpassDescriptions
  @unused map!(u32, VkSubpassDependency)     SubpassDependencies
  @unused ref!VulkanDebugMarkerInfo                      DebugInfo
}

@internal class PipelineCacheObject {
  @unused VkDevice        Device
  @unused VkPipelineCache VulkanHandle
  @unused ref!VulkanDebugMarkerInfo   DebugInfo
}

@internal class CommandPoolObject {
  @unused VkDevice                                       Device
  @unused VkCommandPool                                  VulkanHandle
  @unsued VkCommandPoolCreateFlags                       Flags
  @unused u32                                            QueueFamilyIndex
  @unused map!(VkCommandBuffer, ref!CommandBufferObject) CommandBuffers
  @unused ref!VulkanDebugMarkerInfo                                  DebugInfo
}

enum SurfaceType {
  SURFACE_TYPE_UNKNOWN = 0
  SURFACE_TYPE_XCB     = 1
  SURFACE_TYPE_ANDROID = 2
  SURFACE_TYPE_WIN32   = 3
  SURFACE_TYPE_WAYLAND = 4
  SURFACE_TYPE_XLIB    = 5
  SURFACE_TYPE_MIR     = 6
}

@internal class SurfaceObject {
  @unused VkInstance   Instance
  @unused VkSurfaceKHR VulkanHandle
  @unused SurfaceType  Type
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@internal class SwapchainObject {
  @unused VkDevice                      Device
  @unused VkSwapchainKHR                VulkanHandle
  @unused ImageInfo                     Info
  @unused ref!SurfaceObject             Surface
  @unused VkColorSpaceKHR               ColorSpace
  @unused VkSurfaceTransformFlagBitsKHR PreTransform
  @unused VkCompositeAlphaFlagBitsKHR   CompositeAlpha
  @unused VkPresentModeKHR              PresentMode
  @unused VkBool32                      Clipped
  map!(u32, ref!ImageObject)            SwapchainImages
  @unused ref!VulkanDebugMarkerInfo                 DebugInfo
}

@internal class DisplayModeObject {
  @unused VkPhysicalDevice PhysicalDevice
  @unused VkDisplayKHR     Display
  @unused VkDisplayModeKHR VulkanHandle
  @unused ref!VulkanDebugMarkerInfo    DebugInfo
}

sub VkQueueFlags AddQueueFlag(VkQueueFlags flags, VkQueueFlagBits bit) {
  return as!VkQueueFlags(as!u32(flags) | as!u32(bit))
}

@serialize
class VulkanStructHeader {
  VkStructureType SType
  void*           PNext
}

@internal class DedicatedAllocationBufferImageCreateInfoNV {
  VkBool32 DedicatedAllocation
}

@internal class DedicatedAllocationMemoryAllocateInfoNV {
  VkImage  Image
  VkBuffer Buffer
}
