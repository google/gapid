// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package vulkan

import (
	"testing"

	"github.com/google/gapid/core/assert"
)

func TestUnpackData(t *testing.T) {
	h := newImageRebuildHelper(nil)

	// Expect valid unpacked data with a 2x2x1 image
	valid := func(src []uint8, srcFmt, dstFmt VkFormat, expected []uint8) {
		r, err := h.unpackData(src, VkExtent3D{2, 2, 1}, srcFmt, dstFmt)

		if assert.To(t).For("srcFmt %v dstFmt %v", srcFmt, dstFmt).ThatError(err).Succeeded() {
			assert.To(t).For("srcFmt %v dstFmt %v", srcFmt, dstFmt).ThatSlice(r).Equals(expected)
		}
	}

	// uint type
	valid([]uint8{
		0xAB,
		0xCD,
		0xEF,
		0x12,
	}, VkFormat_VK_FORMAT_R8_UINT,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0xAB, 0x00, 0x00, 0x00,
			0xCD, 0x00, 0x00, 0x00,
			0xEF, 0x00, 0x00, 0x00,
			0x12, 0x00, 0x00, 0x00,
		})

	// unorm type
	valid([]uint8{
		0xAB,
		0xCD,
		0xEF,
		0x12,
	}, VkFormat_VK_FORMAT_R8_UNORM,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0xAB, 0x00, 0x00, 0x00,
			0xCD, 0x00, 0x00, 0x00,
			0xEF, 0x00, 0x00, 0x00,
			0x12, 0x00, 0x00, 0x00,
		})

	// sint type
	valid([]uint8{
		0xAB, // 10101011
		0xCD, // 11001101
		0xEF, // 11101111
		0x12, // 00010010
	}, VkFormat_VK_FORMAT_R8_SINT,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0xAB, 0xFF, 0xFF, 0xFF,
			0xCD, 0xFF, 0xFF, 0xFF,
			0xEF, 0xFF, 0xFF, 0xFF,
			0x12, 0x00, 0x00, 0x00,
		})

	// snorm type
	valid([]uint8{
		0xAB, // 10101011
		0xCD, // 11001101
		0xEF, // 11101111
		0x12, // 00010010
	}, VkFormat_VK_FORMAT_R8_SNORM,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0xAB, 0xFF, 0xFF, 0xFF,
			0xCD, 0xFF, 0xFF, 0xFF,
			0xEF, 0xFF, 0xFF, 0xFF,
			0x12, 0x00, 0x00, 0x00,
		})

	// f16 type
	valid([]uint8{
		0x00, 0x3D, // 1.25
		0xC0, 0x45, // 5.75
		0xB8, 0x57, // 123.5
		0x00, 0xC1, // -2.5
	}, VkFormat_VK_FORMAT_R16_SFLOAT,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0x00, 0x00, 0xA0, 0x3F,
			0x00, 0x00, 0xB8, 0x40,
			0x00, 0x00, 0xF7, 0x42,
			0x00, 0x00, 0x20, 0xC0,
		})

	// f32 type
	valid([]uint8{
		0xDA, 0x0F, 0x49, 0x40, // 3.1415926
		0xDA, 0x0F, 0x49, 0xC0, // -3.1415926
		0xC2, 0xF3, 0x8E, 0x4D, // 299792458
		0xC2, 0xF3, 0x8E, 0xCD, // -299792458
	}, VkFormat_VK_FORMAT_R32_SFLOAT,
		VkFormat_VK_FORMAT_R32_UINT,
		[]uint8{
			0xDA, 0x0F, 0x49, 0x40,
			0xDA, 0x0F, 0x49, 0xC0,
			0xC2, 0xF3, 0x8E, 0x4D,
			0xC2, 0xF3, 0x8E, 0xCD,
		})

	// E5B9G9R9_UFLOAT_PACK32
	valid([]uint8{
		0x12, 0x34, 0x56, 0x78,
		0xAB, 0xCD, 0xEF, 0x00,
		0x12, 0x34, 0x56, 0x78,
		0xAB, 0xCD, 0xEF, 0x00,
	}, VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
		VkFormat_VK_FORMAT_R32G32B32A32_UINT,
		[]uint8{
			0x00, 0x00, 0x10, 0x3D,
			0x00, 0x00, 0x0D, 0x3F,
			0x00, 0x00, 0x28, 0x3D,
			0xff, 0xff, 0xff, 0xff,

			0x00, 0x80, 0xD5, 0x37,
			0x00, 0x00, 0xF3, 0x37,
			0x00, 0x00, 0x6C, 0x36,
			0xff, 0xff, 0xff, 0xff,

			0x00, 0x00, 0x10, 0x3D,
			0x00, 0x00, 0x0D, 0x3F,
			0x00, 0x00, 0x28, 0x3D,
			0xff, 0xff, 0xff, 0xff,

			0x00, 0x80, 0xD5, 0x37,
			0x00, 0x00, 0xF3, 0x37,
			0x00, 0x00, 0x6C, 0x36,
			0xff, 0xff, 0xff, 0xff,
		})
}
