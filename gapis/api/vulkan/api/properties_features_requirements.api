// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

/////////////////////////
// Instance and Device //
/////////////////////////

@override
cmd VkResult vkEnumerateInstanceExtensionProperties(
    const char*            pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {

  _ = as!string(pLayerName)

  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

@override
cmd VkResult vkEnumerateInstanceLayerProperties(
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice       physicalDevice,
    const char*            pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {

  _ = as!string(pLayerName)

  // Do not check validness of physicalDevice as the loader may feed 0 to it.
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice   physicalDevice,
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  // Do not check validness of physicalDevice as the loader may feed 0 to it.
  queryLayerProperties(pPropertyCount, pProperties)
  return ?
}

sub void queryExtensionProperties(u32* pPropertyCount, VkExtensionProperties* pProperties) {
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

sub void queryLayerProperties(u32* pPropertyCount, VkLayerProperties* pProperties) {
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

/////////////////////
// Physical Device //
/////////////////////

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice          physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFeatures == null { vkErrorNullPointer("VkPhysicalDeviceFeatures") }
  pFeatures[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice    physicalDevice,
    VkFormat            format,
    VkFormatProperties* pFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pFormatProperties == null { vkErrorNullPointer("VkFormatProperties") }
  pFormatProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice         physicalDevice,
    VkFormat                 format,
    VkImageType              type,
    VkImageTiling            tiling,
    VkImageUsageFlags        usage,
    VkImageCreateFlags       flags,
    VkImageFormatProperties* pImageFormatProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pImageFormatProperties == null { vkErrorNullPointer("VkImageFormatProperties") }
  pImageFormatProperties[0] = ?
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice            physicalDevice,
    VkPhysicalDeviceProperties* pProperties) {
  if pProperties == null { vkErrorNullPointer("VkPhysicalDeviceProperties") }
  pProperties[0] = ?
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  PhysicalDevices[physicalDevice].PhysicalDeviceProperties = pProperties[0]
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice         physicalDevice,
    u32*                     pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
  if pQueueFamilyPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pQueueFamilyPropertyCount[0] = count
    if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i]
    }
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                  physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  memoryProperties := ?
  if pMemoryProperties == null { vkErrorNullPointer("VkPhysicalDeviceMemoryProperties") }
  pMemoryProperties[0] = memoryProperties

  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  dev := PhysicalDevices[physicalDevice]
  dev.MemoryProperties = memoryProperties
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice               physicalDevice,
    VkFormat                       format,
    VkImageType                    type,
    VkSampleCountFlagBits          samples,
    VkImageUsageFlags              usage,
    VkImageTiling                  tiling,
    u32*                           pPropertyCount,
    VkSparseImageFormatProperties* pProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

////////////
// Buffer //
////////////

@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements(
    VkDevice              device,
    VkBuffer              buffer,
    VkMemoryRequirements* pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(buffer in Buffers) { vkErrorInvalidBuffer(buffer) }
  requirements := ?
  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements") }
  pMemoryRequirements[0] = requirements
  Buffers[buffer].MemoryRequirements = requirements
  if (as!u32(Buffers[buffer].Info.Usage) & as!u32(VK_BUFFER_USAGE_TRANSFER_SRC_BIT)) != 0 {
    if !(device in TransferBufferMemoryRequirements) {
      TransferBufferMemoryRequirements[device] = VkMemoryRequirements()
    }
    reqs := TransferBufferMemoryRequirements[device]
    reqs.memoryTypeBits =
    reqs.memoryTypeBits | Buffers[buffer].MemoryRequirements.memoryTypeBits
    TransferBufferMemoryRequirements[device] = reqs
  }
}

///////////
// Image //
///////////

@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements(
    VkDevice              device,
    VkImage               image,
    VkMemoryRequirements* pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) } else {
    requirements := ?
    if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements") }
    pMemoryRequirements[0] = requirements
    // This command can be only used for single-planar images
    plane := as!VkImageAspectFlagBits(0)
    if !(plane in Images[image].PlaneMemoryInfo) {
      Images[image].PlaneMemoryInfo[plane] = new!ImagePlaneMemoryInfo()
    }
    Images[image].PlaneMemoryInfo[plane].MemoryRequirements = requirements
  }
}

@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements(
    VkDevice                         device,
    VkImage                          image,
    u32*                             pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  if pSparseMemoryRequirementCount == null { vkErrorNullPointer("uint32_t") }
  read(pSparseMemoryRequirementCount[0:1])

  fence

  if pSparseMemoryRequirements == null {
    pSparseMemoryRequirementCount[0] = ?
  } else {
    count := as!u32(?)
    requirements := pSparseMemoryRequirements[0:count]
    for i in (0 .. count) {
      requirements[i] = ?
      aspect := requirements[i].formatProperties.aspectMask
      Images[image].SparseMemoryRequirements[as!VkImageAspectFlagBits(aspect)] = requirements[i]
    }
    pSparseMemoryRequirementCount[0] = count
  }
}

// ----------------------------------------------------------------------------
// Vulkan 1.1 Commands
// ----------------------------------------------------------------------------

//////////////
// Instance //
//////////////

@since("1.1")
cmd VkResult vkEnumerateInstanceVersion(
    u32* pApiVersion) {
  pApiVersion[0] = ?
  return ?
}

/////////////////////
// Physical Device //
/////////////////////

sub void GetPhysicalDeviceFeatures2(
    VkPhysicalDevice           physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures) {
  if !(physicalDevice in PhysicalDevices) {
    vkErrorInvalidPhysicalDevice(physicalDevice)
  } else {
    if pFeatures == null {
      vkErrorNullPointer("VkPhysicalDeviceFeatures2(KHR)")
    }
  }
  features := pFeatures[0]
  if (physicalDevice in PhysicalDevices) {
    if features.pNext != null {
      numPNext := numberOfPNext(
        as!const void*(features.pNext))
      next := MutableVoidPtr(as!void*(features.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch sType {
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: {
            _ = as!VkPhysicalDeviceVariablePointerFeatures*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            _ = as!VkPhysicalDevice16BitStorageFeatures*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            _ = as!VkPhysicalDeviceSamplerYcbcrConversionFeatures*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            _ = as!VkPhysicalDeviceProtectedMemoryFeatures*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            _ = as!VkPhysicalDeviceMultiviewFeatures*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceScalarBlockLayoutFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceHostQueryResetFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: {
            _ = as!VkPhysicalDevice8BitStorageFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceShaderClockFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceShaderFloat16Int8FeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceShaderAtomicInt64FeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceLineRasterizationFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceImageRobustnessFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceProvokingVertexFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceTransformFeedbackFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: {
            _ = as!VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceIndexTypeUint8FeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            _ = as!VkPhysicalDeviceCustomBorderColorFeaturesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            _ = as!VkPhysicalDeviceBufferDeviceAddressFeatures*(next.Ptr)[0]
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }
  fence
  if (physicalDevice in PhysicalDevices) {
    pFeatures[0] = ?
    newFeatures := pFeatures[0]
    if newFeatures.pNext != null {
      numPNext := numberOfPNext(
        as!const void*(newFeatures.pNext))
      next := MutableVoidPtr(as!void*(newFeatures.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch sType {
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: {
            write(as!VkPhysicalDeviceVariablePointerFeatures*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {
            write(as!VkPhysicalDevice16BitStorageFeatures*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {
            write(as!VkPhysicalDeviceSamplerYcbcrConversionFeatures*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {
            write(as!VkPhysicalDeviceProtectedMemoryFeatures*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {
            write(as!VkPhysicalDeviceMultiviewFeatures*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: {
            write(as!VkPhysicalDeviceScalarBlockLayoutFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: {
            write(as!VkPhysicalDeviceHostQueryResetFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: {
            write(as!VkPhysicalDevice8BitStorageFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR: {
            write(as!VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR: {
            write(as!VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {
            write(as!VkPhysicalDeviceShaderClockFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: {
            write(as!VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: {
            write(as!VkPhysicalDeviceShaderFloat16Int8FeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: {
            write(as!VkPhysicalDeviceShaderAtomicInt64FeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: {
            write(as!VkPhysicalDeviceLineRasterizationFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: {
            write(as!VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: {
            write(as!VkPhysicalDeviceImageRobustnessFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {
            write(as!VkPhysicalDeviceProvokingVertexFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {
            write(as!VkPhysicalDeviceTransformFeedbackFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR: {
            write(as!VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {
            write(as!VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: {
            write(as!VkPhysicalDeviceIndexTypeUint8FeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {
            write(as!VkPhysicalDeviceCustomBorderColorFeaturesEXT*(next.Ptr)[0:1])
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {
            write(as!VkPhysicalDeviceBufferDeviceAddressFeatures*(next.Ptr)[0:1])
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd void vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice           physicalDevice,
    VkPhysicalDeviceFeatures2* pFeatures) {
  GetPhysicalDeviceFeatures2(physicalDevice, pFeatures)
}

sub void GetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice     physicalDevice,
    VkFormat             format,
    VkFormatProperties2* pFormatProperties) {
  if !(physicalDevice in PhysicalDevices) {
    vkErrorInvalidPhysicalDevice(physicalDevice)
  } else {
    if pFormatProperties == null {
      vkErrorNullPointer("VkFormatProperties2(KHR)")
    } else {
      pFormatProperties[0] = ?
      // TODO: handle pNext
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice     physicalDevice,
    VkFormat             format,
    VkFormatProperties2* pFormatProperties) {
  GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties)
}

sub void GetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice                        physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2*               pImageFormatProperties) {
  if pImageFormatInfo == null {
    vkErrorNullPointer("const VkPhysicalDeviceImageFormatInfo2(KHR)")
  } else {
    info := pImageFormatInfo[0]
    // handle pNext in format info
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch sType {
          case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: {
            ext := as!VkImageFormatListCreateInfoKHR*(next.Ptr)[0]
            if (ext.viewFormatCount > 0) {
              _ = ext.pViewFormats[0:ext.viewFormatCount]
            }
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {
            _ = as!VkPhysicalDeviceExternalImageFormatInfo*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: {
            _ = as!VkAndroidHardwareBufferUsageANDROID*(next.Ptr)[0]
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }
  if pImageFormatProperties == null {
    vkErrorNullPointer("VkImageFormatProperties2(KHR)")
  }
  fence
  pImageFormatProperties[0] = ?
  props := pImageFormatProperties[0]
  // handle pNext in format properties
  if props.pNext != null {
    numPNext := numberOfPNext(as!const void*(props.pNext))
    next := MutableVoidPtr(props.pNext)
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {
          _ = as!VkSamplerYcbcrConversionImageFormatProperties*(next.Ptr)[0]
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {
          _ = as!VkExternalImageFormatProperties*(next.Ptr)[0]
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: {
          _ = as!VkAndroidHardwareBufferUsageANDROID*(next.Ptr)[0]
        }
      }
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice                        physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2*               pImageFormatProperties) {
  GetPhysicalDeviceImageFormatProperties2(
    physicalDevice, pImageFormatInfo, pImageFormatProperties)
  return ?
}

sub void GetPhysicalDeviceProperties2(
    VkPhysicalDevice             physicalDevice,
    VkPhysicalDeviceProperties2* pProperties) {
  if pProperties == null {
    vkErrorNullPointer("VkPhysicalDeviceProperties2")
  } else {
    props := pProperties[0]
    if props.pNext != null {
      numPNext := numberOfPNext(as!const void*(props.pNext))
      next := MutableVoidPtr(as!void*(props.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch sType {
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
            _ = as!VkPhysicalDevicePointClippingProperties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
            _ = as!VkPhysicalDeviceMaintenance3Properties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
            _ = as!VkPhysicalDeviceSubgroupProperties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
            _ = as!VkPhysicalDeviceIDProperties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
            _ = as!VkPhysicalDeviceMultiviewProperties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
            _ = as!VkPhysicalDevicePCIBusInfoPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
            _ = as!VkPhysicalDeviceShaderCorePropertiesAMD*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR :{
            _ = as!VkPhysicalDeviceFloatControlsPropertiesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: {
            _ = as!VkPhysicalDeviceDriverPropertiesKHR*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceLineRasterizationPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceProvokingVertexPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceTransformFeedbackPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
            _ = as!VkPhysicalDeviceProtectedMemoryProperties*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
            _ = as!VkPhysicalDeviceCustomBorderColorPropertiesEXT*(next.Ptr)[0]
          }
          case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
            _ = as!VkPhysicalDeviceSamplerFilterMinmaxProperties*(next.Ptr)[0]
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }
  fence
  if pProperties != null {
    pProperties[0] = ?
    if !(physicalDevice in PhysicalDevices) {
      vkErrorInvalidPhysicalDevice(physicalDevice)
    } else {
      props := pProperties[0]
      phyDev := PhysicalDevices[physicalDevice]
      phyDev.PhysicalDeviceProperties = props.properties
      if props.pNext != null {
        numPNext := numberOfPNext(as!const void*(props.pNext))
        next := MutableVoidPtr(as!void*(props.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch sType {
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {
              ext := as!VkPhysicalDevicePointClippingProperties*(next.Ptr)[0]
              phyDev.PointClippingProperties = new!PointClippingProperties(
                PointClippingBehavior: ext.pointClippingBehavior
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {
              ext := as!VkPhysicalDeviceMaintenance3Properties*(next.Ptr)[0]
              phyDev.Maintenance3Properties = new!Maintenance3Properties(
                MaxPerSetDescriptors: ext.maxPerSetDescriptors,
                MaxMemoryAllocationSize: ext.maxMemoryAllocationSize,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {
              ext := as!VkPhysicalDeviceSubgroupProperties*(next.Ptr)[0]
              phyDev.SubgroupProperties = new!SubgroupProperties(
                SubgroupSize:              ext.subgroupSize,
                SupportedStages:           ext.supportedStages,
                SupportedOperations:       ext.supportedOperations,
                QuadOperationsInAllStages: ext.quadOperationsInAllStages,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {
              ext := as!VkPhysicalDeviceIDProperties*(next.Ptr)[0]
              phyDev.IDProperties = new!PhysicalDeviceIDProperties(
                DeviceUUID: ext.deviceUUID,
                DriverUUID: ext.driverUUID,
                DeviceLUID: ext.deviceLUID,
                DeviceNodeMask: ext.deviceNodeMask,
                DeviceLUIDValid: ext.deviceLUIDValid,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {
              ext := as!VkPhysicalDeviceMultiviewProperties*(next.Ptr)[0]
              phyDev.MultiviewProperties = new!PhysicalDeviceMultiviewProperties(
                MaxMultiviewViewCount: ext.maxMultiviewViewCount,
                MaxMultiviewInstanceIndex: ext.maxMultiviewInstanceIndex,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: {
              ext := as!VkPhysicalDevicePCIBusInfoPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDevicePCIBusInfoPropertiesEXT = new!PhysicalDevicePCIBusInfoPropertiesEXT(
                pciDomain:   ext.pciDomain,
                pciBus:      ext.pciBus,
                pciDevice:   ext.pciDevice,
                pciFunction: ext.pciFunction,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: {
              ext := as!VkPhysicalDeviceShaderCorePropertiesAMD*(next.Ptr)[0]
              phyDev.PhysicalDeviceShaderCorePropertiesAMD = new!PhysicalDeviceShaderCorePropertiesAMD(
                shaderEngineCount: ext.shaderEngineCount,
                shaderArraysPerEngineCount: ext.shaderArraysPerEngineCount,
                computeUnitsPerShaderArray: ext.computeUnitsPerShaderArray,
                simdPerComputeUnit: ext.simdPerComputeUnit,
                wavefrontsPerSimd: ext.wavefrontsPerSimd,
                wavefrontSize: ext.wavefrontSize,
                sgprsPerSimd: ext.sgprsPerSimd,
                minSgprAllocation: ext.minSgprAllocation,
                maxSgprAllocation: ext.maxSgprAllocation,
                sgprAllocationGranularity: ext.sgprAllocationGranularity,
                vgprsPerSimd: ext.vgprsPerSimd,
                minVgprAllocation: ext.minVgprAllocation,
                maxVgprAllocation: ext.maxVgprAllocation,
                vgprAllocationGranularity: ext.vgprAllocationGranularity,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR :{
              ext := as!VkPhysicalDeviceFloatControlsPropertiesKHR*(next.Ptr)[0]
              phyDev.PhysicalDeviceFloatControlsPropertiesKHR = new!PhysicalDeviceFloatControlsPropertiesKHR(
                DenormBehaviorIndependence: ext.denormBehaviorIndependence,
                RoundingModeIndependence: ext.roundingModeIndependence,
                ShaderSignedZeroInfNanPreserveFloat16: ext.shaderSignedZeroInfNanPreserveFloat16,
                ShaderSignedZeroInfNanPreserveFloat32: ext.shaderSignedZeroInfNanPreserveFloat32,
                ShaderSignedZeroInfNanPreserveFloat64: ext.shaderSignedZeroInfNanPreserveFloat64,
                ShaderDenormPreserveFloat16: ext.shaderDenormPreserveFloat16,
                ShaderDenormPreserveFloat32: ext.shaderDenormPreserveFloat32,
                ShaderDenormPreserveFloat64: ext.shaderDenormPreserveFloat64,
                ShaderDenormFlushToZeroFloat16: ext.shaderDenormFlushToZeroFloat16,
                ShaderDenormFlushToZeroFloat32: ext.shaderDenormFlushToZeroFloat32,
                ShaderDenormFlushToZeroFloat64: ext.shaderDenormFlushToZeroFloat64,
                ShaderRoundingModeRTEFloat16: ext.shaderRoundingModeRTEFloat16,
                ShaderRoundingModeRTEFloat32: ext.shaderRoundingModeRTEFloat32,
                ShaderRoundingModeRTEFloat64: ext.shaderRoundingModeRTEFloat64,
                ShaderRoundingModeRTZFloat16: ext.shaderRoundingModeRTZFloat16,
                ShaderRoundingModeRTZFloat32: ext.shaderRoundingModeRTZFloat32,
                ShaderRoundingModeRTZFloat64: ext.shaderRoundingModeRTZFloat64,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: {
              ext := as!VkPhysicalDeviceDriverPropertiesKHR*(next.Ptr)[0]
              phyDev.PhysicalDeviceDriverPropertiesKHR = new!PhysicalDeviceDriverPropertiesKHR(
                DriverID: ext.driverID,
                DriverName: ext.driverName,
                DriverInfo: ext.driverInfo,
                ConformanceVersion: ext.conformanceVersion,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceLineRasterizationPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceLineRasterizationPropertiesEXT = new!PhysicalDeviceLineRasterizationPropertiesEXT(
                LineSubPixelPrecisionBits: ext.lineSubPixelPrecisionBits,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceVertexAttributeDivisorPropertiesEXT = new!PhysicalDeviceVertexAttributeDivisorPropertiesEXT(
                maxVertexAttribDivisor: ext.maxVertexAttribDivisor,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceProvokingVertexPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceProvokingVertexPropertiesEXT = new!PhysicalDeviceProvokingVertexPropertiesEXT(
                ProvokingVertexModePerPipeline: ext.provokingVertexModePerPipeline,
                TransformFeedbackPreservesTriangleFanProvokingVertex: ext.transformFeedbackPreservesTriangleFanProvokingVertex,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceTransformFeedbackPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceTransformFeedbackPropertiesEXT = new!PhysicalDeviceTransformFeedbackPropertiesEXT(
                MaxTransformFeedbackStreams: ext.maxTransformFeedbackStreams,
                MaxTransformFeedbackBuffers: ext.maxTransformFeedbackBuffers,
                MaxTransformFeedbackBufferSize: ext.maxTransformFeedbackBufferSize,
                MaxTransformFeedbackStreamDataSize: ext.maxTransformFeedbackStreamDataSize,
                MaxTransformFeedbackBufferDataSize: ext.maxTransformFeedbackBufferDataSize,
                MaxTransformFeedbackBufferDataStride: ext.maxTransformFeedbackBufferDataStride,
                TransformFeedbackQueries: ext.transformFeedbackQueries,
                TransformFeedbackStreamsLinesTriangles: ext.transformFeedbackStreamsLinesTriangles,
                TransformFeedbackRasterizationStreamSelect: ext.transformFeedbackRasterizationStreamSelect,
                TransformFeedbackDraw: ext.transformFeedbackDraw,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceBlendOperationAdvancedPropertiesEXT = new!PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
                AdvancedBlendMaxColorAttachments: ext.advancedBlendMaxColorAttachments,
                AdvancedBlendIndependentBlend: ext.advancedBlendIndependentBlend,
                AdvancedBlendNonPremultipliedSrcColor: ext.advancedBlendNonPremultipliedSrcColor,
                AdvancedBlendNonPremultipliedDstColor: ext.advancedBlendNonPremultipliedDstColor,
                AdvancedBlendCorrelatedOverlap: ext.advancedBlendCorrelatedOverlap,
                AdvancedBlendAllOperations: ext.advancedBlendAllOperations,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {
              ext := as!VkPhysicalDeviceProtectedMemoryProperties*(next.Ptr)[0]
              phyDev.ProtectedMemoryProperties = new!PhysicalDeviceProtectedMemoryProperties(
                ProtectedNoFault: ext.protectedNoFault,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: {
              ext := as!VkPhysicalDeviceCustomBorderColorPropertiesEXT*(next.Ptr)[0]
              phyDev.PhysicalDeviceCustomBorderColorPropertiesEXT = new!PhysicalDeviceCustomBorderColorPropertiesEXT(
                MaxCustomBorderColorSamplers: ext.maxCustomBorderColorSamplers,
              )
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {
              ext := as!VkPhysicalDeviceSamplerFilterMinmaxProperties*(next.Ptr)[0]
              phyDev.PhysicalDeviceSamplerFilterMinmaxProperties = new!PhysicalDeviceSamplerFilterMinmaxProperties(
                FilterMinmaxSingleComponentFormats: ext.filterMinmaxSingleComponentFormats,
                FilterMinmaxImageComponentMapping: ext.filterMinmaxImageComponentMapping,
              )
            }
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice             physicalDevice,
    VkPhysicalDeviceProperties2* pProperties) {
  GetPhysicalDeviceProperties2(physicalDevice, pProperties)
}

sub void GetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice                   physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
  if pMemoryProperties == null {
    vkErrorNullPointer("VkPhysicalDeviceMemoryProperties2(KHR)")
  }
  fence
  pMemoryProperties[0] = ?
  memoryProperties := pMemoryProperties[0]

  if !(physicalDevice in PhysicalDevices) {
    vkErrorInvalidPhysicalDevice(physicalDevice)
  } else {
    PhysicalDevices[physicalDevice].MemoryProperties = memoryProperties.memoryProperties
    // handle pNext
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice                   physicalDevice,
    VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
  GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties)
}

sub void GetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice                              physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    u32*                                          pPropertyCount,
    VkSparseImageFormatProperties2*               pProperties) {
  if !(physicalDevice in PhysicalDevices) {
    vkErrorInvalidPhysicalDevice(physicalDevice)
  }
  if pPropertyCount == null { vkErrorNullPointer("uint32_t") }
  info := pFormatInfo[0]
  // handle pNext in pFormatInfo
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: handle pNext in pProperties
    }
    pPropertyCount[0] = count
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice                              physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    u32*                                          pPropertyCount,
    VkSparseImageFormatProperties2*               pProperties) {
  GetPhysicalDeviceSparseImageFormatProperties2(
    physicalDevice, pFormatInfo, pPropertyCount, pProperties)
}

sub void GetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice          physicalDevice,
    u32*                      pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pQueueFamilyPropertyCount == null { vkErrorNullPointer("uint32_t") }
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: handle pNext
    }
    pQueueFamilyPropertyCount[0] = count
    if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i].queueFamilyProperties
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd void vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice          physicalDevice,
    u32*                      pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2* pQueueFamilyProperties) {
  GetPhysicalDeviceQueueFamilyProperties2(
    physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)
}

sub void GetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pExternalBufferInfo == null {
    vkErrorNullPointer("const VkPhysicalDeviceExternalBufferInfo")
  } else {
    info := pExternalBufferInfo[0]
    // handle pNext in pExternalBufferInfo
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }

  fence

  if pExternalBufferProperties == null { vkErrorNullPointer("VkExternalBufferProperties") }
  pExternalBufferProperties[0] = ?
  props := pExternalBufferProperties[0]
  // handle pNext in pExternalBufferProperties
  if props.pNext != null {
    numPNext := numberOfPNext(as!const void*(props.pNext))
    next := MutableVoidPtr(props.pNext)
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties) {
  GetPhysicalDeviceExternalBufferProperties(
    physicalDevice, pExternalBufferInfo, pExternalBufferProperties)
}

sub void GetPhysicalDeviceExternalSemaphoreProperties(
      VkPhysicalDevice                              physicalDevice,
      const VkPhysicalDeviceExternalSemaphoreInfo*  pExternalSemaphoreInfo,
      VkExternalSemaphoreProperties*                pExternalSemaphoreProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pExternalSemaphoreInfo == null {
    vkErrorNullPointer("const VkPhysicalDeviceExternalSemaphoreInfo")
  } else {
    info := pExternalSemaphoreInfo[0]
    // handle pNext in pExternalSemaphoreInfo
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }

  fence

  if pExternalSemaphoreProperties == null { vkErrorNullPointer("VkExternalBufferProperties") }
  pExternalSemaphoreProperties[0] = ?
  props := pExternalSemaphoreProperties[0]
  // handle pNext in pExternalSemaphoreProperties
  if props.pNext != null {
    numPNext := numberOfPNext(as!const void*(props.pNext))
    next := MutableVoidPtr(props.pNext)
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice                                physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo*    pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties*                  pExternalSemaphoreProperties) {
  GetPhysicalDeviceExternalSemaphoreProperties(
      physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)
}

sub void GetPhysicalDeviceExternalFenceProperties(
      VkPhysicalDevice                          physicalDevice,
      const VkPhysicalDeviceExternalFenceInfo*  pExternalFenceInfo,
      VkExternalFenceProperties*                pExternalFenceProperties) {
  if !(physicalDevice in PhysicalDevices) { vkErrorInvalidPhysicalDevice(physicalDevice) }
  if pExternalFenceInfo == null {
    vkErrorNullPointer("const VkPhysicalDeviceExternalFenceInfo")
  } else {
    info := pExternalFenceInfo[0]
    // handle pNext in pExternalFenceInfo
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }

  fence

  if pExternalFenceProperties == null { vkErrorNullPointer("VkExternalBufferProperties") }
  pExternalFenceProperties[0] = ?
  props := pExternalFenceProperties[0]
  // handle pNext in pExternalFenceProperties
  if props.pNext != null {
    numPNext := numberOfPNext(as!const void*(props.pNext))
    next := MutableVoidPtr(props.pNext)
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
}

@since("1.1")
@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
    VkExternalFenceProperties*                  pExternalFenceProperties) {
  GetPhysicalDeviceExternalFenceProperties(
      physicalDevice, pExternalFenceInfo, pExternalFenceProperties)
}

////////////
// Buffer //
////////////

sub void GetBufferMemoryRequirements2(
    VkDevice                               device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2*                 pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  info := pInfo[0]
  memReqs := pMemoryRequirements[0]
  if memReqs.pNext != null {
    nPNext := numberOfPNext(as!const void*(memReqs.pNext))
    next := MutableVoidPtr(as!void*(memReqs.pNext))
    for i in (0 .. nPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          _ = as!VkMemoryDedicatedRequirements*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  fence

  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements2(KHR)") }
  pMemoryRequirements[0] = ?
  memReq := pMemoryRequirements[0]
  if !(info.buffer in Buffers) { vkErrorInvalidBuffer(info.buffer) }
  // TODO: Do the touch of the buffer object once we extract the memory
  // requirement info out of the buffer objectd.
  Buffers[info.buffer].MemoryRequirements = memReq.memoryRequirements

  if memReq.pNext != null {
    numPNext := numberOfPNext(as!const void*(memReq.pNext))
    next := MutableVoidPtr(as!void*(memReq.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          ext := as!VkMemoryDedicatedRequirements(?)
          Buffers[info.buffer].DedicatedRequirements = new!DedicatedRequirements(
            PrefersDedicatedAllocation:   ext.prefersDedicatedAllocation,
            RequiresDedicatedAllocation:  ext.requiresDedicatedAllocation,
          )
          as!VkMemoryDedicatedRequirements*(next.Ptr)[0] = ext
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
}

@since("1.1")
@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements2(
    VkDevice                               device,
    const VkBufferMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2*                 pMemoryRequirements) {
  GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements)
}

///////////
// Image //
///////////

sub void GetImageMemoryRequirements2(
    VkDevice                              device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2*                pMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  plane := MutableU32(0)
  info := pInfo[0]
  memReqs := pMemoryRequirements[0]
  if memReqs.pNext != null {
    nPNext := numberOfPNext(as!const void*(memReqs.pNext))
    next := MutableVoidPtr(as!void*(memReqs.pNext))
    for i in (0 .. nPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
          ext := as!VkImagePlaneMemoryRequirementsInfo*(next.Ptr)[0]
          plane.Val = as!u32(ext.planeAspect)
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          _ = as!VkMemoryDedicatedRequirements*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  // TODO: handle pNext for 'info'
  fence

  if pMemoryRequirements == null { vkErrorNullPointer("VkMemoryRequirements2(KHR)") }
  pMemoryRequirements[0] = ?
  memReq := pMemoryRequirements[0]

  if !(info.image in Images) { vkErrorInvalidImage(info.image) }
  // TODO: Drop the touch of the image object once we extract the memory
  // requirement info out of the image object.
  // TODO: Handle multi-planar images
  if !(as!VkImageAspectFlagBits(plane.Val) in Images[info.image].PlaneMemoryInfo) {
    Images[info.image].PlaneMemoryInfo[as!VkImageAspectFlagBits(plane.Val)] = new!ImagePlaneMemoryInfo()
  }
  Images[info.image].PlaneMemoryInfo[as!VkImageAspectFlagBits(plane.Val)].MemoryRequirements = memReq.memoryRequirements

  if memReq.pNext != null {
    numPNext := numberOfPNext(as!const void*(memReq.pNext))
    next := MutableVoidPtr(as!void*(memReq.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {
          ext := as!VkMemoryDedicatedRequirements(?)
          Images[info.image].DedicatedRequirements = new!DedicatedRequirements(
            PrefersDedicatedAllocation:   ext.prefersDedicatedAllocation,
            RequiresDedicatedAllocation:  ext.requiresDedicatedAllocation,
          )
          as!VkMemoryDedicatedRequirements*(next.Ptr)[0] = ext
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
}

@since("1.1")
@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements2(
    VkDevice                              device,
    const VkImageMemoryRequirementsInfo2* pInfo,
    VkMemoryRequirements2*                pMemoryRequirements) {
  GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements)
}

sub void GetImageSparseMemoryRequirements2(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    u32*                                        pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  info := pInfo[0]
  image := info.image
  if !(image in Images) { vkErrorInvalidImage(image) }
  // handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
  if pSparseMemoryRequirementCount == null { vkErrorNullPointer("uint32_t") }
  read(pSparseMemoryRequirementCount[0:1])

  fence

  if pSparseMemoryRequirements == null {
    pSparseMemoryRequirementCount[0] = ?
  } else {
    count := as!u32(?)
    requirements := pSparseMemoryRequirements[0:count]
    for i in (0 .. count) {
      requirements[i] = ?
      // TODO: handle pNext for 'requirements[i]'
      aspect := requirements[i].memoryRequirements.formatProperties.aspectMask
      // TODO: Drop the touch of the image object.
      Images[image].SparseMemoryRequirements[as!VkImageAspectFlagBits(aspect)] = requirements[i].memoryRequirements
    }
    pSparseMemoryRequirementCount[0] = count
  }
}

@since("1.1")
@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements2(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    u32*                                        pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements) {
  GetImageSparseMemoryRequirements2(
    device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)
}

////////////////////
// State tracking //
////////////////////

@internal class DedicatedRequirements {
  VkBool32 PrefersDedicatedAllocation
  VkBool32 RequiresDedicatedAllocation
}
