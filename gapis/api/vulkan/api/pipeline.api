// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

/////////////////////
// Pipeline Layout //
/////////////////////

@internal class PipelineLayoutObject {
  @unused VkDevice                                 Device
  @unused VkPipelineLayout                         VulkanHandle
  @unused map!(u32, ref!DescriptorSetLayoutObject) SetLayouts
  @unused map!(u32, VkPushConstantRange)           PushConstantRanges
  @unused ref!VulkanDebugMarkerInfo                DebugInfo
}

@indirect("VkDevice")
@threadsafe
cmd VkResult vkCreatePipelineLayout(
    VkDevice                          device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    AllocationCallbacks               pAllocator,
    VkPipelineLayout*                 pPipelineLayout) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkPipelineLayoutCreateInfo") }
  info := pCreateInfo[0]
  pipelineLayout := new!PipelineLayoutObject(Device: device)
  // TODO: info.pNext

  layoutCount := info.setLayoutCount
  layouts := info.pSetLayouts[0:layoutCount]
  for i in (0 .. layoutCount) {
    pipelineLayout.SetLayouts[i] = DescriptorSetLayouts[layouts[i]]
  }
  pushConstantCount := info.pushConstantRangeCount
  pushConstants := info.pPushConstantRanges[0:pushConstantCount]
  for i in (0 .. pushConstantCount) {
    pipelineLayout.PushConstantRanges[i] = pushConstants[i]
  }

  handle := ?
  if pPipelineLayout == null { vkErrorNullPointer("VkPipelineLayout") }
  pPipelineLayout[0] = handle
  pipelineLayout.VulkanHandle = handle
  PipelineLayouts[handle] = pipelineLayout
  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipelineLayout(
    VkDevice                     device,
    VkPipelineLayout             pipelineLayout,
    AllocationCallbacks          pAllocator) {

  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(PipelineLayouts, pipelineLayout)
}

//////////////
// Pipeline //
//////////////

@internal class SpecializationInfo {
  map!(u32, VkSpecializationMapEntry) Specializations
  u8[]                                Data
}

@internal class StageData {
  @unused VkShaderStageFlagBits  Stage
  @unused ref!ShaderModuleObject Module
  @unused string                 EntryPoint
  @unused ref!SpecializationInfo Specialization
}

@internal class VertexData {
  @unused map!(u32, VkVertexInputBindingDescription)   BindingDescriptions
  @unused map!(u32, VkVertexInputAttributeDescription) AttributeDescriptions
  @unused map!(u32, u32)                               Divisors
}

@internal class InputAssemblyData {
  @unused VkPrimitiveTopology Topology
  @unused VkBool32            PrimitiveRestartEnable
}

@internal class TessellationDomainOriginState {
  VkTessellationDomainOrigin DomainOrigin
}

@internal class TessellationStateData {
  @unused u32 PatchControlPoints
  @unused ref!TessellationDomainOriginState TessellationDomainOriginState
}

@internal class ViewportData {
  @unused u32                   ViewportCount
  @unused map!(u32, VkViewport) Viewports
  @unused u32                   ScissorCount
  @unused map!(u32, VkRect2D)   Scissors
}

@internal class RasterizationData {
  @unused VkBool32        DepthClampEnable
  @unused VkBool32        RasterizerDiscardEnable
  @unused VkPolygonMode   PolygonMode
  @unused VkCullModeFlags CullMode
  @unused VkFrontFace     FrontFace
  @unused VkBool32        DepthBiasEnable
  @unused f32             DepthBiasConstantFactor
  @unused f32             DepthBiasClamp
  @unused f32             DepthBiasSlopeFactor
  @unused f32             LineWidth

  // @extension("VK_EXT_line_rasterization")
  @unsued ref!PipelineRasterizationLineStateCreateInfoEXT PipelineRasterizationLineStateCreateInfoEXT

  // @extension("VK_EXT_provoking_vertex")
  @unused ref!PipelineRasterizationProvokingVertexStateCreateInfoEXT PipelineRasterizationProvokingVertexStateCreateInfoEXT

  // @extension("VK_EXT_transform_feedback")
  @unused ref!PipelineRasterizationStateStreamCreateInfoEXT PipelineRasterizationStateStreamCreateInfoEXT
}

@internal class MultisampleData {
  @unused VkSampleCountFlagBits   RasterizationSamples
  @unused VkBool32                SampleShadingEnable
  @unused f32                     MinSampleShading
  @unused map!(u32, VkSampleMask) SampleMask
  @unused VkBool32                AlphaToCoverageEnable
  @unused VkBool32                AlphaToOneEnable
}

@internal class DepthData {
  @unused VkBool32         DepthTestEnable
  @unused VkBool32         DepthWriteEnable
  @unused VkCompareOp      DepthCompareOp
  @unused VkBool32         DepthBoundsTestEnable
  @unused VkBool32         StencilTestEnable
  @unused VkStencilOpState Front
  @unused VkStencilOpState Back
  @unused f32              MinDepthBounds
  @unused f32              MaxDepthBounds
}

@internal class ColorBlendData {
  @unused VkBool32                                       LogicOpEnable
  @unused VkLogicOp                                      LogicOp
  @unused map!(u32, VkPipelineColorBlendAttachmentState) Attachments
  @unused f32[4]                                         BlendConstants

  @unused ref!PipelineColorBlendAdvancedStateCreateInfoEXT AdvancedState
}

@internal class DynamicData {
  // A map(u32,<value>) is needed for state rebuilder
  @unused map!(u32, VkDynamicState) DynamicStates
  // At every draw call we need to lookup if a particular dynamic state is
  // enabled, rather than iterating on the DynamicStates map, we use this
  // helper map for simple lookup.
  @unused map!(VkDynamicState, bool) Contains
}

@resource
@internal class GraphicsPipelineObject {
  @unused VkDevice                  Device
  @unused ref!PipelineCacheObject   PipelineCache
  @unused VkPipelineCreateFlags     Flags
  @unused VkPipeline                VulkanHandle
  @unused map!(u32, StageData)      Stages
  @unused VertexData                VertexInputState
  @unused InputAssemblyData         InputAssemblyState
  @unused ref!TessellationStateData TessellationState
  @unused ref!ViewportData          ViewportState
  @unused RasterizationData         RasterizationState
  @unused ref!MultisampleData       MultisampleState
  @unused ref!DepthData             DepthState
  @unused ref!ColorBlendData        ColorBlendState
  @unused ref!DynamicData           DynamicState
  @unused ref!PipelineLayoutObject  Layout
  @unused ref!RenderPassObject      RenderPass
  @unused u32                       Subpass
  @unused VkPipeline                BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                       BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @unused map!(u32, DescriptorUsage) UsedDescriptors
}

@resource
@internal class ComputePipelineObject {
  @unused VkDevice                 Device
  @unused VkPipeline               VulkanHandle
  @unused ref!PipelineCacheObject  PipelineCache
  @unused VkPipelineCreateFlags    Flags
  @unused StageData                Stage
  @unused ref!PipelineLayoutObject PipelineLayout
  @unused VkPipeline               BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                       BasePipelineIndex
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @unused map!(u32, DescriptorUsage) UsedDescriptors
}

@internal
class CreatedGraphicsPipelines {
  map!(u32, ref!GraphicsPipelineObject) Objects
}


@internal class MutableSet {
  map!(u64, bool) Set
}

@indirect("VkDevice")
@threadsafe
cmd VkResult vkCreateGraphicsPipelines(
    VkDevice                            device,
    VkPipelineCache                     pipelineCache,
    u32                                 createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    AllocationCallbacks                 pAllocator,
    VkPipeline*                         pPipelines) {

  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipelineCache != as!VkPipelineCache(0) {
    if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  }
  // TODO(awoloszyn): Figure out what fields we want to store off
  //    in the state block.
  infos := pCreateInfos[0:createInfoCount]
  pipelines := pPipelines[0:createInfoCount]

  createdPipelines := CreatedGraphicsPipelines()

  for i in (0 .. createInfoCount) {
    create_info := infos[i]
    if !(create_info.renderPass in RenderPasses) { vkErrorInvalidRenderPass(create_info.renderPass)}

    obj := new!GraphicsPipelineObject(
      PipelineCache: PipelineCaches[pipelineCache]
    )
    obj.Device = device
    obj.Layout = PipelineLayouts[create_info.layout]
    // handle pNext
    if create_info.pNext != null {
      numPNext := numberOfPNext(create_info.pNext)
      next := MutableVoidPtr(as!void*(create_info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch(sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            pcfcie := as!const VkPipelineCreationFeedbackCreateInfoEXT*(next.Ptr)
            read(pcfcie[0:1])
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
    obj.Flags = create_info.flags

    seenDescs := MutableSet()

    pipeline_shader_stage_create_infos :=
    create_info.pStages[0:create_info.stageCount]
    for j in (0 .. create_info.stageCount) {
      stage_create_info := pipeline_shader_stage_create_infos[j]
      // handle shader stage pNext
      if stage_create_info.pNext != null {
        numPNext := numberOfPNext(stage_create_info.pNext)
        next := MutableVoidPtr(as!void*(stage_create_info.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
      if !(stage_create_info.module in ShaderModules) { vkErrorInvalidShaderModule(stage_create_info.module) }
      stage_data := StageData(
        Stage:       stage_create_info.stage,
        Module:      ShaderModules[stage_create_info.module],
        EntryPoint:  as!string(stage_create_info.pName),
      )
      if (stage_create_info.pSpecializationInfo != null) {
        spec_info := stage_create_info.pSpecializationInfo[0]
        spec_data := new!SpecializationInfo()
        spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
        for k in (0 .. spec_info.mapEntryCount) {
          spec_data.Specializations[k] = spec_map[k]
        }
        spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
        stage_data.Specialization = spec_data
      }

      if stage_data.Module.Descriptors != null {
        moduleDescriptors := stage_data.Module.Descriptors.Descriptors[as!string(stage_create_info.pName)]
        for _, _, d in moduleDescriptors {
          if !seenDescs.Set[(as!u64(d.Set)<<32) | as!u64(d.Binding)] {
            obj.UsedDescriptors[len(obj.UsedDescriptors)] = d
            seenDescs.Set[(as!u64(d.Set)<<32) | as!u64(d.Binding)] = true
          }
        }
      } else {
        nSets := len(obj.Layout.SetLayouts)
        for ii in (0 .. nSets) {
          set := obj.Layout.SetLayouts[as!u32(ii)]
          for _, k, v in set.Bindings {
            if !seenDescs.Set[(as!u64(ii)<<32) | as!u64(k)] {
              obj.UsedDescriptors[len(obj.UsedDescriptors)] =
                DescriptorUsage(Set: as!u32(ii),
                  Binding: k,
                  DescriptorCount: v.Count)
              seenDescs.Set[(as!u64(ii)<<32) | as!u64(k)] = true
            }
          }
        }
      }

      obj.Stages[j] = stage_data
    }

    vertex_input_state := create_info.pVertexInputState[0]
    vertex_descriptions := vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount]
    // handle vertex input state pNext
    if vertex_input_state.pNext != null {
      numPNext := numberOfPNext(vertex_input_state.pNext)
      next := MutableVoidPtr(as!void*(vertex_input_state.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: {
            divisorInfo := as!VkPipelineVertexInputDivisorStateCreateInfoEXT*(next.Ptr)[0]
            numDivisors := divisorInfo.vertexBindingDivisorCount
            divisors := divisorInfo.pVertexBindingDivisors[0:numDivisors]
            for j in (0 .. numDivisors) {
              d := divisors[j]
              obj.VertexInputState.Divisors[d.binding] = d.divisor
            }
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
    for b in (0 .. vertex_input_state.vertexBindingDescriptionCount) {
      vertex_binding := vertex_descriptions[b]
      obj.VertexInputState.BindingDescriptions[b] = vertex_binding
    }

    vertex_attributes := vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount]

    for b in (0 .. vertex_input_state.vertexAttributeDescriptionCount) {
      attribute := vertex_attributes[b]
      obj.VertexInputState.AttributeDescriptions[b] = attribute
    }

    input_assembly_state := create_info.pInputAssemblyState[0]
    obj.InputAssemblyState.Topology = input_assembly_state.topology
    obj.InputAssemblyState.PrimitiveRestartEnable = input_assembly_state.primitiveRestartEnable
    // handle input assembly state pNext
    if input_assembly_state.pNext != null {
      numPNext := numberOfPNext(input_assembly_state.pNext)
      next := MutableVoidPtr(as!void*(input_assembly_state.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }

    if (create_info.pTessellationState != null) {
      tessellation_state := create_info.pTessellationState[0]
      obj.TessellationState = new!TessellationStateData(
        PatchControlPoints: tessellation_state.patchControlPoints
      )
      // handle tessellation state pNext
      if tessellation_state.pNext != null {
        numPNext := numberOfPNext(tessellation_state.pNext)
        next := MutableVoidPtr(as!void*(tessellation_state.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch sType {
            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {
              ext := as!VkPipelineTessellationDomainOriginStateCreateInfo*(next.Ptr)[0]
              obj.TessellationState.TessellationDomainOriginState
                = new!TessellationDomainOriginState(DomainOrigin: ext.domainOrigin)
            }
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
    }

    // Register dynamic states early on as we need to know which ones are
    // enabled when handling viewport state.
    if (create_info.pDynamicState != null) {
      dynamic_state_info := create_info.pDynamicState[0]
      dynamic_data := new!DynamicData()
      // handle dynamic_state_info.pNext
      if dynamic_state_info.pNext != null {
        numPNext := numberOfPNext(dynamic_state_info.pNext)
        next := MutableVoidPtr(as!void*(dynamic_state_info.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
      states := dynamic_state_info.pDynamicStates[0:dynamic_state_info.dynamicStateCount]
      for k in (0 .. dynamic_state_info.dynamicStateCount) {
        dynamic_data.DynamicStates[k] = states[k]
        dynamic_data.Contains[states[k]] = true
      }
      obj.DynamicState = dynamic_data
    }

    if (create_info.pViewportState != null) {
      pipeline_viewport_state_create_info := create_info.pViewportState[0]
      // viewport state pNext
      if pipeline_viewport_state_create_info.pNext != null {
        numPNext := numberOfPNext(pipeline_viewport_state_create_info.pNext)
        next := MutableVoidPtr(as!void*(pipeline_viewport_state_create_info.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }

      viewport_data := new!ViewportData()

      // Even if the viewports and scissors are set dynamically, the number of
      // viewports and scissors must match with the viewportCount and
      // sicssorCount set in this VkPipelineViewportStateCreateInfo struct.
      viewport_data.ViewportCount = pipeline_viewport_state_create_info.viewportCount
      viewport_data.ScissorCount = pipeline_viewport_state_create_info.scissorCount

      if (!hasDynamicState(obj, VK_DYNAMIC_STATE_VIEWPORT)) {
        viewports := pipeline_viewport_state_create_info.pViewports[0:viewport_data.ViewportCount]
        for k in (0 .. viewport_data.ViewportCount) {
          viewport_data.Viewports[k] = viewports[k]
        }
      }

      if (!hasDynamicState(obj, VK_DYNAMIC_STATE_SCISSOR)) {
        scissors := pipeline_viewport_state_create_info.pScissors[0:viewport_data.ScissorCount]
        for k in (0 .. viewport_data.ScissorCount) {
          viewport_data.Scissors[k] = scissors[k]
        }
      }

      obj.ViewportState = viewport_data
    }
    rasterization_state := create_info.pRasterizationState[0]

    obj.RasterizationState.DepthClampEnable = rasterization_state.depthClampEnable
    obj.RasterizationState.RasterizerDiscardEnable = rasterization_state.rasterizerDiscardEnable
    obj.RasterizationState.PolygonMode = rasterization_state.polygonMode
    obj.RasterizationState.CullMode = rasterization_state.cullMode
    obj.RasterizationState.FrontFace = rasterization_state.frontFace
    obj.RasterizationState.DepthBiasEnable = rasterization_state.depthBiasEnable
    obj.RasterizationState.DepthBiasConstantFactor = rasterization_state.depthBiasConstantFactor
    obj.RasterizationState.DepthBiasClamp = rasterization_state.depthBiasClamp
    obj.RasterizationState.DepthBiasSlopeFactor = rasterization_state.depthBiasSlopeFactor
    obj.RasterizationState.LineWidth = rasterization_state.lineWidth

    // handle rasterization state pNext
    if rasterization_state.pNext != null {
      numPNext := numberOfPNext(rasterization_state.pNext)
      next := MutableVoidPtr(as!void*(rasterization_state.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: {
            ext := as!VkPipelineRasterizationLineStateCreateInfoEXT*(next.Ptr)[0]
            obj.RasterizationState.PipelineRasterizationLineStateCreateInfoEXT = new!PipelineRasterizationLineStateCreateInfoEXT(
              LineRasterizationMode: ext.lineRasterizationMode,
              StippledLineEnable: ext.stippledLineEnable,
              LineStippleFactor: ext.lineStippleFactor,
              LineStipplePattern: ext.lineStipplePattern,
            )
          }
          case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {
            ext := as!VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*(next.Ptr)[0]
            obj.RasterizationState.PipelineRasterizationProvokingVertexStateCreateInfoEXT = new!PipelineRasterizationProvokingVertexStateCreateInfoEXT(
              ProvokingVertexMode: ext.provokingVertexMode
            )
          }
          case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {
            ext := as!VkPipelineRasterizationStateStreamCreateInfoEXT*(next.Ptr)[0]
            obj.RasterizationState.PipelineRasterizationStateStreamCreateInfoEXT = new!PipelineRasterizationStateStreamCreateInfoEXT(
              Flags: ext.flags,
              RasterizationStream: ext.rasterizationStream,
            )
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }

    if (create_info.pMultisampleState != null) {
      multisample_state := create_info.pMultisampleState[0]
      multisample_data := new!MultisampleData(
        RasterizationSamples:   multisample_state.rasterizationSamples,
        SampleShadingEnable:    multisample_state.sampleShadingEnable,
        MinSampleShading:       multisample_state.minSampleShading,
        AlphaToCoverageEnable:  multisample_state.alphaToCoverageEnable,
        AlphaToOneEnable:       multisample_state.alphaToOneEnable
      )
      // handle multisample state pNext
      if multisample_state.pNext != null {
        numPNext := numberOfPNext(multisample_state.pNext)
        next := MutableVoidPtr(as!void*(multisample_state.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
      if (multisample_state.pSampleMask != null) {
        num_samples := as!u32(multisample_state.rasterizationSamples)
        sizeof_samplemask := (num_samples + 31) / 32
        sample_masks := multisample_state.pSampleMask[0:sizeof_samplemask]
        for k in (0 .. sizeof_samplemask) {
          multisample_data.SampleMask[k] = sample_masks[k]
        }
      }
      obj.MultisampleState = multisample_data
    }

    if (create_info.pDepthStencilState != null) {
      depth_stencil_state := create_info.pDepthStencilState[0]
      // handle depth stencil state pNext
      if depth_stencil_state.pNext != null {
        numPNext := numberOfPNext(depth_stencil_state.pNext)
        next := MutableVoidPtr(as!void*(depth_stencil_state.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
      obj.DepthState = new!DepthData(
        DepthTestEnable:        depth_stencil_state.depthTestEnable,
        DepthWriteEnable:       depth_stencil_state.depthWriteEnable,
        DepthCompareOp:         depth_stencil_state.depthCompareOp,
        DepthBoundsTestEnable:  depth_stencil_state.depthBoundsTestEnable,
        StencilTestEnable:      depth_stencil_state.stencilTestEnable,
        Front:                  depth_stencil_state.front,
        Back:                   depth_stencil_state.back,
        MinDepthBounds:         depth_stencil_state.minDepthBounds,
        MaxDepthBounds:         depth_stencil_state.maxDepthBounds)
    }
    if (create_info.pColorBlendState != null) {
      color_blend_state := create_info.pColorBlendState[0]
      color_blend_data := new!ColorBlendData(
        LogicOpEnable:   color_blend_state.logicOpEnable,
        LogicOp:         color_blend_state.logicOp,
        BlendConstants:  color_blend_state.blendConstants
      )
      // handle color blend state pNext
      if color_blend_state.pNext != null {
        numPNext := numberOfPNext(color_blend_state.pNext)
        next := MutableVoidPtr(as!void*(color_blend_state.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch (sType) {
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: {
              ext := as!VkPipelineColorBlendAdvancedStateCreateInfoEXT*(next.Ptr)[0]
              color_blend_data.AdvancedState = new!PipelineColorBlendAdvancedStateCreateInfoEXT(
                SrcPremultiplied: ext.srcPremultiplied,
                DstPremultiplied: ext.dstPremultiplied,
                BlendOverlap: ext.blendOverlap,
              )
            }
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
        }
      }
      attachments := color_blend_state.pAttachments[0:
      color_blend_state.attachmentCount]
      for k in (0 .. color_blend_state.attachmentCount) {
        color_blend_data.Attachments[k] = attachments[k]
      }
      obj.ColorBlendState = color_blend_data
    }

    obj.RenderPass = RenderPasses[create_info.renderPass]
    obj.Subpass = create_info.subpass
    if ((as!u32(create_info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      obj.BasePipelineIndex = create_info.basePipelineIndex
      obj.BasePipeline = create_info.basePipelineHandle
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }

    createdPipelines.Objects[i] = obj
  }

  fence

  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    createdPipelines.Objects[i].VulkanHandle = pipeline
    if ((createdPipelines.Objects[i].BasePipelineIndex != -1) &&
      ((as!u32(createdPipelines.Objects[i].Flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != as!u32(0))) {
      createdPipelines.Objects[i].BasePipeline = pipelines[createdPipelines.Objects[i].BasePipelineIndex]
    }
    GraphicsPipelines[pipeline] = createdPipelines.Objects[i]

    create_info := infos[i]
    // handle pNext
    if create_info.pNext != null {
      numPNext := numberOfPNext(create_info.pNext)
      next := MutableVoidPtr(as!void*(create_info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch(sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            pcfcie := as!const VkPipelineCreationFeedbackCreateInfoEXT*(next.Ptr)[0]
            write(pcfcie.pPipelineCreationFeedback[0:1])
            write(pcfcie.pPipelineStageCreationFeedbacks[0:pcfcie.pipelineStageCreationFeedbackCount])
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }

  return ?
}

@internal
class CreatedComputePipelines {
  map!(u32, ref!ComputePipelineObject) Objects
}

@indirect("VkDevice")
@threadsafe
cmd VkResult vkCreateComputePipelines(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    u32                                createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    AllocationCallbacks                pAllocator,
    VkPipeline*                        pPipelines) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipelineCache != as!VkPipelineCache(0) {
    if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  }
  created_pipelines := CreatedComputePipelines()
  infos := pCreateInfos[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    info := infos[i]
    // handle pNext
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch(sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            pcfcie := as!const VkPipelineCreationFeedbackCreateInfoEXT*(next.Ptr)
            read(pcfcie[0:1])
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
    obj := new!ComputePipelineObject(
      PipelineCache:   PipelineCaches[pipelineCache],
      Device:          device,
      Flags:           info.flags,
      PipelineLayout:  PipelineLayouts[info.layout]
    )
    stage_create_info := infos[i].stage
    // handle pNext
    if stage_create_info.pNext != null {
      numPNext := numberOfPNext(stage_create_info.pNext)
      next := MutableVoidPtr(as!void*(stage_create_info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }

    stage_data := StageData(
      Stage:       stage_create_info.stage,
      Module:      ShaderModules[stage_create_info.module],
      EntryPoint:  as!string(stage_create_info.pName),
    )
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      spec_data := new!SpecializationInfo()
      spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
      for k in (0 .. spec_info.mapEntryCount) {
        spec_data.Specializations[k] = spec_map[k]
      }
      spec_data.Data = clone(as!u8*(spec_info.pData)[0:spec_info.dataSize])
      stage_data.Specialization = spec_data
    }
    obj.Stage = stage_data
    if ((as!u32(info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      obj.BasePipelineIndex = info.basePipelineIndex
      obj.BasePipeline = info.basePipelineHandle
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    if stage_data.Module.Descriptors != null {
      moduleDescriptors := stage_data.Module.Descriptors.Descriptors[as!string(stage_create_info.pName)]
      for _, _, d in moduleDescriptors {
        obj.UsedDescriptors[len(obj.UsedDescriptors)] = d
      }
    } else {
      nSets := len(obj.PipelineLayout.SetLayouts)
      for ii in (0 .. nSets) {
        set := obj.PipelineLayout.SetLayouts[as!u32(ii)]
        for _, k, v in set.Bindings {
          obj.UsedDescriptors[len(obj.UsedDescriptors)] =
            DescriptorUsage(Set: as!u32(ii),
              Binding: k,
              DescriptorCount: v.Count)
        }
      }
    }
    created_pipelines.Objects[i] = obj
  }

  fence

  pipelines := pPipelines[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    created_pipelines.Objects[i].VulkanHandle = pipeline
    if (created_pipelines.Objects[i].BasePipelineIndex != -1) {
      created_pipelines.Objects[i].BasePipeline = pipelines[created_pipelines.Objects[i].BasePipelineIndex]
    }
    ComputePipelines[pipeline] = created_pipelines.Objects[i]

    create_info := infos[i]
    // handle pNext
    if create_info.pNext != null {
      numPNext := numberOfPNext(create_info.pNext)
      next := MutableVoidPtr(as!void*(create_info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch(sType) {
          case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: {
            pcfcie := as!const VkPipelineCreationFeedbackCreateInfoEXT*(next.Ptr)[0]
            write(pcfcie.pPipelineCreationFeedback[0:1])
            write(pcfcie.pPipelineStageCreationFeedbacks[0:pcfcie.pipelineStageCreationFeedbackCount])
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipeline(
    VkDevice                     device,
    VkPipeline                   pipeline,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pipeline in GraphicsPipelines {
    delete(GraphicsPipelines, pipeline)
  }
  if pipeline in ComputePipelines {
    delete(ComputePipelines, pipeline)
  }
}

////////////////////
// Shader modules //
////////////////////

@internal class DescriptorUsage {
  u32 Set
  u32 Binding
  u32 DescriptorCount
}

@internal class DescriptorInfo {
  map!(string, map!(u32, DescriptorUsage)) Descriptors
}

@resource
@internal class ShaderModuleObject {
  @unused VkDevice                  Device
  @unused u32[]                     Words
  @unused VkShaderModule            VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @unused ref!DescriptorInfo        Descriptors
}

@indirect("VkDevice")
@threadsafe
cmd VkResult vkCreateShaderModule(
    VkDevice                        device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    AllocationCallbacks             pAllocator,
    VkShaderModule*                 pShaderModule) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkShaderModuleCreateInfo") }
  create_info := pCreateInfo[0]
  // handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  num_words := as!u64(create_info.codeSize) / 4
  object := new!ShaderModuleObject(device, clone(create_info.pCode[0:num_words]))
  object.Descriptors = fetchUsedDescriptors(object)

  handle := ?
  if pShaderModule == null { vkErrorNullPointer("VkShaderModule") }
  pShaderModule[0] = handle
  object.VulkanHandle = handle
  ShaderModules[handle] = object

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyShaderModule(
    VkDevice                     device,
    VkShaderModule               shaderModule,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(ShaderModules, shaderModule)
}

////////////////////
// Pipeline cache //
////////////////////

@internal class PipelineCacheObject {
  @unused VkDevice                  Device
  @unused VkPipelineCache           VulkanHandle
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  @hidden @nobox @internal u8[]     Data
}

@indirect("VkDevice")
cmd VkResult vkCreatePipelineCache(
    VkDevice                         device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    AllocationCallbacks              pAllocator,
    VkPipelineCache*                 pPipelineCache) {
  //TODO(awoloszyn): Add Allocator support
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkPipelineCacheCreateInfo") }
  create_info := pCreateInfo[0]
  // handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  read(as!u8*(create_info.pInitialData)[0:create_info.initialDataSize])
  handle := ?
  if pPipelineCache == null { vkErrorNullPointer("VkPipelineCache") }
  pPipelineCache[0] = handle
  PipelineCaches[handle] = new!PipelineCacheObject(device, handle)
  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipelineCache(
    VkDevice                     device,
    VkPipelineCache              pipelineCache,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(PipelineCaches, pipelineCache)
}

@indirect("VkDevice")
cmd VkResult vkGetPipelineCacheData(
    VkDevice        device,
    VkPipelineCache pipelineCache,
    size*           pDataSize,
    void*           pData) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(pipelineCache in PipelineCaches) { vkErrorInvalidPipelineCache(pipelineCache) }
  if pDataSize == null { vkErrorNullPointer("size_t") }
  _ = pDataSize[0]

  writeDataSize := ?
  pDataSize[0] = writeDataSize
  if pData != null {
    write(as!u8*(pData)[0:writeDataSize])
  }
  return ?
}

@indirect("VkDevice")
cmd VkResult vkMergePipelineCaches(
    VkDevice               device,
    VkPipelineCache        dstCache,
    u32                    srcCacheCount,
    const VkPipelineCache* pSrcCaches) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(dstCache in PipelineCaches) { vkErrorInvalidPipelineCache(dstCache) }
  srcCaches := pSrcCaches[0:srcCacheCount]
  for i in (0 .. srcCacheCount) {
    if !(srcCaches[i] in PipelineCaches) { vkErrorInvalidPipelineCache(srcCaches[i]) }
    _ = srcCaches[i]
  }
  return ?
}

/////////////////////////////
// Command buffer commands //
/////////////////////////////

@internal class vkCmdBindPipelineArgs {
  VkPipelineBindPoint PipelineBindPoint
  VkPipeline          Pipeline
}

sub void dovkCmdBindPipeline(ref!vkCmdBindPipelineArgs args) {
  if args.PipelineBindPoint == VK_PIPELINE_BIND_POINT_COMPUTE {
    lci := lastComputeInfo()
    lci.ComputePipeline = ComputePipelines[args.Pipeline]
  } else {
    ldi := lastDrawInfo()
    ldi.GraphicsPipeline = GraphicsPipelines[args.Pipeline]
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdBindPipeline(
    VkCommandBuffer     commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline          pipeline) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdBindPipeline))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdBindPipeline[mapPos] =
  new!vkCmdBindPipelineArgs(
    PipelineBindPoint: pipelineBindPoint,
    Pipeline:          pipeline)

  AddCommand(commandBuffer, cmd_vkCmdBindPipeline, mapPos)
}

@internal class vkCmdSetViewportArgs {
  u32                   FirstViewport
  map!(u32, VkViewport) Viewports
}

sub void dovkCmdSetViewport(ref!vkCmdSetViewportArgs args) {
      viewportCount := len(args.Viewports)
      dyn := lastDynamicPipelineState()
      for i in (0 .. viewportCount) {
        dyn.Viewports[args.FirstViewport + as!u32(i)] = args.Viewports[as!u32(i)]
      }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetViewport(
    VkCommandBuffer   commandBuffer,
    u32               firstViewport,
    u32               viewportCount,
    const VkViewport* pViewports) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pViewports == null { vkErrorNullPointer("VkViewport") }
  viewports := pViewports[0:viewportCount]
  args := new!vkCmdSetViewportArgs(
    firstViewport
  )
  for i in (0 .. viewportCount) {
    args.Viewports[i] = viewports[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetViewport))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetViewport[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetViewport, mapPos)
}

@internal class vkCmdSetScissorArgs {
  u32                 FirstScissor
  map!(u32, VkRect2D) Scissors
}

sub void dovkCmdSetScissor(ref!vkCmdSetScissorArgs args) {
      scissorCount := len(args.Scissors)
      dyn := lastDynamicPipelineState()
      for i in (0 .. scissorCount) {
        dyn.Scissors[args.FirstScissor + as!u32(i)] = args.Scissors[as!u32(i)]
      }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    u32             firstScissor,
    u32             scissorCount,
    const VkRect2D* pScissors) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  if pScissors == null { vkErrorNullPointer("VkRect2D") }
  scissors := pScissors[0:scissorCount]
  args := new!vkCmdSetScissorArgs(
    firstScissor
  )
  for i in (0 .. scissorCount) {
    args.Scissors[i] = scissors[i]
  }

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetScissor))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetScissor[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetScissor, mapPos)
}

@internal class vkCmdSetLineWidthArgs {
  f32 LineWidth
}

sub void dovkCmdSetLineWidth(ref!vkCmdSetLineWidthArgs args) {
  ldps := lastDynamicPipelineState()
  ldps.LineWidth = args.LineWidth
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    f32             lineWidth) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetLineWidthArgs(lineWidth)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetLineWidth))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetLineWidth[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetLineWidth, mapPos)
}

@internal class vkCmdSetDepthBiasArgs {
  f32 DepthBiasConstantFactor
  f32 DepthBiasClamp
  f32 DepthBiasSlopeFactor
}

sub void dovkCmdSetDepthBias(ref!vkCmdSetDepthBiasArgs args) {
  dyn := lastDynamicPipelineState()
  dyn.DepthBiasConstantFactor = args.DepthBiasConstantFactor
  dyn.DepthBiasClamp = args.DepthBiasClamp
  dyn.DepthBiasSlopeFactor = args.DepthBiasSlopeFactor
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    f32             depthBiasConstantFactor,
    f32             depthBiasClamp,
    f32             depthBiasSlopeFactor) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetDepthBiasArgs(
    depthBiasConstantFactor,
    depthBiasClamp,
    depthBiasSlopeFactor
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBias))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBias[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetDepthBias, mapPos)
}

@internal class vkCmdSetBlendConstantsArgs {
  f32 R
  f32 G
  f32 B
  f32 A
}

sub void dovkCmdSetBlendConstants(ref!vkCmdSetBlendConstantsArgs args) {
  dyn := lastDynamicPipelineState()
  dyn.BlendConstants[0] = args.R
  dyn.BlendConstants[1] = args.G
  dyn.BlendConstants[2] = args.B
  dyn.BlendConstants[3] = args.A
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetBlendConstants(
              VkCommandBuffer commandBuffer,
    @readonly f32[4]          blendConstants) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetBlendConstantsArgs(
    blendConstants[0],
    blendConstants[1],
    blendConstants[2],
    blendConstants[3])

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetBlendConstants))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetBlendConstants[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetBlendConstants, mapPos)
}

@internal class vkCmdSetDepthBoundsArgs {
  f32 MinDepthBounds
  f32 MaxDepthBounds
}

sub void dovkCmdSetDepthBounds(ref!vkCmdSetDepthBoundsArgs args) {
  dyn := lastDynamicPipelineState()
  dyn.MinDepthBounds = args.MinDepthBounds
  dyn.MaxDepthBounds = args.MaxDepthBounds
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    f32             minDepthBounds,
    f32             maxDepthBounds) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetDepthBoundsArgs(
    minDepthBounds,
    maxDepthBounds)

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBounds))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetDepthBounds[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetDepthBounds, mapPos)
}

@internal class vkCmdSetStencilCompareMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                CompareMask
}

sub void dovkCmdSetStencilCompareMask(ref!vkCmdSetStencilCompareMaskArgs args) {
  dyn := lastDynamicPipelineState()
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_FRONT_BIT)) != as!u32(0) {
    dyn.StencilFront.compareMask = args.CompareMask
  }
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_BACK_BIT)) != as!u32(0) {
    dyn.StencilBack.compareMask = args.CompareMask
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetStencilCompareMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                compareMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilCompareMaskArgs(
    faceMask,
    compareMask
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilCompareMask))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilCompareMask[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilCompareMask, mapPos)
}

@internal class vkCmdSetStencilWriteMaskArgs {
  VkStencilFaceFlags FaceMask
  u32                WriteMask
}

sub void dovkCmdSetStencilWriteMask(ref!vkCmdSetStencilWriteMaskArgs args) {
  dyn := lastDynamicPipelineState()
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_FRONT_BIT)) != as!u32(0) {
    dyn.StencilFront.writeMask = args.WriteMask
  }
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_BACK_BIT)) != as!u32(0) {
    dyn.StencilBack.writeMask = args.WriteMask
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetStencilWriteMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                writeMask) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilWriteMaskArgs(
    faceMask,
    writeMask
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilWriteMask))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilWriteMask[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilWriteMask, mapPos)
}

@internal class vkCmdSetStencilReferenceArgs {
  VkStencilFaceFlags FaceMask
  u32                Reference
}

sub void dovkCmdSetStencilReference(ref!vkCmdSetStencilReferenceArgs args) {
  dyn := lastDynamicPipelineState()
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_FRONT_BIT)) != as!u32(0) {
    dyn.StencilFront.reference = args.Reference
  }
  if (as!u32(args.FaceMask) & as!u32(VK_STENCIL_FACE_BACK_BIT)) != as!u32(0) {
    dyn.StencilBack.reference = args.Reference
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@threadsafe
cmd void vkCmdSetStencilReference(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                reference) {
  if !(commandBuffer in CommandBuffers) { vkErrorInvalidCommandBuffer(commandBuffer) }
  args := new!vkCmdSetStencilReferenceArgs(
    faceMask,
    reference
  )

  mapPos := as!u32(len(CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilReference))
  CommandBuffers[commandBuffer].BufferCommands.vkCmdSetStencilReference[mapPos] =
  args

  AddCommand(commandBuffer, cmd_vkCmdSetStencilReference, mapPos)
}

@internal class MutablePipelineLayout {
  ref!PipelineLayoutObject Val
}

sub ref!PipelineLayoutObject boundPipelineLayout(VkPipelineBindPoint bindPoint) {
  layout := MutablePipelineLayout(null)
  switch bindPoint {
    case VK_PIPELINE_BIND_POINT_COMPUTE:
      layout.Val = lastComputeInfo().ComputePipeline.PipelineLayout
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
      layout.Val = lastDrawInfo().GraphicsPipeline.Layout
    default: {}
  }
  return layout.Val
}
