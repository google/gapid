// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

/////////////////
// Framebuffer //
/////////////////

@internal class FramebufferObject {
  @unused VkDevice                  Device
  @unused VkFramebuffer             VulkanHandle
  @unused ref!RenderPassObject      RenderPass
  map!(u32, ref!ImageViewObject)    ImageAttachments
  @unused u32                       Width
  @unused u32                       Height
  @unused u32                       Layers
  @unused ref!VulkanDebugMarkerInfo DebugInfo
}

@spy_disabled
sub void registerFramebufferUser(ref!ImageViewObject view, VkFramebuffer vkFb, u32 attachment) {
  if !(vkFb in view.FramebufferUsers) {
    f := view.FramebufferUsers[vkFb]
    view.FramebufferUsers[vkFb] = f
  }
  view.FramebufferUsers[vkFb][attachment] = true
}

@indirect("VkDevice")
cmd VkResult vkCreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    AllocationCallbacks            pAllocator,
    VkFramebuffer*                 pFramebuffer) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkFramebufferCreateInfo") }
  create_info := pCreateInfo[0]
  if !(create_info.renderPass in RenderPasses) { vkErrorInvalidRenderPass(create_info.renderPass) }
  // handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }
  attachments := create_info.pAttachments[0:create_info.attachmentCount]

  framebufferObject := new!FramebufferObject(Device: device,
    Width:                    create_info.width,
    Height:                   create_info.height,
    Layers:                   create_info.layers,
    RenderPass:               RenderPasses[create_info.renderPass])
  for i in (0 .. create_info.attachmentCount) {
    if !(attachments[i] in ImageViews) { vkErrorInvalidImageView(attachments[i]) }
    framebufferObject.ImageAttachments[i] = ImageViews[attachments[i]]
  }

  handle := ?
  if pFramebuffer == null { vkErrorNullPointer("VkFramebuffer") }
  pFramebuffer[0] = handle
  framebufferObject.VulkanHandle = handle
  Framebuffers[handle] = framebufferObject

  for _, i, viewObj in framebufferObject.ImageAttachments {
    if viewObj != null {
      registerFramebufferUser(viewObj, handle, i)
    }
  }

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyFramebuffer(
    VkDevice                     device,
    VkFramebuffer                framebuffer,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(Framebuffers, framebuffer)
}

////////////////
// RenderPass //
////////////////

@internal enum RenderPassVersion : u32 {
  RenderPass = 0,
  RenderPass2 = 1,
  RenderPass2KHR = 2,
}

/*
This extension is already in the Vulkan core.
Thefore there is no need to repeat the KHR structs
*/

@internal class AttachmentDescriptionStencilLayout {
    VkImageLayout StencilInitialLayout
    VkImageLayout StencilFinalLayout
}

@internal class AttachmentDescription {
    VkAttachmentDescriptionFlags           Flags
    VkFormat                               Format
    VkSampleCountFlagBits                  Samples
    VkAttachmentLoadOp                     LoadOp
    VkAttachmentStoreOp                    StoreOp
    VkAttachmentLoadOp                     StencilLoadOp
    VkAttachmentStoreOp                    StencilStoreOp
    VkImageLayout                          InitialLayout
    VkImageLayout                          FinalLayout
    ref!AttachmentDescriptionStencilLayout StencilLayout
}

@internal class AttachmentReferenceStencilLayout {
    VkImageLayout StencilLayout
}

@internal class AttachmentReference {
    u32                                   Attachment
    VkImageLayout                         Layout
    VkImageAspectFlags                    AspectMask
    ref!AttachmentReferenceStencilLayout  StencilLayout
}

@internal class SubpassDescription {
  VkSubpassDescriptionFlags         Flags
  u32                               ViewMask
  VkPipelineBindPoint               PipelineBindPoint
  map!(u32, AttachmentReference)    InputAttachments
  map!(u32, AttachmentReference)    ColorAttachments
  map!(u32, AttachmentReference)    ResolveAttachments
  ref!AttachmentReference           DepthStencilAttachment
  map!(u32, u32)                    PreserveAttachments
}

@internal class SubpassDependency {
    u32                     SrcSubpass
    u32                     DstSubpass
    VkPipelineStageFlags    SrcStageMask
    VkPipelineStageFlags    DstStageMask
    VkAccessFlags           SrcAccessMask
    VkAccessFlags           DstAccessMask
    VkDependencyFlags       DependencyFlags
    s32                     ViewOffset
}

@internal class RenderPassObject {
  @unused VkDevice                           Device
  @unused VkRenderPass                       VulkanHandle
  @unused map!(u32, AttachmentDescription)   AttachmentDescriptions
  @unused map!(u32, SubpassDescription)      SubpassDescriptions
  @unused map!(u32, SubpassDependency)       SubpassDependencies
  @unused map!(u32, u32)                     CorrelatedViewMasks

  @unused ref!VulkanDebugMarkerInfo          DebugInfo

  // internal
  @unused RenderPassVersion                  Version
}

sub AttachmentReference convertAttachment(VkAttachmentReference attachment) {
  return AttachmentReference(
    Attachment: attachment.attachment,
    Layout: attachment.layout,
    AspectMask: 0, // This will be updated by VkRenderPassInputAttachmentAspectCreateInfo
    StencilLayout: null,
  )
}

sub ref!RenderPassObject createRenderPassObjectFromInfo(
    const VkRenderPassCreateInfo* pCreateInfo,
    VkDevice device) {
  info := pCreateInfo[0]
  renderPass := new!RenderPassObject()
  renderPass.Device = device

  attachments := info.pAttachments[0:info.attachmentCount]
  for i in (0 .. info.attachmentCount) {
    attachment := attachments[i]
    renderPass.AttachmentDescriptions[i] = AttachmentDescription(
      Flags: attachment.flags,
      Format: attachment.format,
      Samples: attachment.samples,
      LoadOp: attachment.loadOp,
      StoreOp: attachment.storeOp,
      StencilLoadOp: attachment.stencilLoadOp,
      StencilStoreOp: attachment.stencilStoreOp,
      InitialLayout: attachment.initialLayout,
      FinalLayout: attachment.finalLayout,
      StencilLayout: null,
    )
  }

  subpasses := info.pSubpasses[0:info.subpassCount]
  read(subpasses)
  for i in (0 .. info.subpassCount) {
    subpass := subpasses[i]
    description := SubpassDescription(
      Flags: subpass.flags,
      ViewMask: 0, // This will be updated by KHR_multiview extension.
      PipelineBindPoint: subpass.pipelineBindPoint,
    )

    inputAttachments := subpass.pInputAttachments[0:subpass.inputAttachmentCount]
    for j in (0 .. subpass.inputAttachmentCount) {
      description.InputAttachments[j] = convertAttachment(inputAttachments[j])
    }
    colorAttachments := subpass.pColorAttachments[0:subpass.colorAttachmentCount]
    for j in (0 .. subpass.colorAttachmentCount) {
      description.ColorAttachments[j] = convertAttachment(colorAttachments[j])
    }

    if subpass.pResolveAttachments != null {
      resolveAttachments := subpass.pResolveAttachments[0:subpass.colorAttachmentCount]
      for j in (0 .. subpass.colorAttachmentCount) {
        description.ResolveAttachments[j] = convertAttachment(resolveAttachments[j])
      }
    }

    if (subpass.pDepthStencilAttachment != null) {
      attachment := subpass.pDepthStencilAttachment[0]
      // Cannot call convert
      description.DepthStencilAttachment = new!AttachmentReference(
        Attachment: attachment.attachment,
        Layout: attachment.layout,
        AspectMask: 0, // This will be updated by VkRenderPassInputAttachmentAspectCreateInfo
        StencilLayout: null,
      )
    }

    preserveAttachments := subpass.pPreserveAttachments[0:subpass.preserveAttachmentCount]
    for j in (0 .. subpass.preserveAttachmentCount) {
      description.PreserveAttachments[j] = preserveAttachments[j]
    }

    renderPass.SubpassDescriptions[i] = description
  }

  dependencies := info.pDependencies[0:info.dependencyCount]
  for i in (0 .. info.dependencyCount) {
    dependency := dependencies[i]
    renderPass.SubpassDependencies[i] = SubpassDependency(
      SrcSubpass: dependency.srcSubpass,
      DstSubpass: dependency.dstSubpass,
      SrcStageMask: dependency.srcStageMask,
      DstStageMask: dependency.dstStageMask,
      SrcAccessMask: dependency.srcAccessMask,
      DstAccessMask: dependency.dstAccessMask,
      DependencyFlags: dependency.dependencyFlags,
      ViewOffset: 0, // This will be updated by KHR_multiview extension.
    )
  }

  // CorrelatedViewMasks will be updated by KHR_multiview extension.

  // handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {
          ext := as!VkRenderPassInputAttachmentAspectCreateInfo*(next.Ptr)[0]

          aspectReferences := ext.pAspectReferences[0:ext.aspectReferenceCount]
          for j in (0 .. ext.aspectReferenceCount) {
            // The input attachment aspect info is only cached but not used for now, so the
            // dependency can be wrong as a draw call may depends on just one aspect of a
            // depth stencil image, as specified in the input attachment aspect info, while
            // GAPID will still treat both aspects as dependees.
            // TODO: Once the CL that enables us getting used descriptors from shader is in,
            // we can pull input_attachment_index from the information of the used descriptors
            // then use the input attachment aspect info to fix the dependency.
            aspectReference := aspectReferences[j]
            subPassIndex := aspectReference.subpass
            attachmentIndex := aspectReference.inputAttachmentIndex

            attachment := renderPass.SubpassDescriptions[subPassIndex].InputAttachments[attachmentIndex]
            attachment.AspectMask = aspectReference.aspectMask
            renderPass.SubpassDescriptions[subPassIndex].InputAttachments[attachmentIndex] = attachment
          }
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {
          ext := as!VkRenderPassMultiviewCreateInfo*(next.Ptr)[0]

          if ext.pViewMasks != null {
            viewMasks := ext.pViewMasks[0:ext.subpassCount]
            for j in (0 .. ext.subpassCount) {
              desc := renderPass.SubpassDescriptions[j]
              desc.ViewMask = viewMasks[j]
              renderPass.SubpassDescriptions[j] = desc
            }
          }

          if ext.pViewOffsets != null {
            viewOffsets := ext.pViewOffsets[0:ext.dependencyCount]
            for j in (0 .. ext.dependencyCount) {
              dependency := renderPass.SubpassDependencies[j]
              dependency.ViewOffset = viewOffsets[j]
              renderPass.SubpassDependencies[j] = dependency
            }
          }

          if ext.pCorrelationMasks != null {
            correlationMasks := ext.pCorrelationMasks[0:ext.correlationMaskCount]
            for j in (0 .. ext.correlationMaskCount) {
              renderPass.CorrelatedViewMasks[j] = correlationMasks[j]
            }
          }
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  return renderPass
}

sub ref!RenderPassObject createRenderPassObjectFromInfo2(
    const VkRenderPassCreateInfo2* pCreateInfo,
    VkDevice device) {
  info := pCreateInfo[0]
  renderPass := new!RenderPassObject()
  renderPass.Device = device

  attachments := info.pAttachments[0:info.attachmentCount]
  for i in (0 .. info.attachmentCount) {
    attachment := attachments[i]
    renderPass.AttachmentDescriptions[i] = AttachmentDescription(
      Flags: attachment.flags,
      Format: attachment.format,
      Samples: attachment.samples,
      LoadOp: attachment.loadOp,
      StoreOp: attachment.storeOp,
      StencilLoadOp: attachment.stencilLoadOp,
      StencilStoreOp: attachment.stencilStoreOp,
      InitialLayout: attachment.initialLayout,
      FinalLayout: attachment.finalLayout,
      StencilLayout: null,
    )
    if attachment.pNext != null {
      numPNext := numberOfPNext(attachment.pNext)
      next := MutableVoidPtr(as!void*(attachment.pNext))
      for j in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch sType {
          case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {
            ext := as!VkAttachmentDescriptionStencilLayout*(next.Ptr)[0]
            renderPass.AttachmentDescriptions[j].StencilLayout = new!AttachmentDescriptionStencilLayout(
              StencilInitialLayout: ext.stencilInitialLayout,
              StencilFinalLayout: ext.stencilFinalLayout,
            )
          }
        }
      }
    }
  }

  subpasses := info.pSubpasses[0:info.subpassCount]
  read(subpasses)
  for i in (0 .. info.subpassCount) {
    subpass := subpasses[i]
    description := SubpassDescription(
      Flags: subpass.flags,
      ViewMask: subpass.viewMask,
      PipelineBindPoint: subpass.pipelineBindPoint,
    )

    inputAttachments := subpass.pInputAttachments[0:subpass.inputAttachmentCount]
    for j in (0 .. subpass.inputAttachmentCount) {
      attachment := inputAttachments[j]
      description.InputAttachments[j] = AttachmentReference(
        Attachment: attachment.attachment,
        Layout: attachment.layout,
        AspectMask: attachment.aspectMask,
        StencilLayout: null,
      )
    }

    colorAttachments := subpass.pColorAttachments[0:subpass.colorAttachmentCount]
    for j in (0 .. subpass.colorAttachmentCount) {
      attachment := colorAttachments[j]
      description.ColorAttachments[j] = AttachmentReference(
        Attachment: attachment.attachment,
        Layout: attachment.layout,
        AspectMask: attachment.aspectMask,
        StencilLayout: null,
      )
    }

    if subpass.pResolveAttachments != null {
      resolveAttachments := subpass.pResolveAttachments[0:subpass.colorAttachmentCount]
      for j in (0 .. subpass.colorAttachmentCount) {
        attachment := resolveAttachments[j]
        description.ResolveAttachments[j] = AttachmentReference(
          Attachment: attachment.attachment,
          Layout: attachment.layout,
          AspectMask: attachment.aspectMask,
          StencilLayout: null,
        )
      }
    }

    if (subpass.pDepthStencilAttachment != null) {
      attachment := subpass.pDepthStencilAttachment[0]
      description.DepthStencilAttachment = new!AttachmentReference(
        Attachment: attachment.attachment,
        Layout: attachment.layout,
        AspectMask: attachment.aspectMask,
        StencilLayout: null,
      )
      if attachment.pNext != null {
        numPNext := numberOfPNext(attachment.pNext)
        next := MutableVoidPtr(as!void*(attachment.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0]
          switch sType {
            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {
              ext := as!VkAttachmentReferenceStencilLayout*(next.Ptr)[0]
              description.DepthStencilAttachment.StencilLayout = new!AttachmentReferenceStencilLayout(
                StencilLayout: ext.stencilLayout
              )
            }
          }
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }

    preserveAttachments := subpass.pPreserveAttachments[0:subpass.preserveAttachmentCount]
    for j in (0 .. subpass.preserveAttachmentCount) {
      description.PreserveAttachments[j] = preserveAttachments[j]
    }

    renderPass.SubpassDescriptions[i] = description
  }

  dependencies := info.pDependencies[0:info.dependencyCount]
  for i in (0 .. info.dependencyCount) {
    dependency := dependencies[i]
    renderPass.SubpassDependencies[i] = SubpassDependency(
      SrcSubpass: dependency.srcSubpass,
      DstSubpass: dependency.dstSubpass,
      SrcStageMask: dependency.srcStageMask,
      DstStageMask: dependency.dstStageMask,
      SrcAccessMask: dependency.srcAccessMask,
      DstAccessMask: dependency.dstAccessMask,
      DependencyFlags: dependency.dependencyFlags,
      ViewOffset: dependency.viewOffset,
    )
  }

  if info.pCorrelatedViewMasks != null {
    pCorrelatedViewMasks := info.pCorrelatedViewMasks[0:info.correlatedViewMaskCount]
    for i in (0 .. info.correlatedViewMaskCount) {
      renderPass.CorrelatedViewMasks[i] = pCorrelatedViewMasks[i]
    }
  }

  // This looks like it doesn't do anything but in reality
  // it generates a switch statement with a default case that
  // returns error.
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  return renderPass
}

sub void recordNewRenderPass(ref!RenderPassObject renderPass,  VkRenderPass handle) {
  renderPass.VulkanHandle = handle
  RenderPasses[handle] = renderPass
}

@indirect("VkDevice")
cmd VkResult vkCreateRenderPass(
    VkDevice                      device,
    const VkRenderPassCreateInfo* pCreateInfo,
    AllocationCallbacks           pAllocator,
    VkRenderPass*                 pRenderPass) {
    if !(device in Devices) { vkErrorInvalidDevice(device) }
    if pCreateInfo == null { vkErrorNullPointer("VkRenderPassCreateInfo") }
    if pRenderPass == null { vkErrorNullPointer("VkRenderPass") }

    renderPass := createRenderPassObjectFromInfo(pCreateInfo, device)
    renderPass.Version = RenderPass

    handle := ?
    pRenderPass[0] = handle
    recordNewRenderPass(renderPass, handle)
    return ?
}

@indirect("VkDevice")
cmd VkResult vkCreateRenderPass2(
    VkDevice                                    device,
    const VkRenderPassCreateInfo2*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass) {
    if !(device in Devices) { vkErrorInvalidDevice(device) }
    if pCreateInfo == null { vkErrorNullPointer("VkRenderPassCreateInfo") }
    if pRenderPass == null { vkErrorNullPointer("VkRenderPass") }

    renderPass := createRenderPassObjectFromInfo2(pCreateInfo, device)
    renderPass.Version = RenderPass2

    handle := ?
    pRenderPass[0] = handle
    recordNewRenderPass(renderPass, handle)
    return ?
}

@indirect("VkDevice")
cmd void vkDestroyRenderPass(
    VkDevice                     device,
    VkRenderPass                 renderPass,
    AllocationCallbacks          pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  delete(RenderPasses, renderPass)
}

@indirect("VkDevice")
cmd void vkGetRenderAreaGranularity(
    VkDevice     device,
    VkRenderPass renderPass,
    VkExtent2D*  pGranularity) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(renderPass in RenderPasses) { vkErrorInvalidRenderPass(renderPass) }
  write(pGranularity[0:1])
}

/////////////////////////////
// Command buffer commands //
/////////////////////////////

@internal class DeviceGroupBeginInfo {
  u32    DeviceMask,
  map!(u32, VkRect2D) RenderAreas
}

@internal class RenderPassBeginInfo {
  VkRenderPass            RenderPass
  VkFramebuffer           Framebuffer
  VkRect2D                RenderArea
  map!(u32, VkClearValue) ClearValues

  // @extension("VK_KHR_device_group_creation")
  ref!DeviceGroupBeginInfo DeviceGroupBeginInfo
}

@internal class
vkCmdBeginRenderPassXArgs {
  ref!RenderPassBeginInfo RenderPassBeginInfo
  ref!SubpassBeginInfo    SubpassBeginInfo

  // internal
  RenderPassVersion Version
}

sub void dovkCmdBeginRenderPassX(ref!vkCmdBeginRenderPassXArgs args) {
  renderPassBeginInfo := args.RenderPassBeginInfo

  ldi := lastDrawInfo()
  ldi.Framebuffer = Framebuffers[renderPassBeginInfo.Framebuffer]
  ldi.LastSubpass = 0
  ldi.RenderPass = RenderPasses[renderPassBeginInfo.RenderPass]
  ldi.InRenderPass = true
  attachments := ldi.Framebuffer.ImageAttachments
  n := len(attachments)
  for i in (0 .. n) {
    loadImageAttachment(as!u32(i))
  }
  transitionSubpassAttachmentLayouts(ldi.LastSubpass)
}

@internal
class MutableAspect {
  VkImageAspectFlags aspect
}

sub void recordSubpassBegin(ref!CommandBufferObject cb, u32 subpass) {
  cb.CurrentRecordingSubpass = subpass
  rp := cb.CurrentRecordingRenderpass
  for _, _, v in rp.SubpassDescriptions[subpass].InputAttachments {
    if v.Attachment != VK_ATTACHMENT_UNUSED {
      l := v.Layout
      aspect := MutableAspect(as!VkImageAspectFlags(0))
      aspect.aspect = v.AspectMask
      view := cb.CurrentRecordingFramebuffer.ImageAttachments[v.Attachment]
      rng := view.SubresourceRange
      if aspect.aspect != as!VkImageAspectFlags(0) {
        rng.aspectMask = aspect.aspect
      }
      RecordLayoutTransition(cb, view.Image, rng, l)
    }
  }
}

sub ref!RenderPassBeginInfo createRenderPassBeginInfo(const VkRenderPassBeginInfo* pRenderPassBegin) {
  info := pRenderPassBegin[0]
  if !(info.renderPass in RenderPasses) { vkErrorInvalidRenderPass(info.renderPass) }
  if !(info.framebuffer in Framebuffers) { vkErrorInvalidFramebuffer(info.framebuffer) }

  beginInfo := new!RenderPassBeginInfo(
    RenderPass: info.renderPass,
    Framebuffer: info.framebuffer,
    RenderArea: info.renderArea,
  )

  clearValues := info.pClearValues[0:info.clearValueCount]
  for i in (0 .. info.clearValueCount) {
    beginInfo.ClearValues[i] = clearValues[i]
  }

  // handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {
          ext := as!VkDeviceGroupRenderPassBeginInfo*(next.Ptr)[0]
          beginInfo.DeviceGroupBeginInfo = new!DeviceGroupBeginInfo(
            DeviceMask: ext.deviceMask,
          )
          rects := ext.pDeviceRenderAreas[0:ext.deviceRenderAreaCount]
          for j in (0 .. ext.deviceRenderAreaCount) {
            beginInfo.DeviceGroupBeginInfo.RenderAreas[j] = rects[j]
          }
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  return beginInfo
}

sub ref!SubpassBeginInfo createSubpassBeginInfoFromContents(VkSubpassContents contents) {
  return new!SubpassBeginInfo(
    Contents: contents,
  )
}

sub ref!SubpassBeginInfo createSubpassBeginInfoFromInfo(const VkSubpassBeginInfo* pSubpassBeginInfo) {
  info := pSubpassBeginInfo[0]

  // This looks like it doesn't do anything but in reality
  // it generates a switch statement with a default case that
  // returns error.
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0]
      switch (sType) {
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
    }
  }

  return new!SubpassBeginInfo(
    Contents: info.contents,
  )
}

sub ref!SubpassEndInfo createSubpassEndInfo(const VkSubpassEndInfo* pSubpassEndInfo) {
  if pSubpassEndInfo != null {
    info := pSubpassEndInfo[0]

    // This looks like it doesn't do anything but in reality
    // it generates a switch statement with a default case that
    // returns error.
    if info.pNext != null {
      numPNext := numberOfPNext(info.pNext)
      next := MutableVoidPtr(as!void*(info.pNext))
      for i in (0 .. numPNext) {
        sType := as!const VkStructureType*(next.Ptr)[0]
        switch (sType) {
        }
        next.Ptr = as!VulkanStructHeader*(next.Ptr)[0].PNext
      }
    }
  }
  return new!SubpassEndInfo()
}

sub void recordBeginRenderPass(ref!CommandBufferObject commandBuffer, ref!RenderPassBeginInfo beginInfo) {
  commandBuffer.CurrentRecordingRenderpass = RenderPasses[beginInfo.RenderPass]
  commandBuffer.CurrentRecordingFramebuffer = Framebuffers[beginInfo.Framebuffer]
  commandBuffer.PreviouslyStartedRenderpass = RenderPasses[beginInfo.RenderPass]
  commandBuffer.PreviousFramebuffer = Framebuffers[beginInfo.Framebuffer]
  recordSubpassBegin(commandBuffer, 0)
}

@indirect("VkCommandBuffer", "VkDevice")
@begin_end_renderpass
cmd void vkCmdBeginRenderPass(
    VkCommandBuffer              commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents            contents) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    if pRenderPassBegin == null { vkErrorNullPointer("VkRenderPassBeginInfo") }
    renderPassBeginInfo := createRenderPassBeginInfo(pRenderPassBegin)
    subpassBeginInfo := createSubpassBeginInfoFromContents(contents)

    args := new!vkCmdBeginRenderPassXArgs(
      RenderPassBeginInfo: renderPassBeginInfo,
      SubpassBeginInfo: subpassBeginInfo,
      Version: RenderPass,
    )

    cb := CommandBuffers[commandBuffer]
    recordBeginRenderPass(cb, renderPassBeginInfo)

    mapPos := as!u32(len(cb.BufferCommands.vkCmdBeginRenderPass))
    cb.BufferCommands.vkCmdBeginRenderPass[mapPos] = args
    AddCommand(commandBuffer, cmd_vkCmdBeginRenderPass, mapPos)
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@begin_end_renderpass
cmd void vkCmdBeginRenderPass2(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    if pRenderPassBegin == null { vkErrorNullPointer("VkRenderPassBeginInfo2") }
    renderPassBeginInfo := createRenderPassBeginInfo(pRenderPassBegin)
    subpassBeginInfo := createSubpassBeginInfoFromInfo(pSubpassBeginInfo)

    args := new!vkCmdBeginRenderPassXArgs(
      RenderPassBeginInfo: renderPassBeginInfo,
      SubpassBeginInfo: subpassBeginInfo,
      Version: RenderPass2,
    )

    cb := CommandBuffers[commandBuffer]
    recordBeginRenderPass(cb, renderPassBeginInfo)

    mapPos := as!u32(len(cb.BufferCommands.vkCmdBeginRenderPass2))
    cb.BufferCommands.vkCmdBeginRenderPass2[mapPos] = args
    AddCommand(commandBuffer, cmd_vkCmdBeginRenderPass2, mapPos)
  }
}

@internal class SubpassBeginInfo {
    VkSubpassContents   Contents
}

@internal class SubpassEndInfo {
    // Intentionally left blank
}

@internal class
vkCmdNextSubpassXArgs {
  ref!SubpassBeginInfo              SubpassBeginInfo
  ref!SubpassEndInfo                SubpassEndInfo

  // internal
  RenderPassVersion Version
}

sub void transitionSubpassAttachmentLayouts(u32 subpass) {
  ldi := lastDrawInfo()
  if subpass < len(ldi.RenderPass.SubpassDescriptions) {
    subpassDesc := ldi.RenderPass.SubpassDescriptions[subpass]
    for _, _, a in subpassDesc.InputAttachments {
      attachment := ldi.Framebuffer.ImageAttachments[a.Attachment]
      transitionImageViewLayout(attachment, VK_IMAGE_LAYOUT_UNDEFINED, a.Layout)
    }
    for _ , _ , a in subpassDesc.ColorAttachments {
      attachment := ldi.Framebuffer.ImageAttachments[a.Attachment]
      transitionImageViewLayout(attachment, VK_IMAGE_LAYOUT_UNDEFINED, a.Layout)
    }
    for _ , _ , a in subpassDesc.ResolveAttachments {
      attachment := ldi.Framebuffer.ImageAttachments[a.Attachment]
      transitionImageViewLayout(attachment, VK_IMAGE_LAYOUT_UNDEFINED, a.Layout)
    }
    if subpassDesc.DepthStencilAttachment != null {
      dsRef := subpassDesc.DepthStencilAttachment
      attachment := ldi.Framebuffer.ImageAttachments[dsRef.Attachment]
      transitionImageViewLayout(attachment, VK_IMAGE_LAYOUT_UNDEFINED, dsRef.Layout)
    }
  }
}

sub void dovkCmdNextSubpassX(ref!vkCmdNextSubpassXArgs Unused) {
  useRenderPass()
  ldi := lastDrawInfo()
  ldi.LastSubpass += 1
  transitionSubpassAttachmentLayouts(ldi.LastSubpass)
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdNextSubpass(
    VkCommandBuffer   commandBuffer,
    VkSubpassContents contents) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    cmdBuf := CommandBuffers[commandBuffer]
    recordSubpassBegin(cmdBuf, cmdBuf.CurrentRecordingSubpass + 1)

    subpassBeginInfo := createSubpassBeginInfoFromContents(contents)
    subpassEndInfo := createSubpassEndInfo(null)
    args := new!vkCmdNextSubpassXArgs(
      SubpassBeginInfo: subpassBeginInfo,
      SubpassEndInfo: subpassEndInfo,
      Version: RenderPass,
    )

    mapPos := as!u32(len(cmdBuf.BufferCommands.vkCmdNextSubpass))
    cmdBuf.BufferCommands.vkCmdNextSubpass[mapPos] = args

    AddCommand(commandBuffer, cmd_vkCmdNextSubpass, mapPos)
  }
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdNextSubpass2(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo,
    const VkSubpassEndInfo*                     pSubpassEndInfo) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    cmdBuf := CommandBuffers[commandBuffer]
    recordSubpassBegin(cmdBuf, cmdBuf.CurrentRecordingSubpass + 1)

    subpassBeginInfo := createSubpassBeginInfoFromInfo(pSubpassBeginInfo)
    subpassEndInfo := createSubpassEndInfo(pSubpassEndInfo)
    args := new!vkCmdNextSubpassXArgs(
      SubpassBeginInfo: subpassBeginInfo,
      SubpassEndInfo: subpassEndInfo,
      Version: RenderPass2,
    )

    mapPos := as!u32(len(cmdBuf.BufferCommands.vkCmdNextSubpass2))
    cmdBuf.BufferCommands.vkCmdNextSubpass2[mapPos] = args

    AddCommand(commandBuffer, cmd_vkCmdNextSubpass2, mapPos)
  }
}

@internal class
vkCmdEndRenderPassXArgs {
  ref!SubpassEndInfo SubpassEndInfo
  // internal
  RenderPassVersion Version
}

sub void dovkCmdEndRenderPassX(ref!vkCmdEndRenderPassXArgs unused) {
  ldi := lastDrawInfo()
  attachmentDescriptions := ldi.RenderPass.AttachmentDescriptions
  n := len(attachmentDescriptions)
  for i in (0 .. n) {
    storeImageAttachment(as!u32(i))
  }
  _ = ldi.InRenderPass
  ldi.InRenderPass = false
}

sub void recordEndRenderpass(ref!CommandBufferObject commandBuffer) {
  if (commandBuffer.CurrentRecordingRenderpass == null) {
      vkErrorInvalidRenderPass(as!VkRenderPass(0))
    } else if (commandBuffer.CurrentRecordingFramebuffer == null) {
      vkErrorInvalidFramebuffer(as!VkFramebuffer(0))
    } else {
      rpo := commandBuffer.CurrentRecordingRenderpass
      for _, i, at in rpo.AttachmentDescriptions {
        if (i < len(commandBuffer.CurrentRecordingFramebuffer.ImageAttachments)) {
          view := commandBuffer.CurrentRecordingFramebuffer.ImageAttachments[i]
          rng := view.SubresourceRange
          RecordLayoutTransition(commandBuffer, view.Image, rng, at.FinalLayout)
        }
      }
    }

    commandBuffer.CurrentRecordingRenderpass = null
    commandBuffer.CurrentRecordingFramebuffer = null
    commandBuffer.CurrentRecordingSubpass = 0
}

@indirect("VkCommandBuffer", "VkDevice")
@begin_end_renderpass
cmd void vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
    cmdBuf := CommandBuffers[commandBuffer]
    recordEndRenderpass(cmdBuf)

    subpassEndInfo := createSubpassEndInfo(null)
    args := new!vkCmdEndRenderPassXArgs(
      SubpassEndInfo: subpassEndInfo,
      Version: RenderPass,
    )

    mapPos := as!u32(len(cmdBuf.BufferCommands.vkCmdEndRenderPass))
    cmdBuf.BufferCommands.vkCmdEndRenderPass[mapPos] = args

    AddCommand(commandBuffer, cmd_vkCmdEndRenderPass, mapPos)
  }
}

@indirect("VkCommandBuffer", "VkDevice")
@begin_end_renderpass
cmd void vkCmdEndRenderPass2(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassEndInfo*                     pSubpassEndInfo) {
  if !(commandBuffer in CommandBuffers) {
    vkErrorInvalidCommandBuffer(commandBuffer)
  } else {
      cmdBuf := CommandBuffers[commandBuffer]
      recordEndRenderpass(cmdBuf)

      subpassEndInfo := createSubpassEndInfo(pSubpassEndInfo)
      args := new!vkCmdEndRenderPassXArgs(
        SubpassEndInfo: subpassEndInfo,
        Version: RenderPass2,
      )

      mapPos := as!u32(len(cmdBuf.BufferCommands.vkCmdEndRenderPass2))
      cmdBuf.BufferCommands.vkCmdEndRenderPass2[mapPos] = args

      AddCommand(commandBuffer, cmd_vkCmdEndRenderPass2, mapPos)
  }
}

sub void loadImageAttachment(u32 attachmentID) {
  if attachmentID != VK_ATTACHMENT_UNUSED {
    ldi := lastDrawInfo()
    attachment := ldi.Framebuffer.ImageAttachments[attachmentID]
    desc := ldi.RenderPass.AttachmentDescriptions[attachmentID]
    if attachment.Image != null {
      switch desc.LoadOp {
        case VK_ATTACHMENT_LOAD_OP_LOAD: {
          readCoherentMemoryInImage(attachment.Image)
          readImageView(attachment)
          updateImageViewQueue(attachment)
        }
        default: {
          // write to the attachment image, to prevent any dependencies on previous writes
          updateImageViewQueue(attachment)
          writeImageView(attachment)
        }
      }
    }
  }
}

sub void storeImageAttachment(u32 attachmentID) {
  if attachmentID != VK_ATTACHMENT_UNUSED {
    ldi := lastDrawInfo()
    attachment := ldi.Framebuffer.ImageAttachments[attachmentID]
    desc := ldi.RenderPass.AttachmentDescriptions[attachmentID]
    if attachment.Image != null {
      if desc.InitialLayout != desc.FinalLayout {
        transitionImageViewLayout(attachment, VK_IMAGE_LAYOUT_UNDEFINED, desc.FinalLayout)
      }
      switch desc.StoreOp {
        case VK_ATTACHMENT_STORE_OP_STORE: {
          writeImageView(attachment)
          updateImageViewQueue(attachment)
        }
        default: {
          // do nothing
        }
      }
    }
  }
}

@spy_disabled
sub void useRenderPass() {
  // read and write InRenderPass to ensure dependencies between render pass commands
  _ = lastDrawInfo().InRenderPass
  ldi := lastDrawInfo()
  ldi.InRenderPass = true
}
