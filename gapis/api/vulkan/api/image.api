// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

///////////
// Image //
///////////

@internal class ImageInfo {
  VkImageCreateFlags                             Flags
  VkImageType                                    ImageType
  VkFormat                                       Format
  VkExtent3D                                     Extent
  u32                                            MipLevels
  u32                                            ArrayLayers
  VkSampleCountFlagBits                          Samples
  VkImageTiling                                  Tiling
  VkImageUsageFlags                              Usage
  VkSharingMode                                  SharingMode
  map!(u32, u32)                                 QueueFamilyIndices
  VkImageLayout                                  InitialLayout
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
  ref!ImageFormatList                            ViewFormatList
}

@resource
@internal class ImageObject {
  @unused VkDevice                                              Device

  // mapping from plane bits (0 for non-disjoint or single planar images) to memory information
  map!(VkImageAspectFlagBits, ref!ImagePlaneMemoryInfo)         PlaneMemoryInfo

  // mapping from the resource offsets to the sparse bindings in the unit of sparse blocks
  map!(u64, VkSparseMemoryBind)                                 OpaqueSparseMemoryBindings

  // mapping from image aspect flag bits to sparse binding info
  map!(VkImageAspectFlagBits, ref!SparseBoundImageAspectInfo)   SparseImageMemoryBindings
  @unused bool                                                  IsSwapchainImage
  VkImage                                                       VulkanHandle
  ImageInfo                                                     Info
  VkImageAspectFlags                                            ImageAspect
  map!(VkImageAspectFlagBits, ref!ImageAspect)                  Aspects
  @unused ref!VulkanDebugMarkerInfo                             DebugInfo
  map!(VkImageAspectFlagBits, VkSparseImageMemoryRequirements)  SparseMemoryRequirements

  // Vulkan 1.1 promoted from extension: VK_KHR_dedicated_allocation
  ref!DedicatedRequirements                                     DedicatedRequirements

  // If ever layer/level is set to the same queue, then set it here instead.
  // This can save expensive looping through Aspects/Layers/Levels
  @untracked @unused ref!QueueObject                            LastBoundQueue
  map!(VkImageView, ref!ImageViewObject)                        Views
}

@internal class MutableImageDeviceGroupBinding {
  ref!ImageDeviceGroupBinding Binding
}

@internal class ImageDeviceGroupBinding {
  map!(u32, u32)                     Bindings
  map!(u32, VkRect2D)                SplitInstanceBindings
}

@internal class ImagePlaneMemoryInfo {
  ref!DeviceMemoryObject  BoundMemory
  VkDeviceSize            BoundMemoryOffset
  VkMemoryRequirements    MemoryRequirements
  ref!ImageDeviceGroupBinding  ImageDeviceGroupBinding
}

@internal class ImageAspect {
  dense_map!(u32, ref!ImageLayer) Layers
}

@internal class ImageLayer {
  dense_map!(u32, ref!ImageLevel) Levels
}

@internal class ImageLevel {
  u32         Width
  u32         Height
  @unused u32 Depth
  @spy_disabled
  @hidden @nobox @internal u8[]      Data
  VkImageLayout                      Layout
  ref!VkSubresourceLayout            LinearLayout
  @untracked @unused ref!QueueObject LastBoundQueue
}

@internal class SparseBoundImageAspectInfo {
  map!(u32, ref!SparseBoundImageLayerInfo) Layers
}

@internal class SparseBoundImageLayerInfo {
  map!(u32, ref!SparseBoundImageLevelInfo) Levels
}

@internal class SparseBoundImageLevelInfo {
  // mapping from memory offset to sparse block info
  map!(u64, ref!SparseBoundImageBlockInfo) Blocks
}

@internal class SparseBoundImageBlockInfo {
  VkOffset3D              Offset
  VkExtent3D              Extent
  VkDeviceMemory          Memory
  VkDeviceSize            MemoryOffset
  VkDeviceSize            Size
  VkSparseMemoryBindFlags Flags
}

@internal class FetchedImageMemoryRequirements {
  map!(VkImageAspectFlagBits, VkMemoryRequirements)             PlaneBitsToMemoryRequirements
  map!(VkImageAspectFlagBits, VkSparseImageMemoryRequirements)  AspectBitsToSparseMemoryRequirements
}

@internal class LinearImageLayouts {
  map!(u32, ref!LinearImageAspectLayouts) AspectLayouts
}

@internal class LinearImageAspectLayouts {
  map!(u32, ref!LinearImageLayerLayouts) LayerLayouts
}

@internal class LinearImageLayerLayouts {
  map!(u32, ref!VkSubresourceLayout) LevelLayouts
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateImage(
    VkDevice                 device,
    const VkImageCreateInfo* pCreateInfo,
    AllocationCallbacks      pAllocator,
    VkImage*                 pImage) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkImageCreateInfo") }
  info := pCreateInfo[0]

  imageInfo := ImageInfo(
    Flags:          info.flags,
    ImageType:      info.imageType,
    Format:         info.format,
    Extent:         info.extent,
    MipLevels:      info.mipLevels,
    ArrayLayers:    info.arrayLayers,
    Samples:        info.samples,
    Tiling:         info.tiling,
    Usage:          info.usage,
    SharingMode:    info.sharingMode,
    InitialLayout:  info.initialLayout,
  )

  if (info.sharingMode == VK_SHARING_MODE_CONCURRENT) {
    queueFamilyIndices := info.pQueueFamilyIndices[0:info.queueFamilyIndexCount]
    for i in (0 .. info.queueFamilyIndexCount) {
      imageInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
    }
  }

  imageAspect := as!VkImageAspectFlags(getAspectBitsFromImageFormat(info.format))

  hasSparseBit := (as!u32(info.flags) & as!u32(VK_IMAGE_CREATE_SPARSE_BINDING_BIT)) != 0

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
          imageInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
            DedicatedAllocation: ext.dedicatedAllocation
          )
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: {
           ext := as!VkImageFormatListCreateInfoKHR*(next.Ptr)[0]
           ifl := new!ImageFormatList()
           if (ext.viewFormatCount > 0) {
            formats := ext.pViewFormats[0:ext.viewFormatCount]
            for j in (0 .. ext.viewFormatCount) {
              ifl.viewFormats[j] = formats[j]
            }
           }
           imageInfo.ViewFormatList = ifl
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  handle := ?
  if pImage == null { vkErrorNullPointer("VkImage") }
  pImage[0] = handle
  object := new!ImageObject(
    Device:            device,
    IsSwapchainImage:  false,
    VulkanHandle:      handle,
    Info:              imageInfo,
    ImageAspect:       imageAspect,
  )

  for _ , _ , aspectBit in unpackImageAspectFlags(object, imageAspect) {
    divisor := getAspectSizeDivisor(info.format, aspectBit)
    object.Aspects[aspectBit] = new!ImageAspect()
    aspect := object.Aspects[aspectBit]
    for j in (0 .. info.arrayLayers) {
      aspect.Layers[j] = new!ImageLayer()
      for i in (0 .. info.mipLevels) {
        width := getMipSize(info.extent.width, i) / divisor.Width
        height := getMipSize(info.extent.height, i) / divisor.Height
        depth := getMipSize(info.extent.depth, i)
        level := new!ImageLevel(
          Width: width,
          Height:  height,
          Depth:  depth,
          Layout:  info.initialLayout)
        aspect.Layers[j].Levels[i] = level
      }
    }
  }

  fetchedRequirements := fetchImageMemoryRequirements(device, object, hasSparseBit)
  // If the vkCreateImage is inserted by GAPID (e.g. the staging image for
  // reading framebuffer), NO memory requirements will be returned.
  if fetchedRequirements != null {
    for _, p, _ in fetchedRequirements.PlaneBitsToMemoryRequirements {
      if !(p in object.PlaneMemoryInfo) {
        object.PlaneMemoryInfo[p] = new!ImagePlaneMemoryInfo()
      }
      object.PlaneMemoryInfo[p].MemoryRequirements = fetchedRequirements.PlaneBitsToMemoryRequirements[p]
    }
    for _, a, _ in fetchedRequirements.AspectBitsToSparseMemoryRequirements {
      object.SparseMemoryRequirements[a] = fetchedRequirements.AspectBitsToSparseMemoryRequirements[a]
    }
  }

  // If the image tiling is LINEAR, get the VkSubresourceLayout for each linear image level
  if (info.tiling == VK_IMAGE_TILING_LINEAR) {
    linearLayouts := fetchLinearImageSubresourceLayouts(device, object,
      VkImageSubresourceRange(
        aspectMask:      imageAspect,
        baseMipLevel:    0,
        levelCount:      imageInfo.MipLevels,
        baseArrayLayer:  0,
        layerCount:      imageInfo.ArrayLayers,
      ))
    if (linearLayouts != null) {
      for _ , aspectBit , al in linearLayouts.AspectLayouts {
        for _ , layer , layl in al.LayerLayouts {
          for _ , level , levl in layl.LevelLayouts {
            if levl != null {
              object.Aspects[as!VkImageAspectFlagBits(aspectBit)].Layers[layer].Levels[level].LinearLayout = levl
            }
          }
        }
      }
    }
  }

  Images[handle] = object

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImage(
    VkDevice            device,
    VkImage             image,
    AllocationCallbacks pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) } else {
    if (image != as!VkImage(0)) {
      imageObject := Images[image]
      for _, _, m in imageObject.PlaneMemoryInfo {
        if m.BoundMemory != null {
          // If the memory is deleted first, then do not try to remove ourselves.
          delete(m.BoundMemory.BoundObjects, as!u64(image))
        }
      }
      delete(Images, image)
      for _ , _ , v in imageObject.Views {
        v.Image = null
      }
      for i in (0 .. LastPresentInfo.PresentImageCount) {
        if (LastPresentInfo.PresentImages[i] != null) {
          if (LastPresentInfo.PresentImages[i].VulkanHandle == image) {
            LastPresentInfo.PresentImages[i] = null
          }
        }
      }
    }
  }
}

@indirect("VkDevice")
cmd void vkGetImageSubresourceLayout(
    VkDevice                  device,
    VkImage                   image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout*      pLayout) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if !(image in Images) { vkErrorInvalidImage(image) }
  _ = pSubresource[0]

  pLayout[0] = ?
}

sub void BindImageMemory(
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset,
    VkImageAspectFlagBits plane,
    ref!ImageDeviceGroupBinding deviceGroupBinding) {
  if !(memory in DeviceMemories) {
    vkErrorInvalidDeviceMemory(memory)
  } else {
    if !(image in Images) {
      vkErrorInvalidImage(image)
    } else {
      imageObject := Images[image]
      if !(plane in imageObject.PlaneMemoryInfo) {
        imageObject.PlaneMemoryInfo[plane] = new!ImagePlaneMemoryInfo()
      }
      imageObject.PlaneMemoryInfo[plane].BoundMemory = DeviceMemories[memory]
      imageObject.PlaneMemoryInfo[plane].BoundMemoryOffset = memoryOffset
      imageObject.PlaneMemoryInfo[plane].ImageDeviceGroupBinding = deviceGroupBinding
      DeviceMemories[memory].BoundObjects[as!u64(image)] = memoryOffset

      for _ , _ , aspectBit in unpackImageAspectFlags(imageObject, imageObject.ImageAspect) {
        aspect := imageObject.Aspects[aspectBit]
        for j in (0 .. imageObject.Info.ArrayLayers) {
          for i in (0 .. imageObject.Info.MipLevels) {
            level := aspect.Layers[j].Levels[i]
            elementAndTexelBlockSize := getElementAndTexelBlockSizeForAspect(imageObject.Info.Format, aspectBit)
            // Roundup the width and height in the number of blocks.
            widthInBlocks := roundUpTo(level.Width, elementAndTexelBlockSize.TexelBlockSize.Width)
            heightInBlocks := roundUpTo(level.Height, elementAndTexelBlockSize.TexelBlockSize.Height)
            elementSize := elementAndTexelBlockSize.ElementSize
            tightlyPackedSize := widthInBlocks * heightInBlocks * level.Depth * elementSize

            // If the image has LINEAR tiling and the image level has layout
            // PREINITIALIZED and size larger than our calculated tightly packed
            // size, link the data back to the bound device memory. Otherwise
            // creates its own shadow memory pool.
            // TODO: If the image as a whole requires more memory than we
            // calculated, we should link the data back to the bound device memory
            // no matter whether the tiling is LINEAR or OPTIMAL. But we need to
            // come up with a 'linear layout' in GAPID.
            if (imageObject.Info.Tiling == VK_IMAGE_TILING_LINEAR) &&
                (level.Layout == VK_IMAGE_LAYOUT_PREINITIALIZED) &&
                (level.LinearLayout != null) &&
                (as!u64(level.LinearLayout.size) > as!u64(tightlyPackedSize)) {
              loffset := as!u64(memoryOffset + level.LinearLayout.offset)
              lsize := as!u64(level.LinearLayout.size)
              level.Data = getImagePlaneMemoryInfo(imageObject, plane).BoundMemory.Data[loffset:loffset + lsize]
            } else {
              level.Data = make!u8(tightlyPackedSize)
            }
          }
        }
      }

      if (Images[image].Info.DedicatedAllocationNV != null) && (DeviceMemories[memory].DedicatedAllocationNV == null) {
        vkErrorExpectNVDedicatedlyAllocatedHandle("VkImage", as!u64(image))
      }
      if (Images[image].Info.DedicatedAllocationNV == null) && (DeviceMemories[memory].DedicatedAllocationNV != null) {
        vkErrorExpectNVDedicatedlyAllocatedHandle("VkDeviceMemory", as!u64(memory))
      }
    }
  }
}

@indirect("VkDevice")
cmd VkResult vkBindImageMemory(
    VkDevice       device,
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  // BindImageMemory only handles non-disjoint images, meaning
  // we always use plane-0 for allocation.
  BindImageMemory(image, memory, memoryOffset, as!VkImageAspectFlagBits(0), null)
  return ?
}

////////////////
// Image view //
////////////////

@internal class ImageViewUsageInfo {
  VkImageUsageFlags Usage
}

@internal class ImageViewObject {
  @unused VkDevice                  Device
  @unused VkImageView               VulkanHandle
  @unused VkImageViewType           Type
  @unused VkFormat                  Format
  @unused VkComponentMapping        Components
  @unused VkImageSubresourceRange   SubresourceRange
  ref!ImageObject                   Image
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  // Do not track dependency for the following back-references.
  @hidden @untrackedMap @untracked
  map!(VkDescriptorSet, map!(u32, map!(u32, bool))) DescriptorUsers
  @hidden @untrackedMap @untracked
  map!(VkFramebuffer, map!(u32, bool)) FramebufferUsers
  // Vulkan 1.1 core
  @unused ref!ImageViewUsageInfo UsageInfo
  @unused ref!SamplerYcbcrConversionObject YcbcrConversion
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateImageView(
    VkDevice                     device,
    const VkImageViewCreateInfo* pCreateInfo,
    AllocationCallbacks          pAllocator,
    VkImageView*                 pView) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkImageViewCreateInfo") }
  image_view_create_info := pCreateInfo[0]
  imageViewObject := new!ImageViewObject(
    Device:                 device,
    Type:                   image_view_create_info.viewType,
    Format:                 image_view_create_info.format,
    Components:             image_view_create_info.components,
    SubresourceRange:       image_view_create_info.subresourceRange
  )
  // handle pNext
  if image_view_create_info.pNext != null {
    numPNext := numberOfPNext(image_view_create_info.pNext)
    next := MutableVoidPtr(as!void*(image_view_create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {
          ext := as!VkImageViewUsageCreateInfo*(next.Ptr)[0:1][0]
          imageViewObject.UsageInfo = new!ImageViewUsageInfo(Usage: ext.usage)
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
          ycbcrInfo := as!VkSamplerYcbcrConversionInfo*(next.Ptr)[0]
          conversion := ycbcrInfo.conversion
          if conversion in SamplerYcbcrConversions {
            imageViewObject.YcbcrConversion = SamplerYcbcrConversions[conversion]
          }
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  handle := ?
  if !(image_view_create_info.image in Images) { vkErrorInvalidImage(image_view_create_info.image) } else {
    imageObject := Images[image_view_create_info.image]
    imageViewObject.Image = imageObject

    // Validate the following Valid Usage for VkImageViewCreateInfo:
    //  > If image is non-sparse then it must be bound completely and
    //  > contiguously to a single VkDeviceMemory object.
    // Checking this here also ensures correct dependencies from
    // vkCreateImageView to vkBindImageMemory.
    hasSparseBit := (as!u32(imageObject.Info.Flags) & as!u32(VK_IMAGE_CREATE_SPARSE_BINDING_BIT)) != 0
    // TODO: Handle multi-planar images
    planeMemInfo := getImagePlaneMemoryInfo(imageObject, as!VkImageAspectFlagBits(0))
    if planeMemInfo != null {
      planeBoundMemory := planeMemInfo.BoundMemory
      if (!hasSparseBit) && (planeBoundMemory == null) {
        vkErrorImageMemoryNotBound(image_view_create_info.image)
      }
      if (((0xFFFFFFFF - as!u32(imageObject.ImageAspect)) & as!u32(translateImageAspectFlags(imageObject, image_view_create_info.subresourceRange.aspectMask))) != 0) {
        vkErrorInvalidImageAspect(imageObject.VulkanHandle,
          as!VkImageAspectFlagBits(image_view_create_info.subresourceRange.aspectMask))
      }
      imageObject.Views[handle] = imageViewObject
    }
  }
  if pView == null {
    vkErrorNullPointer("VkImageView")
  } else {
    pView[0] = handle
    imageViewObject.VulkanHandle = handle
    ImageViews[handle] = imageViewObject
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImageView(
    VkDevice            device,
    VkImageView         imageView,
    AllocationCallbacks pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }

  if imageView in ImageViews {
    viewObj := ImageViews[imageView]

    // Release the binding with descriptor sets
    for _, vkDesSet, bindingAndIndices in viewObj.DescriptorUsers {
      if vkDesSet in DescriptorSets {
        desSetObj := DescriptorSets[vkDesSet]
        for _, binding, indices in bindingAndIndices {
          if binding in desSetObj.Bindings {
            switch desSetObj.Bindings[binding].BindingType {
              case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
                  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
                  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
                _ = indices
                for _, index, _ in indices {
                  if index in desSetObj.Bindings[binding].ImageBinding {
                    if desSetObj.Bindings[binding].ImageBinding[index].ImageView == imageView {
                      desSetObj.Bindings[binding].ImageBinding[index].ImageView = as!VkImageView(0)
                    }
                  }
                }
              }
              default: {
                // do nothing
              }
            }
          }
        }
      }
    }

    // Release the binding with framebuffers
    for _, vkFmBuf, attachmentIndices in viewObj.FramebufferUsers {
      if vkFmBuf in Framebuffers {
        fmBufObj := Framebuffers[vkFmBuf]
        if fmBufObj != null {
          for _, index, _ in attachmentIndices {
            if index in fmBufObj.ImageAttachments {
              v := fmBufObj.ImageAttachments[index]
              if (v != null) && (v == viewObj) {
                fmBufObj.ImageAttachments[index] = null
              }
            }
          }
        }
      }
    }

    delete(ImageViews, imageView)
    if ((viewObj.Image != null) && (imageView in viewObj.Image.Views)) {
      delete(viewObj.Image.Views, imageView)
    }
  }
}

/////////////
// Sampler //
/////////////

@internal class SamplerObject {
  @unused VkDevice                  Device
  @unused VkSampler                 VulkanHandle
  @unused VkFilter                  MagFilter
  @unused VkFilter                  MinFilter
  @unused VkSamplerMipmapMode       MipMapMode
  @unused VkSamplerAddressMode      AddressModeU
  @unused VkSamplerAddressMode      AddressModeV
  @unused VkSamplerAddressMode      AddressModeW
  @unused f32                       MipLodBias
  @unused VkBool32                  AnisotropyEnable
  @unused f32                       MaxAnisotropy
  @unused VkBool32                  CompareEnable
  @unused VkCompareOp               CompareOp
  @unused f32                       MinLod
  @unused f32                       MaxLod
  @unused VkBorderColor             BorderColor
  @unsued VkBool32                  UnnormalizedCoordinates
  @unused ref!VulkanDebugMarkerInfo DebugInfo
  // Do not track dependency for the following back-references.
  @hidden @untrackedMap @untracked
  map!(VkDescriptorSet, map!(u32, map!(u32, bool))) DescriptorUsers

  // Vulkan 1.1 core
  @unused ref!SamplerYcbcrConversionObject YcbcrConversion
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSampler(
    VkDevice                   device,
    const VkSamplerCreateInfo* pCreateInfo,
    AllocationCallbacks        pAllocator,
    VkSampler*                 pSampler) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pCreateInfo == null { vkErrorNullPointer("VkSamplerCreateInfo") }
  create_info := pCreateInfo[0]
  sampler := new!SamplerObject(
    Device:                   device,
    MagFilter:                create_info.magFilter,
    MinFilter:                create_info.minFilter,
    MipMapMode:               create_info.mipmapMode,
    AddressModeU:             create_info.addressModeU,
    AddressModeV:             create_info.addressModeV,
    AddressModeW:             create_info.addressModeW,
    MipLodBias:               create_info.mipLodBias,
    AnisotropyEnable:         create_info.anisotropyEnable,
    MaxAnisotropy:            create_info.maxAnisotropy,
    CompareEnable:            create_info.compareEnable,
    CompareOp:                create_info.compareOp,
    MinLod:                   create_info.minLod,
    MaxLod:                   create_info.maxLod,
    BorderColor:              create_info.borderColor,
    UnnormalizedCoordinates:  create_info.unnormalizedCoordinates
  )
  // handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {
          ycbcrInfo := as!VkSamplerYcbcrConversionInfo*(next.Ptr)[0]
          conversion := ycbcrInfo.conversion
          if conversion in SamplerYcbcrConversions {
            sampler.YcbcrConversion = SamplerYcbcrConversions[conversion]
          }
        }
        default: {
          // do nothing
        }
      }
      // TODO: handle extensions for VkSamplerCreateInfo
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
  handle := ?
  if pSampler == null { vkErrorNullPointer("VkSampler") }
  pSampler[0] = handle
  sampler.VulkanHandle = handle
  Samplers[handle] = sampler
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySampler(
    VkDevice            device,
    VkSampler           sampler,
    AllocationCallbacks pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if sampler in Samplers {
    obj := Samplers[sampler]
    if obj != null {
      for _, vkDesSet, bindingAndIndices in obj.DescriptorUsers {
        if vkDesSet in DescriptorSets {
          desSetObj := DescriptorSets[vkDesSet]
          for _, binding, indices in bindingAndIndices {
            if binding in desSetObj.Bindings {
              switch desSetObj.Bindings[binding].BindingType {
                case VK_DESCRIPTOR_TYPE_SAMPLER,
                  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: {
                  for _, index, _ in indices {
                    if desSetObj.Bindings[binding].ImageBinding[index].Sampler == sampler {
                      desSetObj.Bindings[binding].ImageBinding[index].Sampler = as!VkSampler(0)
                    }
                  }
                }
                default: {
                  // do nothing
                }
              }
            }
          }
        }
      }
    }
    delete(Samplers, sampler)
  }
}

sub bool isEntireSubresource(ref!ImageObject image, VkImageSubresourceRange rng) {
  layerCount := imageSubresourceLayerCount(image, rng)
  levelCount := imageSubresourceLevelCount(image, rng)
  return ((as!u32(image.ImageAspect) & as!u32(rng.aspectMask)) == as!u32(image.ImageAspect)) &&
          (rng.baseArrayLayer == 0) && (rng.baseMipLevel == 0) &&
          (layerCount == image.Info.ArrayLayers) && (levelCount == image.Info.MipLevels)
}

sub void updateImageQueue(ref!ImageObject image, VkImageSubresourceRange rng) {
  if (image.LastBoundQueue != LastBoundQueue) {
    if (isEntireSubresource(image, rng)) {
      image.LastBoundQueue = LastBoundQueue
      setQueueInRange(image, rng, LastBoundQueue)
    } else {
      setQueueInRange(image, rng, LastBoundQueue)
      image.LastBoundQueue = null
    }
  }
}

sub void setQueueInRange(ref!ImageObject image, VkImageSubresourceRange rng,
    ref!QueueObject queue) {
  layerCount := imageSubresourceLayerCount(image, rng)
  levelCount := imageSubresourceLevelCount(image, rng)
  for _ , _ , aspectBit in unpackImageAspectFlags(image, rng.aspectMask) {
    if aspectBit in image.Aspects {
      layers := image.Aspects[aspectBit].Layers
      for _, i, layer in  layers {
        if (i >= rng.baseArrayLayer) && (i < rng.baseArrayLayer + layerCount) {
          for _, k, level in layer.Levels {
            if (k >= rng.baseMipLevel) && (k < rng.baseMipLevel + levelCount) {
              level.LastBoundQueue = queue
            }
          }
        }
      }
    }
  }
}

sub u32 imageSubresourceLayerCount(ref!ImageObject image, VkImageSubresourceRange rng) {
  VK_REMAINING_ARRAY_LAYERS := as!u32(0xFFFFFFFF)
  return switch (rng.layerCount == VK_REMAINING_ARRAY_LAYERS) {
    case true:
      image.Info.ArrayLayers - rng.baseArrayLayer
    case false:
      switch ((rng.layerCount + rng.baseArrayLayer) > image.Info.ArrayLayers) {
        case true:
          image.Info.ArrayLayers - rng.baseArrayLayer
        case false:
          rng.layerCount
      }
  }
}

sub u32 imageSubresourceLevelCount(ref!ImageObject image, VkImageSubresourceRange rng) {
  VK_REMAINING_MIP_LEVELS := as!u32(0xFFFFFFFF)
  return switch (rng.levelCount == VK_REMAINING_MIP_LEVELS) {
    case true:
      image.Info.MipLevels - rng.baseMipLevel
    case false:
      switch ((rng.levelCount + rng.baseMipLevel) > image.Info.MipLevels) {
        case true:
          image.Info.MipLevels - rng.baseMipLevel
        case false:
          rng.levelCount
      }
  }
}

sub void transitionImageLayout(ref!ImageObject img, VkImageSubresourceRange rng, VkImageLayout oldLayout, VkImageLayout newLayout) {
  layerCount := imageSubresourceLayerCount(img, rng)
  levelCount := imageSubresourceLevelCount(img, rng)
  for _ , _ , aspectBit in unpackImageAspectFlags(img, rng.aspectMask) {
    if (aspectBit in img.Aspects) {
      aspects := img.Aspects[aspectBit]
      for layer in (rng.baseArrayLayer .. rng.baseArrayLayer + layerCount) {
        if (layer in aspects.Layers) {
          ll := aspects.Layers[layer]
          for level in (rng.baseMipLevel .. rng.baseMipLevel + levelCount) {
            if (level in ll.Levels) {
              imgLevel := ll.Levels[level]
              imgLevel.Layout = newLayout
              imgLevel.LastBoundQueue = LastBoundQueue
            }
          }
        }
      }
    }
  }
}

sub void transitionImageViewLayout(
    ref!ImageViewObject view,
    VkImageLayout oldLayout,
    VkImageLayout newLayout) {
  if view != null {
    if is2DView3DImage(view) {
      rng := VkImageSubresourceRange(
        aspectMask: view.SubresourceRange.aspectMask,
        baseMipLevel: view.SubresourceRange.baseMipLevel,
        levelCount: view.SubresourceRange.levelCount,
        baseArrayLayer: 0,
        layerCount: 1)
      transitionImageLayout(
        view.Image, rng, oldLayout, newLayout)
    } else {
      transitionImageLayout(
        view.Image, view.SubresourceRange, oldLayout, newLayout)
    }
  }
}

// ----------------------------------------------------------------------------
// Vulkan 1.1 Core
// ----------------------------------------------------------------------------

@internal
class MutablePlane {
  VkImageAspectFlagBits aspect
}

///////////
// Image //
///////////
sub void BindImageMemory2(
    VkDevice                     device,
    u32                          bindInfoCount,
    const VkBindImageMemoryInfo* pBindInfos) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if pBindInfos == null {
    vkErrorNullPointer("VkBindImageMemoryInfo(KHR)")
  } else {
    p := MutablePlane(as!VkImageAspectFlagBits(0))
    infos := pBindInfos[0:bindInfoCount]
    for i in (0 .. bindInfoCount) {
      dg := MutableImageDeviceGroupBinding()
      info := infos[i]
      // handle pNext
      if info.pNext != null {
        numPNext := numberOfPNext(info.pNext)
        next := MutableVoidPtr(as!void*(info.pNext))
        for i in (0 .. numPNext) {
          sType := as!const VkStructureType*(next.Ptr)[0:1][0]
          switch sType {
            case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {
              ext := as!VkBindImagePlaneMemoryInfo*(next.Ptr)[0]
              p.aspect = ext.planeAspect
            }
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {
              ext := as!VkBindImageMemoryDeviceGroupInfo*(next.Ptr)[0:1][0]
              dg.Binding = new!ImageDeviceGroupBinding()
              indices := ext.pDeviceIndices[0:ext.deviceIndexCount]
              for j in (0 .. ext.deviceIndexCount) {
                dg.Binding.Bindings[j] = indices[j]
              }
              regions := ext.pSplitInstanceBindRegions[0:ext.splitInstanceBindRegionCount]
              for j in (0 .. ext.splitInstanceBindRegionCount) {
                dg.Binding.SplitInstanceBindings[j] = regions[j]
              }
            }
            default: {}
          }
          next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
        }
      }
      BindImageMemory(info.image, info.memory, info.memoryOffset, p.aspect, dg.Binding)
    }
  }
}

@since("1.1")
@indirect("VkDevice")
cmd VkResult vkBindImageMemory2(
    VkDevice                     device,
    u32                          bindInfoCount,
    @len("bindInfoCount")
    const VkBindImageMemoryInfo* pBindInfos) {
  BindImageMemory2(device, bindInfoCount, pBindInfos)
  return ?
}

/////////////
// Sampler //
/////////////

@internal class SamplerYcbcrConversionObject {
  @unused VkSamplerYcbcrConversion      VulkanHandle
  @unused VkDevice                      Device
  @unused VkFormat                      Format
  @unused VkSamplerYcbcrModelConversion YcbcrModel
  @unused VkSamplerYcbcrRange           YcbcrRange
  @unused VkComponentMapping            Components
  @unused VkChromaLocation              XChromaOffset
  @unused VkChromaLocation              YChromaOffset
  @unused VkFilter                      ChromaFilter
  @unused VkBool32                      ForceExplicitReconstruction
  @unused bool                          IsFromExtension
}

sub void CreateSamplerYcbcrConversion(
  VkDevice                                  device,
  const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
  const VkAllocationCallbacks*              pAllocator,
  VkSamplerYcbcrConversion*                 pYcbcrConversion,
  bool isFromExtension) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  object := new!SamplerYcbcrConversionObject(Device: device)
  if pCreateInfo == null {
    vkErrorNullPointer("VkSamplerYcbcrConversionCreateInfo(KHR)")
  } else {
    createInfo := pCreateInfo[0]
    object.Format = createInfo.format
    object.YcbcrModel = createInfo.ycbcrModel
    object.YcbcrRange = createInfo.ycbcrRange
    object.Components = createInfo.components
    object.XChromaOffset = createInfo.xChromaOffset
    object.YChromaOffset = createInfo.yChromaOffset
    object.ChromaFilter = createInfo.chromaFilter
    object.ForceExplicitReconstruction = createInfo.forceExplicitReconstruction
    object.IsFromExtension = isFromExtension
  }
  fence
  pYcbcrConversion[0] = ?
  handle := pYcbcrConversion[0]
  object.VulkanHandle = handle
  SamplerYcbcrConversions[handle] = object
}

@since("1.1")
@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSamplerYcbcrConversion(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversion*                   pYcbcrConversion) {
  CreateSamplerYcbcrConversion(
      device, pCreateInfo, pAllocator, pYcbcrConversion, false)
  return ?
}

sub void DestroySamplerYcbcrConversion(
    VkDevice                      device,
    VkSamplerYcbcrConversion      ycbcrConversion,
    const VkAllocationCallbacks*  pAllocator) {
  if !(device in Devices) { vkErrorInvalidDevice(device) }
  if ycbcrConversion in SamplerYcbcrConversions {
    delete(SamplerYcbcrConversions, ycbcrConversion)
  }
}

@since("1.1")
@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySamplerYcbcrConversion(
    VkDevice                                    device,
    VkSamplerYcbcrConversion                    ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator) {
  DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)
}

///////////
// Utils //
///////////

sub bool isDisjointImage(ref!ImageObject img) {
  return (as!u32(img.Info.Flags) & as!u32(VK_IMAGE_CREATE_DISJOINT_BIT)) != as!u32(0)
}

sub VkImageAspectFlagBits getAspectBitsFromImageFormat(VkFormat fmt) {
  return switch fmt {
    // Depth only
    case VK_FORMAT_D16_UNORM,
        VK_FORMAT_X8_D24_UNORM_PACK32,
        VK_FORMAT_D32_SFLOAT:
      VK_IMAGE_ASPECT_DEPTH_BIT
    // Stencil only
    case VK_FORMAT_S8_UINT:
      VK_IMAGE_ASPECT_STENCIL_BIT
    // Depth and stencil
    case VK_FORMAT_D16_UNORM_S8_UINT,
        VK_FORMAT_D24_UNORM_S8_UINT,
        VK_FORMAT_D32_SFLOAT_S8_UINT:
      VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT
    // Multi-planar
    case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR,
        VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR,
        VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR,
        VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR,
        VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR,
        VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR,
        VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR,
        VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR,
        VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR,
        VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR,
        VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR,
        VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR:
      VK_IMAGE_ASPECT_PLANE_0_BIT | VK_IMAGE_ASPECT_PLANE_1_BIT | VK_IMAGE_ASPECT_PLANE_2_BIT

    case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR,
        VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR,
        VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR,
        VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR,
        VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR,
        VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR,
        VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR,
        VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR:
      VK_IMAGE_ASPECT_PLANE_0_BIT | VK_IMAGE_ASPECT_PLANE_1_BIT
    // Others
    default:
      VK_IMAGE_ASPECT_COLOR_BIT
  }
}

sub ref!ImagePlaneMemoryInfo getImagePlaneMemoryInfo(ref!ImageObject img, VkImageAspectFlagBits plane) {
  disjoint := isDisjointImage(img)
  return switch disjoint {
    case true:
      img.PlaneMemoryInfo[plane]
    default:
      img.PlaneMemoryInfo[as!VkImageAspectFlagBits(0)]
  }
}
