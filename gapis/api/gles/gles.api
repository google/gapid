// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

api_index 1

import "api/android_extension_pack.api"
import "api/android_native.api"
import "api/asynchronous_queries.api"
import "api/buffer_objects.api"
import "api/constants.api"
import "api/egl.api"
import "api/eglenum.api"
import "api/errors.api"
import "api/debug.api"
import "api/draw_commands.api"
import "api/extensions.api"
import "api/extras.api"
import "api/fragment_operations.api"
import "api/framebuffer.api"
import "api/glbitfield.api"
import "api/gl.api"
import "api/glenum.api"
import "api/other.api"
import "api/image_format.api"
import "api/programs_and_shaders.api"
import "api/rasterization.api"
import "api/state_queries.api"
import "api/synchronization.api"
import "api/textures_and_samplers.api"
import "api/transform_feedback.api"
import "api/util.api"
import "api/vertex_arrays.api"
import "types.api"
import "synthetic.api"
import "gles10.api"
import "../../messages/messages.api"

extern void mapMemory(u8[] slice)
extern void unmapMemory(u8[] slice)

// Flags which are set if the context supports given GLES version
@internal
class Versions {
  bool GLES10 = true
  bool GLES20 = true
  bool GLES30 = true
  bool GLES31 = true
  bool GLES32 = true
}
// TODO: This should be thread local variable
Versions Version

sub void InitVersions(ref!Context ctx) {
  Version = Versions(
    GLES10:  VersionGreaterOrEqual(ctx, 1, 0),
    GLES20:  VersionGreaterOrEqual(ctx, 2, 0),
    GLES30:  VersionGreaterOrEqual(ctx, 3, 0),
    GLES31:  VersionGreaterOrEqual(ctx, 3, 1),
    GLES32:  VersionGreaterOrEqual(ctx, 3, 2),
  )
}

// Flags which are set if the context supports given GLES extension
@internal
class Extensions {
  bool EGL_ANDROID_create_native_client_buffer         = true
  bool EGL_ANDROID_image_native_buffer                 = true
  bool EGL_ANDROID_native_fence_sync                   = true
  bool EGL_KHR_image_base                              = true
  bool EGL_KHR_wait_sync                               = true
  bool GL_AMD_compressed_ATC_texture                   = true
  bool GL_AMD_performance_monitor                      = true
  bool GL_ANGLE_framebuffer_blit                       = true
  bool GL_ANGLE_framebuffer_multisample                = true
  bool GL_ANGLE_instanced_arrays                       = true
  bool GL_ANGLE_translated_shader_source               = true
  bool GL_APPLE_copy_texture_levels                    = true
  bool GL_APPLE_framebuffer_multisample                = true
  bool GL_APPLE_sync                                   = true
  bool GL_EXT_base_instance                            = true
  bool GL_EXT_blend_func_extended                      = true
  bool GL_EXT_buffer_storage                           = true
  bool GL_EXT_clear_texture                            = true
  bool GL_EXT_clip_cull_distance                       = true
  bool GL_EXT_copy_image                               = true
  bool GL_EXT_debug_label                              = true
  bool GL_EXT_debug_marker                             = true
  bool GL_EXT_discard_framebuffer                      = true
  bool GL_EXT_disjoint_timer_query                     = true
  bool GL_EXT_draw_buffers                             = true
  bool GL_EXT_draw_buffers_indexed                     = true
  bool GL_EXT_draw_elements_base_vertex                = true
  bool GL_EXT_draw_instanced                           = true
  bool GL_EXT_draw_transform_feedback                  = true
  bool GL_EXT_geometry_shader                          = true
  bool GL_EXT_instanced_arrays                         = true
  bool GL_EXT_map_buffer_range                         = true
  bool GL_EXT_multi_draw_arrays                        = true
  bool GL_EXT_multi_draw_indirect                      = true
  bool GL_EXT_multisampled_render_to_texture           = true
  bool GL_EXT_multiview_draw_buffers                   = true
  bool GL_EXT_occlusion_query_boolean                  = true
  bool GL_EXT_polygon_offset_clamp                     = true
  bool GL_EXT_primitive_bounding_box                   = true
  bool GL_EXT_raster_multisample                       = true
  bool GL_EXT_robustness                               = true
  bool GL_EXT_sRGB_write_control                       = true
  bool GL_EXT_separate_shader_objects                  = true
  bool GL_EXT_shader_pixel_local_storage2              = true
  bool GL_EXT_shadow_samplers                          = true
  bool GL_EXT_sparse_texture                           = true
  bool GL_EXT_tessellation_shader                      = true
  bool GL_EXT_texture_border_clamp                     = true
  bool GL_EXT_texture_buffer                           = true
  bool GL_EXT_texture_compression_s3tc                 = true
  bool GL_EXT_texture_filter_anisotropic               = true
  bool GL_EXT_texture_filter_minmax                    = true
  bool GL_EXT_texture_format_BGRA8888                  = true
  bool GL_EXT_texture_norm16                           = true
  bool GL_EXT_texture_rg                               = true
  bool GL_EXT_texture_sRGB_decode                      = true
  bool GL_EXT_texture_storage                          = true
  bool GL_EXT_texture_type_2_10_10_10_REV              = true
  bool GL_EXT_texture_view                             = true
  bool GL_EXT_window_rectangles                        = true
  bool GL_IMG_bindless_texture                         = true
  bool GL_IMG_framebuffer_downsample                   = true
  bool GL_IMG_multisampled_render_to_texture           = true
  bool GL_IMG_user_clip_plane                          = true
  bool GL_INTEL_framebuffer_CMAA                       = true
  bool GL_INTEL_performance_query                      = true
  bool GL_KHR_blend_equation_advanced                  = true
  bool GL_KHR_debug                                    = true
  bool GL_KHR_robustness                               = true
  bool GL_NV_bindless_texture                          = true
  bool GL_NV_blend_equation_advanced                   = true
  bool GL_NV_conditional_render                        = true
  bool GL_NV_conservative_raster                       = true
  bool GL_NV_conservative_raster_pre_snap_triangles    = true
  bool GL_NV_copy_buffer                               = true
  bool GL_NV_coverage_sample                           = true
  bool GL_NV_draw_buffers                              = true
  bool GL_NV_draw_instanced                            = true
  bool GL_NV_fence                                     = true
  bool GL_NV_fragment_coverage_to_color                = true
  bool GL_NV_framebuffer_blit                          = true
  bool GL_NV_framebuffer_mixed_samples                 = true
  bool GL_NV_framebuffer_multisample                   = true
  bool GL_NV_gpu_shader5                               = true
  bool GL_NV_instanced_arrays                          = true
  bool GL_NV_internalformat_sample_query               = true
  bool GL_NV_non_square_matrices                       = true
  bool GL_NV_path_rendering                            = true
  bool GL_NV_polygon_mode                              = true
  bool GL_NV_read_buffer                               = true
  bool GL_NV_sample_locations                          = true
  bool GL_NV_viewport_array                            = true
  bool GL_NV_viewport_swizzle                          = true
  bool GL_OES_EGL_image                                = true
  bool GL_OES_EGL_image_external                       = true
  bool GL_OES_blend_equation_separate                  = true
  bool GL_OES_blend_func_separate                      = true
  bool GL_OES_blend_subtract                           = true
  bool GL_OES_compressed_ETC1_RGB8_texture             = true
  bool GL_OES_copy_image                               = true
  bool GL_OES_depth_texture                            = true
  bool GL_OES_draw_buffers_indexed                     = true
  bool GL_OES_draw_elements_base_vertex                = true
  bool GL_OES_draw_texture                             = true
  bool GL_OES_fixed_point                              = true
  bool GL_OES_framebuffer_object                       = true
  bool GL_OES_geometry_shader                          = true
  bool GL_OES_get_program_binary                       = true
  bool GL_OES_mapbuffer                                = true
  bool GL_OES_matrix_palette                           = true
  bool GL_OES_packed_depth_stencil                     = true
  bool GL_OES_point_size_array                         = true
  bool GL_OES_primitive_bounding_box                   = true
  bool GL_OES_query_matrix                             = true
  bool GL_OES_sample_shading                           = true
  bool GL_OES_single_precision                         = true
  bool GL_OES_tessellation_shader                      = true
  bool GL_OES_texture_3D                               = true
  bool GL_OES_texture_border_clamp                     = true
  bool GL_OES_texture_buffer                           = true
  bool GL_OES_texture_cube_map                         = true
  bool GL_OES_texture_float                            = true
  bool GL_OES_texture_half_float                       = true
  bool GL_OES_texture_stencil8                         = true
  bool GL_OES_texture_storage_multisample_2d_array     = true
  bool GL_OES_texture_view                             = true
  bool GL_OES_vertex_array_object                      = true
  bool GL_OES_vertex_half_float                        = true
  bool GL_OES_viewport_array                           = true
  bool GL_OVR_multiview                                = true
  bool GL_OVR_multiview_multisampled_render_to_texture = true
  bool GL_QCOM_alpha_test                              = true
  bool GL_QCOM_driver_control                          = true
  bool GL_QCOM_extended_get                            = true
  bool GL_QCOM_extended_get2                           = true
  bool GL_QCOM_tiled_rendering                         = true
}
// TODO: This should be thread local variable
Extensions Extension

sub void InitExtensions(ref!Context ctx) {
  set := StringSet()
  for _ , _ , ext in ctx.Constants.Extensions {
    set.Strings[ext] = true
  }
  Extension = Extensions(
    EGL_ANDROID_create_native_client_buffer:          set.Strings["EGL_ANDROID_create_native_client_buffer"],
    EGL_ANDROID_image_native_buffer:                  set.Strings["EGL_ANDROID_image_native_buffer"],
    EGL_KHR_image_base:                               set.Strings["EGL_KHR_image_base"],
    GL_AMD_compressed_ATC_texture:                    set.Strings["GL_AMD_compressed_ATC_texture"],
    GL_AMD_performance_monitor:                       set.Strings["GL_AMD_performance_monitor"],
    GL_ANGLE_framebuffer_blit:                        set.Strings["GL_ANGLE_framebuffer_blit"],
    GL_ANGLE_framebuffer_multisample:                 set.Strings["GL_ANGLE_framebuffer_multisample"],
    GL_ANGLE_instanced_arrays:                        set.Strings["GL_ANGLE_instanced_arrays"],
    GL_ANGLE_translated_shader_source:                set.Strings["GL_ANGLE_translated_shader_source"],
    GL_APPLE_copy_texture_levels:                     set.Strings["GL_APPLE_copy_texture_levels"],
    GL_APPLE_framebuffer_multisample:                 set.Strings["GL_APPLE_framebuffer_multisample"],
    GL_APPLE_sync:                                    set.Strings["GL_APPLE_sync"],
    GL_EXT_base_instance:                             set.Strings["GL_EXT_base_instance"],
    GL_EXT_blend_func_extended:                       set.Strings["GL_EXT_blend_func_extended"],
    GL_EXT_buffer_storage:                            set.Strings["GL_EXT_buffer_storage"],
    GL_EXT_clear_texture:                             set.Strings["GL_EXT_clear_texture"],
    GL_EXT_clip_cull_distance:                        set.Strings["GL_EXT_clip_cull_distance"],
    GL_EXT_copy_image:                                set.Strings["GL_EXT_copy_image"],
    GL_EXT_debug_label:                               set.Strings["GL_EXT_debug_label"],
    GL_EXT_debug_marker:                              set.Strings["GL_EXT_debug_marker"],
    GL_EXT_discard_framebuffer:                       set.Strings["GL_EXT_discard_framebuffer"],
    GL_EXT_disjoint_timer_query:                      set.Strings["GL_EXT_disjoint_timer_query"],
    GL_EXT_draw_buffers:                              set.Strings["GL_EXT_draw_buffers"],
    GL_EXT_draw_buffers_indexed:                      set.Strings["GL_EXT_draw_buffers_indexed"],
    GL_EXT_draw_elements_base_vertex:                 set.Strings["GL_EXT_draw_elements_base_vertex"],
    GL_EXT_draw_instanced:                            set.Strings["GL_EXT_draw_instanced"],
    GL_EXT_draw_transform_feedback:                   set.Strings["GL_EXT_draw_transform_feedback"],
    GL_EXT_geometry_shader:                           set.Strings["GL_EXT_geometry_shader"],
    GL_EXT_instanced_arrays:                          set.Strings["GL_EXT_instanced_arrays"],
    GL_EXT_map_buffer_range:                          set.Strings["GL_EXT_map_buffer_range"],
    GL_EXT_multi_draw_arrays:                         set.Strings["GL_EXT_multi_draw_arrays"],
    GL_EXT_multi_draw_indirect:                       set.Strings["GL_EXT_multi_draw_indirect"],
    GL_EXT_multisampled_render_to_texture:            set.Strings["GL_EXT_multisampled_render_to_texture"],
    GL_EXT_multiview_draw_buffers:                    set.Strings["GL_EXT_multiview_draw_buffers"],
    GL_EXT_occlusion_query_boolean:                   set.Strings["GL_EXT_occlusion_query_boolean"],
    GL_EXT_polygon_offset_clamp:                      set.Strings["GL_EXT_polygon_offset_clamp"],
    GL_EXT_primitive_bounding_box:                    set.Strings["GL_EXT_primitive_bounding_box"],
    GL_EXT_raster_multisample:                        set.Strings["GL_EXT_raster_multisample"],
    GL_EXT_robustness:                                set.Strings["GL_EXT_robustness"],
    GL_EXT_sRGB_write_control:                        set.Strings["GL_EXT_sRGB_write_control"],
    GL_EXT_separate_shader_objects:                   set.Strings["GL_EXT_separate_shader_objects"],
    GL_EXT_shader_pixel_local_storage2:               set.Strings["GL_EXT_shader_pixel_local_storage2"],
    GL_EXT_shadow_samplers:                           set.Strings["GL_EXT_shadow_samplers"],
    GL_EXT_sparse_texture:                            set.Strings["GL_EXT_sparse_texture"],
    GL_EXT_tessellation_shader:                       set.Strings["GL_EXT_tessellation_shader"],
    GL_EXT_texture_border_clamp:                      set.Strings["GL_EXT_texture_border_clamp"],
    GL_EXT_texture_buffer:                            set.Strings["GL_EXT_texture_buffer"],
    GL_EXT_texture_compression_s3tc:                  set.Strings["GL_EXT_texture_compression_s3tc"],
    GL_EXT_texture_filter_anisotropic:                set.Strings["GL_EXT_texture_filter_anisotropic"],
    GL_EXT_texture_filter_minmax:                     set.Strings["GL_EXT_texture_filter_minmax"],
    GL_EXT_texture_format_BGRA8888:                   set.Strings["GL_EXT_texture_format_BGRA8888"],
    GL_EXT_texture_norm16:                            set.Strings["GL_EXT_texture_norm16"],
    GL_EXT_texture_rg:                                set.Strings["GL_EXT_texture_rg"],
    GL_EXT_texture_sRGB_decode:                       set.Strings["GL_EXT_texture_sRGB_decode"],
    GL_EXT_texture_storage:                           set.Strings["GL_EXT_texture_storage"],
    GL_EXT_texture_type_2_10_10_10_REV:               set.Strings["GL_EXT_texture_type_2_10_10_10_REV"],
    GL_EXT_texture_view:                              set.Strings["GL_EXT_texture_view"],
    GL_EXT_window_rectangles:                         set.Strings["GL_EXT_window_rectangles"],
    GL_IMG_bindless_texture:                          set.Strings["GL_IMG_bindless_texture"],
    GL_IMG_framebuffer_downsample:                    set.Strings["GL_IMG_framebuffer_downsample"],
    GL_IMG_multisampled_render_to_texture:            set.Strings["GL_IMG_multisampled_render_to_texture"],
    GL_IMG_user_clip_plane:                           set.Strings["GL_IMG_user_clip_plane"],
    GL_INTEL_framebuffer_CMAA:                        set.Strings["GL_INTEL_framebuffer_CMAA"],
    GL_INTEL_performance_query:                       set.Strings["GL_INTEL_performance_query"],
    GL_KHR_blend_equation_advanced:                   set.Strings["GL_KHR_blend_equation_advanced"],
    GL_KHR_debug:                                     set.Strings["GL_KHR_debug"],
    GL_KHR_robustness:                                set.Strings["GL_KHR_robustness"],
    GL_NV_bindless_texture:                           set.Strings["GL_NV_bindless_texture"],
    GL_NV_blend_equation_advanced:                    set.Strings["GL_NV_blend_equation_advanced"],
    GL_NV_conditional_render:                         set.Strings["GL_NV_conditional_render"],
    GL_NV_conservative_raster:                        set.Strings["GL_NV_conservative_raster"],
    GL_NV_conservative_raster_pre_snap_triangles:     set.Strings["GL_NV_conservative_raster_pre_snap_triangles"],
    GL_NV_copy_buffer:                                set.Strings["GL_NV_copy_buffer"],
    GL_NV_coverage_sample:                            set.Strings["GL_NV_coverage_sample"],
    GL_NV_draw_buffers:                               set.Strings["GL_NV_draw_buffers"],
    GL_NV_draw_instanced:                             set.Strings["GL_NV_draw_instanced"],
    GL_NV_fence:                                      set.Strings["GL_NV_fence"],
    GL_NV_fragment_coverage_to_color:                 set.Strings["GL_NV_fragment_coverage_to_color"],
    GL_NV_framebuffer_blit:                           set.Strings["GL_NV_framebuffer_blit"],
    GL_NV_framebuffer_mixed_samples:                  set.Strings["GL_NV_framebuffer_mixed_samples"],
    GL_NV_framebuffer_multisample:                    set.Strings["GL_NV_framebuffer_multisample"],
    GL_NV_gpu_shader5:                                set.Strings["GL_NV_gpu_shader5"],
    GL_NV_instanced_arrays:                           set.Strings["GL_NV_instanced_arrays"],
    GL_NV_internalformat_sample_query:                set.Strings["GL_NV_internalformat_sample_query"],
    GL_NV_non_square_matrices:                        set.Strings["GL_NV_non_square_matrices"],
    GL_NV_path_rendering:                             set.Strings["GL_NV_path_rendering"],
    GL_NV_polygon_mode:                               set.Strings["GL_NV_polygon_mode"],
    GL_NV_read_buffer:                                set.Strings["GL_NV_read_buffer"],
    GL_NV_sample_locations:                           set.Strings["GL_NV_sample_locations"],
    GL_NV_viewport_array:                             set.Strings["GL_NV_viewport_array"],
    GL_NV_viewport_swizzle:                           set.Strings["GL_NV_viewport_swizzle"],
    GL_OES_EGL_image:                                 set.Strings["GL_OES_EGL_image"],
    GL_OES_EGL_image_external:                        set.Strings["GL_OES_EGL_image_external"],
    GL_OES_blend_equation_separate:                   set.Strings["GL_OES_blend_equation_separate"],
    GL_OES_blend_func_separate:                       set.Strings["GL_OES_blend_func_separate"],
    GL_OES_blend_subtract:                            set.Strings["GL_OES_blend_subtract"],
    GL_OES_compressed_ETC1_RGB8_texture:              set.Strings["GL_OES_compressed_ETC1_RGB8_texture"],
    GL_OES_copy_image:                                set.Strings["GL_OES_copy_image"],
    GL_OES_depth_texture:                             set.Strings["GL_OES_depth_texture"],
    GL_OES_draw_buffers_indexed:                      set.Strings["GL_OES_draw_buffers_indexed"],
    GL_OES_draw_elements_base_vertex:                 set.Strings["GL_OES_draw_elements_base_vertex"],
    GL_OES_draw_texture:                              set.Strings["GL_OES_draw_texture"],
    GL_OES_fixed_point:                               set.Strings["GL_OES_fixed_point"],
    GL_OES_framebuffer_object:                        set.Strings["GL_OES_framebuffer_object"],
    GL_OES_geometry_shader:                           set.Strings["GL_OES_geometry_shader"],
    GL_OES_get_program_binary:                        set.Strings["GL_OES_get_program_binary"],
    GL_OES_mapbuffer:                                 set.Strings["GL_OES_mapbuffer"],
    GL_OES_matrix_palette:                            set.Strings["GL_OES_matrix_palette"],
    GL_OES_packed_depth_stencil:                      set.Strings["GL_OES_packed_depth_stencil"],
    GL_OES_point_size_array:                          set.Strings["GL_OES_point_size_array"],
    GL_OES_primitive_bounding_box:                    set.Strings["GL_OES_primitive_bounding_box"],
    GL_OES_query_matrix:                              set.Strings["GL_OES_query_matrix"],
    GL_OES_sample_shading:                            set.Strings["GL_OES_sample_shading"],
    GL_OES_single_precision:                          set.Strings["GL_OES_single_precision"],
    GL_OES_tessellation_shader:                       set.Strings["GL_OES_tessellation_shader"],
    GL_OES_texture_3D:                                set.Strings["GL_OES_texture_3D"],
    GL_OES_texture_border_clamp:                      set.Strings["GL_OES_texture_border_clamp"],
    GL_OES_texture_buffer:                            set.Strings["GL_OES_texture_buffer"],
    GL_OES_texture_cube_map:                          set.Strings["GL_OES_texture_cube_map"],
    GL_OES_texture_float:                             set.Strings["GL_OES_texture_float"],
    GL_OES_texture_half_float:                        set.Strings["GL_OES_texture_half_float"],
    GL_OES_texture_stencil8:                          set.Strings["GL_OES_texture_stencil8"],
    GL_OES_texture_storage_multisample_2d_array:      set.Strings["GL_OES_texture_storage_multisample_2d_array"],
    GL_OES_texture_view:                              set.Strings["GL_OES_texture_view"],
    GL_OES_vertex_array_object:                       set.Strings["GL_OES_vertex_array_object"],
    GL_OES_vertex_half_float:                         set.Strings["GL_OES_vertex_half_float"],
    GL_OES_viewport_array:                            set.Strings["GL_OES_viewport_array"],
    GL_OVR_multiview:                                 set.Strings["GL_OVR_multiview"],
    GL_OVR_multiview_multisampled_render_to_texture:  set.Strings["GL_OVR_multiview_multisampled_render_to_texture"],
    GL_QCOM_alpha_test:                               set.Strings["GL_QCOM_alpha_test"],
    GL_QCOM_driver_control:                           set.Strings["GL_QCOM_driver_control"],
    GL_QCOM_extended_get:                             set.Strings["GL_QCOM_extended_get"],
    GL_QCOM_extended_get2:                            set.Strings["GL_QCOM_extended_get2"],
    GL_QCOM_tiled_rendering:                          set.Strings["GL_QCOM_tiled_rendering"],
  )
}

@internal
class StringSet {
  map!(string, bool) Strings
}

@internal
class Color {
  GLfloat Red
  GLfloat Green
  GLfloat Blue
  GLfloat Alpha
}

@internal
class Rect {
  GLint   X
  GLint   Y
  GLsizei Width
  GLsizei Height
}

@internal type GLboolean[4] Vec4b
@internal type GLint[1]     Vec1i
@internal type GLint[2]     Vec2i
@internal type GLint[3]     Vec3i
@internal type GLint[4]     Vec4i
@internal type GLuint[2]    Vec2u
@internal type GLuint[3]    Vec3u
@internal type GLuint[4]    Vec4u
@internal type GLfloat[1]   Vec1f
@internal type GLfloat[2]   Vec2f
@internal type GLfloat[3]   Vec3f
@internal type GLfloat[4]   Vec4f
@internal type Vec2f[2]     Mat2f
@internal type Vec3f[2]     Mat2x3f
@internal type Vec4f[2]     Mat2x4f
@internal type Vec2f[3]     Mat3x2f
@internal type Vec3f[3]     Mat3f
@internal type Vec4f[3]     Mat3x4f
@internal type Vec2f[4]     Mat4x2f
@internal type Vec3f[4]     Mat4x3f
@internal type Vec4f[4]     Mat4f

/////////////////////////////////////////////////////////////////
// State
/////////////////////////////////////////////////////////////////

@replay_remap type GLuint RenderbufferId
@replay_remap type GLuint TextureId
@replay_remap type GLuint FramebufferId
@replay_remap type GLuint BufferId
@replay_remap type GLuint ShaderId
@replay_remap type GLuint ProgramId
@replay_remap type GLuint VertexArrayId
@replay_remap type GLuint QueryId
@replay_remap type GLint  UniformLocation
type GLuint               UniformIndex
type GLuint               AttributeLocation
type GLuint               AttributeIndex
type GLuint               TextureUnitId
@replay_remap type GLuint SamplerId
@replay_remap type GLuint PipelineId
@replay_remap type GLuint UniformBlockIndex
@replay_remap type GLuint TransformFeedbackId
@replay_remap type GLuint SrcImageId
@replay_remap type GLuint DstImageId

@replay_custom_value type const void* IndicesPointer
@replay_custom_value type const void* VertexPointer
@replay_custom_value type const void* TexturePointer
@replay_custom_value type const void* BufferDataPointer

@internal
class DefaultObjects {
  ref!Framebuffer       Framebuffer
  ref!VertexArray       VertexArray
  ref!TransformFeedback TransformFeedback
  ref!Texture           Texture2d
  ref!Texture           Texture2dArray
  ref!Texture           Texture2dMultisample
  ref!Texture           Texture2dMultisampleArray
  ref!Texture           Texture3d
  ref!Texture           TextureBuffer
  ref!Texture           TextureCubeMap
  ref!Texture           TextureCubeMapArray
  ref!Texture           TextureExternalOes
}

// Objects which are never shared between contexts.
@internal
class Objects {
  GeneratedObjectNames                             GeneratedNames
  DefaultObjects                                   Default
  map!(BufferId, ref!Buffer)                       Buffers
  map!(FramebufferId, ref!Framebuffer)             Framebuffers
  map!(GLuint, ImageUnit)                          ImageUnits
  map!(PipelineId, ref!Pipeline)                   Pipelines
  map!(ProgramId, ref!Program)                     Programs
  map!(QueryId, ref!Query)                         Queries
  map!(RenderbufferId, ref!Renderbuffer)           Renderbuffers
  map!(SamplerId, ref!Sampler)                     Samplers
  map!(ShaderId, ref!Shader)                       Shaders
  map!(GLsync, ref!SyncObject)                     SyncObjects
  map!(TextureUnitId, ref!TextureUnit)             TextureUnits
  map!(TextureId, ref!Texture)                     Textures
  map!(TransformFeedbackId, ref!TransformFeedback) TransformFeedbacks
  map!(VertexArrayId, ref!VertexArray)             VertexArrays
}

@internal
class GeneratedObjectNames {
  map!(BufferId, bool)            Buffers
  map!(FramebufferId, bool)       Framebuffers
  map!(PipelineId, bool)          Pipelines
  map!(QueryId, bool)             Queries
  map!(RenderbufferId, bool)      Renderbuffers
  map!(SamplerId, bool)           Samplers
  map!(TextureId, bool)           Textures
  map!(TransformFeedbackId, bool) TransformFeedbacks
  map!(VertexArrayId, bool)       VertexArrays
}

@internal type s32 ContextID

@internal
class ContextCreationInfo {
  bool              Initialized
  string            ThreadName
  @unused bool      PreserveBuffersOnSwap
  @unused ContextID SharedContext
}

@internal
class Bindings {
  ref!Buffer                  ArrayBuffer
  ref!Buffer                  AtomicCounterBuffer
  map!(GLuint, BufferBinding) AtomicCounterBuffers
  ref!Buffer                  CopyReadBuffer
  ref!Buffer                  CopyWriteBuffer
  ref!Buffer                  DispatchIndirectBuffer
  ref!Framebuffer             DrawFramebuffer
  ref!Buffer                  DrawIndirectBuffer
  ref!Buffer                  PixelPackBuffer
  ref!Buffer                  PixelUnpackBuffer
  ref!Program                 Program
  ref!Framebuffer             ReadFramebuffer
  ref!Renderbuffer            Renderbuffer
  ref!Buffer                  ShaderStorageBuffer
  map!(GLuint, BufferBinding) ShaderStorageBuffers
  ref!Buffer                  TextureBuffer
  ref!TextureUnit             TextureUnit
  ref!TransformFeedback       TransformFeedback
  ref!Buffer                  TransformFeedbackBuffer
  ref!Buffer                  UniformBuffer
  map!(GLuint, BufferBinding) UniformBuffers
  ref!VertexArray             VertexArray
}

@internal
class BufferBinding {
  ref!Buffer Binding
  GLintptr   Start
  GLsizeiptr Size
}

@internal
class VertexState {
  @unused map!(AttributeLocation, VertexAttributeValue) Attributes

  // Table 21.2: Current Values and Associated Data
  @unused GLint PatchVertices = 3

  // Table 21.4: Vertex Array Data (not in vertex array objects)
  GLboolean PrimitiveRestartFixedIndex = GL_FALSE
}

@internal
class OtherState {
  DebugState              Debug
  map!(GLenum, ref!Query) ActiveQueries
  PixelStorageState       Pack
  PixelStorageState       Unpack

  // Table 21.38: Hints
  GLenum         GenerateMipmapHint           = GL_DONT_CARE
  @unused GLenum FragmentShaderDerivativeHint = GL_DONT_CARE

// Table 21.57: Miscellaneous
// GLenum CurrentError = as!GLenum(0)
// GLboolean HasError = GL_FALSE
// Vec3u CurrentQuery = Vec3u(0,0,0)
// GLint ResetNotificationStrategy /// TODO: See sec. 2.3.2

  bool IsBound
}

@internal
class Context {
  ContextID           Identifier
  Constants           Constants
  ContextCreationInfo Info
  Bindings            Bound
  Objects             Objects
  VertexState         Vertex
  RasterizationState  Rasterization
  PixelState          Pixel
  OtherState          Other
}


// Globals
ContextID              NextContextID
map!(u64, ref!Context) Contexts
ref!Context            CurrentContext

sub ref!Context GetContext() {
  context := Contexts[$Thread]
  if context == null {
    _ = newMsg(SEVERITY_ERROR, new!ERR_NO_CONTEXT_BOUND(thread: $Thread))
    abort
  }
  return context
}

sub void SetContext(ref!Context newContext) {
  oldContext := Contexts[$Thread]
  if oldContext != null {
    oldContext.Other.IsBound = false
  }
  Contexts[$Thread] = newContext
  CurrentContext = newContext
  if newContext != null {
    newContext.Other.IsBound = true
  }
}

sub ref!Context CreateContext(ref!Context sharedContext) {
  identifier := NextContextID
  NextContextID = NextContextID + 1

  ctx := new!Context(Identifier: identifier)

  if sharedContext != null {
    ctx.Info.SharedContext = sharedContext.Identifier
  } else {
    ctx.Info.SharedContext = -1
  }

  // Objects which can be shared between contexts.
  // See: Chapter 5 - "Shared Objects and Multiple Contexts"
  // We implement it by sharing reference to the object maps.
  if sharedContext != null {
    ctx.Objects.GeneratedNames.Renderbuffers = sharedContext.Objects.GeneratedNames.Renderbuffers
    ctx.Objects.GeneratedNames.Textures      = sharedContext.Objects.GeneratedNames.Textures
    ctx.Objects.GeneratedNames.Buffers       = sharedContext.Objects.GeneratedNames.Buffers
    ctx.Objects.GeneratedNames.Samplers      = sharedContext.Objects.GeneratedNames.Samplers

    ctx.Objects.Renderbuffers = sharedContext.Objects.Renderbuffers
    ctx.Objects.Textures      = sharedContext.Objects.Textures
    ctx.Objects.Buffers       = sharedContext.Objects.Buffers
    ctx.Objects.Samplers      = sharedContext.Objects.Samplers
    ctx.Objects.Shaders       = sharedContext.Objects.Shaders
    ctx.Objects.Programs      = sharedContext.Objects.Programs
    ctx.Objects.SyncObjects   = sharedContext.Objects.SyncObjects
  }

  return ctx
}

sub void ApplyStaticContextState(ref!Context ctx, ref!StaticContextState staticState) {
  if (staticState != null) {
    // Renderbuffers are shared so make sure we create unique IDs.
    color_id := as!RenderbufferId(as!u32(0xff000001) + as!u32(16 * ctx.Identifier))
    depth_id := as!RenderbufferId(as!u32(0xff000002) + as!u32(16 * ctx.Identifier))
    stencil_id := as!RenderbufferId(as!u32(0xff000003) + as!u32(16 * ctx.Identifier))

    // First initialization for the context.
    ctx.Constants = staticState.Constants
    ctx.Info.ThreadName = staticState.ThreadName
    InitVersions(ctx)
    InitExtensions(ctx)

    ctx.Objects.Default.Framebuffer = new!Framebuffer(ID: 0,ReadBuffer:  GL_BACK)
    ctx.Objects.Framebuffers[0] = ctx.Objects.Default.Framebuffer
    ctx.Bound.DrawFramebuffer = ctx.Objects.Default.Framebuffer
    ctx.Bound.ReadFramebuffer = ctx.Objects.Default.Framebuffer

    ctx.Objects.Default.TransformFeedback = new!TransformFeedback(ID: 0)
    ctx.Objects.TransformFeedbacks[0] = ctx.Objects.Default.TransformFeedback
    ctx.Bound.TransformFeedback = ctx.Objects.Default.TransformFeedback

    ctx.Objects.Default.VertexArray = NewVertexArray(0)
    ctx.Objects.VertexArrays[0] = ctx.Objects.Default.VertexArray
    ctx.Bound.VertexArray = ctx.Objects.Default.VertexArray

    ctx.Objects.Default.Texture2d = new!Texture(ID: 0,Kind:  GL_TEXTURE_2D)
    ctx.Objects.Default.Texture2dArray = new!Texture(ID: 0,Kind:  GL_TEXTURE_2D_ARRAY)
    ctx.Objects.Default.Texture2dMultisample = new!Texture(ID: 0,Kind:  GL_TEXTURE_2D_MULTISAMPLE)
    ctx.Objects.Default.Texture2dMultisampleArray = new!Texture(ID: 0,Kind:  GL_TEXTURE_2D_MULTISAMPLE_ARRAY)
    ctx.Objects.Default.Texture3d = new!Texture(ID: 0,Kind:  GL_TEXTURE_3D)
    ctx.Objects.Default.TextureBuffer = new!Texture(ID: 0,Kind:  GL_TEXTURE_BUFFER)
    ctx.Objects.Default.TextureCubeMap = new!Texture(ID: 0,Kind:  GL_TEXTURE_CUBE_MAP)
    ctx.Objects.Default.TextureCubeMapArray = new!Texture(ID: 0,Kind:  GL_TEXTURE_CUBE_MAP_ARRAY)
    ctx.Objects.Default.TextureExternalOes = new!Texture(ID: 0,Kind:  GL_TEXTURE_EXTERNAL_OES)

    ctx.Objects.Renderbuffers[color_id] = new!Renderbuffer(ID: color_id)
    ctx.Objects.Renderbuffers[depth_id] = new!Renderbuffer(ID: depth_id)
    ctx.Objects.Renderbuffers[stencil_id] = new!Renderbuffer(ID: stencil_id)

    backbuffer := ctx.Objects.Framebuffers[0]
    backbuffer.ColorAttachments[0] = FramebufferAttachment(
      Type:          GL_RENDERBUFFER,
      Renderbuffer:  ctx.Objects.Renderbuffers[color_id],
    )

    backbuffer.DepthAttachment = FramebufferAttachment(
      Type:          GL_RENDERBUFFER,
      Renderbuffer:  ctx.Objects.Renderbuffers[depth_id],
    )

    backbuffer.StencilAttachment = FramebufferAttachment(
      Type:          GL_RENDERBUFFER,
      Renderbuffer:  ctx.Objects.Renderbuffers[stencil_id],
    )

    for i in 0 .. as!AttributeLocation(staticState.Constants.MaxVertexAttribs) {
      v := make!Vec4f(1)
      v[0] = Vec4f(0.0, 0.0, 0.0, 1.0)
      ctx.Vertex.Attributes[i] = VertexAttributeValue(Value: as!u8[](v))
    }

    for i in 0 .. as!TextureUnitId(staticState.Constants.MaxCombinedTextureImageUnits) {
      ctx.Objects.TextureUnits[i] = NewTextureUnit(i)
    }
    ctx.Bound.TextureUnit = ctx.Objects.TextureUnits[0]

    for i in 0 .. as!GLuint(staticState.Constants.MaxImageUnits) {
      ctx.Objects.ImageUnits[i] = ImageUnit()
    }

    for i in (0 .. as!DrawBufferIndex(ctx.Constants.MaxDrawBuffers)) {
      ctx.Pixel.Blend[i] = BlendState()
      ctx.Pixel.ColorWritemask[i] = Vec4b(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE)
    }

    ctx.Info.Initialized = true
  }
}

sub void ApplyDynamicContextState(ref!Context ctx, ref!DynamicContextState dynamicState) {
  if (dynamicState != null) {
    backbuffer := ctx.Objects.Framebuffers[0]
    color_id := backbuffer.ColorAttachments[0].Renderbuffer.ID
    depth_id := backbuffer.DepthAttachment.Renderbuffer.ID
    stencil_id := backbuffer.StencilAttachment.Renderbuffer.ID

    color_buffer := ctx.Objects.Renderbuffers[color_id]
    color_buffer.Width = dynamicState.BackbufferWidth
    color_buffer.Height = dynamicState.BackbufferHeight
    color_buffer.InternalFormat = dynamicState.BackbufferColorFmt
    ctx.Objects.Renderbuffers[color_id] = color_buffer

    depth_buffer := ctx.Objects.Renderbuffers[depth_id]
    depth_buffer.Width = dynamicState.BackbufferWidth
    depth_buffer.Height = dynamicState.BackbufferHeight
    depth_buffer.InternalFormat = dynamicState.BackbufferDepthFmt
    ctx.Objects.Renderbuffers[depth_id] = depth_buffer

    stencil_buffer := ctx.Objects.Renderbuffers[stencil_id]
    stencil_buffer.Width = dynamicState.BackbufferWidth
    stencil_buffer.Height = dynamicState.BackbufferHeight
    stencil_buffer.InternalFormat = dynamicState.BackbufferStencilFmt
    ctx.Objects.Renderbuffers[stencil_id] = stencil_buffer

    if dynamicState.ResetViewportScissor {
      ctx.Pixel.Scissor.Box.Width = dynamicState.BackbufferWidth
      ctx.Pixel.Scissor.Box.Height = dynamicState.BackbufferHeight
      ctx.Rasterization.Viewport.Width = dynamicState.BackbufferWidth
      ctx.Rasterization.Viewport.Height = dynamicState.BackbufferHeight
    }

    ctx.Info.PreserveBuffersOnSwap = dynamicState.PreserveBuffersOnSwap
  }
}

/////////////////////////////////////////////////////////////////
// GLX APIs
/////////////////////////////////////////////////////////////////
type void* GLXContext
type void* GLXDrawable
type int   Bool

map!(GLXContext, ref!Context) GLXContexts

@custom @no_replay
cmd GLXContext glXCreateContext(void* dpy, void* vis, GLXContext shareList, bool direct) {
  context := ?
  GLXContexts[context] = CreateContext(GLXContexts[shareList])
  return context
}

@custom @no_replay
cmd GLXContext glXCreateNewContext(void* display, void* fbconfig, u32 type, GLXContext shared, bool direct) {
  context := ?
  GLXContexts[context] = CreateContext(GLXContexts[shared])
  return context
}

@custom @no_replay
cmd Bool glXMakeContextCurrent(void* display, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
  SetContext(GLXContexts[ctx])
  return ?
}

@no_replay
cmd Bool glXMakeCurrent(void* display, GLXDrawable drawable, GLXContext ctx) {
  SetContext(GLXContexts[ctx])
  return ?
}

@no_replay
@frame_start
cmd void glXSwapBuffers(void* display, GLXDrawable drawable) {
}

@no_replay
cmd int glXQueryDrawable(void* display, GLXDrawable draw, int attribute, int* value) {
  value[0] = ?
  return ?
}

/////////////////////////////////////////////////////////////////
// WGL APIs
/////////////////////////////////////////////////////////////////
type void* HGLRC
type void* HDC
type int   BOOL

map!(HGLRC, ref!Context) WGLContexts

@custom @no_replay
///http://msdn.microsoft.com/en-us/library/windows/desktop/dd374379(v=vs.85).aspx
cmd HGLRC wglCreateContext(HDC hdc) {
  context := ?
  WGLContexts[context] = CreateContext(null)
  return context
}

@custom @no_replay
///http://www.opengl.org/registry/specs/ARB/wgl_create_context.txt
cmd HGLRC wglCreateContextAttribsARB(HDC hdc, HGLRC hShareContext, int* attribList) {
  context := ?
  WGLContexts[context] = CreateContext(WGLContexts[hShareContext])
  return context
}

@custom @no_replay
///http://msdn.microsoft.com/en-us/library/windows/desktop/dd374387(v=vs.85).aspx
cmd BOOL wglMakeCurrent(HDC hdc, HGLRC hglrc) {
  SetContext(WGLContexts[hglrc])
  return ?
}

@no_replay
@frame_start
///http://msdn.microsoft.com/en-us/library/dd369060(v=vs.85)
cmd void wglSwapBuffers(HDC hdc) { }

/////////////////////////////////////////////////////////////////
// CGL APIs
/////////////////////////////////////////////////////////////////
type int   CGLError
type void* CGLTexelFormatObj
type void* CGLContextObj
type void* CGSConnectionID
type s32   CGSWindowID
type s32   CGSSurfaceID

map!(CGLContextObj, ref!Context) CGLContexts

@custom @no_replay
///http://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CGL_OpenGL/index.html#//apple_ref/c/func/CGLCreateContext
cmd CGLError CGLCreateContext(CGLTexelFormatObj pix, CGLContextObj share, CGLContextObj* ctx) {
  context := ?
  CGLContexts[context] = CreateContext(CGLContexts[share])
  ctx[0] = context
  return context
}

@custom @no_replay
cmd CGLError CGLSetCurrentContext(CGLContextObj ctx) {
  SetContext(CGLContexts[ctx])
  return ?
}

@no_replay
cmd int CGLGetSurface(CGLContextObj ctx, CGSConnectionID* cid, CGSWindowID* wid, CGSSurfaceID* sid) {
  cid[0] = ?
  wid[0] = ?
  sid[0] = ?
  return ?
}

@no_replay
cmd int CGSGetSurfaceBounds(CGSConnectionID cid, CGSWindowID wid, CGSSurfaceID sid, f64* bounds) {
  write(bounds[0:4])
  return ?
}

@no_replay
@frame_start
cmd CGLError CGLFlushDrawable(CGLContextObj ctx) {
  return ?
}


/////////////////////////////////////////////////////////////////
// GLES 2 APIs
/////////////////////////////////////////////////////////////////

sub u32 IndexSize(GLenum indices_type) {
  return switch (indices_type) {
    case GL_UNSIGNED_BYTE:  1
    case GL_UNSIGNED_SHORT: 2
    case GL_UNSIGNED_INT:   4
  }
}

@internal class u32Limits { u32 first u32 count }
extern u32Limits IndexLimits(u8[] indices, s32 sizeof_index)
