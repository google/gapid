// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

@internal
class FramebufferState {
  // Table 21.14: Framebuffer Control
  map!(DrawBufferIndex, Vec4b) ColorWritemask
  GLboolean                    DepthWritemask       = GL_TRUE
  GLuint                       StencilWritemask     = 0xFFFFFFFF
  GLuint                       StencilBackWritemask = 0xFFFFFFFF
  Vec4f                        ColorClearValue      = Vec4f(0.0, 0.0, 0.0, 0.0)
  GLfloat                      DepthClearValue      = 1
  GLint                        StencilClearValue    = 0
// GLuint DrawFramebufferBinding = 0
// GLuint ReadFramebufferBinding = 0
// GLint RenderbufferBinding = 0
}

@internal
class Framebuffer {
  FramebufferId ID

  map!(GLint, FramebufferAttachment) ColorAttachments
  FramebufferAttachment DepthAttachment
  FramebufferAttachment StencilAttachment

  // Table 21.15: Framebuffer (state per framebuffer object)
  map!(GLint, GLenum) DrawBuffer                                         // TODO: init - see 15.2.1
  @unused GLenum      ReadBuffer                  = GL_COLOR_ATTACHMENT0
  GLint               DefaultWidth                = 0
  GLint               DefaultHeight               = 0
  GLint               DefaultLayers               = 0
  GLint               DefaultSamples              = 0
  GLboolean           DefaultFixedSampleLocations = GL_FALSE

  @unused string Label // SPEC: Missing
}

@internal
class FramebufferAttachment {
  // Table 21.16: Framebuffer (state per attachment point)
  GLenum           Type = GL_NONE
  ref!Texture      Texture
  ref!Renderbuffer Renderbuffer
  GLint            TextureLevel       = 0
  GLint            TextureLayer       = 0
  GLboolean        Layered            = GL_FALSE
  // OVR_multiview
  GLsizei          NumViews           = 1
/* TODO
  GLenum ColorEncoding
  GLenum ComponentType
  GLuint RedSize
  GLuint GreenSize
  GLuint BlueSize
  GLuint AlphaSize
  GLuint DepthSize
  GLuint StencilSize
  string ObjectLabel
  */
}

@internal
class Renderbuffer {
  RenderbufferId ID
  @unused u8[] Data

  // Table 21.17: Renderbuffer (state per renderbuffer object)
  GLsizei Width          = 0
  GLsizei Height         = 0
  GLenum  InternalFormat = GL_RGBA4
  GLsizei Samples = 0
  /* TODO
  GLuint RedSize = 0
  GLuint GreenSize = 0
  GLuint BlueSize = 0
  GLuint AlphaSize = 0
  GLuint DepthSize = 0
  GLuint StencilSize = 0
  */

  @unused string Label
}

/* TODO
@internal
class FramebufferDependentValues {
  // Table 21.56: Framebuffer Dependent Values
  GLint SampleBuffers = 0
  GLuint Samples = 0
  GLuint MaxSamples = 4
  GLuint RedBits
  GLuint GreenBits
  GLuint BlueBits
  GLuint AlphaBits
  GLuint DepthBits
  GLuint StencilBits
  GLenum ImplementationColorReadType
  GLenum ImplementationColorReadFormat
  GLfloat[2][] SamplePosition // TODO: impl-dependent
}
*/

sub ref!Framebuffer GetBoundFramebufferOrErrorInvalidEnum(GLenum framebuffer_target) {
  ctx := GetContext()
  return switch (framebuffer_target) {
    @if(Version.GLES20) case GL_FRAMEBUFFER: ctx.Bound.DrawFramebuffer
    @if(Version.GLES30) case GL_DRAW_FRAMEBUFFER: ctx.Bound.DrawFramebuffer
    @if(Version.GLES30) case GL_READ_FRAMEBUFFER: ctx.Bound.ReadFramebuffer
    default: ctx.Bound.DrawFramebuffer // TODO: glErrorInvalidEnum(framebuffer_target)
  }
}

sub void CheckNonDefaultFramebuffer(ref!Framebuffer framebuffer) {
  ctx := GetContext()
  if framebuffer == ctx.Objects.Framebuffers[0] {
    glErrorInvalidOperationMsg(new!ERR_INVALID_OPERATION_DEFAULT_FRAMEBUFFER_BOUND())
  }
}

sub bool IsDefaultFramebuffer(ref!Framebuffer framebuffer) {
  ctx := GetContext()
  return framebuffer == ctx.Objects.Framebuffers[0]
}

sub void SetFramebufferAttachment(GLenum                framebuffer_target,
                                  GLenum                framebuffer_attachment,
                                  FramebufferAttachment attachment) {
  ctx := GetContext()
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(framebuffer_target)
  CheckNonDefaultFramebuffer(framebuffer)
  switch (framebuffer_attachment) {
    case GL_COLOR_ATTACHMENT0:
      framebuffer.ColorAttachments[0] = attachment
    case GL_DEPTH_ATTACHMENT:
      framebuffer.DepthAttachment = attachment
    case GL_STENCIL_ATTACHMENT:
      framebuffer.StencilAttachment = attachment
    @if(Version.GLES30)
    case GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT11, GL_COLOR_ATTACHMENT12,
        GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT15, GL_COLOR_ATTACHMENT2,
        GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6,
        GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT9: {
      i := as!GLint(framebuffer_attachment - GL_COLOR_ATTACHMENT0)
      if (i < 0) || (i >= ctx.Constants.MaxColorAttachments) { glErrorInvalidOperation() }
      framebuffer.ColorAttachments[i] = attachment
    }
    @if(Version.GLES30)
    case GL_DEPTH_STENCIL_ATTACHMENT: {
      framebuffer.DepthAttachment = attachment
      framebuffer.StencilAttachment = attachment
    }
    default: {
      glErrorInvalidEnum(framebuffer_attachment)
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindFramebuffer.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindFramebuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindFramebuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindFramebuffer.xhtml", Version.GLES32)
cmd void glBindFramebuffer(GLenum target, FramebufferId framebuffer) {
  ctx := GetContext()
  switch (target) {
    case GL_FRAMEBUFFER: {
      // version 2.0
      fb := GetOrCreateFramebuffer(framebuffer)
      ctx.Bound.ReadFramebuffer = fb
      ctx.Bound.DrawFramebuffer = fb
    }
    @if(Version.GLES30)
    case GL_READ_FRAMEBUFFER: {
      ctx.Bound.ReadFramebuffer = GetOrCreateFramebuffer(framebuffer)
    }
    @if(Version.GLES30)
    case GL_DRAW_FRAMEBUFFER: {
      ctx.Bound.DrawFramebuffer = GetOrCreateFramebuffer(framebuffer)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
}

sub ref!Framebuffer GetOrCreateFramebuffer(FramebufferId id) {
  ctx := GetContext()
  if (id != 0) && (ctx.Objects.Framebuffers[id] == null) {
    ctx.Objects.Framebuffers[id] = new!Framebuffer(ID: id)
    ctx.Objects.GeneratedNames.Framebuffers[id] = true
  }
  return ctx.Objects.Framebuffers[id]
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindRenderbuffer.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindRenderbuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindRenderbuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindRenderbuffer.xhtml", Version.GLES32)
cmd void glBindRenderbuffer(GLenum target, RenderbufferId renderbuffer) {
  ctx := GetContext()
  switch (target) {
    case GL_RENDERBUFFER: {
      ctx.Bound.Renderbuffer = GetOrCreateRenderbuffer(renderbuffer)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
}

sub ref!Renderbuffer GetOrCreateRenderbuffer(RenderbufferId id) {
  ctx := GetContext()
  if (id != 0) && (ctx.Objects.Renderbuffers[id] == null) {
    ctx.Objects.Renderbuffers[id] = new!Renderbuffer(ID: id)
    ctx.Objects.GeneratedNames.Renderbuffers[id] = true
  }
  return ctx.Objects.Renderbuffers[id]
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBlitFramebuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBlitFramebuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBlitFramebuffer.xhtml", Version.GLES32)
cmd void glBlitFramebuffer(GLint      srcX0,
                           GLint      srcY0,
                           GLint      srcX1,
                           GLint      srcY1,
                           GLint      dstX0,
                           GLint      dstY0,
                           GLint      dstX1,
                           GLint      dstY1,
                           GLbitfield mask,
                           GLenum     filter) {
  BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)
}

sub void BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
  supportsBits(mask, GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)
  if (GL_COLOR_BUFFER_BIT in mask) {
  }
  if (GL_DEPTH_BUFFER_BIT in mask) {
  }
  if (GL_STENCIL_BUFFER_BIT in mask) {
  }
  switch (filter) {
    case GL_LINEAR, GL_NEAREST: {
      // version 3.0
    }
    default: {
      glErrorInvalidEnum(filter)
    }
  }
  _ = srcX0 // TODO
  _ = srcY0 // TODO
  _ = srcX1 // TODO
  _ = srcY1 // TODO
  _ = dstX0 // TODO
  _ = dstY0 // TODO
  _ = dstX1 // TODO
  _ = dstY1 // TODO
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCheckFramebufferStatus.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCheckFramebufferStatus.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCheckFramebufferStatus.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCheckFramebufferStatus.xhtml", Version.GLES32)
cmd GLenum glCheckFramebufferStatus(GLenum target) {
  switch (target) {
    case GL_FRAMEBUFFER: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER: {
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }

  return ?
}

@clear
@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glClear.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClear.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClear.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClear.xhtml", Version.GLES32)
cmd void glClear(GLbitfield mask) {
  supportsBits(mask, GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT)
  if (GL_COLOR_BUFFER_BIT in mask) {
  }
  if (GL_DEPTH_BUFFER_BIT in mask) {
  }
  if (GL_STENCIL_BUFFER_BIT in mask) {
  }

  // TODO: use(Clearing.ClearColor) when mask[GL_COLOR_BUFFER_BIT] == true
  if (GL_COLOR_BUFFER_BIT in mask) {
    // color := BoundFramebuffers[GL_FRAMEBUFFER].Attachments[GL_COLOR_ATTACHMENT0]
    // error("Attempting to clear missing color buffer") if !exists(color)
    // modifies(color.Levels[0].Data) // COMPILATION ERROR
  }
}

@clear
@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearBuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearBuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearBuffer.xhtml", Version.GLES32)
cmd void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
  switch (buffer) {
    case GL_DEPTH_STENCIL: {
      CheckEQ!GLint(drawbuffer, 0)
    }
    default: {
      glErrorInvalidEnum(buffer)
    }
  }
}

@clear
@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearBuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearBuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearBuffer.xhtml", Version.GLES32)
cmd void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat* value) {
  switch (buffer) {
    case GL_COLOR: {
      ctx := GetContext()
      CheckLT!GLint(drawbuffer, ctx.Constants.MaxDrawBuffers)
      read(value[0:4])
    }
    case GL_DEPTH: {
      CheckEQ!GLint(drawbuffer, 0)
      read(value[0:1])
    }
    default: {
      glErrorInvalidEnum(buffer)
    }
  }
}

@clear
@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearBuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearBuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearBuffer.xhtml", Version.GLES32)
cmd void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint* value) {
  switch (buffer) {
    case GL_COLOR: {
      ctx := GetContext()
      CheckLT!GLint(drawbuffer, ctx.Constants.MaxDrawBuffers)
      read(value[0:4])
    }
    case GL_STENCIL: {
      CheckEQ!GLint(drawbuffer, 0)
      read(value[0:1])
    }
    default: {
      glErrorInvalidEnum(buffer)
    }
  }
}

@clear
@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearBuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearBuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearBuffer.xhtml", Version.GLES32)
cmd void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint* value) {
  switch (buffer) {
    case GL_COLOR: {
      ctx := GetContext()
      CheckLT!GLint(drawbuffer, ctx.Constants.MaxDrawBuffers)
      read(value[0:4])
    }
    default: {
      glErrorInvalidEnum(buffer)
    }
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glClearColor.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearColor.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearColor.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearColor.xhtml", Version.GLES32)
cmd void glClearColor(GLfloat r, GLfloat g, GLfloat b, GLfloat a) {

  ctx := GetContext()
  ctx.Pixel.ColorClearValue = Vec4f(r, g, b, a)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glClearDepthf.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearDepthf.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearDepthf.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearDepthf.xhtml", Version.GLES32)
cmd void glClearDepthf(GLfloat depth) {

  ctx := GetContext()
  ctx.Pixel.DepthClearValue = depth
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glClearStencil.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glClearStencil.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glClearStencil.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glClearStencil.xhtml", Version.GLES32)
cmd void glClearStencil(GLint stencil) {

  ctx := GetContext()
  ctx.Pixel.StencilClearValue = stencil
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glColorMask.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glColorMask.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glColorMask.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glColorMask.xhtml", Version.GLES32)
cmd void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
  ctx := GetContext()
  for i in (0 .. as!DrawBufferIndex(len(ctx.Pixel.ColorWritemask))) {
    ctx.Pixel.ColorWritemask[i] = Vec4b(red, green, blue, alpha)
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glColorMask.xhtml", Version.GLES32)
cmd void glColorMaski(DrawBufferIndex index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
  ColorMaski(index, r, g, b, a)
}

sub void ColorMaski(DrawBufferIndex index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
  ctx := GetContext()
  ctx.Pixel.ColorWritemask[index] = Vec4b(r, g, b, a)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteFramebuffers.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteFramebuffers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteFramebuffers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteFramebuffers.xhtml", Version.GLES32)
cmd void glDeleteFramebuffers(GLsizei count, const FramebufferId* framebuffers) {
  CheckCountGE!GLsizei(count, 0)

  f := framebuffers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := f[i]
    if id != 0 {
      // TODO: This is not really an error according to the spec.
      //       However, we need to ensure the command is removed,
      //       or else the invalid ID breaks remapping in replay.
      if !(id in ctx.Objects.Framebuffers) { glErrorInvalidValue!FramebufferId(id) }
      delete(ctx.Objects.Framebuffers, id)
      delete(ctx.Objects.GeneratedNames.Framebuffers, id)
      if id == ctx.Bound.ReadFramebuffer.ID {
        ctx.Bound.ReadFramebuffer = ctx.Objects.Default.Framebuffer
      }
      if id == ctx.Bound.DrawFramebuffer.ID {
        ctx.Bound.DrawFramebuffer = ctx.Objects.Default.Framebuffer
      }
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteRenderbuffers.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteRenderbuffers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteRenderbuffers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteRenderbuffers.xhtml", Version.GLES32)
cmd void glDeleteRenderbuffers(GLsizei count, const RenderbufferId* renderbuffers) {
  CheckCountGE!GLsizei(count, 0)

  r := renderbuffers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := r[i]
    if id != 0 {
      delete(ctx.Objects.Renderbuffers, id)
      delete(ctx.Objects.GeneratedNames.Renderbuffers, id)
    }
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDepthMask.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDepthMask.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDepthMask.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDepthMask.xhtml", Version.GLES32)
cmd void glDepthMask(GLboolean enabled) {

  ctx := GetContext()
  ctx.Pixel.DepthWritemask = enabled
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDrawBuffers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDrawBuffers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDrawBuffers.xhtml", Version.GLES32)
cmd void glDrawBuffers(GLsizei n, const GLenum* bufs) {
  DrawBuffers(n, bufs)
}

sub void DrawBuffers(GLsizei n, const GLenum* buffers) {
  ctx := GetContext()
  b := buffers[0:n]
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(GL_DRAW_FRAMEBUFFER)
  for i in (0 .. as!GLint(n)) {
    framebuffer.DrawBuffer[i] = b[i]
  }
  for i in (as!GLint(n) .. ctx.Constants.MaxDrawBuffers) {
    framebuffer.DrawBuffer[i] = GL_NONE
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glFramebufferParameteri.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glFramebufferParameteri.xhtml", Version.GLES32)
cmd void glFramebufferParameteri(GLenum target, GLenum pname, GLint param) {
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(target)
  CheckNonDefaultFramebuffer(framebuffer)
  switch (pname) {
    case GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: {
      framebuffer.DefaultFixedSampleLocations = as!GLboolean(param)
    }
    case GL_FRAMEBUFFER_DEFAULT_HEIGHT: {
      framebuffer.DefaultHeight = param
    }
    case GL_FRAMEBUFFER_DEFAULT_SAMPLES: {
      framebuffer.DefaultSamples = param
    }
    case GL_FRAMEBUFFER_DEFAULT_WIDTH: {
      framebuffer.DefaultWidth = param
    }
    @if(Version.GLES32)
    case GL_FRAMEBUFFER_DEFAULT_LAYERS: {
      framebuffer.DefaultLayers = param
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glFramebufferRenderbuffer.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glFramebufferRenderbuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glFramebufferRenderbuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glFramebufferRenderbuffer.xhtml", Version.GLES32)
cmd void glFramebufferRenderbuffer(GLenum         framebuffer_target,
                                   GLenum         framebuffer_attachment,
                                   GLenum         renderbuffer_target,
                                   RenderbufferId renderbuffer) {
  ctx := GetContext()
  if renderbuffer_target != GL_RENDERBUFFER { glErrorInvalidEnum(renderbuffer_target) }
  // SPEC: Only PDF spec mentions this:
  if (renderbuffer != 0) && !(renderbuffer in ctx.Objects.Renderbuffers) {
    glErrorInvalidOperation_ObjectDoesNotExist!RenderbufferId(renderbuffer)
  }

  attachment := FramebufferAttachment()
  if (renderbuffer != 0) {
    attachment.Type = GL_RENDERBUFFER
    attachment.Renderbuffer = ctx.Objects.Renderbuffers[renderbuffer]
  }
  SetFramebufferAttachment(framebuffer_target, framebuffer_attachment, attachment)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glFramebufferTexture.xhtml", Version.GLES32)
cmd void glFramebufferTexture(GLenum target, GLenum attachment, TextureId texture, GLint level) {
  FramebufferTexture(target, attachment, texture, level)
}

sub void FramebufferTexture(GLenum target, GLenum attachment, TextureId texture, GLint level) {
  ctx := GetContext()
  attachment_info := FramebufferAttachment()
  if (texture != 0) {
    if !(texture in ctx.Objects.Textures) { glErrorInvalidValue!TextureId(texture) }
    attachment_info.Type = GL_TEXTURE
    attachment_info.Texture = ctx.Objects.Textures[texture]
    attachment_info.TextureLevel = level
    attachment_info.Layered = 0 // TODO
  }
  SetFramebufferAttachment(target, attachment, attachment_info)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glFramebufferTexture2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glFramebufferTexture2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glFramebufferTexture2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glFramebufferTexture2D.xhtml", Version.GLES32)
cmd void glFramebufferTexture2D(GLenum    framebuffer_target,
                                GLenum    framebuffer_attachment,
                                GLenum    texture_target,
                                TextureId texture,
                                GLint     level) {
  FramebufferTexture2D(framebuffer_target, framebuffer_attachment, texture_target, texture, level)
}

sub void FramebufferTexture2D(GLenum    framebuffer_target,
                              GLenum    framebuffer_attachment,
                              GLenum    texture_target,
                              TextureId texture,
                              GLint     level) {
  switch (texture_target) {
    case GL_TEXTURE_2D,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: {
      // version 2.0
    }
    @if(Version.GLES31)
    case GL_TEXTURE_2D_MULTISAMPLE: {
    }
    default: {
      glErrorInvalidEnum(texture_target)
    }
  }
  // TODO: Level must be 0 in GLES20

  ctx := GetContext()
  attachment := FramebufferAttachment()
  if (texture != 0) {
    if !(texture in ctx.Objects.Textures) {
      glErrorInvalidOperation_ObjectDoesNotExist!TextureId(texture)
    }
    kind := switch (texture_target) {
      case GL_TEXTURE_2D:
        GL_TEXTURE_2D
      case GL_TEXTURE_2D_MULTISAMPLE:
        GL_TEXTURE_2D_MULTISAMPLE
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
          GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
          GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
        GL_TEXTURE_CUBE_MAP
      default:
        as!GLenum(0)
    }
    // TODO: Handle texture 0
    if ctx.Objects.Textures[texture].Kind != kind { glErrorInvalidOperation() }
    attachment.Type = GL_TEXTURE
    attachment.Texture = ctx.Objects.Textures[texture]
    attachment.TextureLevel = level
    attachment.TextureLayer = CubemapFaceToLayer(texture_target)
  }
  SetFramebufferAttachment(framebuffer_target, framebuffer_attachment, attachment)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glFramebufferTextureLayer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glFramebufferTextureLayer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glFramebufferTextureLayer.xhtml", Version.GLES32)
cmd void glFramebufferTextureLayer(GLenum    target,
                                   GLenum    attachment,
                                   TextureId texture,
                                   GLint     level,
                                   GLint     layer) {
  ctx := GetContext()
  attachment_info := FramebufferAttachment()
  if (texture != 0) {
    if !(texture in ctx.Objects.Textures) { glErrorInvalidValue!TextureId(texture) }
    attachment_info.Type = GL_TEXTURE
    attachment_info.Texture = ctx.Objects.Textures[texture]
    attachment_info.TextureLevel = level
    attachment_info.TextureLayer = layer
  }
  SetFramebufferAttachment(target, attachment, attachment_info)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenFramebuffers.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenFramebuffers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenFramebuffers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenFramebuffers.xhtml", Version.GLES32)
cmd void glGenFramebuffers(GLsizei count, FramebufferId* framebuffers) {
  CheckCountGE!GLsizei(count, 0)
  f := framebuffers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!FramebufferId(?)
    assert(id != 0)
    ctx.Objects.GeneratedNames.Framebuffers[id] = true
    f[i] = id
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenRenderbuffers.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenRenderbuffers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenRenderbuffers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenRenderbuffers.xhtml", Version.GLES32)
cmd void glGenRenderbuffers(GLsizei count, RenderbufferId* renderbuffers) {
  CheckCountGE!GLsizei(count, 0)
  r := renderbuffers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!RenderbufferId(?)
    assert(id != 0)
    ctx.Objects.GeneratedNames.Renderbuffers[id] = true
    r[i] = id
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetFramebufferAttachmentParameteriv.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetFramebufferAttachmentParameteriv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetFramebufferAttachmentParameteriv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetFramebufferAttachmentParameteriv.xhtml", Version.GLES32)
cmd void glGetFramebufferAttachmentParameteriv(GLenum framebuffer_target,
                                               GLenum attachment,
                                               GLenum parameter,
                                               GLint* value) {
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(framebuffer_target)
  a := switch (attachment) {
    case GL_COLOR_ATTACHMENT0, GL_BACK:
      framebuffer.ColorAttachments[0]
    case GL_DEPTH_ATTACHMENT:
      framebuffer.DepthAttachment
    case GL_STENCIL_ATTACHMENT:
      framebuffer.StencilAttachment
    @if(Version.GLES30)
    case GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT11,
        GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT15,
        GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5,
        GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT9: {
      // TODO: if i < 0 || i >= ctx.Constants.MaxColorAttachments { glErrorInvalidOperation() }
      framebuffer.ColorAttachments[as!GLint(attachment - GL_COLOR_ATTACHMENT0)]
    }
    @if(Version.GLES30)
    case GL_DEPTH_STENCIL_ATTACHMENT: {
      // TODO: check framebuffer.DepthAttachment == framebuffer.StencilAttachment
      framebuffer.DepthAttachment
    }
    default: {
      // TODO: glErrorInvalidEnum(attachment)
      framebuffer.ColorAttachments[0]
    }
  }
  if (a.Type == GL_NONE) &&
      (parameter != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) && (parameter != GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) {
    glErrorInvalidOperation()
  }
  switch (parameter) {
    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:           value[0] = as!GLint(a.Type)
    case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
      switch a.Type {
        case GL_NONE:         value[0] = as!GLint(0)
        case GL_TEXTURE:      value[0] = as!GLint(a.Texture.ID)
        case GL_RENDERBUFFER: value[0] = as!GLint(a.Renderbuffer.ID)
      }
    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:         value[0] = as!GLint(a.TextureLevel)
    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: value[0] = ? // TODO
    @if(Version.GLES32)
    case GL_FRAMEBUFFER_ATTACHMENT_LAYERED:               value[0] = as!GLint(a.Layered)
    @if(Version.GLES30)
    case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:         value[0] = as!GLint(a.TextureLayer)
    @if(Version.GLES30)
    case GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE,
        GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE,
        GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE,
        GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE, GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
      value[0] = ?
    default:
      glErrorInvalidEnum(parameter)
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetFramebufferParameteriv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetFramebufferParameteriv.xhtml", Version.GLES32)
cmd void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params) {
  switch (pname) {
    case GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS, GL_FRAMEBUFFER_DEFAULT_HEIGHT,
        GL_FRAMEBUFFER_DEFAULT_SAMPLES, GL_FRAMEBUFFER_DEFAULT_WIDTH: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_FRAMEBUFFER_DEFAULT_LAYERS: {
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }

  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(target)
  CheckNonDefaultFramebuffer(framebuffer)
  params[0] = switch (pname) {
    case GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: as!GLint(framebuffer.DefaultFixedSampleLocations)
    case GL_FRAMEBUFFER_DEFAULT_HEIGHT:                 framebuffer.DefaultHeight
    case GL_FRAMEBUFFER_DEFAULT_SAMPLES:                framebuffer.DefaultSamples
    case GL_FRAMEBUFFER_DEFAULT_WIDTH:                  framebuffer.DefaultWidth
    case GL_FRAMEBUFFER_DEFAULT_LAYERS:                 framebuffer.DefaultLayers
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetRenderbufferParameteriv.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetRenderbufferParameteriv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetRenderbufferParameteriv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetRenderbufferParameteriv.xhtml", Version.GLES32)
cmd void glGetRenderbufferParameteriv(GLenum target, GLenum parameter, GLint* values) {
  switch (target) {
    case GL_RENDERBUFFER: {
      // version 2.0
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (parameter) {
    case GL_RENDERBUFFER_ALPHA_SIZE, GL_RENDERBUFFER_BLUE_SIZE, GL_RENDERBUFFER_DEPTH_SIZE,
        GL_RENDERBUFFER_GREEN_SIZE, GL_RENDERBUFFER_HEIGHT, GL_RENDERBUFFER_INTERNAL_FORMAT,
        GL_RENDERBUFFER_RED_SIZE, GL_RENDERBUFFER_STENCIL_SIZE, GL_RENDERBUFFER_WIDTH: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_RENDERBUFFER_SAMPLES: {
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }

  ctx := GetContext()
  rb := ctx.Bound.Renderbuffer
  if rb == null { glErrorInvalidOperation() }
  values[0] = switch (parameter) {
    case GL_RENDERBUFFER_WIDTH:           as!GLint(rb.Width)
    case GL_RENDERBUFFER_HEIGHT:          as!GLint(rb.Height)
    case GL_RENDERBUFFER_INTERNAL_FORMAT: as!GLint(rb.InternalFormat)
  // TODO:
  // case GL_RENDERBUFFER_RED_SIZE:        ?
  // case GL_RENDERBUFFER_GREEN_SIZE:      ?
  // case GL_RENDERBUFFER_BLUE_SIZE:       ?
  // case GL_RENDERBUFFER_ALPHA_SIZE:      ?
  // case GL_RENDERBUFFER_DEPTH_SIZE:      ?
  // case GL_RENDERBUFFER_STENCIL_SIZE:    ?
  }
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glInvalidateFramebuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glInvalidateFramebuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glInvalidateFramebuffer.xhtml", Version.GLES32)
cmd void glInvalidateFramebuffer(GLenum target, GLsizei count, const GLenum* attachments) {
  InvalidateFramebuffer(target, count, attachments)
}

sub void InvalidateFramebuffer(GLenum target, GLsizei count, const GLenum* attachments) {
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(target)
  a := attachments[0:count]
  if IsDefaultFramebuffer(framebuffer) {
    for i in 0 .. count {
      switch a[i] {
        case GL_COLOR, GL_DEPTH, GL_STENCIL: { }
        default:                             {
          glErrorInvalidEnum(a[i])
        }
      }
    }
  } else {
    for i in 0 .. count {
      switch a[i] {
        case GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10, GL_COLOR_ATTACHMENT11,
            GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14, GL_COLOR_ATTACHMENT15,
            GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4, GL_COLOR_ATTACHMENT5,
            GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8, GL_COLOR_ATTACHMENT9,
            GL_DEPTH_ATTACHMENT, GL_DEPTH_STENCIL_ATTACHMENT, GL_STENCIL_ATTACHMENT: { }
        default:                                                                     {
          glErrorInvalidEnum(a[i])
        }
      }
    }
  }
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glInvalidateSubFramebuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glInvalidateSubFramebuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glInvalidateSubFramebuffer.xhtml", Version.GLES32)
cmd void glInvalidateSubFramebuffer(GLenum        target,
                                    GLsizei       numAttachments,
                                    const GLenum* attachments,
                                    GLint         x,
                                    GLint         y,
                                    GLsizei       width,
                                    GLsizei       height) {
  switch (target) {
    case GL_FRAMEBUFFER: {
      // version 3.0
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }

  // TODO
  read(attachments[0:numAttachments])
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsFramebuffer.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsFramebuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsFramebuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsFramebuffer.xhtml", Version.GLES32)
cmd GLboolean glIsFramebuffer(FramebufferId framebuffer) {

  ctx := GetContext()
  return as!GLboolean(framebuffer in ctx.Objects.Framebuffers)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsRenderbuffer.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsRenderbuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsRenderbuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsRenderbuffer.xhtml", Version.GLES32)
cmd GLboolean glIsRenderbuffer(RenderbufferId renderbuffer) {

  ctx := GetContext()
  return as!GLboolean(renderbuffer in ctx.Objects.Renderbuffers)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glReadBuffer.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glReadBuffer.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glReadBuffer.xhtml", Version.GLES32)
cmd void glReadBuffer(GLenum src) {
  switch (src) {
    case GL_BACK, GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT10,
        GL_COLOR_ATTACHMENT11, GL_COLOR_ATTACHMENT12, GL_COLOR_ATTACHMENT13, GL_COLOR_ATTACHMENT14,
        GL_COLOR_ATTACHMENT15, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4,
        GL_COLOR_ATTACHMENT5, GL_COLOR_ATTACHMENT6, GL_COLOR_ATTACHMENT7, GL_COLOR_ATTACHMENT8,
        GL_COLOR_ATTACHMENT9, GL_NONE: {
      // version 3.0
    }
    default: {
      glErrorInvalidEnum(src)
    }
  }
  framebuffer := GetBoundFramebufferOrErrorInvalidEnum(GL_READ_FRAMEBUFFER)
  framebuffer.ReadBuffer = src
}

sub void checkReadPixels(GLsizei width,
                         GLsizei height,
                         GLenum  format,
                         GLenum  type) {
  switch (format) {
    case GL_ALPHA, GL_RGB, GL_RGBA: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_RED, GL_RED_INTEGER, GL_RG, GL_RG_INTEGER, GL_RGB_INTEGER, GL_LUMINANCE_ALPHA, GL_LUMINANCE: {
    }
    default: {
      glErrorInvalidEnum(format)
    }
  }
  switch (type) {
    case GL_UNSIGNED_SHORT_5_6_5: {
      // version 2.0
      if format != GL_RGB { glErrorInvalidOperation() }
    }
    case GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_5_5_5_1: {
      // version 2.0
      if format != GL_RGBA { glErrorInvalidOperation() }
    }
    case GL_UNSIGNED_BYTE: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_FLOAT, GL_INT, GL_UNSIGNED_INT, GL_UNSIGNED_INT_2_10_10_10_REV, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV: {
      // TODO(dsrbecky) - implement additional 'type compatible with format'
      // validation. PDF spec contains a table with for these.
    }
    default: {
      glErrorInvalidEnum(type)
    }
  }
  CheckSizeGE!GLsizei(width, 0)
  CheckSizeGE!GLsizei(height, 0)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glReadPixels.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glReadPixels.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glReadPixels.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glReadPixels.xhtml", Version.GLES32)
cmd void glReadPixels(GLint   x,
                      GLint   y,
                      GLsizei width,
                      GLsizei height,
                      GLenum  format,
                      GLenum  type,
                      void*   data) {
  checkReadPixels(width, height, format, type)

  ctx := GetContext()
  if (ctx.Bound.PixelPackBuffer == null) && (data != null) {
    requiredSize := uncompressedImageSize(width, height, format, type)
    write(data[0:requiredSize])
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glReadPixels.xhtml", Version.GLES32)
cmd void glReadnPixels(GLint   x,
                       GLint   y,
                       GLsizei width,
                       GLsizei height,
                       GLenum  format,
                       GLenum  type,
                       GLsizei bufSize,
                       void*   data) {
  ReadnPixels(x, y, width, height, format, type, bufSize, data)
}

sub void ReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) {
  checkReadPixels(width, height, format, type)
  ctx := GetContext()
  if (ctx.Bound.PixelPackBuffer == null) && (data != null) {
    requiredSize := uncompressedImageSize(width, height, format, type)
    if as!GLsizei(requiredSize) > bufSize { glErrorInvalidOperation() }
    write(data[0:requiredSize])
  }

  _ = x // TODO
  _ = y // TODO
  _ = width // TODO
  _ = height // TODO
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glRenderbufferStorage.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glRenderbufferStorage.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glRenderbufferStorage.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glRenderbufferStorage.xhtml", Version.GLES32)
cmd void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
  RenderbufferStorageMultisample(target, 0 /* samples */, internalformat, width, height)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glRenderbufferStorageMultisample.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glRenderbufferStorageMultisample.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glRenderbufferStorageMultisample.xhtml", Version.GLES32)
cmd void glRenderbufferStorageMultisample(GLenum  target,
                                          GLsizei samples,
                                          GLenum  internalformat,
                                          GLsizei width,
                                          GLsizei height) {
  RenderbufferStorageMultisample(target, samples, internalformat, width, height)
}

sub void RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
  switch (target) {
    case GL_RENDERBUFFER: {
      // version 2.0
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  // TODO: Not all formats are required to be supported as renderbuffer.
  sizedFormatInfo := GetSizedFormatInfoOrEnumError(internalformat)
  if sizedFormatInfo.Compression != Uncompressed {
    glErrorInvalidEnum(internalformat)
  }
  CheckSizeGE!GLsizei(width, 0)
  CheckSizeGE!GLsizei(height, 0)

  ctx := GetContext()
  CheckLE!GLsizei(width, as!GLsizei(ctx.Constants.MaxRenderbufferSize))
  CheckLE!GLsizei(height, as!GLsizei(ctx.Constants.MaxRenderbufferSize))

  rb := ctx.Bound.Renderbuffer
  if rb == null { glErrorInvalidOperation() }
  rb.InternalFormat = internalformat
  rb.Width = width
  rb.Height = height
  rb.Samples = samples
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glStencilMask.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glStencilMask.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glStencilMask.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glStencilMask.xhtml", Version.GLES32)
cmd void glStencilMask(GLuint mask) {

  ctx := GetContext()
  ctx.Pixel.StencilWritemask = mask
  ctx.Pixel.StencilBackWritemask = mask
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glStencilMaskSeparate.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glStencilMaskSeparate.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glStencilMaskSeparate.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glStencilMaskSeparate.xhtml", Version.GLES32)
cmd void glStencilMaskSeparate(GLenum face, GLuint mask) {
  ctx := GetContext()
  switch (face) {
    case GL_BACK:
      ctx.Pixel.StencilBackWritemask = mask
    case GL_FRONT:
      ctx.Pixel.StencilWritemask = mask
    case GL_FRONT_AND_BACK: {
      ctx.Pixel.StencilWritemask = mask
      ctx.Pixel.StencilBackWritemask = mask
    }
    default: {
      glErrorInvalidEnum(face)
    }
  }
}
