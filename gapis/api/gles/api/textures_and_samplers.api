// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

@internal
class TextureUnit {
  TextureUnitId ID

  // Table 21.9: Textures (selector; state per texture unit)
  ref!Texture Binding2d                 = null
  ref!Texture Binding3d                 = null
  ref!Texture Binding2dArray            = null
  ref!Texture BindingBuffer             = null
  ref!Texture BindingCubeMap            = null
  ref!Texture BindingCubeMapArray       = null
  ref!Texture Binding2dMultisample      = null
  ref!Texture Binding2dMultisampleArray = null
  ref!Texture BindingExternalOes        = null // OES_EGL_image_external
  ref!Sampler SamplerBinding            = null
}

sub ref!TextureUnit NewTextureUnit(TextureUnitId id) {
  ctx := GetContext()
  return new!TextureUnit(
    ID:                         id,
    Binding2d:                  ctx.Objects.Default.Texture2d,
    Binding2dArray:             ctx.Objects.Default.Texture2dArray,
    Binding2dMultisample:       ctx.Objects.Default.Texture2dMultisample,
    Binding2dMultisampleArray:  ctx.Objects.Default.Texture2dMultisampleArray,
    Binding3d:                  ctx.Objects.Default.Texture3d,
    BindingBuffer:              ctx.Objects.Default.TextureBuffer,
    BindingCubeMap:             ctx.Objects.Default.TextureCubeMap,
    BindingCubeMapArray:        ctx.Objects.Default.TextureCubeMapArray,
    BindingExternalOes:         ctx.Objects.Default.TextureExternalOes,
  )
}

@internal
@resource
class Texture {
  TextureId                 ID

  GLenum                    Kind
  map!(GLint, Level)        Levels

  // Table 21.10: Textures (state per texture object)
  GLenum         SwizzleR                = GL_RED
  GLenum         SwizzleG                = GL_GREEN
  GLenum         SwizzleB                = GL_BLUE
  GLenum         SwizzleA                = GL_ALPHA
  @unused Vec4f  BorderColor             = Vec4f(0.0, 0.0, 0.0, 0.0)
  GLenum         MinFilter               = GL_NEAREST_MIPMAP_LINEAR
  GLenum         MagFilter               = GL_LINEAR
  GLenum         WrapS                   = GL_REPEAT
  GLenum         WrapT                   = GL_REPEAT
  GLenum         WrapR                   = GL_REPEAT
  GLfloat        MinLod                  = -1000
  GLfloat        MaxLod                  = 1000
  GLint          BaseLevel               = 0
  GLint          MaxLevel                = 1000
  GLenum         DepthStencilTextureMode = GL_DEPTH_COMPONENT
  GLenum         CompareMode             = GL_NONE
  GLenum         CompareFunc             = GL_LEQUAL
  GLboolean      ImmutableFormat         = GL_FALSE
  @unused GLuint ImmutableLevels         = 0
  @unused string Label

  // EXT/texture_filter_anisotropic
  GLfloat MaxAnisotropy = 1.0

  // GL_OES_EGL_image
  // EGL image which is used as storage for this texture.
  // TODO: Standard glTex* methods which define new storage should clear this.
  @unused ref!EGLImage EGLImage
}

@internal
class Level {
  map!(GLint, ref!Image) Layers
}

@internal
class Image {
  GLsizei        Width
  GLsizei        Height
  GLsizei        Samples
  GLboolean      FixedSampleLocations
  // GPU format of the texture including bit-sizes of the channels.
  // This is unrelated to the format of the data passed to the API.
  @unused GLenum SizedFormat

  @internal u8[] Data
  // Tuple of (format, type) describing the Data field above.
  // This describes the format of the data the user passed in,
  // not the format of the data stored on the GPU (sizedFormat).
  // TODO: We should use the GPU format, but that needs conversions.
  // One of the following:
  //   (GL_NONE, GL_NONE) - No data was uploaded yet.
  //   (unsizedFormat, ty) - Uncompressed data.
  //   (sizedFormat, GL_NONE) - Compressed data.
  @unused GLenum DataFormat
  @unused GLenum DataType
}

@internal
class Sampler {
  SamplerId ID

  // Table 21.12: Textures (state per sampler object)
  @unused Vec4f  BorderColor = Vec4f(0.0, 0.0, 0.0, 0.0)
  GLenum         MinFilter   = GL_NEAREST_MIPMAP_LINEAR
  GLenum         MagFilter   = GL_LINEAR
  GLenum         WrapS       = GL_REPEAT
  GLenum         WrapT       = GL_REPEAT
  GLenum         WrapR       = GL_REPEAT
  GLfloat        MinLod      = -1000
  GLfloat        MaxLod      = 1000
  GLenum         CompareMode = GL_NONE
  GLenum         CompareFunc = GL_LEQUAL
  @unused string Label

  // EXT/texture_filter_anisotropic
  GLfloat MaxAnisotropy = 1.0
}

@internal
class PixelStorageState {
  // Table 21.18: Pixels
  GLint ImageHeight = 0
  GLint SkipImages  = 0
  GLint RowLength   = 0
  GLint SkipRows    = 0
  GLint SkipPixels  = 0
  GLint Alignment   = 4
}

@internal
class ImageUnit {
  // Table 21.33: Image State (state per image unit)
  TextureId Name    = 0
  GLint     Level   = 0
  GLboolean Layered = GL_FALSE
  GLint     Layer   = 0
  GLenum    Access  = GL_READ_ONLY
  GLenum    Format  = GL_R32UI
}

// The spec maps cubemap faces to layers 0..5 in the exact order of GLenum values.
sub GLint CubemapFaceToLayer(GLenum target) {
  return switch (target) {
    case GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      as!GLint(target) - as!GLint(GL_TEXTURE_CUBE_MAP_POSITIVE_X)
    default:
      as!GLint(0)
  }
}

sub ref!Texture GetBoundTextureOrErrorInvalidEnum(GLenum target) {
  ctx := GetContext()
  return GetBoundTextureForUnit(ctx.Bound.TextureUnit, target)
}

sub ref!Texture GetBoundTextureForUnit(ref!TextureUnit tu, GLenum target) {
  return switch (target) {
    @if(Version.GLES20)
    case GL_TEXTURE_2D: {
      tu.Binding2d
    }
    @if(Version.GLES20)
    case GL_TEXTURE_EXTERNAL_OES: {
      tu.BindingExternalOes
    }
    @if(Version.GLES30)
    case GL_TEXTURE_2D_ARRAY: {
      tu.Binding2dArray
    }
    @if(Version.GLES31)
    case GL_TEXTURE_2D_MULTISAMPLE: {
      tu.Binding2dMultisample
    }
    @if(Version.GLES32)
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      tu.Binding2dMultisampleArray
    }
    @if(Version.GLES30)
    case GL_TEXTURE_3D: {
      tu.Binding3d
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BUFFER: {
      tu.BindingBuffer
    }
    @if(Version.GLES20)
    case GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      tu.BindingCubeMap
    }
    @if(Version.GLES32)
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
      tu.BindingCubeMapArray
    }
    default: {
      // TODO: glErrorInvalidEnum(target)
      tu.Binding2d
    }
  }
}

@ignore_unreachables
sub GLenum GetTextureTargetFromSamplerType(GLenum samplerType) {
	return switch (samplerType) {
	case GL_INT_SAMPLER_2D, GL_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_2D, GL_SAMPLER_2D_SHADOW:
		GL_TEXTURE_2D
	case GL_INT_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY_SHADOW:
		GL_TEXTURE_2D_ARRAY
	case GL_INT_SAMPLER_2D_MULTISAMPLE, GL_SAMPLER_2D_MULTISAMPLE, GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:
		GL_TEXTURE_2D_MULTISAMPLE
	case GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY, GL_SAMPLER_2D_MULTISAMPLE_ARRAY, GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY:
		GL_TEXTURE_2D_MULTISAMPLE_ARRAY
	case GL_INT_SAMPLER_3D, GL_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_3D:
		GL_TEXTURE_3D
	case GL_INT_SAMPLER_BUFFER, GL_SAMPLER_BUFFER, GL_UNSIGNED_INT_SAMPLER_BUFFER:
		GL_TEXTURE_BUFFER
	case GL_INT_SAMPLER_CUBE, GL_SAMPLER_CUBE, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_SAMPLER_CUBE_SHADOW:
		GL_TEXTURE_CUBE_MAP
	case GL_INT_SAMPLER_CUBE_MAP_ARRAY, GL_SAMPLER_CUBE_MAP_ARRAY, GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY, GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW:
		GL_TEXTURE_CUBE_MAP_ARRAY
	case GL_SAMPLER_EXTERNAL_OES:
		GL_TEXTURE_EXTERNAL_OES
  default:
    GL_NONE
	}
}

sub SizedFormatInfo GetSizedFormatInfoOrEnumError(GLenum internalformat) {
  info := GetSizedFormatInfo(internalformat)
  if info.UnsizedFormat == GL_NONE {
    glErrorInvalidEnum(internalformat)
  }
  return info
}

@ignore_unreachables
sub SizedFormatInfo GetSizedFormatInfoOrValueError(GLint internalformat) {
  info := GetSizedFormatInfo(as!GLenum(internalformat))
  if info.UnsizedFormat == GL_NONE {
    glErrorInvalidValue!GLint(internalformat)
  }
  return info
}

sub UnsizedFormatInfo GetUnsizedFormatInfoOrEnumError(GLenum format) {
  info := GetUnsizedFormatInfo(format)
  if info.Count == 0 {
    glErrorInvalidEnum(format)
  }
  return info
}

@internal
bitfield TexImageFlags {
  IsCompressedTexImageCmd = 1,
  IsCopyTexImageCmd = 2,
  IsTexImageCmd = 4,
  IsTexStorageCmd = 8,
  HasSubModifier = 16,
  Has3DModifier = 32,
  HasMultisampleModifier = 64,
}

// Uber-function to handle all texture image specification commands.
sub void TexImage(TexImageFlags  flags,
                  GLenum         target,
                  // Offsets
                  GLint          loffset,
                  GLint          xoffset,
                  GLint          yoffset,
                  GLint          zoffset,
                  // Dimensions
                  GLsizei        levels,
                  GLsizei        width,
                  GLsizei        height,
                  GLsizei        depth,
                  GLint          border,
                  GLsizei        samples,
                  GLboolean      fixedsamplelocations,
                  // Format&data
                  GLenum         sized_format,
                  GLenum         data_format,
                  GLenum         data_type,
                  GLsizei        data_size,
                  TexturePointer data) {
  isCompressedTexImageCmd := IsCompressedTexImageCmd in flags
  isCopyTexImageCmd := IsCopyTexImageCmd in flags
  isTexImageCmd := IsTexImageCmd in flags
  isTexStorageCmd := IsTexStorageCmd in flags
  hasSubModifier := HasSubModifier in flags
  has3DModifier := Has3DModifier in flags
  hasMultisampleModifier := HasMultisampleModifier in flags

  sfBox := Image(SizedFormat: sized_format)

  // Check target
  if hasMultisampleModifier {
    if has3DModifier {
      if target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY { glErrorInvalidEnum(target) }
    } else {
      if target != GL_TEXTURE_2D_MULTISAMPLE { glErrorInvalidEnum(target) }
    }
  } else {
    if has3DModifier {
      switch (target) {
        case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY: { }
        default: { glErrorInvalidEnum(target) }
      }
    } else {
      if isTexStorageCmd {
        switch (target) {
          case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: { }
          default: { glErrorInvalidEnum(target) }
        }
      } else {
        switch (target) {
          case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: { }
          default: { glErrorInvalidEnum(target) }
        }
      }
    }
  }
  t := GetBoundTextureOrErrorInvalidEnum(target)

  // Check offsets and sizes
  CheckGE!GLint(loffset, 0)
  CheckGE!GLint(xoffset, 0)
  CheckGE!GLint(yoffset, 0)
  CheckGE!GLint(zoffset, 0)
  CheckGE!GLsizei(levels, 1)
  CheckSizeGE!GLsizei(width, 0)
  CheckSizeGE!GLsizei(height, 0)
  CheckSizeGE!GLsizei(depth, 0)
  CheckEQ!GLint(border, 0)
  CheckGE!GLsizei(data_size, 0)
  switch target {
    case GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      CheckEQ!GLsizei(width, height)
    }
    default: { }
  }

  // Check the data_format and data_type
  if isTexImageCmd {
    _ = GetUnsizedFormatInfoOrEnumError(data_format)
    CheckTextureDataType(data_type)
  }

  // Check the sized_format
  if !hasSubModifier {
    if isTexImageCmd && as!GLenum(sized_format) == data_format {
      sf := GetSizedFormatFromTuple(data_format, data_type)
      if sf == GL_NONE { glErrorInvalidOperation() } // Invalid combination of format and type
      sfBox.SizedFormat = sf // Legacy - sized format is inferred from data format and type
    } else {
      sizedFormatInfo := GetSizedFormatInfoOrEnumError(sized_format)
      isCompressedFmt := sizedFormatInfo.Compression != Uncompressed
      if isCompressedTexImageCmd {
        if !isCompressedFmt { glErrorInvalidEnum(sized_format) } // Requires compressed format
      }
      if isCopyTexImageCmd || isTexImageCmd || hasMultisampleModifier {
        if isCompressedFmt { glErrorInvalidEnum(sized_format) } // Requires uncompressed format
      }
    }
  }

  // We need to do all checks before we start modifying state.
  cubemap_layer := CubemapFaceToLayer(target)
  for l in (0 .. as!GLint(levels)) {
    for z in (0 .. as!GLint(depth)) {
      if hasSubModifier {
        i := t.Levels[loffset + l].Layers[zoffset + z + cubemap_layer]
        if (i == null) { glErrorInvalidOperation() }
        CheckLE!GLsizei((as!GLsizei(xoffset) + width), i.Width)
        CheckLE!GLsizei((as!GLsizei(yoffset) + height), i.Height)
      }
    }
  }

  if isTexStorageCmd {
    t.Levels = Texture().Levels
    t.ImmutableFormat = GL_TRUE
  }

  ctx := GetContext()
  for l in (0 .. as!GLint(levels)) {
    tmpLevel := t.Levels[loffset + l]
    // Depth decreases with each level for 3D textures, but not for arrays.
    mipDepth := max!GLsizei(1, depth >> as!u32(l))
    for z in (0 .. as!GLint(Select!GLsizei(target == GL_TEXTURE_3D, mipDepth, depth))) {
      if !hasSubModifier {
        // Initialize the image with the provided parameters
        tmpLevel.Layers[zoffset + z + cubemap_layer] = new!Image(
          Width: max!GLsizei(1, width >> as!u32(l)),
          Height: max!GLsizei(1, height >> as!u32(l)),
          Samples: samples,
          FixedSampleLocations: fixedsamplelocations,
          SizedFormat: sfBox.SizedFormat,
          DataFormat: data_format,
          DataType: data_type)
      }

      // Update the content of the image
      img := tmpLevel.Layers[zoffset + z + cubemap_layer]
      if isTexImageCmd {
        src_skip_images := Select!GLint(has3DModifier, ctx.Other.Unpack.SkipImages, 0) + z
        UpdateImageData(img, xoffset, yoffset, width, height,
                        src_skip_images, data_format, data_type, data)
      } else if isCompressedTexImageCmd {
        if (ctx.Bound.PixelUnpackBuffer == null) && (data != null) {
          // TODO: Implement sub-range updates
          img.Data = clone(as!u8*(data)[0:data_size])
          img.DataFormat = data_format
        }
      }
    }
    t.Levels[loffset + l] = tmpLevel
  }
}

sub void UpdateImageData(ref!Image      dst_image,
                         GLint          dst_xoffset,
                         GLint          dst_yoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLint          src_skip_images,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  ctx := GetContext()
  unpack := ctx.Other.Unpack
  url := SelectNonZero!GLint(unpack.RowLength, as!GLint(width))
  pixel_size := as!GLint(uncompressedPixelSize(format, type))

  src_row_size := Align!GLint(url * pixel_size, unpack.Alignment)
  src_image_size := SelectNonZero!GLint(unpack.ImageHeight, as!GLint(height)) * src_row_size
  src_offset := (unpack.SkipPixels * pixel_size) +
                (unpack.SkipRows * src_row_size) +
                (src_skip_images * src_image_size)

  dst_row_size := as!GLint(dst_image.Width) * pixel_size
  dst_image_size := as!GLint(dst_image.Height) * dst_row_size
  dst_offset := (dst_xoffset * pixel_size) + (dst_yoffset * dst_row_size)

  // Initialize the buffer if we have not used the image before or
  // if the format changed to one with different size per texel.
  // TODO: Do this properly using data conversion.
  if len(dst_image.Data) != as!s32(dst_image_size) {
    dst_image.Data = make!u8(dst_image_size)
  }
  dst_image.DataFormat = format
  dst_image.DataType = type

  pbo := ctx.Bound.PixelUnpackBuffer
  copy_size := as!GLint(width) * pixel_size
  for y in (0 .. as!GLint(height)) {
    dst := dst_offset + (dst_row_size * y)
    if pbo == null {
      if data != null {
        src := src_offset + (src_row_size * y)
        copy(dst_image.Data[dst:dst + copy_size], as!u8*(data)[src:src + copy_size])
      }
    } else {
      src := as!u64(data) + as!u64(src_offset + (src_row_size * y))
      assert((src + as!u64(copy_size)) <= len(pbo.Data))
      copy(dst_image.Data[dst:dst + copy_size], pbo.Data[src:src + as!u64(copy_size)])
    }
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glActiveTexture.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glActiveTexture.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glActiveTexture.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glActiveTexture.xhtml", Version.GLES32)
cmd void glActiveTexture(GLenum unit) {
  // TODO: Tidy this. This switch case is preserved for the snippet system.
  switch (unit) {
    case GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13,
        GL_TEXTURE14, GL_TEXTURE15, GL_TEXTURE16, GL_TEXTURE17, GL_TEXTURE18, GL_TEXTURE19,
        GL_TEXTURE2, GL_TEXTURE20, GL_TEXTURE21, GL_TEXTURE22, GL_TEXTURE23, GL_TEXTURE24,
        GL_TEXTURE25, GL_TEXTURE26, GL_TEXTURE27, GL_TEXTURE28, GL_TEXTURE29, GL_TEXTURE3,
        GL_TEXTURE30, GL_TEXTURE31, GL_TEXTURE4, GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7,
        GL_TEXTURE8, GL_TEXTURE9: {
      // version 2.0
    }
    default: {
      // Higher texture numbers are still valid, but they do not have GLenum entries.
    }
  }
  ctx := GetContext()
  tu := ctx.Objects.TextureUnits[as!TextureUnitId(unit - GL_TEXTURE0)]
  if tu == null { glErrorInvalidEnum(unit) }
  ctx.Bound.TextureUnit = tu
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindImageTexture.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindImageTexture.xhtml", Version.GLES32)
cmd void glBindImageTexture(GLuint    unit,
                            TextureId texture,
                            GLint     level,
                            GLboolean layered,
                            GLint     layer,
                            GLenum    access,
                            GLenum    format) {
  switch (access) {
    case GL_READ_ONLY, GL_READ_WRITE, GL_WRITE_ONLY: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(access)
    }
  }
  switch (format) {
    case GL_R32F, GL_R32I, GL_R32UI, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI, GL_RGBA32F, GL_RGBA32I,
        GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI, GL_RGBA8_SNORM: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(format)
    }
  }
  ctx := GetContext()
  ctx.Objects.ImageUnits[unit] = ImageUnit(
    Name:     texture,
    Level:    level,
    Layered:  layered,
    Layer:    layer,
    Access:   access,
    Format:   format
  )
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindSampler.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindSampler.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindSampler.xhtml", Version.GLES32)
cmd void glBindSampler(GLuint index, SamplerId sampler) {
  ctx := GetContext()
  tu := ctx.Objects.TextureUnits[as!TextureUnitId(index)]
  if tu == null { glErrorInvalidObjectName!SamplerId(sampler) }
  tu.SamplerBinding = GetOrCreateSampler(sampler)
}

sub ref!Sampler GetOrCreateSampler(SamplerId id) {
  ctx := GetContext()
  if (id != 0) && (ctx.Objects.Samplers[id] == null) {
    ctx.Objects.Samplers[id] = new!Sampler(ID: id)
    ctx.Objects.GeneratedNames.Samplers[id] = true
  }
  return ctx.Objects.Samplers[id]
}

sub ref!Texture GetOrCreateTexture(GLenum target, TextureId texture, ref!Texture defaultTexture) {
  ctx := GetContext()
  if (texture != 0) {
    // Create the texture if it does not exist already
    if (ctx.Objects.Textures[texture] == null) {
      if target == GL_TEXTURE_EXTERNAL_OES {
        ctx.Objects.Textures[texture] = new!Texture(
          ID:         texture,
          WrapS:      GL_CLAMP_TO_EDGE,
          WrapT:      GL_CLAMP_TO_EDGE,
          MinFilter:  GL_LINEAR)
      } else {
        ctx.Objects.Textures[texture] = new!Texture(ID: texture)
      }
    }
    ctx.Objects.GeneratedNames.Textures[texture] = true

    // Set or check the kind of the texture
    t := ctx.Objects.Textures[texture]
    if t.Kind == as!GLenum(0) {
      t.Kind = target
    } else {
      if t.Kind != target { glErrorInvalidOperation() }
    }
  }
  return Select!ref!Texture(texture != 0, ctx.Objects.Textures[texture], defaultTexture)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindTexture.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindTexture.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindTexture.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindTexture.xhtml", Version.GLES32)
cmd void glBindTexture(GLenum target, TextureId texture) {
  ctx := GetContext()
  tu := ctx.Bound.TextureUnit
  switch (target) {
    @if(Version.GLES20)
    case GL_TEXTURE_2D: {
      tu.Binding2d = GetOrCreateTexture(target, texture, ctx.Objects.Default.Texture2d)
    }
    @if(Version.GLES20)
    case GL_TEXTURE_EXTERNAL_OES: {
      tu.BindingExternalOes = GetOrCreateTexture(target, texture, ctx.Objects.Default.TextureExternalOes)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_2D_ARRAY: {
      tu.Binding2dArray = GetOrCreateTexture(target, texture, ctx.Objects.Default.Texture2dArray)
    }
    @if(Version.GLES31)
    case GL_TEXTURE_2D_MULTISAMPLE: {
      tu.Binding2dMultisample = GetOrCreateTexture(target, texture, ctx.Objects.Default.Texture2dMultisample)
    }
    @if(Version.GLES32)
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      tu.Binding2dMultisampleArray = GetOrCreateTexture(target, texture, ctx.Objects.Default.Texture2dMultisampleArray)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_3D: {
      tu.Binding3d = GetOrCreateTexture(target, texture, ctx.Objects.Default.Texture3d)
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BUFFER: {
      tu.BindingBuffer = GetOrCreateTexture(target, texture, ctx.Objects.Default.TextureBuffer)
    }
    @if(Version.GLES20)
    case GL_TEXTURE_CUBE_MAP: {
      tu.BindingCubeMap = GetOrCreateTexture(target, texture, ctx.Objects.Default.TextureCubeMap)
    }
    @if(Version.GLES32)
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
      tu.BindingCubeMapArray = GetOrCreateTexture(target, texture, ctx.Objects.Default.TextureCubeMapArray)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCompressedTexImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexImage2D.xhtml", Version.GLES32)
cmd void glCompressedTexImage2D(GLenum         target,
                                GLint          level,
                                GLenum         internalformat,
                                GLsizei        width,
                                GLsizei        height,
                                GLint          border,
                                GLsizei        image_size,
                                TexturePointer data) {
  TexImage(IsCompressedTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, 0, GL_TRUE, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexImage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexImage3D.xhtml", Version.GLES32)
cmd void glCompressedTexImage3D(GLenum         target,
                                GLint          level,
                                GLenum         internalformat,
                                GLsizei        width,
                                GLsizei        height,
                                GLsizei        depth,
                                GLint          border,
                                GLsizei        image_size,
                                TexturePointer data) {
  CompressedTexImage3D(target, level, internalformat, width, height, depth, border, image_size, data)
}

sub void CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei image_size, TexturePointer data) {
  TexImage(IsCompressedTexImageCmd | Has3DModifier, target,
           level, 0, 0, 0, // Offsets
           1, width, height, depth, border, 0, GL_TRUE, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCompressedTexSubImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexSubImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexSubImage2D.xhtml", Version.GLES32)
cmd void glCompressedTexSubImage2D(GLenum         target,
                                   GLint          level,
                                   GLint          xoffset,
                                   GLint          yoffset,
                                   GLsizei        width,
                                   GLsizei        height,
                                   GLenum         internalformat,
                                   GLsizei        image_size,
                                   TexturePointer data) {
  TexImage(IsCompressedTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, 0, GL_TRUE, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexSubImage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexSubImage3D.xhtml", Version.GLES32)
cmd void glCompressedTexSubImage3D(GLenum         target,
                                   GLint          level,
                                   GLint          xoffset,
                                   GLint          yoffset,
                                   GLint          zoffset,
                                   GLsizei        width,
                                   GLsizei        height,
                                   GLsizei        depth,
                                   GLenum         internalformat,
                                   GLsizei        image_size,
                                   TexturePointer data) {
  CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, internalformat, image_size, data)
}

sub void CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum internalformat, GLsizei image_size, TexturePointer data) {
  TexImage(IsCompressedTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, depth, 0, 0, GL_TRUE, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyImageSubData.xhtml", Version.GLES32)
cmd void glCopyImageSubData(SrcImageId srcName,
                            GLenum     srcTarget,
                            GLint      srcLevel,
                            GLint      srcX,
                            GLint      srcY,
                            GLint      srcZ,
                            DstImageId dstName,
                            GLenum     dstTarget,
                            GLint      dstLevel,
                            GLint      dstX,
                            GLint      dstY,
                            GLint      dstZ,
                            GLsizei    srcWidth,
                            GLsizei    srcHeight,
                            GLsizei    srcDepth) {
  CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
}

sub void CopyImageSubData(SrcImageId  srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, DstImageId  dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
  switch (srcTarget) {
    case GL_RENDERBUFFER, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
        GL_TEXTURE_CUBE_MAP_ARRAY: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(srcTarget)
    }
  }
  switch (dstTarget) {
    case GL_RENDERBUFFER, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
        GL_TEXTURE_CUBE_MAP_ARRAY: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(dstTarget)
    }
  }

  _ = srcName // TODO
  _ = srcLevel // TODO
  _ = srcX // TODO
  _ = srcY // TODO
  _ = srcZ // TODO
  _ = dstName // TODO
  _ = dstLevel // TODO
  _ = dstX // TODO
  _ = dstY // TODO
  _ = dstZ // TODO
  _ = srcWidth // TODO
  _ = srcHeight // TODO
  _ = srcDepth // TODO
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCopyTexImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexImage2D.xhtml", Version.GLES32)
cmd void glCopyTexImage2D(GLenum  target,
                          GLint   level,
                          GLenum  internalformat,
                          GLint   x,
                          GLint   y,
                          GLsizei width,
                          GLsizei height,
                          GLint   border) {
  TexImage(IsCopyTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, 0, GL_TRUE, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCopyTexSubImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexSubImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexSubImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexSubImage2D.xhtml", Version.GLES32)
cmd void glCopyTexSubImage2D(GLenum  target,
                             GLint   level,
                             GLint   xoffset,
                             GLint   yoffset,
                             GLint   x,
                             GLint   y,
                             GLsizei width,
                             GLsizei height) {
  TexImage(IsCopyTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, 0, GL_TRUE, // Dimensions
           GL_NONE, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexSubImage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexSubImage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexSubImage3D.xhtml", Version.GLES32)
cmd void glCopyTexSubImage3D(GLenum  target,
                             GLint   level,
                             GLint   xoffset,
                             GLint   yoffset,
                             GLint   zoffset,
                             GLint   x,
                             GLint   y,
                             GLsizei width,
                             GLsizei height) {
  CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height)
}

sub void CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  TexImage(IsCopyTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, 1, 0, 0, GL_TRUE, // Dimensions
           GL_NONE, GL_NONE, GL_NONE, 0, null) // Format&data
  _ = x // TODO
  _ = y // TODO
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSamplers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteSamplers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteSamplers.xhtml", Version.GLES32)
cmd void glDeleteSamplers(GLsizei count, const SamplerId* samplers) {
  CheckCountGE!GLsizei(count, 0)
  s := samplers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := s[i]
    if id != 0 {
      delete(ctx.Objects.Samplers, id)
      delete(ctx.Objects.GeneratedNames.Samplers, id)
    }
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteTextures.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteTextures.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteTextures.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteTextures.xhtml", Version.GLES32)
cmd void glDeleteTextures(GLsizei count, const TextureId* textures) {
  CheckCountGE!GLsizei(count, 0)
  t := textures[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := t[i]
    if id != 0 {
      delete(ctx.Objects.Textures, id)
      delete(ctx.Objects.GeneratedNames.Textures, id)
    }
    // TODO: Unbind from all texture units.
  }
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenSamplers.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenSamplers.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenSamplers.xhtml", Version.GLES32)
cmd void glGenSamplers(GLsizei count, SamplerId* samplers) {
  CheckCountGE!GLsizei(count, 0)
  s := samplers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!SamplerId(?)
    assert(id != 0)
    ctx.Objects.GeneratedNames.Samplers[id] = true
    s[i] = id
  }
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenTextures.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenTextures.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenTextures.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenTextures.xhtml", Version.GLES32)
cmd void glGenTextures(GLsizei count, TextureId* textures) {
  CheckCountGE!GLsizei(count, 0)
  t := textures[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!TextureId(?)
    assert(id != 0)
    ctx.Objects.GeneratedNames.Textures[id] = true
    t[i] = id
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenerateMipmap.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenerateMipmap.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenerateMipmap.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenerateMipmap.xhtml", Version.GLES32)
cmd void glGenerateMipmap(GLenum target) {
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D: {
    }
    @if(Version.GLES32)
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }

  texture := GetBoundTextureOrErrorInvalidEnum(target)
  if texture != null {
    for _, levelIndex, level in texture.Levels {
      for _, layerIndex, layer in level.Layers {
        if layer.Data == null {
          layer.Data = ReadGPUTextureData(texture, levelIndex, layerIndex)
        } else {
          copy(layer.Data, ReadGPUTextureData(texture, levelIndex, layerIndex))
        }
      }
    }
  }
}

sub void GetSamplerParameterv!T(SamplerId sampler, GLenum pname, T* params) {
  s := GetOrCreateSampler(sampler)
  switch (pname) {
    case GL_TEXTURE_COMPARE_FUNC: params[0] = as!T(s.CompareFunc)
    case GL_TEXTURE_COMPARE_MODE: params[0] = as!T(s.CompareMode)
    case GL_TEXTURE_MIN_FILTER:   params[0] = as!T(s.MinFilter)
    case GL_TEXTURE_MAG_FILTER:   params[0] = as!T(s.MagFilter)
    case GL_TEXTURE_MIN_LOD:      params[0] = as!T(s.MinLod)
    case GL_TEXTURE_MAX_LOD:      params[0] = as!T(s.MaxLod)
    case GL_TEXTURE_WRAP_R:       params[0] = as!T(s.WrapR)
    case GL_TEXTURE_WRAP_S:       params[0] = as!T(s.WrapS)
    case GL_TEXTURE_WRAP_T:       params[0] = as!T(s.WrapT)
    @if(Version.GLES32)
    case GL_TEXTURE_BORDER_COLOR: {
      // TODO: Different behaviour based on the I suffix.
      p := params[0:4]
      p[0] = as!T(s.BorderColor[0])
      p[1] = as!T(s.BorderColor[1])
      p[2] = as!T(s.BorderColor[2])
      p[3] = as!T(s.BorderColor[3])
    }
    @if(Extension.GL_EXT_texture_filter_anisotropic)
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      params[0] = as!T(s.MaxAnisotropy)
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", Version.GLES32)
cmd void glGetSamplerParameterIiv(SamplerId sampler, GLenum pname, GLint* params) {
  GetSamplerParameterIiv(sampler, pname, params)
}

sub void GetSamplerParameterIiv(SamplerId sampler, GLenum pname, GLint* params) {
  GetSamplerParameterv!GLint(sampler, pname, params)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", Version.GLES32)
cmd void glGetSamplerParameterIuiv(SamplerId sampler, GLenum pname, GLuint* params) {
  GetSamplerParameterIuiv(sampler, pname, params)
}

sub void GetSamplerParameterIuiv(SamplerId sampler, GLenum pname, GLuint* params) {
  GetSamplerParameterv!GLuint(sampler, pname, params)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", Version.GLES32)
cmd void glGetSamplerParameterfv(SamplerId sampler, GLenum pname, GLfloat* params) {
  GetSamplerParameterv!GLfloat(sampler, pname, params)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", Version.GLES32)
cmd void glGetSamplerParameteriv(SamplerId sampler, GLenum pname, GLint* params) {
  GetSamplerParameterv!GLint(sampler, pname, params)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexLevelParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexLevelParameter.xhtml", Version.GLES32)
cmd void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) {
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_3D,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_ARRAY: {
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (pname) {
    case GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_BLUE_TYPE,
        GL_TEXTURE_COMPRESSED, GL_TEXTURE_DEPTH, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_DEPTH_TYPE,
        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_GREEN_TYPE,
        GL_TEXTURE_HEIGHT, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_RED_TYPE,
        GL_TEXTURE_SAMPLES, GL_TEXTURE_SHARED_SIZE, GL_TEXTURE_STENCIL_SIZE, GL_TEXTURE_WIDTH: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BUFFER_DATA_STORE_BINDING, GL_TEXTURE_BUFFER_OFFSET, GL_TEXTURE_BUFFER_SIZE: {
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexLevelParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexLevelParameter.xhtml", Version.GLES32)
cmd void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) {
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_3D,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_ARRAY: {
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (pname) {
    case GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_BLUE_TYPE,
        GL_TEXTURE_COMPRESSED, GL_TEXTURE_DEPTH, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_DEPTH_TYPE,
        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_GREEN_TYPE,
        GL_TEXTURE_HEIGHT, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_RED_TYPE,
        GL_TEXTURE_SAMPLES, GL_TEXTURE_SHARED_SIZE, GL_TEXTURE_STENCIL_SIZE, GL_TEXTURE_WIDTH: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BUFFER_DATA_STORE_BINDING, GL_TEXTURE_BUFFER_OFFSET, GL_TEXTURE_BUFFER_SIZE: {
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

sub void GetTexParameter!T(GLenum target, GLenum parameter, T* params) {
  // TODO: Remove and rely on the switch in GetBoundTextureOrErrorInvalidEnum.
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D: {
    }
    @if(Version.GLES31)
    case GL_TEXTURE_2D_MULTISAMPLE: {
    }
    @if(Version.GLES32)
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY: {
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  t := GetBoundTextureOrErrorInvalidEnum(target)
  switch (parameter) {
    @if(Version.GLES20)
    case GL_TEXTURE_MAG_FILTER: {
      params[0] = as!T(t.MagFilter)
    }
    @if(Version.GLES20)
    case GL_TEXTURE_MIN_FILTER: {
      params[0] = as!T(t.MinFilter)
    }
    @if(Version.GLES20)
    case GL_TEXTURE_WRAP_S: {
      params[0] = as!T(t.WrapS)
    }
    @if(Version.GLES20)
    case GL_TEXTURE_WRAP_T: {
      params[0] = as!T(t.WrapT)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_BASE_LEVEL: {
      params[0] = as!T(t.BaseLevel)
    }
    @if(Version.GLES30 || Extension.GL_EXT_shadow_samplers)
    case GL_TEXTURE_COMPARE_FUNC: {
      params[0] = as!T(t.CompareFunc)
    }
    @if(Version.GLES30 || Extension.GL_EXT_shadow_samplers)
    case GL_TEXTURE_COMPARE_MODE: {
      params[0] = as!T(t.CompareMode)
    }
    @if(Version.GLES30 || Extension.GL_EXT_texture_storage)
    case GL_TEXTURE_IMMUTABLE_FORMAT: {
      params[0] = as!T(t.ImmutableFormat)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MAX_LEVEL: {
      params[0] = as!T(t.MaxLevel)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MAX_LOD: {
      params[0] = as!T(t.MaxLod)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MIN_LOD: {
      params[0] = as!T(t.MinLod)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_A: {
      params[0] = as!T(t.SwizzleA)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_B: {
      params[0] = as!T(t.SwizzleB)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_G: {
      params[0] = as!T(t.SwizzleG)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_R: {
      params[0] = as!T(t.SwizzleR)
    }
    @if(Version.GLES30)
    case GL_TEXTURE_WRAP_R: {
      params[0] = as!T(t.WrapR)
    }
    @if(Version.GLES31)
    case GL_DEPTH_STENCIL_TEXTURE_MODE: {
      params[0] = as!T(t.DepthStencilTextureMode)
    }
    @if(Version.GLES31)
    case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: {
      params[0] = ? // TODO
    }
    @if(Version.GLES31)
    case GL_TEXTURE_IMMUTABLE_LEVELS: {
      params[0] = as!T(t.ImmutableLevels)
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BORDER_COLOR: {
      // TODO: Depends on the I suffix
      p := params[0:4]
      p[0] = as!T(t.BorderColor[0])
      p[1] = as!T(t.BorderColor[1])
      p[2] = as!T(t.BorderColor[2])
      p[3] = as!T(t.BorderColor[3])
    }
    @if(Extension.GL_EXT_texture_filter_anisotropic)
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      params[0] = as!T(t.MaxAnisotropy)
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", Version.GLES32)
cmd void glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params) {
  GetTexParameterIiv(target, pname, params)
}

sub void GetTexParameterIiv(GLenum target, GLenum pname, GLint* params) {
  GetTexParameter!GLint(target, pname, params)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", Version.GLES32)
cmd void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) {
  GetTexParameterIuiv(target, pname, params)
}

sub void GetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) {
  GetTexParameter!GLuint(target, pname, params)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", Version.GLES32)
cmd void glGetTexParameterfv(GLenum target, GLenum parameter, GLfloat* values) {
  GetTexParameter!GLfloat(target, parameter, values)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", Version.GLES32)
cmd void glGetTexParameteriv(GLenum target, GLenum parameter, GLint* values) {
  GetTexParameter!GLint(target, parameter, values)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsSampler.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsSampler.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsSampler.xhtml", Version.GLES32)
cmd GLboolean glIsSampler(SamplerId sampler) {

  ctx := GetContext()
  // This seems to be different to all other glIs* commands.
  // Just have generated name seems sufficient to return true.
  return as!GLboolean(ctx.Objects.GeneratedNames.Samplers[sampler])
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsTexture.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsTexture.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsTexture.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsTexture.xhtml", Version.GLES32)
cmd GLboolean glIsTexture(TextureId texture) {

  ctx := GetContext()
  return as!GLboolean(texture in ctx.Objects.Textures)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glPixelStorei.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glPixelStorei.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glPixelStorei.xhtml", Version.GLES32)
cmd void glPixelStorei(GLenum parameter, GLint value) {
  CheckGE!GLint(value, 0)
  ctx := GetContext()
  switch (parameter) {
    @if(Version.GLES20)
    case GL_PACK_ALIGNMENT: {
      if (value != 1) && (value != 2) && (value != 4) && (value != 8) { glErrorInvalidValue!GLint(value) }
      ctx.Other.Pack.Alignment = value
    }
    @if(Version.GLES30)
    case GL_PACK_IMAGE_HEIGHT: {
      ctx.Other.Pack.ImageHeight = value
    }
    @if(Version.GLES30)
    case GL_PACK_ROW_LENGTH: {
      ctx.Other.Pack.RowLength = value
    }
    @if(Version.GLES30)
    case GL_PACK_SKIP_IMAGES: {
      ctx.Other.Pack.SkipImages = value
    }
    @if(Version.GLES30)
    case GL_PACK_SKIP_PIXELS: {
      ctx.Other.Pack.SkipPixels = value
    }
    @if(Version.GLES30)
    case GL_PACK_SKIP_ROWS: {
      ctx.Other.Pack.SkipRows = value
    }
    @if(Version.GLES20)
    case GL_UNPACK_ALIGNMENT: {
      if (value != 1) && (value != 2) && (value != 4) && (value != 8) { glErrorInvalidValue!GLint(value) }
      ctx.Other.Unpack.Alignment = value
    }
    @if(Version.GLES30)
    case GL_UNPACK_IMAGE_HEIGHT: {
      ctx.Other.Unpack.ImageHeight = value
    }
    @if(Version.GLES30)
    case GL_UNPACK_ROW_LENGTH: {
      ctx.Other.Unpack.RowLength = value
    }
    @if(Version.GLES30)
    case GL_UNPACK_SKIP_IMAGES: {
      ctx.Other.Unpack.SkipImages = value
    }
    @if(Version.GLES30)
    case GL_UNPACK_SKIP_PIXELS: {
      ctx.Other.Unpack.SkipPixels = value
    }
    @if(Version.GLES30)
    case GL_UNPACK_SKIP_ROWS: {
      ctx.Other.Unpack.SkipRows = value
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }
}

sub void SamplerParameterv!T(SamplerId sampler, GLenum pname, T params) {
  s := GetOrCreateSampler(sampler)
  switch (pname) {
    case GL_TEXTURE_COMPARE_FUNC: s.CompareFunc = as!GLenum(params[0])
    case GL_TEXTURE_COMPARE_MODE: s.CompareMode = as!GLenum(params[0])
    case GL_TEXTURE_MIN_FILTER:   s.MinFilter = as!GLenum(params[0])
    case GL_TEXTURE_MAG_FILTER:   s.MagFilter = as!GLenum(params[0])
    case GL_TEXTURE_MIN_LOD:      s.MinLod = as!GLfloat(params[0])
    case GL_TEXTURE_MAX_LOD:      s.MaxLod = as!GLfloat(params[0])
    case GL_TEXTURE_WRAP_R:       s.WrapR = as!GLenum(params[0])
    case GL_TEXTURE_WRAP_S:       s.WrapS = as!GLenum(params[0])
    case GL_TEXTURE_WRAP_T:       s.WrapT = as!GLenum(params[0])
    @if(Version.GLES32)
    case GL_TEXTURE_BORDER_COLOR: {
      // TODO: Handle - has different behaviour based on the I suffix.
    }
    @if(Extension.GL_EXT_texture_filter_anisotropic)
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      // This use case is not explicitly mentioned in the extension (presumably
      // because it is written for GLES2, but samplers were introduced in GLES3).
      // However, it is used and supported in practice (which is reasonable).
      s.MaxAnisotropy = as!GLfloat(params[0])
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameterIiv(SamplerId sampler, GLenum pname, const GLint* param) {
  SamplerParameterIiv(sampler, pname, param)
}

sub void SamplerParameterIiv(SamplerId sampler, GLenum pname, const GLint* param) {
  SamplerParameterv!(const GLint*)(sampler, pname, param)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameterIuiv(SamplerId sampler, GLenum pname, const GLuint* param) {
  SamplerParameterIuiv(sampler, pname, param)
}

sub void SamplerParameterIuiv(SamplerId sampler, GLenum pname, const GLuint* param) {
  SamplerParameterv!(const GLuint*)(sampler, pname, param)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameterf(SamplerId sampler, GLenum pname, GLfloat param) {
  params := Vec1f(param)
  SamplerParameterv!Vec1f(sampler, pname, params)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameterfv(SamplerId sampler, GLenum pname, const GLfloat* param) {
  SamplerParameterv!(const GLfloat*)(sampler, pname, param)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameteri(SamplerId sampler, GLenum pname, GLint param) {
  params := Vec1i(param)
  SamplerParameterv!Vec1i(sampler, pname, params)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", Version.GLES32)
cmd void glSamplerParameteriv(SamplerId sampler, GLenum pname, const GLint* param) {
  SamplerParameterv!(const GLint*)(sampler, pname, param)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexBuffer.xhtml", Version.GLES32)
cmd void glTexBuffer(GLenum target, GLenum internalformat, BufferId buffer) {
  TexBuffer(target, internalformat, buffer)
}

sub void TexBuffer(GLenum target, GLenum internalformat, BufferId buffer) {
  switch (target) {
    case GL_TEXTURE_BUFFER: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (internalformat) {
    case GL_R16, GL_R16F, GL_R16I, GL_R16UI, GL_R32F, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI,
        GL_RG16, GL_RG16F, GL_RG16I, GL_RG16UI, GL_RG32F, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I,
        GL_RG8UI, GL_RGB32F, GL_RGB32I, GL_RGB32UI, GL_RGBA16, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI,
        GL_RGBA32F, GL_RGBA32I, GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(internalformat)
    }
  }
  _ = buffer // TODO
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexBufferRange.xhtml", Version.GLES32)
cmd void glTexBufferRange(GLenum     target,
                          GLenum     internalformat,
                          BufferId   buffer,
                          GLintptr   offset,
                          GLsizeiptr size) {
  TexBufferRange(target, internalformat, buffer, offset, size)
}

sub void TexBufferRange(GLenum target, GLenum internalformat, BufferId buffer, GLintptr offset, GLsizeiptr size) {
  switch (target) {
    case GL_TEXTURE_BUFFER: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (internalformat) {
    case GL_R16, GL_R16F, GL_R16I, GL_R16UI, GL_R32F, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI,
        GL_RG16, GL_RG16F, GL_RG16I, GL_RG16UI, GL_RG32F, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I,
        GL_RG8UI, GL_RGB32F, GL_RGB32I, GL_RGB32UI, GL_RGBA16, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI,
        GL_RGBA32F, GL_RGBA32I, GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(internalformat)
    }
  }
  _ = buffer // TODO
  _ = offset // TODO
  _ = size // TODO
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexImage2D.xhtml", Version.GLES32)
cmd void glTexImage2D(GLenum         target,
                      GLint          level,
                      GLint          internalformat,
                      GLsizei        width,
                      GLsizei        height,
                      GLint          border,
                      GLenum         format,
                      GLenum         type,
                      TexturePointer data) {
  TexImage(IsTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, 0, GL_TRUE, // Dimensions
           as!GLenum(internalformat), format, type, 0, data) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexImage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexImage3D.xhtml", Version.GLES32)
cmd void glTexImage3D(GLenum         target,
                      GLint          level,
                      GLint          internalformat,
                      GLsizei        width,
                      GLsizei        height,
                      GLsizei        depth,
                      GLint          border,
                      GLenum         format,
                      GLenum         type,
                      TexturePointer data) {
  TexImage3D(target, level, internalformat, width, height, depth, border, format, type, data)
}

sub void TexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexturePointer data) {
  TexImage(IsTexImageCmd | Has3DModifier, target,
           level, 0, 0, 0, // Offsets
           1, width, height, depth, border, 0, GL_TRUE, // Dimensions
           as!GLenum(internalformat), format, type, 0, data) // Format&data
}

// Check that wrap is a valid value for GL_TEXTURE_WRAP_* otherwise
// abort with GL_INVALID_ENUM
sub GLenum checkWrapParam(GLenum wrap) {
  switch wrap {
    case GL_CLAMP_TO_EDGE, GL_REPEAT, GL_MIRRORED_REPEAT, GL_CLAMP_TO_BORDER: {
    }
    default: {
      glErrorInvalidEnum(wrap)
    }
  }
  return wrap
}

// Check that swizzle is a valid value for GL_TEXTURE_SWIZZLE_* otherwise
// abort with GL_INVALID_ENUM
sub GLenum checkSwizzleParam(GLenum swizzle) {
  switch swizzle {
    case GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_ZERO, GL_ONE: { /* fine */ }
    default:                                                   {
      glErrorInvalidEnum(swizzle)
    }
  }
  return swizzle
}

sub void TexParameterv!T(GLenum target, GLenum pname, T params) {
  switch target {
    case GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      glErrorInvalidEnum(target) // Excluded.
    }
    default: {
    }
  }

  t := GetBoundTextureOrErrorInvalidEnum(target)
  switch pname {
    @if(Version.GLES20)
    case GL_TEXTURE_MAG_FILTER: {
      magFilter := as!GLenum(params[0])
      switch (magFilter) {
        case GL_NEAREST, GL_LINEAR: { /* fine */ }
        default:                    {
          glErrorInvalidEnum(magFilter)
        }
      }
      t.MagFilter = magFilter
    }
    @if(Version.GLES20)
    case GL_TEXTURE_MIN_FILTER: {
      minFilter := as!GLenum(params[0])
      switch (minFilter) {
        case GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST,
            GL_LINEAR_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR,
            GL_LINEAR_MIPMAP_LINEAR: { /* fine */ }
        default:                     {
          glErrorInvalidEnum(minFilter)
        }
      }
      t.MinFilter = minFilter
    }
    @if(Version.GLES20)
    case GL_TEXTURE_WRAP_S: {
      t.WrapS = checkWrapParam(as!GLenum(params[0]))
    }
    @if(Version.GLES20)
    case GL_TEXTURE_WRAP_T: {
      t.WrapT = checkWrapParam(as!GLenum(params[0]))
    }
    @if(Version.GLES30)
    case GL_TEXTURE_BASE_LEVEL: {
      baseLevel := as!GLint(params[0])
      CheckGE!GLint(baseLevel, 0)
      t.BaseLevel = baseLevel
    }
    @if(Version.GLES30 || Extension.GL_EXT_shadow_samplers)
    case GL_TEXTURE_COMPARE_FUNC: {
      t.CompareFunc = as!GLenum(params[0])
    }
    @if(Version.GLES30 || Extension.GL_EXT_shadow_samplers)
    case GL_TEXTURE_COMPARE_MODE: {
      t.CompareMode = as!GLenum(params[0])
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MAX_LEVEL: {
      maxLevel := as!GLint(params[0])
      CheckGE!GLint(maxLevel, 0)
      t.MaxLevel = maxLevel
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MAX_LOD: {
      t.MaxLod = as!GLfloat(params[0])
    }
    @if(Version.GLES30)
    case GL_TEXTURE_MIN_LOD: {
      t.MinLod = as!GLfloat(params[0])
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_A: {
      t.SwizzleA = checkSwizzleParam(as!GLenum(params[0]))
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_B: {
      t.SwizzleB = checkSwizzleParam(as!GLenum(params[0]))
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_G: {
      t.SwizzleG = checkSwizzleParam(as!GLenum(params[0]))
    }
    @if(Version.GLES30)
    case GL_TEXTURE_SWIZZLE_R: {
      t.SwizzleR = checkSwizzleParam(as!GLenum(params[0]))
    }
    @if(Version.GLES30)
    case GL_TEXTURE_WRAP_R: {
      t.WrapR = as!GLenum(params[0])
    }
    @if(Version.GLES31)
    case GL_DEPTH_STENCIL_TEXTURE_MODE: {
      t.DepthStencilTextureMode = as!GLenum(params[0])
    }
    @if(Version.GLES32)
    case GL_TEXTURE_BORDER_COLOR: {
      // TODO: Handle - has different behaviour based on the I suffix.
    }
    @if(Extension.GL_EXT_texture_filter_anisotropic)
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      t.MaxAnisotropy = as!GLfloat(params[0])
    }
    @if(Extension.GL_EXT_texture_sRGB_decode)
    case GL_TEXTURE_SRGB_DECODE_EXT: {
      // TODO: DECODE_EXT, SKIP_DECODE_EXT
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameterIiv(GLenum target, GLenum pname, const GLint* params) {
  TexParameterIiv(target, pname, params)
}

sub void TexParameterIiv(GLenum target, GLenum pname, const GLint* params) {
  TexParameterv!(const GLint*)(target, pname, params)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) {
  TexParameterIuiv(target, pname, params)
}

sub void TexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) {
  TexParameterv!(const GLuint*)(target, pname, params)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameterf(GLenum target, GLenum parameter, GLfloat value) {
  if parameter == GL_TEXTURE_BORDER_COLOR { glErrorInvalidEnum(parameter) } // not scalar
  params := Vec1f(value)
  TexParameterv!Vec1f(target, parameter, params)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) {
  TexParameterv!(const GLfloat*)(target, pname, params)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameteri(GLenum target, GLenum parameter, GLint value) {
  if parameter == GL_TEXTURE_BORDER_COLOR { glErrorInvalidEnum(parameter) } // not scalar
  params := Vec1i(value)
  TexParameterv!Vec1i(target, parameter, params)
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", Version.GLES32)
cmd void glTexParameteriv(GLenum target, GLenum pname, const GLint* params) {
  TexParameterv!(const GLint*)(target, pname, params)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage2D.xhtml", Version.GLES32)
cmd void glTexStorage2D(GLenum  target,
                        GLsizei levels,
                        GLenum  internalformat,
                        GLsizei width,
                        GLsizei height) {
  TexStorage2D(target, levels, internalformat, width, height)
}

sub void TexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
  depth := switch (target) {
    case GL_TEXTURE_CUBE_MAP: as!GLsizei(6)
    default: as!GLsizei(1)
  }
  TexImage(IsTexStorageCmd, target,
           0, 0, 0, 0, // Offsets
           levels, width, height, depth, 0, 0, GL_TRUE, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage2DMultisample.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage2DMultisample.xhtml", Version.GLES32)
cmd void glTexStorage2DMultisample(GLenum    target,
                                   GLsizei   samples,
                                   GLenum    internalformat,
                                   GLsizei   width,
                                   GLsizei   height,
                                   GLboolean fixedsamplelocations) {
  TexImage(IsTexStorageCmd | HasMultisampleModifier, target,
           0, 0, 0, 0, // Offsets
           1, width, height, 1, 0, samples, fixedsamplelocations, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage3D.xhtml", Version.GLES32)
cmd void glTexStorage3D(GLenum  target,
                        GLsizei levels,
                        GLenum  internalformat,
                        GLsizei width,
                        GLsizei height,
                        GLsizei depth) {
  TexStorage3D(target, levels, internalformat, width, height, depth)
}

sub void TexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
  TexImage(IsTexStorageCmd | Has3DModifier, target,
           0, 0, 0, 0, // Offsets
           levels, width, height, depth, 0, 0, GL_TRUE, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage3DMultisample.xhtml", Version.GLES32)
cmd void glTexStorage3DMultisample(GLenum    target,
                                   GLsizei   samples,
                                   GLenum    internalformat,
                                   GLsizei   width,
                                   GLsizei   height,
                                   GLsizei   depth,
                                   GLboolean fixedsamplelocations) {
  TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations)
}

sub void TexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
  TexImage(IsTexStorageCmd | Has3DModifier | HasMultisampleModifier, target,
           0, 0, 0, 0, // Offsets
           1, width, height, depth, 0, samples, fixedsamplelocations, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@if(Version.GLES10)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexSubImage2D.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage2D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexSubImage2D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexSubImage2D.xhtml", Version.GLES32)
cmd void glTexSubImage2D(GLenum         target,
                         GLint          level,
                         GLint          xoffset,
                         GLint          yoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  TexImage(IsTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, 0, GL_TRUE, // Dimensions
           GL_NONE, format, type, 0, data) // Format&data
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage3D.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexSubImage3D.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexSubImage3D.xhtml", Version.GLES32)
cmd void glTexSubImage3D(GLenum         target,
                         GLint          level,
                         GLint          xoffset,
                         GLint          yoffset,
                         GLint          zoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLsizei        depth,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data)
}

sub void TexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexturePointer data) {
  TexImage(IsTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, depth, 0, 0, GL_TRUE, // Dimensions
           GL_NONE, format, type, 0, data) // Format&data
}
