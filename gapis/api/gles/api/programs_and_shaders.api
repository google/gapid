// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

@internal
@resource
class Shader {
  @unused ShaderId ID

  // Table 21.19: Shader Object State
  GLenum         Type
  @unused bool   CompileStatus = false
  @unused string InfoLog
  string         Source
  bool           DeleteStatus
  @unused string Label
  s32            AttachCount

  @hidden ref!CompileShaderExtra CompileExtra // Describes last compile command
}

// Extra describing shader compilation including both the inputs and outputs.
// We need to store copy of compile-time inputs for mid-execution capture,
// because changing the source code does not change the compiled shader code.
@internal
class CompileShaderExtra {
  ShaderId ID

  // Outputs
  bool   CompileStatus
  string InfoLog

  // Inputs
  string          Source
  ref!BinaryExtra Binary // Takes precedence over Source if set
}

@post_fence
extern ref!CompileShaderExtra GetCompileShaderExtra(ref!Context ctx, ref!Shader p, ref!BinaryExtra binary)

sub void ApplyCompileShaderExtra(ref!Shader s, ref!CompileShaderExtra i) {
  if i != null {
    assert(s != null)
    s.CompileExtra = i
    s.CompileStatus = i.CompileStatus
    s.InfoLog = i.InfoLog
  }
}

@internal
class BinaryExtra {
  u8[]    Data   // Binary blob
  GLenum  Format // Vendor-specific format
  GLsizei Count  // Number of binaries stored in the blob
  GLsizei Index  // Index of the binary that we are referencing
}

@internal
@resource
class Program {
  @unused ProgramId                       ID
  map!(GLenum, ref!Shader)                Shaders
  ref!ActiveProgramResources              ActiveResources
  map!(UniformLocation, Uniform)          UniformLocations
  GLboolean                               LinkStatus
  bool                                    ValidateStatus
  @unused string                          InfoLog
  ref!ShaderLayoutQualifiers              ShaderLayout
  @unused map!(string, AttributeLocation) AttributeBindings
  map!(u32, string)                       TransformFeedbackVaryings
  GLenum                                  TransformFeedbackBufferMode = GL_INTERLEAVED_ATTRIBS
  bool                                    Separable                   = false
  bool                                    BinaryRetrievableHint       = false
  bool                                    DeleteStatus
  @unused string                          Label
  s32                                     UseCount

  @hidden ref!LinkProgramExtra     LinkExtra           // Describes last link command
  @hidden ref!LinkProgramExtra     SuccessfulLinkExtra // Describes last successful link command
  @hidden ref!ValidateProgramExtra ValidateExtra       // Describes last validate command
}

// Extra describing program link including both the inputs and outputs.
// We need to store copy of compile-time inputs for mid-execution capture,
// because changing the inputs does not change the compiled program code.
@internal
class LinkProgramExtra {
  ProgramId ID

  // Outputs
  GLboolean                  LinkStatus
  string                     InfoLog
  ref!ActiveProgramResources ActiveResources
  ref!ShaderLayoutQualifiers ShaderLayout

  // Inputs
  map!(GLenum, ref!CompileShaderExtra) Shaders
  ref!BinaryExtra                      Binary // Takes precedence over Shaders if set
  map!(string, AttributeLocation)      AttributeBindings
  map!(u32, string)                    TransformFeedbackVaryings
  GLenum                               TransformFeedbackBufferMode
  bool                                 Separable
  bool                                 BinaryRetrievableHint
}

@post_fence
extern ref!LinkProgramExtra GetLinkProgramExtra(ref!Context ctx, ref!Program p, ref!BinaryExtra binary)

sub void ApplyLinkProgramExtra(ref!Program p, ref!LinkProgramExtra i) {
  if i != null {
    assert(p != null)
    if i.LinkStatus == GL_TRUE {
      // We need to keep track of the last successful link,
      // since it remains in effect at any binding points.
      p.SuccessfulLinkExtra = i
    }
    p.LinkExtra = i
    p.LinkStatus = i.LinkStatus
    p.InfoLog = i.InfoLog
    p.ActiveResources = i.ActiveResources
    p.ShaderLayout = i.ShaderLayout

    // Memorize the exact state of shaders at link time.
    // Use the reference object from our state rather than the cloned copy.
    // This saves a little spaces and avoids MEC complaining about the clone.
    p.LinkExtra.Shaders = null
    for _, k, v in p.Shaders {
      p.LinkExtra.Shaders[k] = v.CompileExtra
    }

    // Set uniform values to default (zeroed)
    p.UniformLocations = null
    if i.LinkStatus == GL_TRUE {
      for _, uniformIndex, uniform in i.ActiveResources.DefaultUniformBlock {
        elementInfo := GetUniformTypeInfo(uniform.Type)
        elementSize := elementInfo.primitiveSize * elementInfo.vectorSize * elementInfo.vectorCount
        values := make!u8(elementSize * as!u32(uniform.ArraySize))
        // Each element of the array is assigned a location by compiler.
        // The location acts as a handle. Locations do not have to be consecutive.
        for _, elementIndex, loc in uniform.Locations {
          if (loc != -1) {
            assert(elementIndex < as!u32(uniform.ArraySize))
            offset := elementIndex * elementSize
            p.UniformLocations[as!UniformLocation(loc)] = Uniform(
              Type:          uniform.Type,
              Value:         values[offset:offset + elementSize],
              Values:        values[offset:len(values)],
              UniformIndex:  uniformIndex
            )
          }
        }
        uniform.Value = values
      }
    }
  }
}

@internal
class Uniform {
  @unused GLenum         Type
  @internal u8[]         Value
  @hidden @internal u8[] Values // Includes this uniform and any following array-elements
  UniformIndex           UniformIndex // Reference back to ProgramResource (not location)
}

@internal
class ValidateProgramExtra {
  ProgramId ID
  bool      ValidateStatus
  string    InfoLog
}

@post_fence
extern ref!ValidateProgramExtra GetValidateProgramExtra(ref!Context ctx, ref!Program p)

sub void ApplyValidateProgramExtra(ref!Program p, ref!ValidateProgramExtra i) {
  if i != null {
    p.ValidateStatus = i.ValidateStatus
    p.InfoLog = i.InfoLog
  }
}

@internal
class Pipeline {
  PipelineId ID

  // Table 21.20: Program Pipeline Object State
  ref!Program ActiveProgram
  ref!Program VertexShader
  ref!Program TessControlShader
  ref!Program TessEvaluationShader
  ref!Program GeometryShader
  ref!Program FragmentShader
  ref!Program ComputeShader
  bool        ValidateStatus
  string      InfoLog
  string      Label

  @hidden ref!ValidateProgramPipelineExtra ValidateExtra // Describes last validate command
}

@internal
class ValidateProgramPipelineExtra {
  PipelineId ID
  bool       ValidateStatus
  string     InfoLog
}

@post_fence
extern ref!ValidateProgramPipelineExtra GetValidateProgramPipelineExtra(ref!Context ctx, ref!Pipeline p)

sub void ApplyValidateProgramPipelineExtra(ref!Pipeline p, ref!ValidateProgramPipelineExtra i) {
  if i != null {
    p.ValidateStatus = i.ValidateStatus
    p.InfoLog = i.InfoLog
  }
}

@internal
class ActiveProgramResources {
  @unused map!(u32, ref!ProgramResource)          ProgramInputs
  @unused map!(u32, ref!ProgramResource)          ProgramOutputs
  @unused map!(u32, ref!ProgramResource)          Uniforms
  @unused map!(UniformIndex, ref!ProgramResource) DefaultUniformBlock
  @unused map!(u32, ref!ProgramResourceBlock)     UniformBlocks
  @unused map!(u32, ref!ProgramResourceBlock)     AtomicCounterBuffers
  @unused map!(u32, ref!ProgramResource)          BufferVariables
  @unused map!(u32, ref!ProgramResourceBlock)     ShaderStorageBlocks
  @unused map!(u32, ref!ProgramResource)          TransformFeedbackVaryings
}

@internal
class ProgramResourceBlock {
  @unused string                         Name
  @unused GLint                          Binding
  @unused GLint                          DataSize
  @unused ref!ProgramResourceUses        ReferencedBy // May be null if unknown (older GL versions)
  @unused map!(u32, ref!ProgramResource) Resources
}

@internal
class ProgramResource {
  @unused string          Name
  @unused GLenum          Type
  @unused u8[]            Value
  @unused GLint           ArraySize = 1  // Number of active array elements (can be less than declared)
  @unused map!(u32,GLint) Locations      // Location of array elements (can be non-consecutive)
  @unused @hidden GLint   BlockIndex = -1                // Hidden as it is implied by the owning container
  @unused @hidden GLint   AtomicCounterBufferIndex = -1  // Hidden as it is implied by the owning container
  @unused @hidden bool    IsPerPatch                     // Hidden to reduce noise

  @unused ref!ProgramResourceUses   ReferencedBy // May be null if unknown or not applicable
  @unused ref!ProgramResourceLayout Layout       // May be null if unknown or not applicable
}

@internal
class ProgramResourceUses {
  @unused bool VertexShader
  @unused bool TessControlShader
  @unused bool TessEvaluationShader
  @unused bool GeometryShader
  @unused bool FragmentShader
  @unused bool ComputeShader
}

@internal
class ProgramResourceLayout {
  @unused GLint Offset              = -1
  @unused GLint ArrayStride         = -1
  @unused GLint MatrixStride        = -1
  @unused bool  IsRowMajor
  @unused GLint TopLevelArraySize   = 0
  @unused GLint TopLevelArrayStride = 0
}

@internal
class ShaderLayoutQualifiers {
  @unused GLuint GeometryVerticesOut       = 0
  @unused GLenum GeometryInputType         = GL_TRIANGLES
  @unused GLenum GeometryOutputType        = GL_TRIANGLE_STRIP
  @unused GLuint GeometryShaderInvocations = 1

  @unused GLuint TessControlOutputVertices = 0
  @unused GLenum TessGenMode               = GL_QUADS
  @unused GLenum TessGenSpacing            = GL_EQUAL
  @unused GLenum TessGenVertexOrder        = GL_CCW
  @unused bool   TessGenPointMode          = false

  @unused GLuint[3] ComputeWorkGroupSize
}

sub ref!Pipeline GetOrCreatePipelineOrError(PipelineId id) {
  ctx := GetContext()
  if ctx.Objects.Pipelines[id] == null {
    if ctx.Objects.GeneratedNames.Pipelines[id] {
      ctx.Objects.Pipelines[id] = new!Pipeline(ID: id)
    } else {
      glErrorInvalidOperation_ObjectDoesNotExist!PipelineId(id)
    }
  }
  return ctx.Objects.Pipelines[id]
}

sub string readString(GLsizei length, const GLchar* buffer, bool consider_zero_length_nt) {
  chars := as!(const char*)(buffer)
  return switch buffer != null {
    case true: {
      // Negative length implies null-terminated string
      switch (length < 0) || (consider_zero_length_nt && length == 0) {
        case true:  as!string(chars)
        case false: as!string(chars[0:length])
      }
    }
    case false: as!string(null)
  }
}

sub void writeString(GLsizei  buffer_size,
                     GLsizei* buffer_bytes_written,
                     GLchar*  buffer) {
  if (buffer != null) && (buffer_size > 0) {
    if buffer_bytes_written != null {
      length := as!GLsizei(?)
      buffer_bytes_written[0] = length // Excluding null-terminator
      write(buffer[0:length + 1]) // Including null-terminator
    } else {
      write(buffer[0:buffer_size])
    }
  }
}

sub ref!Shader GetShaderOrError(ShaderId shader) {
  ctx := GetContext()
  s := ctx.Objects.Shaders[shader]
  if s == null {
    if !(as!ProgramId(shader) in ctx.Objects.Programs) { glErrorInvalidObjectName!ShaderId(shader) }
    glErrorInvalidOperation()
  }
  return s
}

sub ref!Program GetProgramOrError(ProgramId program) {
  ctx := GetContext()
  p := ctx.Objects.Programs[program]
  if p == null {
    if !(as!ShaderId(program) in ctx.Objects.Shaders) { glErrorInvalidValue!ProgramId(program) }
    glErrorInvalidOperation()
  }
  return p
}

sub void AdjustShaderAttachCount(ref!Shader s, s32 delta) {
  ctx := GetContext()
  if s != null {
    s.AttachCount += delta
    assert(s.AttachCount >= 0)
    // Delete if it was marked for deletion and it is no longer attached anywhere
    if s.DeleteStatus && (s.AttachCount == 0) {
      delete(ctx.Objects.Shaders, s.ID)
    }
  }
}

sub void AdjustProgramUseCount(ref!Program p, s32 delta) {
  ctx := GetContext()
  if p != null {
    p.UseCount += delta
    assert(p.UseCount >= 0)
    // Delete if it was marked for deletion and it is no longer used anywhere
    if p.DeleteStatus && (p.UseCount == 0) {
      for _ , _ , s in p.Shaders {
        AdjustShaderAttachCount(s, -1)
      }
      delete(ctx.Objects.Programs, p.ID)
    }
  }
}

// Returns the slice to the uniform's value. It can be used to read/write the value.
// If the uniform is an array, it includes the "overflow" until the end of array.
// It handles locations witch are in mid-array and non-consecutive array locations.
// Matrices in this slice should be always stored in default (column major) order.
@internal sub T[] ProgramUniformValue!T(ref!Program p, UniformLocation loc, GLenum type) {
  if p == null { glErrorInvalidOperation() }
  if !(loc in p.UniformLocations) { glErrorInvalidOperation() }
  // TODO: Check that the type is compatible with the type declared in the shader.
  values := as!T[](p.UniformLocations[loc].Values)
  if len(values) == 0 { glErrorInvalidOperation() }
  return values
}

sub void SetProgramUniform!T(ProgramId p, UniformLocation loc, T value, GLenum type) {
  if loc != -1 {
    ProgramUniformValue!T(GetProgramOrError(p), loc, type)[0] = value
  }
}

sub void SetProgramUniformv!T(ProgramId p, UniformLocation loc, T[] values, GLenum type) {
  if loc != -1 {
    copy(ProgramUniformValue!T(GetProgramOrError(p), loc, type), values)
  }
}

sub void SetProgramUniformMatrixv!T(ProgramId p, UniformLocation loc, GLboolean t, T[] values, GLenum type) {
  // TODO: transpose values if the flag is set
  if loc != -1 {
    copy(ProgramUniformValue!T(GetProgramOrError(p), loc, type), values)
  }
}

sub void SetUniform!T(UniformLocation loc, T value, GLenum type) {
  if loc != -1 {
    ProgramUniformValue!T(GetContext().Bound.Program, loc, type)[0] = value
  }
}

sub void SetUniformv!T(UniformLocation loc, T[] values, GLenum type) {
  if loc != -1 {
    copy(ProgramUniformValue!T(GetContext().Bound.Program, loc, type), values)
  }
}

sub void SetUniformMatrixv!T(UniformLocation loc, GLboolean t, T[] values, GLenum type) {
  // TODO: transpose values if the flag is set
  if loc != -1 {
    copy(ProgramUniformValue!T(GetContext().Bound.Program, loc, type), values)
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glActiveShaderProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glActiveShaderProgram.xhtml", Version.GLES32)
cmd void glActiveShaderProgram(PipelineId pipeline, ProgramId program) {
  pipe := GetOrCreatePipelineOrError(pipeline)
  if program == 0 {
    pipe.ActiveProgram = null
  } else {
    pipe.ActiveProgram = GetProgramOrError(program)
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glAttachShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glAttachShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glAttachShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glAttachShader.xhtml", Version.GLES32)
cmd void glAttachShader(ProgramId program, ShaderId shader) {

  s := GetShaderOrError(shader)
  p := GetProgramOrError(program)
  if s.Type in p.Shaders { glErrorInvalidOperation() } // shader already attached
  p.Shaders[s.Type] = s
  AdjustShaderAttachCount(s, +1)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindAttribLocation.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindAttribLocation.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindAttribLocation.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindAttribLocation.xhtml", Version.GLES32)
cmd void glBindAttribLocation(ProgramId program, AttributeLocation location, const GLchar* name) {
  n := as!string(as!char*(name))
  if (len(n) > 2) && (as!string(as!char*(name)[0:3]) == "gl_") { glErrorInvalidOperation() }
  p := GetProgramOrError(program)
  CheckAttributeLocation(location)
  p.AttributeBindings[n] = location
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindProgramPipeline.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindProgramPipeline.xhtml", Version.GLES32)
cmd void glBindProgramPipeline(PipelineId pipeline) {
  ctx := GetContext()
  if pipeline == 0 {
    ctx.Bound.Pipeline = null
  } else {
    ctx.Bound.Pipeline = GetOrCreatePipelineOrError(pipeline)
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCompileShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompileShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompileShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompileShader.xhtml", Version.GLES32)
cmd void glCompileShader(ShaderId shader) {
  ctx := GetContext()
  s := GetShaderOrError(shader)
  _ = s.Source
  ApplyCompileShaderExtra(s, GetCompileShaderExtra(ctx, s, null))
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCreateProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCreateProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCreateProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCreateProgram.xhtml", Version.GLES32)
cmd ProgramId glCreateProgram() {
  ctx := GetContext()
  id := ?
  ctx.Objects.Programs[id] = new!Program(ID: id)
  return id
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCreateShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCreateShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCreateShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCreateShader.xhtml", Version.GLES32)
cmd ShaderId glCreateShader(GLenum type) {
  switch (type) {
    case GL_FRAGMENT_SHADER, GL_VERTEX_SHADER: {
      // version 2.0
    }
    @if(Version.GLES31)
    case GL_COMPUTE_SHADER: {
    }
    @if(Version.GLES32)
    case GL_GEOMETRY_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER: {
    }
    default: {
      glErrorInvalidEnum(type)
    }
  }

  ctx := GetContext()
  id := ?
  ctx.Objects.Shaders[id] = new!Shader(ID: id, Type: type)
  return id
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCreateShaderProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCreateShaderProgram.xhtml", Version.GLES32)
cmd ProgramId glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar* const* strings) {
  switch (type) {
    case GL_COMPUTE_SHADER, GL_FRAGMENT_SHADER, GL_VERTEX_SHADER: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_GEOMETRY_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER: {
    }
    default: {
      glErrorInvalidEnum(type)
    }
  }
  sources := strings[0:count]
  for i in (0 .. count) {
    _ = as!string(as!char*(sources[i]))
  }
  ctx := GetContext()
  id := ?
  ctx.Objects.Programs[id] = new!Program(ID: id, Separable: true)
  // TODO: Program link info
  return id
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteProgram.xhtml", Version.GLES32)
cmd void glDeleteProgram(ProgramId program) {
  if program != 0 {
    p := GetProgramOrError(program)
    p.DeleteStatus = true
    AdjustProgramUseCount(p, 0) // Do not change the count, just check if it can be deleted now.
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteProgramPipelines.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteProgramPipelines.xhtml", Version.GLES32)
cmd void glDeleteProgramPipelines(GLsizei n, const PipelineId* pipelines) {
  DeleteProgramPipelines(n, pipelines)
}

sub void DeleteProgramPipelines(GLsizei count, const PipelineId* pipelines) {
  CheckCountGE!GLsizei(count, 0)
  ids := pipelines[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := ids[i]
    if id != 0 {
      delete(ctx.Objects.Pipelines, id)
      delete(ctx.Objects.GeneratedNames.Pipelines, id)
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteShader.xhtml", Version.GLES32)
cmd void glDeleteShader(ShaderId shader) {
  if shader != 0 {
    s := GetShaderOrError(shader)
    s.DeleteStatus = true
    AdjustShaderAttachCount(s, 0) // Do not change the count, just check if it can be deleted now.
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDetachShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDetachShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDetachShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDetachShader.xhtml", Version.GLES32)
cmd void glDetachShader(ProgramId program, ShaderId shader) {

  s := GetShaderOrError(shader)
  p := GetProgramOrError(program)

  if (!(s.Type in p.Shaders)) || (p.Shaders[s.Type] != s) { glErrorInvalidOperation() }
  delete(p.Shaders, s.Type)
  AdjustShaderAttachCount(s, -1)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDispatchCompute.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDispatchCompute.xhtml", Version.GLES32)
cmd void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
  // TODO
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDispatchComputeIndirect.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDispatchComputeIndirect.xhtml", Version.GLES32)
cmd void glDispatchComputeIndirect(GLintptr indirect) {
  // TODO
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenProgramPipelines.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenProgramPipelines.xhtml", Version.GLES32)
cmd void glGenProgramPipelines(GLsizei count, PipelineId* pipelines) {
  GenProgramPipelines(count, pipelines)
}

sub void GenProgramPipelines(GLsizei count, PipelineId* pipelines) {
  CheckCountGE!GLsizei(count, 0)
  t := pipelines[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!PipelineId(?)
    assert(id != 0)
    ctx.Objects.GeneratedNames.Pipelines[id] = true
    t[i] = id
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetActiveAttrib.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveAttrib.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetActiveAttrib.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetActiveAttrib.xhtml", Version.GLES32)
cmd void glGetActiveAttrib(ProgramId      program,
                           AttributeIndex index,
                           GLsizei        buffer_size,
                           GLsizei*       buffer_bytes_written,
                           GLint*         vector_count,
                           GLenum*        type,
                           GLchar*        name) {

  CheckSizeGE!GLsizei(buffer_size, 0)

  p := GetProgramOrError(program)
  if !(as!u32(index) in p.ActiveResources.ProgramInputs) { glErrorInvalidValue!AttributeIndex(index) }

  writeString(buffer_size, buffer_bytes_written, name)

  vector_count[0] = as!GLint(?)
  type[0] = as!GLenum(?)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetActiveUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetActiveUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetActiveUniform.xhtml", Version.GLES32)
cmd void glGetActiveUniform(ProgramId    program,
                            UniformIndex index,
                            GLsizei      buffer_size,
                            GLsizei*     buffer_bytes_written,
                            GLint*       vector_count,
                            GLenum*      type,
                            GLchar*      name) {

  p := GetProgramOrError(program)
  CheckSizeGE!GLsizei(buffer_size, 0)
  if !(as!u32(index) in p.ActiveResources.Uniforms) { glErrorInvalidValue!UniformIndex(index) }

  writeString(buffer_size, buffer_bytes_written, name)

  vector_count[0] = as!GLint(?)
  type[0] = as!GLenum(?)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformBlockName.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetActiveUniformBlockName.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetActiveUniformBlockName.xhtml", Version.GLES32)
cmd void glGetActiveUniformBlockName(ProgramId         program,
                                     UniformBlockIndex uniform_block_index,
                                     GLsizei           buffer_size,
                                     GLsizei*          buffer_bytes_written,
                                     GLchar*           name) {

  writeString(buffer_size, buffer_bytes_written, name)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformBlockiv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetActiveUniformBlockiv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetActiveUniformBlockiv.xhtml", Version.GLES32)
cmd void glGetActiveUniformBlockiv(ProgramId         program,
                                   UniformBlockIndex uniform_block_index,
                                   GLenum            parameter_name,
                                   GLint*            parameters) {
  switch (parameter_name) {
    case GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES,
        GL_UNIFORM_BLOCK_BINDING, GL_UNIFORM_BLOCK_DATA_SIZE, GL_UNIFORM_BLOCK_NAME_LENGTH,
        GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER,
        GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: {
      // version 3.0
    }
    default: {
      glErrorInvalidEnum(parameter_name)
    }
  }

  parameters[0] = ?
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetActiveUniformsiv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetActiveUniformsiv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetActiveUniformsiv.xhtml", Version.GLES32)
cmd void glGetActiveUniformsiv(ProgramId           program,
                               GLsizei             uniform_count,
                               const UniformIndex* uniform_indices,
                               GLenum              parameter_name,
                               GLint*              parameters) {
  switch (parameter_name) {
    case GL_UNIFORM_ARRAY_STRIDE, GL_UNIFORM_BLOCK_INDEX, GL_UNIFORM_IS_ROW_MAJOR,
        GL_UNIFORM_MATRIX_STRIDE, GL_UNIFORM_NAME_LENGTH, GL_UNIFORM_OFFSET, GL_UNIFORM_SIZE,
        GL_UNIFORM_TYPE: {
      // version 3.0
    }
    default: {
      glErrorInvalidEnum(parameter_name)
    }
  }

  read(uniform_indices[0:uniform_count])
  write(parameters[0:uniform_count])
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetAttachedShaders.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetAttachedShaders.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetAttachedShaders.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetAttachedShaders.xhtml", Version.GLES32)
cmd void glGetAttachedShaders(ProgramId program,
                              GLsizei   buffer_length,
                              GLsizei*  shaders_length_written,
                              ShaderId* shaders) {

  p := GetProgramOrError(program)
  CheckGE!GLsizei(buffer_length, 0)
  l := min!s32(as!s32(buffer_length), len(p.Shaders))
  if shaders_length_written != null {
    shaders_length_written[0] = as!GLsizei(l)
  }

  s := shaders[0:l]
  for i , _ , v in p.Shaders {
    if i < l {
      s[i] = v.ID
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetAttribLocation.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetAttribLocation.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetAttribLocation.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetAttribLocation.xhtml", Version.GLES32)
cmd GLint glGetAttribLocation(ProgramId program, const GLchar* name) {
  _ = as!string(as!char*(name))
  // The HTML and PDF give different error codes. This matches the PDF.
  _ = GetProgramOrError(program)
  return ?
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetFragDataLocation.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetFragDataLocation.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetFragDataLocation.xhtml", Version.GLES32)
cmd GLint glGetFragDataLocation(ProgramId program, const GLchar* name) {
  _ = as!string(as!char*(name))
  _ = GetProgramOrError(program)
  return ?
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetProgramBinary.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramBinary.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramBinary.xhtml", Version.GLES32)
cmd void glGetProgramBinary(ProgramId program,
                            GLsizei   bufSize,
                            GLsizei*  length,
                            GLenum*   binaryFormat,
                            void*     binary) {
  GetProgramBinary(program, bufSize, length, binaryFormat, binary)
}

sub void GetProgramBinary(ProgramId program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) {
  _ = program // TODO: Not needed? Remove from signature.
  if length != null {
    l := as!GLsizei(?)
    length[0] = l
    write(binary[0:l])
  } else {
    write(binary[0:bufSize])
  }
  binaryFormat[0] = ?
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetProgramInfoLog.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetProgramInfoLog.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramInfoLog.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramInfoLog.xhtml", Version.GLES32)
cmd void glGetProgramInfoLog(ProgramId program,
                             GLsizei   buffer_length,
                             GLsizei*  string_length_written,
                             GLchar*   info) {
  _ = GetProgramOrError(program)
  CheckGE!GLsizei(buffer_length, 0)
  writeString(buffer_length, string_length_written, info)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramInterface.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramInterface.xhtml", Version.GLES32)
cmd void glGetProgramInterfaceiv(ProgramId program,
                                 GLenum    programInterface,
                                 GLenum    pname,
                                 GLint*    params) {
  switch (programInterface) {
    case GL_ATOMIC_COUNTER_BUFFER, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT,
        GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER, GL_TRANSFORM_FEEDBACK_VARYING,
        GL_UNIFORM, GL_UNIFORM_BLOCK: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(programInterface)
    }
  }
  switch (pname) {
    case GL_ACTIVE_RESOURCES, GL_MAX_NAME_LENGTH, GL_MAX_NUM_ACTIVE_VARIABLES: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramPipelineInfoLog.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramPipelineInfoLog.xhtml", Version.GLES32)
cmd void glGetProgramPipelineInfoLog(PipelineId pipeline,
                                     GLsizei    bufSize,
                                     GLsizei*   length,
                                     GLchar*    infoLog) {
  writeString(bufSize, length, infoLog)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramPipeline.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramPipeline.xhtml", Version.GLES32)
cmd void glGetProgramPipelineiv(PipelineId pipeline, GLenum pname, GLint* params) {
  switch (pname) {
    case GL_ACTIVE_PROGRAM, GL_COMPUTE_SHADER, GL_FRAGMENT_SHADER, GL_INFO_LOG_LENGTH,
        GL_VALIDATE_STATUS, GL_VERTEX_SHADER: {
      // version 3.1
    }
    @if(Version.GLES32)
    case GL_GEOMETRY_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER: {
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramResourceIndex.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramResourceIndex.xhtml", Version.GLES32)
cmd GLuint glGetProgramResourceIndex(ProgramId     program,
                                     GLenum        programInterface,
                                     const GLchar* name) {
  _ = as!string(as!char*(name))
  switch (programInterface) {
    case GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_SHADER_STORAGE_BLOCK,
        GL_TRANSFORM_FEEDBACK_VARYING, GL_UNIFORM, GL_UNIFORM_BLOCK: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(programInterface)
    }
  }
  // TODO
  return ?
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramResourceLocation.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramResourceLocation.xhtml", Version.GLES32)
cmd GLint glGetProgramResourceLocation(ProgramId     program,
                                       GLenum        programInterface,
                                       const GLchar* name) {
  _ = as!string(as!char*(name))
  switch (programInterface) {
    case GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(programInterface)
    }
  }
  // TODO
  return ?
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramResourceName.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramResourceName.xhtml", Version.GLES32)
cmd void glGetProgramResourceName(ProgramId program,
                                  GLenum    programInterface,
                                  GLuint    index,
                                  GLsizei   bufSize,
                                  GLsizei*  length,
                                  GLchar*   name) {
  switch (programInterface) {
    case GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_SHADER_STORAGE_BLOCK,
        GL_TRANSFORM_FEEDBACK_VARYING, GL_UNIFORM, GL_UNIFORM_BLOCK: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(programInterface)
    }
  }
  writeString(bufSize, length, name)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramResource.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramResource.xhtml", Version.GLES32)
cmd void glGetProgramResourceiv(ProgramId     program,
                                GLenum        programInterface,
                                GLuint        index,
                                GLsizei       propCount,
                                const GLenum* props,
                                GLsizei       bufSize,
                                GLsizei*      length,
                                GLint*        params) {
  switch (programInterface) {
    case GL_ATOMIC_COUNTER_BUFFER, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT,
        GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER, GL_TRANSFORM_FEEDBACK_VARYING,
        GL_UNIFORM, GL_UNIFORM_BLOCK: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(programInterface)
    }
  }
  // TODO
  read(props[0:propCount])
  if length != null {
    l := as!GLsizei(?)
    length[0] = l
    write(params[0:l])
  } else {
    write(params[0:bufSize])
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetProgramiv.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetProgramiv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetProgramiv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetProgramiv.xhtml", Version.GLES32)
cmd void glGetProgramiv(ProgramId program, GLenum parameter, GLint* value) {
  switch (parameter) {
    case GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS,
        GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_ATTACHED_SHADERS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH,
        GL_LINK_STATUS, GL_VALIDATE_STATUS: {
      // version 2.0
    }
    @if(Version.GLES30)
    case GL_ACTIVE_UNIFORM_BLOCKS, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH,
        GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRANSFORM_FEEDBACK_BUFFER_MODE,
        GL_TRANSFORM_FEEDBACK_VARYINGS, GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: {
    }
    @if(Version.GLES30)
    case GL_PROGRAM_BINARY_LENGTH: {
      // TODO: Missing from online man pages.
    }
    @if(Version.GLES31)
    case GL_ACTIVE_ATOMIC_COUNTER_BUFFERS, GL_COMPUTE_WORK_GROUP_SIZE, GL_PROGRAM_SEPARABLE: {
    }
    @if(Version.GLES32)
    case GL_GEOMETRY_INPUT_TYPE, GL_GEOMETRY_OUTPUT_TYPE,
        GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_SHADER_INVOCATIONS,
        GL_TESS_CONTROL_OUTPUT_VERTICES, GL_TESS_GEN_MODE, GL_TESS_GEN_POINT_MODE,
        GL_TESS_GEN_SPACING, GL_TESS_GEN_VERTEX_ORDER: {
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }
  _ = GetProgramOrError(program)

  value[0] = ?
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderInfoLog.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetShaderInfoLog.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetShaderInfoLog.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetShaderInfoLog.xhtml", Version.GLES32)
cmd void glGetShaderInfoLog(ShaderId shader,
                            GLsizei  buffer_length,
                            GLsizei* string_length_written,
                            GLchar*  info) {
  _ = GetShaderOrError(shader)
  CheckGE!GLsizei(buffer_length, 0)
  writeString(buffer_length, string_length_written, info)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderPrecisionFormat.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetShaderPrecisionFormat.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetShaderPrecisionFormat.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetShaderPrecisionFormat.xhtml", Version.GLES32)
cmd void glGetShaderPrecisionFormat(GLenum shader_type,
                                    GLenum precision_type,
                                    GLint* range,
                                    GLint* precision) {
  switch (shader_type) {
    case GL_FRAGMENT_SHADER, GL_VERTEX_SHADER: {
      // version 2.0
    }
    default: {
      glErrorInvalidEnum(shader_type)
    }
  }
  switch (precision_type) {
    case GL_HIGH_FLOAT, GL_HIGH_INT, GL_LOW_FLOAT, GL_LOW_INT, GL_MEDIUM_FLOAT, GL_MEDIUM_INT: {
      // version 2.0
    }
    default: {
      glErrorInvalidEnum(precision_type)
    }
  }

  write(range[0:2])
  precision[0] = ?
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderSource.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetShaderSource.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetShaderSource.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetShaderSource.xhtml", Version.GLES32)
cmd void glGetShaderSource(ShaderId shader,
                           GLsizei  buffer_length,
                           GLsizei* string_length_written,
                           GLchar*  source) {
  _ = GetShaderOrError(shader)
  CheckGE!GLsizei(buffer_length, 0)
  // TODO: Handle properly. Mind the null-terminator.
  writeString(buffer_length, string_length_written, source)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderiv.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetShaderiv.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetShaderiv.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetShaderiv.xhtml", Version.GLES32)
cmd void glGetShaderiv(ShaderId shader, GLenum parameter, GLint* value) {
  switch (parameter) {
    case GL_COMPILE_STATUS, GL_DELETE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH,
        GL_SHADER_TYPE: {
      // version 2.0
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }

  s := GetShaderOrError(shader)
  value[0] = switch (parameter) {
    case GL_SHADER_TYPE:          as!GLint(s.Type)
    case GL_DELETE_STATUS:        switch (s.DeleteStatus) { case true: 1 case false: 0 }
    case GL_COMPILE_STATUS:       switch (s.CompileStatus) { case true: 1 case false: 0 }
    case GL_INFO_LOG_LENGTH:      as!GLint(len(s.InfoLog))
    case GL_SHADER_SOURCE_LENGTH: as!GLint(len(s.Source))
  }
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniformBlockIndex.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniformBlockIndex.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniformBlockIndex.xhtml", Version.GLES32)
cmd UniformBlockIndex glGetUniformBlockIndex(ProgramId program, const GLchar* uniformBlockName) {
  _ = as!string(as!char*(uniformBlockName))
  // TODO
  return ?
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniformIndices.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniformIndices.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniformIndices.xhtml", Version.GLES32)
cmd void glGetUniformIndices(ProgramId            program,
                             GLsizei              uniformCount,
                             const GLchar* const* uniformNames,
                             UniformIndex*        uniformIndices) {
  names := uniformNames[0:uniformCount]
  for i in (0 .. uniformCount) {
    _ = as!string(as!char*(names[i]))
  }
  write(uniformIndices[0:uniformCount])
  // TODO
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetUniformLocation.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniformLocation.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniformLocation.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniformLocation.xhtml", Version.GLES32)
cmd UniformLocation glGetUniformLocation(ProgramId program, const GLchar* name) {
  _ = as!string(as!char*(name))
  _ = GetProgramOrError(program)
  return ?
}

sub void GetUniformv!T(ProgramId program, UniformLocation location, T values) {
  _ = GetProgramOrError(program)
  // TODO: Determine size based on uniform type.
  _ = program // TODO
  _ = location // TODO
  write(values[0:16])
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetUniformfv(ProgramId program, UniformLocation location, GLfloat* values) {
  GetUniformv!GLfloat*(program, location, values)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetUniformiv(ProgramId program, UniformLocation location, GLint* values) {
  GetUniformv!GLint*(program, location, values)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetUniformuiv(ProgramId program, UniformLocation location, GLuint* values) {
  GetUniformv!GLuint*(program, location, values)
}

sub void GetnUniformfv!T(ProgramId       program,
                         UniformLocation location,
                         GLsizei         bufSize, // bytes
                         T               values) {
  _ = program // TODO: Use or lose.
  _ = location // TODO: Use or lose.
  write(as!char*(values)[0:bufSize])
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetnUniformfv(ProgramId       program,
                         UniformLocation location,
                         GLsizei         bufSize,
                         GLfloat*        values) {
  GetnUniformfv!GLfloat*(program, location, bufSize, values)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetnUniformiv(ProgramId       program,
                         UniformLocation location,
                         GLsizei         bufSize,
                         GLint*          values) {
  GetnUniformiv(program, location, bufSize, values)
}

sub void GetnUniformiv(ProgramId program, UniformLocation location, GLsizei bufSize, GLint* values) {
  GetnUniformfv!GLint*(program, location, bufSize, values)
}

@if(Version.GLES32)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetUniform.xhtml", Version.GLES32)
cmd void glGetnUniformuiv(ProgramId       program,
                          UniformLocation location,
                          GLsizei         bufSize,
                          GLuint*         values) {
  GetnUniformuiv(program, location, bufSize, values)
}

sub void GetnUniformuiv(ProgramId program, UniformLocation location, GLsizei bufSize, GLuint* values) {
  GetnUniformfv!GLuint*(program, location, bufSize, values)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsProgram.xhtml", Version.GLES32)
cmd GLboolean glIsProgram(ProgramId program) {
  ctx := GetContext()
  return toGLboolean(program in ctx.Objects.Programs)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsProgramPipeline.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsProgramPipeline.xhtml", Version.GLES32)
cmd GLboolean glIsProgramPipeline(PipelineId pipeline) {
  ctx := GetContext()
  return toGLboolean(pipeline in ctx.Objects.Pipelines)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsShader.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsShader.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsShader.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsShader.xhtml", Version.GLES32)
cmd GLboolean glIsShader(ShaderId shader) {
  ctx := GetContext()
  return toGLboolean(shader in ctx.Objects.Shaders)
}

@if(Version.GLES20)
@custom
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glLinkProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glLinkProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glLinkProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glLinkProgram.xhtml", Version.GLES32)
cmd void glLinkProgram(ProgramId program) {
  p := GetProgramOrError(program)
  for _, _, attributeLocation in p.AttributeBindings {
    _ = attributeLocation
  }
  ctx := GetContext()
  ApplyLinkProgramExtra(p, GetLinkProgramExtra(ctx, p, null))
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glMemoryBarrier.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glMemoryBarrier.xhtml", Version.GLES32)
cmd void glMemoryBarrier(GLbitfield barriers) {
  supportsBits(barriers, GL_ALL_BARRIER_BITS | GL_ATOMIC_COUNTER_BARRIER_BIT | GL_BUFFER_UPDATE_BARRIER_BIT | GL_COMMAND_BARRIER_BIT | GL_ELEMENT_ARRAY_BARRIER_BIT | GL_FRAMEBUFFER_BARRIER_BIT | GL_PIXEL_BUFFER_BARRIER_BIT | GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT | GL_TEXTURE_FETCH_BARRIER_BIT | GL_TEXTURE_UPDATE_BARRIER_BIT | GL_TRANSFORM_FEEDBACK_BARRIER_BIT | GL_UNIFORM_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT)
  if (GL_ALL_BARRIER_BITS in barriers) {
  }
  if (GL_ATOMIC_COUNTER_BARRIER_BIT in barriers) {
  }
  if (GL_BUFFER_UPDATE_BARRIER_BIT in barriers) {
  }
  if (GL_COMMAND_BARRIER_BIT in barriers) {
  }
  if (GL_ELEMENT_ARRAY_BARRIER_BIT in barriers) {
  }
  if (GL_FRAMEBUFFER_BARRIER_BIT in barriers) {
  }
  if (GL_PIXEL_BUFFER_BARRIER_BIT in barriers) {
  }
  if (GL_SHADER_IMAGE_ACCESS_BARRIER_BIT in barriers) {
  }
  if (GL_SHADER_STORAGE_BARRIER_BIT in barriers) {
  }
  if (GL_TEXTURE_FETCH_BARRIER_BIT in barriers) {
  }
  if (GL_TEXTURE_UPDATE_BARRIER_BIT in barriers) {
  }
  if (GL_TRANSFORM_FEEDBACK_BARRIER_BIT in barriers) {
  }
  if (GL_UNIFORM_BARRIER_BIT in barriers) {
  }
  if (GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT in barriers) {
  }
  // TODO
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glMemoryBarrier.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glMemoryBarrier.xhtml", Version.GLES32)
cmd void glMemoryBarrierByRegion(GLbitfield barriers) {
  supportsBits(barriers, GL_ALL_BARRIER_BITS | GL_ATOMIC_COUNTER_BARRIER_BIT | GL_BUFFER_UPDATE_BARRIER_BIT | GL_COMMAND_BARRIER_BIT | GL_ELEMENT_ARRAY_BARRIER_BIT | GL_FRAMEBUFFER_BARRIER_BIT | GL_PIXEL_BUFFER_BARRIER_BIT | GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT | GL_TEXTURE_FETCH_BARRIER_BIT | GL_TEXTURE_UPDATE_BARRIER_BIT | GL_TRANSFORM_FEEDBACK_BARRIER_BIT | GL_UNIFORM_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT)
  if (GL_ALL_BARRIER_BITS in barriers) {
  }
  if (GL_ATOMIC_COUNTER_BARRIER_BIT in barriers) {
  }
  if (GL_BUFFER_UPDATE_BARRIER_BIT in barriers) {
  }
  if (GL_COMMAND_BARRIER_BIT in barriers) {
  }
  if (GL_ELEMENT_ARRAY_BARRIER_BIT in barriers) {
  }
  if (GL_FRAMEBUFFER_BARRIER_BIT in barriers) {
  }
  if (GL_PIXEL_BUFFER_BARRIER_BIT in barriers) {
  }
  if (GL_SHADER_IMAGE_ACCESS_BARRIER_BIT in barriers) {
  }
  if (GL_SHADER_STORAGE_BARRIER_BIT in barriers) {
  }
  if (GL_TEXTURE_FETCH_BARRIER_BIT in barriers) {
  }
  if (GL_TEXTURE_UPDATE_BARRIER_BIT in barriers) {
  }
  if (GL_TRANSFORM_FEEDBACK_BARRIER_BIT in barriers) {
  }
  if (GL_UNIFORM_BARRIER_BIT in barriers) {
  }
  if (GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT in barriers) {
  }
  // TODO
}

@if(Version.GLES30)
@custom
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glProgramBinary.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramBinary.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramBinary.xhtml", Version.GLES32)
cmd void glProgramBinary(ProgramId   program,
                         GLenum      binaryFormat,
                         const void* binary,
                         GLsizei     length) {
  ProgramBinary(program, binaryFormat, binary, length)
}

sub void ProgramBinary(ProgramId program, GLenum format, const void* binary, GLsizei length) {
  ctx := GetContext()
  p := GetProgramOrError(program)
  data := clone(as!u8[](binary[0:length]))
  switch (format) {
    case GL_Z400_BINARY_AMD: { }
    default: {
      glErrorInvalidEnum(format)
    }
  }
  b := new!BinaryExtra(Data: data, Format: format, Count: 1)
  ApplyLinkProgramExtra(p, GetLinkProgramExtra(ctx, p, b))
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glProgramParameteri.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramParameteri.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramParameteri.xhtml", Version.GLES32)
cmd void glProgramParameteri(ProgramId program, GLenum pname, GLint value) {
  ProgramParameteri(program, pname, value)
}

sub void ProgramParameteri(ProgramId program, GLenum pname, GLint value) {
  p := GetProgramOrError(program)
  switch (pname) {
    @if(Version.GLES30)
    case GL_PROGRAM_BINARY_RETRIEVABLE_HINT: {
      p.BinaryRetrievableHint = as!bool(value)
    }
    @if(Version.GLES31)
    case GL_PROGRAM_SEPARABLE: {
      p.Separable = as!bool(value)
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1f(ProgramId program, UniformLocation location, GLfloat value0) {
  ProgramUniform1f(program, location, value0)
}

sub void ProgramUniform1f(ProgramId program, UniformLocation location, GLfloat value0) {
  v := value0
  SetProgramUniform!GLfloat(program, location, v, GL_FLOAT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1fv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLfloat*  values) {
  ProgramUniform1fv(program, location, count, values)
}

sub void ProgramUniform1fv(ProgramId program, UniformLocation location, GLsizei count, const GLfloat* values) {
  v := values[0:count]
  SetProgramUniformv!GLfloat(program, location, v, GL_FLOAT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1i(ProgramId program, UniformLocation location, GLint value0) {
  ProgramUniform1i(program, location, value0)
}

sub void ProgramUniform1i(ProgramId program, UniformLocation location, GLint value0) {
  v := value0
  SetProgramUniform!GLint(program, location, v, GL_INT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1iv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLint*    values) {
  ProgramUniform1iv(program, location, count, values)
}

sub void ProgramUniform1iv(ProgramId program, UniformLocation location, GLsizei count, const GLint* values) {
  v := values[0:count]
  SetProgramUniformv!GLint(program, location, v, GL_INT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1ui(ProgramId program, UniformLocation location, GLuint value0) {
  ProgramUniform1ui(program, location, value0)
}

sub void ProgramUniform1ui(ProgramId program, UniformLocation location, GLuint value0) {
  v := value0
  SetProgramUniform!GLuint(program, location, v, GL_UNSIGNED_INT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform1uiv(ProgramId       program,
                              UniformLocation location,
                              GLsizei         count,
                              const GLuint*   values) {
  ProgramUniform1uiv(program, location, count, values)
}

sub void ProgramUniform1uiv(ProgramId program, UniformLocation location, GLsizei count, const GLuint* values) {
  v := values[0:count]
  SetProgramUniformv!GLuint(program, location, v, GL_UNSIGNED_INT)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2f(ProgramId program, UniformLocation location, GLfloat value0, GLfloat value1) {
  ProgramUniform2f(program, location, value0, value1)
}

sub void ProgramUniform2f(ProgramId program, UniformLocation location, GLfloat value0, GLfloat value1) {
  v := Vec2f(value0, value1)
  SetProgramUniform!Vec2f(program, location, v, GL_FLOAT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2fv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLfloat*  values) {
  ProgramUniform2fv(program, location, count, values)
}

sub void ProgramUniform2fv(ProgramId program, UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec2f*(values)[0:count]
  SetProgramUniformv!Vec2f(program, location, v, GL_FLOAT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2i(ProgramId program, UniformLocation location, GLint value0, GLint value1) {
  ProgramUniform2i(program, location, value0, value1)
}

sub void ProgramUniform2i(ProgramId program, UniformLocation location, GLint value0, GLint value1) {
  v := Vec2i(value0, value1)
  SetProgramUniform!Vec2i(program, location, v, GL_INT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2iv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLint*    values) {
  ProgramUniform2iv(program, location, count, values)
}

sub void ProgramUniform2iv(ProgramId program, UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec2i*(values)[0:count]
  SetProgramUniformv!Vec2i(program, location, v, GL_INT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2ui(ProgramId program, UniformLocation location, GLuint value0, GLuint value1) {
  ProgramUniform2ui(program, location, value0, value1)
}

sub void ProgramUniform2ui(ProgramId program, UniformLocation location, GLuint value0, GLuint value1) {
  v := Vec2u(value0, value1)
  SetProgramUniform!Vec2u(program, location, v, GL_UNSIGNED_INT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform2uiv(ProgramId       program,
                              UniformLocation location,
                              GLsizei         count,
                              const GLuint*   values) {
  ProgramUniform2uiv(program, location, count, values)
}

sub void ProgramUniform2uiv(ProgramId program, UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec2u*(values)[0:count]
  SetProgramUniformv!Vec2u(program, location, v, GL_UNSIGNED_INT_VEC2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3f(ProgramId       program,
                            UniformLocation location,
                            GLfloat         value0,
                            GLfloat         value1,
                            GLfloat         value2) {
  ProgramUniform3f(program, location, value0, value1, value2)
}

sub void ProgramUniform3f(ProgramId program, UniformLocation location, GLfloat value0, GLfloat value1, GLfloat value2) {
  v := Vec3f(value0, value1, value2)
  SetProgramUniform!Vec3f(program, location, v, GL_FLOAT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3fv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLfloat*  values) {
  ProgramUniform3fv(program, location, count, values)
}

sub void ProgramUniform3fv(ProgramId program, UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec3f*(values)[0:count]
  SetProgramUniformv!Vec3f(program, location, v, GL_FLOAT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3i(ProgramId       program,
                            UniformLocation location,
                            GLint           value0,
                            GLint           value1,
                            GLint           value2) {
  ProgramUniform3i(program, location, value0, value1, value2)
}

sub void ProgramUniform3i(ProgramId program, UniformLocation location, GLint value0, GLint value1, GLint value2) {
  v := Vec3i(value0, value1, value2)
  SetProgramUniform!Vec3i(program, location, v, GL_INT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3iv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLint*    values) {
  ProgramUniform3iv(program, location, count, values)
}

sub void ProgramUniform3iv(ProgramId program, UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec3i*(values)[0:count]
  SetProgramUniformv!Vec3i(program, location, v, GL_INT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3ui(ProgramId       program,
                             UniformLocation location,
                             GLuint          value0,
                             GLuint          value1,
                             GLuint          value2) {
  ProgramUniform3ui(program, location, value0, value1, value2)
}

sub void ProgramUniform3ui(ProgramId program, UniformLocation location, GLuint value0, GLuint value1, GLuint value2) {
  v := Vec3u(value0, value1, value2)
  SetProgramUniform!Vec3u(program, location, v, GL_UNSIGNED_INT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform3uiv(ProgramId       program,
                              UniformLocation location,
                              GLsizei         count,
                              const GLuint*   values) {
  ProgramUniform3uiv(program, location, count, values)
}

sub void ProgramUniform3uiv(ProgramId program, UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec3u*(values)[0:count]
  SetProgramUniformv!Vec3u(program, location, v, GL_UNSIGNED_INT_VEC3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4f(ProgramId       program,
                            UniformLocation location,
                            GLfloat         value0,
                            GLfloat         value1,
                            GLfloat         value2,
                            GLfloat         value3) {
  ProgramUniform4f(program, location, value0, value1, value2, value3)
}

sub void ProgramUniform4f(ProgramId program, UniformLocation location, GLfloat value0, GLfloat value1, GLfloat value2, GLfloat value3) {
  v := Vec4f(value0, value1, value2, value3)
  SetProgramUniform!Vec4f(program, location, v, GL_FLOAT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4fv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLfloat*  values) {
  ProgramUniform4fv(program, location, count, values)
}

sub void ProgramUniform4fv(ProgramId program, UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec4f*(values)[0:count]
  SetProgramUniformv!Vec4f(program, location, v, GL_FLOAT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4i(ProgramId       program,
                            UniformLocation location,
                            GLint           value0,
                            GLint           value1,
                            GLint           value2,
                            GLint           value3) {
  ProgramUniform4i(program, location, value0, value1, value2, value3)
}

sub void ProgramUniform4i(ProgramId program, UniformLocation location, GLint value0, GLint value1, GLint value2, GLint value3) {
  v := Vec4i(value0, value1, value2, value3)
  SetProgramUniform!Vec4i(program, location, v, GL_INT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4iv(ProgramId       program,
                             UniformLocation location,
                             GLsizei         count,
                             const GLint*    values) {
  ProgramUniform4iv(program, location, count, values)
}

sub void ProgramUniform4iv(ProgramId program, UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec4i*(values)[0:count]
  SetProgramUniformv!Vec4i(program, location, v, GL_INT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4ui(ProgramId       program,
                             UniformLocation location,
                             GLuint          value0,
                             GLuint          value1,
                             GLuint          value2,
                             GLuint          value3) {
  ProgramUniform4ui(program, location, value0, value1, value2, value3)
}

sub void ProgramUniform4ui(ProgramId program, UniformLocation location, GLuint value0, GLuint value1, GLuint value2, GLuint value3) {
  v := Vec4u(value0, value1, value2, value3)
  SetProgramUniform!Vec4u(program, location, v, GL_UNSIGNED_INT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniform4uiv(ProgramId       program,
                              UniformLocation location,
                              GLsizei         count,
                              const GLuint*   values) {
  ProgramUniform4uiv(program, location, count, values)
}

sub void ProgramUniform4uiv(ProgramId program, UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec4u*(values)[0:count]
  SetProgramUniformv!Vec4u(program, location, v, GL_UNSIGNED_INT_VEC4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix2fv(ProgramId       program,
                                   UniformLocation location,
                                   GLsizei         count,
                                   GLboolean       transpose,
                                   const GLfloat*  values) {
  ProgramUniformMatrix2fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix2fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat2f*(values)[0:count]
  SetProgramUniformMatrixv!Mat2f(program, location, transpose, v, GL_FLOAT_MAT2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix2x3fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix2x3fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix2x3fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat2x3f*(values)[0:count]
  SetProgramUniformMatrixv!Mat2x3f(program, location, transpose, v, GL_FLOAT_MAT2x3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix2x4fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix2x4fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix2x4fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat2x4f*(values)[0:count]
  SetProgramUniformMatrixv!Mat2x4f(program, location, transpose, v, GL_FLOAT_MAT2x4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix3fv(ProgramId       program,
                                   UniformLocation location,
                                   GLsizei         count,
                                   GLboolean       transpose,
                                   const GLfloat*  values) {
  ProgramUniformMatrix3fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix3fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat3f*(values)[0:count]
  SetProgramUniformMatrixv!Mat3f(program, location, transpose, v, GL_FLOAT_MAT3)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix3x2fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix3x2fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix3x2fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat3x2f*(values)[0:count]
  SetProgramUniformMatrixv!Mat3x2f(program, location, transpose, v, GL_FLOAT_MAT3x2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix3x4fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix3x4fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix3x4fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat3x4f*(values)[0:count]
  SetProgramUniformMatrixv!Mat3x4f(program, location, transpose, v, GL_FLOAT_MAT3x4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix4fv(ProgramId       program,
                                   UniformLocation location,
                                   GLsizei         count,
                                   GLboolean       transpose,
                                   const GLfloat*  values) {
  ProgramUniformMatrix4fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix4fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat4f*(values)[0:count]
  SetProgramUniformMatrixv!Mat4f(program, location, transpose, v, GL_FLOAT_MAT4)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix4x2fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix4x2fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix4x2fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat4x2f*(values)[0:count]
  SetProgramUniformMatrixv!Mat4x2f(program, location, transpose, v, GL_FLOAT_MAT4x2)
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glProgramUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glProgramUniform.xhtml", Version.GLES32)
cmd void glProgramUniformMatrix4x3fv(ProgramId       program,
                                     UniformLocation location,
                                     GLsizei         count,
                                     GLboolean       transpose,
                                     const GLfloat*  values) {
  ProgramUniformMatrix4x3fv(program, location, count, transpose, values)
}

sub void ProgramUniformMatrix4x3fv(ProgramId program, UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat4x3f*(values)[0:count]
  SetProgramUniformMatrixv!Mat4x3f(program, location, transpose, v, GL_FLOAT_MAT4x3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glReleaseShaderCompiler.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glReleaseShaderCompiler.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glReleaseShaderCompiler.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glReleaseShaderCompiler.xhtml", Version.GLES32)
cmd void glReleaseShaderCompiler() {

}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glShaderBinary.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glShaderBinary.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glShaderBinary.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glShaderBinary.xhtml", Version.GLES32)
cmd void glShaderBinary(GLsizei         count,
                        const ShaderId* shaders,
                        GLenum          binary_format,
                        const void*     binary,
                        GLsizei         binary_size) {
  ctx := GetContext()
  t := shaders[0:count]
  for i in (0 .. count) {
    _ := GetShaderOrError(t[i]) // Error check only.
  }
  data := clone(as!u8[](binary[0:binary_size]))
  switch (binary_format) {
    default: {
      glErrorInvalidEnum(binary_format)
    }
  }
  fence // TODO: Automatic placement failed.
  for i in (0 .. count) {
    s := GetShaderOrError(t[i])
    b := new!BinaryExtra(
      Data:    data,
      Format:  binary_format,
      Count:   count,
      Index:   i,
    )
    ApplyCompileShaderExtra(s, GetCompileShaderExtra(ctx, s, b))
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glShaderSource.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glShaderSource.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glShaderSource.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glShaderSource.xhtml", Version.GLES32)
cmd void glShaderSource(ShaderId             shader,
                        GLsizei              count,
                        const GLchar* const* source,
                        const GLint*         length) {
  CheckCountGE!GLsizei(count, 0)

  sources := source[0:count]
  s := GetShaderOrError(shader)
  s.Source = as!string(null)
  if length == null {
    for i in (0 .. count) {
      str := as!string(as!char*(sources[i]))
      s.Source += str
    }
  } else {
    lengths := length[0:count]
    for i in (0 .. count) {
      str := switch lengths[i] < 0 {
        case true:  as!string(as!char*(sources[i]))
        case false: as!string(as!char*(sources[i])[0:lengths[i]])
      }
      s.Source += str
    }
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1f(UniformLocation location, GLfloat value) {
  v := value
  SetUniform!GLfloat(location, v, GL_FLOAT)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1fv(UniformLocation location, GLsizei count, const GLfloat* values) {
  v := values[0:count]
  SetUniformv!GLfloat(location, v, GL_FLOAT)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1i(UniformLocation location, GLint value) {
  v := value
  SetUniform!GLint(location, v, GL_INT)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1iv(UniformLocation location, GLsizei count, const GLint* values) {
  v := values[0:count]
  SetUniformv!GLint(location, v, GL_INT)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1ui(UniformLocation location, GLuint value0) {
  v := value0
  SetUniform!GLuint(location, v, GL_UNSIGNED_INT)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform1uiv(UniformLocation location, GLsizei count, const GLuint* values) {
  v := values[0:count]
  SetUniformv!GLuint(location, v, GL_UNSIGNED_INT)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2f(UniformLocation location, GLfloat value0, GLfloat value1) {
  v := Vec2f(value0, value1)
  SetUniform!Vec2f(location, v, GL_FLOAT_VEC2)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2fv(UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec2f*(values)[0:count]
  SetUniformv!Vec2f(location, v, GL_FLOAT_VEC2)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2i(UniformLocation location, GLint value0, GLint value1) {
  v := Vec2i(value0, value1)
  SetUniform!Vec2i(location, v, GL_INT_VEC2)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2iv(UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec2i*(values)[0:count]
  SetUniformv!Vec2i(location, v, GL_INT_VEC2)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2ui(UniformLocation location, GLuint value0, GLuint value1) {
  v := Vec2u(value0, value1)
  SetUniform!Vec2u(location, v, GL_UNSIGNED_INT_VEC2)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform2uiv(UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec2u*(values)[0:count]
  SetUniformv!Vec2u(location, v, GL_UNSIGNED_INT_VEC2)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3f(UniformLocation location, GLfloat value0, GLfloat value1, GLfloat value2) {
  v := Vec3f(value0, value1, value2)
  SetUniform!Vec3f(location, v, GL_FLOAT_VEC3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3fv(UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec3f*(values)[0:count]
  SetUniformv!Vec3f(location, v, GL_FLOAT_VEC3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3i(UniformLocation location, GLint value0, GLint value1, GLint value2) {
  v := Vec3i(value0, value1, value2)
  SetUniform!Vec3i(location, v, GL_INT_VEC3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3iv(UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec3i*(values)[0:count]
  SetUniformv!Vec3i(location, v, GL_INT_VEC3)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3ui(UniformLocation location, GLuint value0, GLuint value1, GLuint value2) {
  v := Vec3u(value0, value1, value2)
  SetUniform!Vec3u(location, v, GL_UNSIGNED_INT_VEC3)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform3uiv(UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec3u*(values)[0:count]
  SetUniformv!Vec3u(location, v, GL_UNSIGNED_INT_VEC3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4f(UniformLocation location,
                     GLfloat         value0,
                     GLfloat         value1,
                     GLfloat         value2,
                     GLfloat         value3) {
  v := Vec4f(value0, value1, value2, value3)
  SetUniform!Vec4f(location, v, GL_FLOAT_VEC4)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4fv(UniformLocation location, GLsizei count, const GLfloat* values) {
  v := as!Vec4f*(values)[0:count]
  SetUniformv!Vec4f(location, v, GL_FLOAT_VEC4)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4i(UniformLocation location,
                     GLint           value0,
                     GLint           value1,
                     GLint           value2,
                     GLint           value3) {
  v := Vec4i(value0, value1, value2, value3)
  SetUniform!Vec4i(location, v, GL_INT_VEC4)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4iv(UniformLocation location, GLsizei count, const GLint* values) {
  v := as!Vec4i*(values)[0:count]
  SetUniformv!Vec4i(location, v, GL_INT_VEC4)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4ui(UniformLocation location, GLuint value0, GLuint value1, GLuint value2, GLuint value3) {
  v := Vec4u(value0, value1, value2, value3)
  SetUniform!Vec4u(location, v, GL_UNSIGNED_INT_VEC4)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniform4uiv(UniformLocation location, GLsizei count, const GLuint* values) {
  v := as!Vec4u*(values)[0:count]
  SetUniformv!Vec4u(location, v, GL_UNSIGNED_INT_VEC4)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniformBlockBinding.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniformBlockBinding.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniformBlockBinding.xhtml", Version.GLES32)
cmd void glUniformBlockBinding(ProgramId         program,
                               UniformBlockIndex uniform_block_index,
                               GLuint            uniform_block_binding) {
  ctx := GetContext()
  p := GetProgramOrError(program)
  ub := p.ActiveResources.UniformBlocks[as!u32(uniform_block_index)]
  if ub == null { glErrorInvalidValue!UniformBlockIndex(uniform_block_index) }
  CheckLT!GLuint(uniform_block_binding, as!GLuint(ctx.Constants.MaxUniformBufferBindings))
  ub.Binding = as!GLint(uniform_block_binding)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix2fv(UniformLocation location,
                            GLsizei         count,
                            GLboolean       transpose,
                            const GLfloat*  values) {
  v := as!Mat2f*(values)[0:count]
  SetUniformMatrixv!Mat2f(location, transpose, v, GL_FLOAT_MAT2)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix2x3fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix2x3fv(location, count, transpose, values)
}

sub void UniformMatrix2x3fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat2x3f*(values)[0:count]
  SetUniformMatrixv!Mat2x3f(location, transpose, v, GL_FLOAT_MAT2x3)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix2x4fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix2x4fv(location, count, transpose, values)
}

sub void UniformMatrix2x4fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat2x4f*(values)[0:count]
  SetUniformMatrixv!Mat2x4f(location, transpose, v, GL_FLOAT_MAT2x4)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix3fv(UniformLocation location,
                            GLsizei         count,
                            GLboolean       transpose,
                            const GLfloat*  values) {
  v := as!Mat3f*(values)[0:count]
  SetUniformMatrixv!Mat3f(location, transpose, v, GL_FLOAT_MAT3)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix3x2fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix3x2fv(location, count, transpose, values)
}

sub void UniformMatrix3x2fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat3x2f*(values)[0:count]
  SetUniformMatrixv!Mat3x2f(location, transpose, v, GL_FLOAT_MAT3x2)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix3x4fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix3x4fv(location, count, transpose, values)
}

sub void UniformMatrix3x4fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat3x4f*(values)[0:count]
  SetUniformMatrixv!Mat3x4f(location, transpose, v, GL_FLOAT_MAT3x4)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUniform.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix4fv(UniformLocation location,
                            GLsizei         count,
                            GLboolean       transpose,
                            const GLfloat*  values) {
  v := as!Mat4f*(values)[0:count]
  SetUniformMatrixv!Mat4f(location, transpose, v, GL_FLOAT_MAT4)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix4x2fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix4x2fv(location, count, transpose, values)
}

sub void UniformMatrix4x2fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat4x2f*(values)[0:count]
  SetUniformMatrixv!Mat4x2f(location, transpose, v, GL_FLOAT_MAT4x2)
}

@if(Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUniform.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUniform.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUniform.xhtml", Version.GLES32)
cmd void glUniformMatrix4x3fv(UniformLocation location,
                              GLsizei         count,
                              GLboolean       transpose,
                              const GLfloat*  values) {
  UniformMatrix4x3fv(location, count, transpose, values)
}

sub void UniformMatrix4x3fv(UniformLocation location, GLsizei count, GLboolean transpose, const GLfloat* values) {
  v := as!Mat4x3f*(values)[0:count]
  SetUniformMatrixv!Mat4x3f(location, transpose, v, GL_FLOAT_MAT4x3)
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUseProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glUseProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUseProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUseProgram.xhtml", Version.GLES32)
cmd void glUseProgram(ProgramId program) {
  ctx := GetContext()
  // TODO: Invalid op if transform feedback is active.
  if program == 0 {
    AdjustProgramUseCount(ctx.Bound.Program, -1)
    ctx.Bound.Program = null
  } else {
    p := GetProgramOrError(program)
    if p.LinkStatus == GL_FALSE { glErrorInvalidOperation() }
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(ctx.Bound.Program, -1)
    ctx.Bound.Program = p
  }
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glUseProgramStages.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glUseProgramStages.xhtml", Version.GLES32)
cmd void glUseProgramStages(PipelineId pipeline, GLbitfield stages, ProgramId program) {
  pipe := GetOrCreatePipelineOrError(pipeline)
  supportsBits(stages, GL_ALL_SHADER_BITS | GL_COMPUTE_SHADER_BIT | GL_FRAGMENT_SHADER_BIT | GL_VERTEX_SHADER_BIT)
  if program == 0 {
    SetProgramStates(pipe, stages, null)
  } else {
    p := GetProgramOrError(program)
    if p.LinkStatus == GL_FALSE { glErrorInvalidOperation() }
    if !p.LinkExtra.Separable { glErrorInvalidOperation() }
    SetProgramStates(pipe, stages, p)
  }
}

sub void SetProgramStates(ref!Pipeline pipe, GLbitfield stages, ref!Program p) {
  if (GL_COMPUTE_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.ComputeShader, -1)
    pipe.ComputeShader = p
  }
  if (GL_FRAGMENT_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.FragmentShader, -1)
    pipe.FragmentShader = p
  }
  if (GL_VERTEX_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.VertexShader, -1)
    pipe.VertexShader = p
  }
  if (GL_TESS_CONTROL_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.TessControlShader, -1)
    pipe.TessControlShader = p
  }
  if (GL_TESS_EVALUATION_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.TessEvaluationShader, -1)
    pipe.TessEvaluationShader = p
  }
  if (GL_GEOMETRY_SHADER_BIT in stages) {
    AdjustProgramUseCount(p, +1)
    AdjustProgramUseCount(pipe.GeometryShader, -1)
    pipe.GeometryShader = p
  }
}

@if(Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glValidateProgram.xml", Version.GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glValidateProgram.xhtml", Version.GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glValidateProgram.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glValidateProgram.xhtml", Version.GLES32)
cmd void glValidateProgram(ProgramId program) {
  ctx := GetContext()
  p := GetProgramOrError(program)
  ApplyValidateProgramExtra(p, GetValidateProgramExtra(ctx, p))
}

@if(Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glValidateProgramPipeline.xhtml", Version.GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glValidateProgramPipeline.xhtml", Version.GLES32)
cmd void glValidateProgramPipeline(PipelineId pipeline) {
  ctx := GetContext()
  pipe := GetOrCreatePipelineOrError(pipeline)
  ApplyValidateProgramPipelineExtra(pipe, GetValidateProgramPipelineExtra(ctx, pipe))
}

