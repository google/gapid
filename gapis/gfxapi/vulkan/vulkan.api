// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based off of the original vulkan.h header file which has the following
// license.

// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

api_index 2

import "android/vulkan_android.api"
import "linux/vulkan_linux.api"
import "windows/vulkan_windows.api"
import "synthetic.api"

///////////////
// Constants //
///////////////

// API version (major.minor.patch)
define VERSION_MAJOR 1
define VERSION_MINOR 0
define VERSION_PATCH 3

// API limits
define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
define VK_UUID_SIZE                     16

define VK_MAX_EXTENSION_NAME_SIZE 256
define VK_MAX_DESCRIPTION_SIZE    256
define VK_MAX_MEMORY_TYPES        32
define VK_MAX_MEMORY_HEAPS        16 /// The maximum number of unique memory heaps, each of which supporting 1 or more memory types.

// API keywords
define VK_TRUE  1
define VK_FALSE 0

// API keyword, but needs special handling by some templates
define NULL_HANDLE 0

@extension("VK_KHR_surface") define VK_KHR_SURFACE_SPEC_VERSION   25
@extension("VK_KHR_surface") define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"

@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_SPEC_VERSION   67
@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"

@extension("VK_KHR_display") define VK_KHR_DISPLAY_SPEC_VERSION   21
@extension("VK_KHR_display") define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"

@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION   9
@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"

@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_SPEC_VERSION   1
@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"


/////////////
//  Types  //
/////////////

type u32 VkFlags
type u32 VkBool32
type u64 VkDeviceSize
type u32 VkSampleMask

/// Dispatchable handle types.
@replay_remap @dispatchHandle type size VkInstance
@replay_remap @dispatchHandle type size VkPhysicalDevice
@replay_remap @dispatchHandle type size VkDevice
@replay_remap @dispatchHandle type size VkQueue
@replay_remap @dispatchHandle type size VkCommandBuffer

/// Non dispatchable handle types.
@replay_remap @nonDispatchHandle type u64 VkSemaphore
@replay_remap @nonDispatchHandle type u64 VkFence
@replay_remap @nonDispatchHandle type u64 VkDeviceMemory
@replay_remap @nonDispatchHandle type u64 VkBuffer
@replay_remap @nonDispatchHandle type u64 VkImage
@replay_remap @nonDispatchHandle type u64 VkEvent
@replay_remap @nonDispatchHandle type u64 VkQueryPool
@replay_remap @nonDispatchHandle type u64 VkBufferView
@replay_remap @nonDispatchHandle type u64 VkImageView
@replay_remap @nonDispatchHandle type u64 VkShaderModule
@replay_remap @nonDispatchHandle type u64 VkPipelineCache
@replay_remap @nonDispatchHandle type u64 VkPipelineLayout
@replay_remap @nonDispatchHandle type u64 VkRenderPass
@replay_remap @nonDispatchHandle type u64 VkPipeline
@replay_remap @nonDispatchHandle type u64 VkDescriptorSetLayout
@replay_remap @nonDispatchHandle type u64 VkSampler
@replay_remap @nonDispatchHandle type u64 VkDescriptorPool
@replay_remap @nonDispatchHandle type u64 VkDescriptorSet
@replay_remap @nonDispatchHandle type u64 VkFramebuffer
@replay_remap @nonDispatchHandle type u64 VkCommandPool

@extension("VK_KHR_surface") @replay_remap @nonDispatchHandle type u64 VkSurfaceKHR

@extension("VK_KHR_swapchain") @replay_remap @nonDispatchHandle type u64 VkSwapchainKHR

@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayKHR
@extension("VK_KHR_display") @replay_remap @nonDispatchHandle type u64 VkDisplayModeKHR

@extension("VK_EXT_debug_report") @replay_remap @nonDispatchHandle type u64 VkDebugReportCallbackEXT


/////////////
//  Enums  //
/////////////

extern void mapMemory(void** mem, u8[] slice)
extern void unmapMemory(u8[] slice)
extern void trackMappedCoherentMemory(u64 start, size size)
extern void readMappedCoherentMemory(VkDeviceMemory memory, u64 offset_in_mapped, size readSize)
extern void untrackMappedCoherentMemory(u64 start, size size)

@unused
enum VkPipelineCacheHeaderVersion {
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}

@lastUnused(-11)
/// Error and return codes
enum VkResult {
  // Return codes for successful operation execution (positive values)
  VK_SUCCESS     = 0,
  VK_NOT_READY   = 1,
  VK_TIMEOUT     = 2,
  VK_EVENT_SET   = 3,
  VK_EVENT_RESET = 4,
  VK_INCOMPLETE  = 5,

  // Error codes (negative values)
  VK_ERROR_OUT_OF_HOST_MEMORY    = 0xFFFFFFFF, // -1
  VK_ERROR_OUT_OF_DEVICE_MEMORY  = 0xFFFFFFFE, // -2
  VK_ERROR_INITIALIZATION_FAILED = 0xFFFFFFFD, // -3
  VK_ERROR_DEVICE_LOST           = 0xFFFFFFFC, // -4
  VK_ERROR_MEMORY_MAP_FAILED     = 0xFFFFFFFB, // -5
  VK_ERROR_LAYER_NOT_PRESENT     = 0xFFFFFFFA, // -6
  VK_ERROR_EXTENSION_NOT_PRESENT = 0xFFFFFFF9, // -7
  VK_ERROR_FEATURE_NOT_PRESENT   = 0xFFFFFFF8, // -8
  VK_ERROR_INCOMPATIBLE_DRIVER   = 0xFFFFFFF7, // -9
  VK_ERROR_TOO_MANY_OBJECTS      = 0xFFFFFFF6, // -10
  VK_ERROR_FORMAT_NOT_SUPPORTED  = 0xFFFFFFF5, // -11

  //@extension("VK_KHR_surface")
  VK_ERROR_SURFACE_LOST_KHR = 0xC4653600, // -1000000000

  //@extension("VK_KHR_surface")
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = 0xC46535FF, // -1000008001

  //@extension("VK_KHR_swapchain")
  VK_SUBOPTIMAL_KHR = 1000001003,

  //@extension("VK_KHR_swapchain")
  VK_ERROR_OUT_OF_DATE_KHR = 0xC4653214, // -1000001004

  //@extension("VK_KHR_display_swapchain")
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = 0xC4652A47, // -1000003001

  //@extension("VK_EXT_debug_report")
  VK_ERROR_VALIDATION_FAILED_EXT = 0xC4650B07, // -1000011001

  VK_ERROR_INVALID_SHADER_NV = 0x3B9AF8E0, // -1000012000
}

/// Structure type enumerant
enum VkStructureType {
  VK_STRUCTURE_TYPE_APPLICATION_INFO                          = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                      = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                  = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                        = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO                               = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                      = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                       = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                          = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                         = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                     = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                         = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                    = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                        = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                   = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                         = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                    = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                 = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO         = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO   = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO   = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO       = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO  = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO    = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO  = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO    = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO        = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO             = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO              = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO               = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                       = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO         = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO               = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO              = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                      = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                       = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                   = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                   = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                  = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO              = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO           = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                 = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                    = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                     = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                      = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER                            = 46,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO               = 47,
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                 = 48,

  //@extension("VK_KHR_swapchain")
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR          = 1000001001,

  //@extension("VK_KHR_display")
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR    = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,

  //@extension("VK_KHR_display_swapchain")
  VK_STRUCTURE_TYPE_DISPLAY_DISPLAY_PRESENT_INFO_KHR = 1000003000,

  //@extension("VK_KHR_xlib_surface")
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,

  //@extension("VK_KHR_xcb_surface")
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,

  //@extension("VK_KHR_wayland_surface")
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,

  //@extension("VK_KHR_mir_surface")
  VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,

  //@extension("VK_KHR_android_surface")
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,

  //@extension("VK_KHR_win32_surface")
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,

  //@extension("VK_ANDROID_native_buffer")
  VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,

  //@extension("VK_EXT_debug_report")
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,

  //@extension("VK_NV_dedicated_allocation")
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV    = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV   = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
}

enum VkSystemAllocationScope {
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND  = 0x00000000,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT   = 0x00000001,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE    = 0x00000002,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE   = 0x00000003,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 0x00000004,
}

enum VkInternalAllocationType {
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0x00000000,
}

/// Vulkan format definitions
enum VkFormat {
  VK_FORMAT_UNDEFINED                  = 0,
  VK_FORMAT_R4G4_UNORM_PACK8           = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16      = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16      = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16        = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16        = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16      = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16      = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16      = 8,
  VK_FORMAT_R8_UNORM                   = 9,
  VK_FORMAT_R8_SNORM                   = 10,
  VK_FORMAT_R8_USCALED                 = 11,
  VK_FORMAT_R8_SSCALED                 = 12,
  VK_FORMAT_R8_UINT                    = 13,
  VK_FORMAT_R8_SINT                    = 14,
  VK_FORMAT_R8_SRGB                    = 15,
  VK_FORMAT_R8G8_UNORM                 = 16,
  VK_FORMAT_R8G8_SNORM                 = 17,
  VK_FORMAT_R8G8_USCALED               = 18,
  VK_FORMAT_R8G8_SSCALED               = 19,
  VK_FORMAT_R8G8_UINT                  = 20,
  VK_FORMAT_R8G8_SINT                  = 21,
  VK_FORMAT_R8G8_SRGB                  = 22,
  VK_FORMAT_R8G8B8_UNORM               = 23,
  VK_FORMAT_R8G8B8_SNORM               = 24,
  VK_FORMAT_R8G8B8_USCALED             = 25,
  VK_FORMAT_R8G8B8_SSCALED             = 26,
  VK_FORMAT_R8G8B8_UINT                = 27,
  VK_FORMAT_R8G8B8_SINT                = 28,
  VK_FORMAT_R8G8B8_SRGB                = 29,
  VK_FORMAT_B8G8R8_UNORM               = 30,
  VK_FORMAT_B8G8R8_SNORM               = 31,
  VK_FORMAT_B8G8R8_USCALED             = 32,
  VK_FORMAT_B8G8R8_SSCALED             = 33,
  VK_FORMAT_B8G8R8_UINT                = 34,
  VK_FORMAT_B8G8R8_SINT                = 35,
  VK_FORMAT_B8G8R8_SRGB                = 36,
  VK_FORMAT_R8G8B8A8_UNORM             = 37,
  VK_FORMAT_R8G8B8A8_SNORM             = 38,
  VK_FORMAT_R8G8B8A8_USCALED           = 39,
  VK_FORMAT_R8G8B8A8_SSCALED           = 40,
  VK_FORMAT_R8G8B8A8_UINT              = 41,
  VK_FORMAT_R8G8B8A8_SINT              = 42,
  VK_FORMAT_R8G8B8A8_SRGB              = 43,
  VK_FORMAT_B8G8R8A8_UNORM             = 44,
  VK_FORMAT_B8G8R8A8_SNORM             = 45,
  VK_FORMAT_B8G8R8A8_USCALED           = 46,
  VK_FORMAT_B8G8R8A8_SSCALED           = 47,
  VK_FORMAT_B8G8R8A8_UINT              = 48,
  VK_FORMAT_B8G8R8A8_SINT              = 49,
  VK_FORMAT_B8G8R8A8_SRGB              = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32      = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32      = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32    = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32    = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32       = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32       = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32       = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32   = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32   = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32    = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32    = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32   = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32   = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32    = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32    = 69,
  VK_FORMAT_R16_UNORM                  = 70,
  VK_FORMAT_R16_SNORM                  = 71,
  VK_FORMAT_R16_USCALED                = 72,
  VK_FORMAT_R16_SSCALED                = 73,
  VK_FORMAT_R16_UINT                   = 74,
  VK_FORMAT_R16_SINT                   = 75,
  VK_FORMAT_R16_SFLOAT                 = 76,
  VK_FORMAT_R16G16_UNORM               = 77,
  VK_FORMAT_R16G16_SNORM               = 78,
  VK_FORMAT_R16G16_USCALED             = 79,
  VK_FORMAT_R16G16_SSCALED             = 80,
  VK_FORMAT_R16G16_UINT                = 81,
  VK_FORMAT_R16G16_SINT                = 82,
  VK_FORMAT_R16G16_SFLOAT              = 83,
  VK_FORMAT_R16G16B16_UNORM            = 84,
  VK_FORMAT_R16G16B16_SNORM            = 85,
  VK_FORMAT_R16G16B16_USCALED          = 86,
  VK_FORMAT_R16G16B16_SSCALED          = 87,
  VK_FORMAT_R16G16B16_UINT             = 88,
  VK_FORMAT_R16G16B16_SINT             = 89,
  VK_FORMAT_R16G16B16_SFLOAT           = 90,
  VK_FORMAT_R16G16B16A16_UNORM         = 91,
  VK_FORMAT_R16G16B16A16_SNORM         = 92,
  VK_FORMAT_R16G16B16A16_USCALED       = 93,
  VK_FORMAT_R16G16B16A16_SSCALED       = 94,
  VK_FORMAT_R16G16B16A16_UINT          = 95,
  VK_FORMAT_R16G16B16A16_SINT          = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT        = 97,
  VK_FORMAT_R32_UINT                   = 98,
  VK_FORMAT_R32_SINT                   = 99,
  VK_FORMAT_R32_SFLOAT                 = 100,
  VK_FORMAT_R32G32_UINT                = 101,
  VK_FORMAT_R32G32_SINT                = 102,
  VK_FORMAT_R32G32_SFLOAT              = 103,
  VK_FORMAT_R32G32B32_UINT             = 104,
  VK_FORMAT_R32G32B32_SINT             = 105,
  VK_FORMAT_R32G32B32_SFLOAT           = 106,
  VK_FORMAT_R32G32B32A32_UINT          = 107,
  VK_FORMAT_R32G32B32A32_SINT          = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT        = 109,
  VK_FORMAT_R64_UINT                   = 110,
  VK_FORMAT_R64_SINT                   = 111,
  VK_FORMAT_R64_SFLOAT                 = 112,
  VK_FORMAT_R64G64_UINT                = 113,
  VK_FORMAT_R64G64_SINT                = 114,
  VK_FORMAT_R64G64_SFLOAT              = 115,
  VK_FORMAT_R64G64B64_UINT             = 116,
  VK_FORMAT_R64G64B64_SINT             = 117,
  VK_FORMAT_R64G64B64_SFLOAT           = 118,
  VK_FORMAT_R64G64B64A64_UINT          = 119,
  VK_FORMAT_R64G64B64A64_SINT          = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT        = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32    = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32     = 123,
  VK_FORMAT_D16_UNORM                  = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32        = 125,
  VK_FORMAT_D32_SFLOAT                 = 126,
  VK_FORMAT_S8_UINT                    = 127,
  VK_FORMAT_D16_UNORM_S8_UINT          = 128,
  VK_FORMAT_D24_UNORM_S8_UINT          = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT         = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK        = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK         = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK       = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK        = 134,
  VK_FORMAT_BC2_UNORM_BLOCK            = 135,
  VK_FORMAT_BC2_SRGB_BLOCK             = 136,
  VK_FORMAT_BC3_UNORM_BLOCK            = 137,
  VK_FORMAT_BC3_SRGB_BLOCK             = 138,
  VK_FORMAT_BC4_UNORM_BLOCK            = 139,
  VK_FORMAT_BC4_SNORM_BLOCK            = 140,
  VK_FORMAT_BC5_UNORM_BLOCK            = 141,
  VK_FORMAT_BC5_SNORM_BLOCK            = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK          = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK          = 144,
  VK_FORMAT_BC7_UNORM_BLOCK            = 145,
  VK_FORMAT_BC7_SRGB_BLOCK             = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK    = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK     = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK  = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK   = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK  = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK   = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK        = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK        = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK     = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK     = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK       = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK        = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK       = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK        = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK       = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK        = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK       = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK        = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK       = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK        = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK       = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK        = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK       = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK        = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK       = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK        = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK      = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK       = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK      = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK       = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK      = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK       = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK     = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK      = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK     = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK      = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK     = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK      = 184,
}

enum VkImageType {
  VK_IMAGE_TYPE_1D = 0x00000000,
  VK_IMAGE_TYPE_2D = 0x00000001,
  VK_IMAGE_TYPE_3D = 0x00000002,
}

enum VkImageTiling {
  VK_IMAGE_TILING_OPTIMAL = 0x00000000,
  VK_IMAGE_TILING_LINEAR  = 0x00000001,
}

enum VkPhysicalDeviceType {
  VK_PHYSICAL_DEVICE_TYPE_OTHER          = 0x00000000,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 0x00000001,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU   = 0x00000002,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU    = 0x00000003,
  VK_PHYSICAL_DEVICE_TYPE_CPU            = 0x00000004,
}

enum VkQueryType {
  VK_QUERY_TYPE_OCCLUSION           = 0x00000000,
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 0x00000001, /// Optional
  VK_QUERY_TYPE_TIMESTAMP           = 0x00000002,
}

enum VkSharingMode {
  VK_SHARING_MODE_EXCLUSIVE  = 0x00000000,
  VK_SHARING_MODE_CONCURRENT = 0x00000001,
}

enum VkImageLayout {
  VK_IMAGE_LAYOUT_UNDEFINED                        = 0x00000000, /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
  VK_IMAGE_LAYOUT_GENERAL                          = 0x00000001, /// General layout when image can be used for any kind of access
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL         = 0x00000002, /// Optimal layout when image is only used for color attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 0x00000003, /// Optimal layout when image is only used for depth/stencil attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL  = 0x00000004, /// Optimal layout when image is used for read only depth/stencil attachment and shader access
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL         = 0x00000005, /// Optimal layout when image is used for read only shader access
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL             = 0x00000006, /// Optimal layout when image is used only as source of transfer operations
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL             = 0x00000007, /// Optimal layout when image is used only as destination of transfer operations
  VK_IMAGE_LAYOUT_PREINITIALIZED                   = 0x00000008, /// Initial layout used when the data is populated by the CPU

  //@extension("VK_KHR_swapchain")
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
}

enum VkImageViewType {
  VK_IMAGE_VIEW_TYPE_1D         = 0x00000000,
  VK_IMAGE_VIEW_TYPE_2D         = 0x00000001,
  VK_IMAGE_VIEW_TYPE_3D         = 0x00000002,
  VK_IMAGE_VIEW_TYPE_CUBE       = 0x00000003,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY   = 0x00000004,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY   = 0x00000005,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 0x00000006,
}

enum VkComponentSwizzle {
  VK_COMPONENT_SWIZZLE_IDENTITY = 0x00000000,
  VK_COMPONENT_SWIZZLE_ZERO     = 0x00000001,
  VK_COMPONENT_SWIZZLE_ONE      = 0x00000002,
  VK_COMPONENT_SWIZZLE_R        = 0x00000003,
  VK_COMPONENT_SWIZZLE_G        = 0x00000004,
  VK_COMPONENT_SWIZZLE_B        = 0x00000005,
  VK_COMPONENT_SWIZZLE_A        = 0x00000006,
}

enum VkVertexInputRate {
  VK_VERTEX_INPUT_RATE_VERTEX   = 0x00000000,
  VK_VERTEX_INPUT_RATE_INSTANCE = 0x00000001,
}

enum VkPrimitiveTopology {
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST                    = 0x00000000,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST                     = 0x00000001,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                    = 0x00000002,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                 = 0x00000003,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                = 0x00000004,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                  = 0x00000005,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY      = 0x00000006,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY     = 0x00000007,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY  = 0x00000008,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 0x00000009,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                    = 0x0000000a,
}

enum VkPolygonMode {
  VK_POLYGON_MODE_FILL  = 0x00000000,
  VK_POLYGON_MODE_LINE  = 0x00000001,
  VK_POLYGON_MODE_POINT = 0x00000002,
}

enum VkFrontFace {
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0x00000000,
  VK_FRONT_FACE_CLOCKWISE         = 0x00000001,
}

enum VkCompareOp {
  VK_COMPARE_OP_NEVER            = 0x00000000,
  VK_COMPARE_OP_LESS             = 0x00000001,
  VK_COMPARE_OP_EQUAL            = 0x00000002,
  VK_COMPARE_OP_LESS_OR_EQUAL    = 0x00000003,
  VK_COMPARE_OP_GREATER          = 0x00000004,
  VK_COMPARE_OP_NOT_EQUAL        = 0x00000005,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 0x00000006,
  VK_COMPARE_OP_ALWAYS           = 0x00000007,
}

enum VkStencilOp {
  VK_STENCIL_OP_KEEP                = 0x00000000,
  VK_STENCIL_OP_ZERO                = 0x00000001,
  VK_STENCIL_OP_REPLACE             = 0x00000002,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 0x00000003,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 0x00000004,
  VK_STENCIL_OP_INVERT              = 0x00000005,
  VK_STENCIL_OP_INCREMENT_AND_WRAP  = 0x00000006,
  VK_STENCIL_OP_DECREMENT_AND_WRAP  = 0x00000007,
}

enum VkLogicOp {
  VK_LOGIC_OP_CLEAR         = 0x00000000,
  VK_LOGIC_OP_AND           = 0x00000001,
  VK_LOGIC_OP_AND_REVERSE   = 0x00000002,
  VK_LOGIC_OP_COPY          = 0x00000003,
  VK_LOGIC_OP_AND_INVERTED  = 0x00000004,
  VK_LOGIC_OP_NO_OP         = 0x00000005,
  VK_LOGIC_OP_XOR           = 0x00000006,
  VK_LOGIC_OP_OR            = 0x00000007,
  VK_LOGIC_OP_NOR           = 0x00000008,
  VK_LOGIC_OP_EQUIVALENT    = 0x00000009,
  VK_LOGIC_OP_INVERT        = 0x0000000a,
  VK_LOGIC_OP_OR_REVERSE    = 0x0000000b,
  VK_LOGIC_OP_COPY_INVERTED = 0x0000000c,
  VK_LOGIC_OP_OR_INVERTED   = 0x0000000d,
  VK_LOGIC_OP_NAND          = 0x0000000e,
  VK_LOGIC_OP_SET           = 0x0000000f,
}

enum VkBlendFactor {
  VK_BLEND_FACTOR_ZERO                     = 0x00000000,
  VK_BLEND_FACTOR_ONE                      = 0x00000001,
  VK_BLEND_FACTOR_SRC_COLOR                = 0x00000002,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR      = 0x00000003,
  VK_BLEND_FACTOR_DST_COLOR                = 0x00000004,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR      = 0x00000005,
  VK_BLEND_FACTOR_SRC_ALPHA                = 0x00000006,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA      = 0x00000007,
  VK_BLEND_FACTOR_DST_ALPHA                = 0x00000008,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA      = 0x00000009,
  VK_BLEND_FACTOR_CONSTANT_COLOR           = 0x0000000a,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 0x0000000b,
  VK_BLEND_FACTOR_CONSTANT_ALPHA           = 0x0000000c,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 0x0000000d,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE       = 0x0000000e,
  VK_BLEND_FACTOR_SRC1_COLOR               = 0x0000000f,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR     = 0x00000010,
  VK_BLEND_FACTOR_SRC1_ALPHA               = 0x00000011,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA     = 0x00000012,
}

enum VkBlendOp {
  VK_BLEND_OP_ADD              = 0x00000000,
  VK_BLEND_OP_SUBTRACT         = 0x00000001,
  VK_BLEND_OP_REVERSE_SUBTRACT = 0x00000002,
  VK_BLEND_OP_MIN              = 0x00000003,
  VK_BLEND_OP_MAX              = 0x00000004,
}

enum VkDynamicState {
  VK_DYNAMIC_STATE_VIEWPORT             = 0x00000000,
  VK_DYNAMIC_STATE_SCISSOR              = 0x00000001,
  VK_DYNAMIC_STATE_LINE_WIDTH           = 0x00000002,
  VK_DYNAMIC_STATE_DEPTH_BIAS           = 0x00000003,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS      = 0x00000004,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS         = 0x00000005,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 0x00000006,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK   = 0x00000007,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE    = 0x00000008,
}

enum VkFilter {
  VK_FILTER_NEAREST   = 0x00000000,
  VK_FILTER_LINEAR    = 0x00000001,
  VK_FILTER_CUBIC_IMG = 0x3B9B0498
}

enum VkSamplerMipmapMode {
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0x00000000, /// Choose nearest mip level
  VK_SAMPLER_MIPMAP_MODE_LINEAR  = 0x00000001, /// Linear filter between mip levels
}

enum VkSamplerAddressMode {
  VK_SAMPLER_ADDRESS_MODE_REPEAT               = 0x00000000,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT      = 0x00000001,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE        = 0x00000002,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER      = 0x00000003,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 0x00000004,
}

enum VkBorderColor {
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0x00000000,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK   = 0x00000001,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK      = 0x00000002,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK        = 0x00000003,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE      = 0x00000004,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE        = 0x00000005,
}

// NOTE: when updating this enum, be sure to update vkUpdateDescriptorSets
// in sync.
enum VkDescriptorType {
  VK_DESCRIPTOR_TYPE_SAMPLER                = 0x00000000,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 0x00000001,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE          = 0x00000002,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE          = 0x00000003,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER   = 0x00000004,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER   = 0x00000005,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER         = 0x00000006,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER         = 0x00000007,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 0x00000008,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 0x00000009,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT       = 0x0000000a,
}

enum VkAttachmentLoadOp {
  VK_ATTACHMENT_LOAD_OP_LOAD      = 0x00000000,
  VK_ATTACHMENT_LOAD_OP_CLEAR     = 0x00000001,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 0x00000002,
}

enum VkAttachmentStoreOp {
  VK_ATTACHMENT_STORE_OP_STORE     = 0x00000000,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 0x00000001,
}

enum VkPipelineBindPoint {
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0x00000000,
  VK_PIPELINE_BIND_POINT_COMPUTE  = 0x00000001,
}

enum VkCommandBufferLevel {
  VK_COMMAND_BUFFER_LEVEL_PRIMARY   = 0x00000000,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 0x00000001,
}

enum VkIndexType {
  VK_INDEX_TYPE_UINT16 = 0x00000000,
  VK_INDEX_TYPE_UINT32 = 0x00000001,
}

enum VkSubpassContents {
  VK_SUBPASS_CONTENTS_INLINE                    = 0x00000000,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 0x00000001,
}



/////////////////
//  Bitfields  //
/////////////////

@reserved_flags
type VkFlags VkInstanceCreateFlags

/// Format capability flags
@unused
bitfield VkFormatFeatureFlagBits {
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                  = 0x00000001, /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                  = 0x00000002, /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT           = 0x00000004, /// Format supports atomic operations in case it's used for storage images
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT           = 0x00000008, /// Format can be used for uniform texel buffers (TBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT           = 0x00000010, /// Format can be used for storage texel buffers (IBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT    = 0x00000020, /// Format supports atomic operations in case it's used for storage texel buffers
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                  = 0x00000040, /// Format can be used for vertex buffers (VBOs)
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT               = 0x00000080, /// Format can be used for color attachment images
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT         = 0x00000100, /// Format supports blending in case it's used for color attachment images
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT       = 0x00000200, /// Format can be used for depth/stencil attachment images
  VK_FORMAT_FEATURE_BLIT_SRC_BIT                       = 0x00000400, /// Format can be used as the source image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_BLIT_DST_BIT                       = 0x00000800, /// Format can be used as the destination image of blits with vkCommandBlitImage
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT    = 0x00001000,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
}
type VkFlags VkFormatFeatureFlags

/// Image usage flags
@unused
bitfield VkImageUsageFlagBits {
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT             = 0x00000001, /// Can be used as a source of transfer operations
  VK_IMAGE_USAGE_TRANSFER_DST_BIT             = 0x00000002, /// Can be used as a destination of transfer operations
  VK_IMAGE_USAGE_SAMPLED_BIT                  = 0x00000004, /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_IMAGE_USAGE_STORAGE_BIT                  = 0x00000008, /// Can be used as storage image (STORAGE_IMAGE descriptor type)
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT         = 0x00000010, /// Can be used as framebuffer color attachment
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020, /// Can be used as framebuffer depth/stencil attachment
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT     = 0x00000040, /// Image data not needed outside of rendering
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT         = 0x00000080, /// Can be used as framebuffer input attachment
}
type VkFlags VkImageUsageFlags

/// Image creation flags
@unused
bitfield VkImageCreateFlagBits {
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Image should support sparse backing
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Image should support sparse backing with partial residency
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT   = 0x00000008, /// Allows image views to have different format than the base image
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT  = 0x00000010, /// Allows creating image views with cube type from the created image
}
type VkFlags VkImageCreateFlags

bitfield VkSampleCountFlagBits {
  VK_SAMPLE_COUNT_1_BIT  = 0x00000001,
  VK_SAMPLE_COUNT_2_BIT  = 0x00000002,
  VK_SAMPLE_COUNT_4_BIT  = 0x00000004,
  VK_SAMPLE_COUNT_8_BIT  = 0x00000008,
  VK_SAMPLE_COUNT_16_BIT = 0x00000010,
  VK_SAMPLE_COUNT_32_BIT = 0x00000020,
  VK_SAMPLE_COUNT_64_BIT = 0x00000040,
}
type VkFlags VkSampleCountFlags

bitfield VkQueueFlagBits {
  VK_QUEUE_GRAPHICS_BIT       = 0x00000001, /// Queue supports graphics operations
  VK_QUEUE_COMPUTE_BIT        = 0x00000002, /// Queue supports compute operations
  VK_QUEUE_TRANSFER_BIT       = 0x00000004, /// Queue supports transfer operations
  VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008, /// Queue supports sparse resource memory management operations
}
type VkFlags VkQueueFlags

bitfield VkMemoryPropertyFlagBits {
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT     = 0x00000001,
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT     = 0x00000002,
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT    = 0x00000004,
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT      = 0x00000008,
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
}
type VkFlags VkMemoryPropertyFlags

@unused
bitfield VkMemoryHeapFlagBits {
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
}
type VkFlags VkMemoryHeapFlags
@reserved_flags
type VkFlags VkDeviceCreateFlags
@reserved_flags
type VkFlags VkDeviceQueueCreateFlags

/// Pipeline stages
bitfield VkPipelineStageFlagBits {
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                    = 0x00000001, /// Before subsequent commands are processed
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                  = 0x00000002, /// Draw/DispatchIndirect command fetch
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                   = 0x00000004, /// Vertex/index fetch
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                  = 0x00000008, /// Vertex shading
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT    = 0x00000010, /// Tessellation control shading
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, /// Tessellation evaluation shading
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                = 0x00000040, /// Geometry shading
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                = 0x00000080, /// Fragment shading
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT           = 0x00000100, /// Early fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT            = 0x00000200, /// Late fragment (depth/stencil) tests
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT        = 0x00000400, /// Color attachment writes
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                 = 0x00000800, /// Compute shading
  VK_PIPELINE_STAGE_TRANSFER_BIT                       = 0x00001000, /// Transfer/copy operations
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                 = 0x00002000,
  VK_PIPELINE_STAGE_HOST_BIT                           = 0x00004000, /// Indicates host (CPU) is a source/sink of the dependency
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                   = 0x00008000, /// All stages of the graphics pipeline
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                   = 0x00010000, /// All graphics, compute, copy, and transition commands
}
type VkFlags VkPipelineStageFlags
@reserved_flags
type VkFlags VkMemoryMapFlags

bitfield VkImageAspectFlagBits {
  VK_IMAGE_ASPECT_COLOR_BIT    = 0x00000001,
  VK_IMAGE_ASPECT_DEPTH_BIT    = 0x00000002,
  VK_IMAGE_ASPECT_STENCIL_BIT  = 0x00000004,
  VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
}
type VkFlags VkImageAspectFlags

@unused
bitfield VkSparseImageFormatFlagBits {
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT         = 0x00000001, /// Image uses a single miptail region for all array slices
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT       = 0x00000002, /// Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels.
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004, /// Image uses a non-standard sparse block size
}
type VkFlags VkSparseImageFormatFlags

@unused
bitfield VkSparseMemoryBindFlagBits {
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
}
type VkFlags VkSparseMemoryBindFlags

bitfield VkFenceCreateFlagBits {
  VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
}
type VkFlags VkFenceCreateFlags
@reserved_flags
type VkFlags VkSemaphoreCreateFlags
@reserved_flags
type VkFlags VkEventCreateFlags
@reserved_flags
type VkFlags VkQueryPoolCreateFlags

@unused
bitfield VkQueryPipelineStatisticFlagBits {
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                    = 0x00000001, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                  = 0x00000002, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                  = 0x00000004, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                = 0x00000008, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                 = 0x00000010, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                       = 0x00000020, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                        = 0x00000040, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                = 0x00000080, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT        = 0x00000100, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200, /// Optional
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                 = 0x00000400, /// Optional
}
type VkFlags VkQueryPipelineStatisticFlags

@unused
bitfield VkQueryResultFlagBits {
  VK_QUERY_RESULT_64_BIT                = 0x00000001, /// Results of the queries are written to the destination buffer as 64-bit values
  VK_QUERY_RESULT_WAIT_BIT              = 0x00000002, /// Results of the queries are waited on before proceeding with the result copy
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004, /// Besides the results of the query, the availability of the results is also written
  VK_QUERY_RESULT_PARTIAL_BIT           = 0x00000008, /// Copy the partial results of the query even if the final results aren't available
}
type VkFlags VkQueryResultFlags

@unused
bitfield VkBufferCreateFlagBits {
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT   = 0x00000001, /// Buffer should support sparse backing
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002, /// Buffer should support sparse backing with partial residency
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT   = 0x00000004, /// Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers
}
type VkFlags VkBufferCreateFlags

type VkFlags VkBufferUsageFlags
@unused
bitfield VkBufferUsageFlagBits {
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT         = 0x00000001, /// Can be used as a source of transfer operations
  VK_BUFFER_USAGE_TRANSFER_DST_BIT         = 0x00000002, /// Can be used as a destination of transfer operations
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004, /// Can be used as TBO
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008, /// Can be used as IBO
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT       = 0x00000010, /// Can be used as UBO
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT       = 0x00000020, /// Can be used as SSBO
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT         = 0x00000040, /// Can be used as source of fixed function index fetch (index buffer)
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT        = 0x00000080, /// Can be used as source of fixed function vertex fetch (VBO)
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT      = 0x00000100, /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
}
@reserved_flags
type VkFlags VkBufferViewCreateFlags
@reserved_flags
type VkFlags VkImageViewCreateFlags
@reserved_flags
type VkFlags VkShaderModuleCreateFlags
@reserved_flags
type VkFlags VkPipelineCacheCreateFlags

@unused
bitfield VkPipelineCreateFlagBits {
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT    = 0x00000002,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT           = 0x00000004,
}
type VkFlags VkPipelineCreateFlags
@reserved_flags
type VkFlags VkPipelineShaderStageCreateFlags


bitfield VkShaderStageFlagBits {
  VK_SHADER_STAGE_VERTEX_BIT                  = 0x00000001,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT    = 0x00000002,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
  VK_SHADER_STAGE_GEOMETRY_BIT                = 0x00000008,
  VK_SHADER_STAGE_FRAGMENT_BIT                = 0x00000010,
  VK_SHADER_STAGE_COMPUTE_BIT                 = 0x00000020,
  VK_SHADER_STAGE_ALL_GRAPHICS                = 0x0000001F,
  VK_SHADER_STAGE_ALL                         = 0x7FFFFFFF,
}
type VkFlags VkShaderStageFlags
@reserved_flags
type VkFlags VkPipelineVertexInputStateCreateFlags
@reserved_flags
type VkFlags VkPipelineInputAssemblyStateCreateFlags
@reserved_flags
type VkFlags VkPipelineTessellationStateCreateFlags
@reserved_flags
type VkFlags VkPipelineViewportStateCreateFlags
@reserved_flags
type VkFlags VkPipelineRasterizationStateCreateFlags


@unused
bitfield VkCullModeFlagBits {
  VK_CULL_MODE_NONE           = 0x00000000,
  VK_CULL_MODE_FRONT_BIT      = 0x00000001,
  VK_CULL_MODE_BACK_BIT       = 0x00000002,
  VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkCullModeFlags

@reserved_flags
type VkFlags VkPipelineMultisampleStateCreateFlags
@reserved_flags
type VkFlags VkPipelineDepthStencilStateCreateFlags
@reserved_flags
type VkFlags VkPipelineColorBlendStateCreateFlags

@unused
bitfield VkColorComponentFlagBits {
  VK_COLOR_COMPONENT_R_BIT = 0x00000001,
  VK_COLOR_COMPONENT_G_BIT = 0x00000002,
  VK_COLOR_COMPONENT_B_BIT = 0x00000004,
  VK_COLOR_COMPONENT_A_BIT = 0x00000008,
}
type VkFlags VkColorComponentFlags

@reserved_flags
type VkFlags VkPipelineDynamicStateCreateFlags
@reserved_flags
type VkFlags VkPipelineLayoutCreateFlags
@reserved_flags
type VkFlags VkSamplerCreateFlags
@reserved_flags
type VkFlags VkDescriptorSetLayoutCreateFlags

@unused
bitfield VkDescriptorPoolCreateFlagBits {
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
}
type VkFlags VkDescriptorPoolCreateFlags

@reserved_flags
type VkFlags VkDescriptorPoolResetFlags
@reserved_flags
type VkFlags VkFramebufferCreateFlags
@reserved_flags
type VkFlags VkRenderPassCreateFlags

@unused
bitfield VkAttachmentDescriptionFlagBits {
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001, /// The attachment may alias physical memory of another attachment in the same renderpass
}
type VkFlags VkAttachmentDescriptionFlags

@reserved_flags
type VkFlags VkSubpassDescriptionFlags


@unused
bitfield VkAccessFlagBits {
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT          = 0x00000001,
  VK_ACCESS_INDEX_READ_BIT                     = 0x00000002,
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT          = 0x00000004,
  VK_ACCESS_UNIFORM_READ_BIT                   = 0x00000008,
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT          = 0x00000010,
  VK_ACCESS_SHADER_READ_BIT                    = 0x00000020,
  VK_ACCESS_SHADER_WRITE_BIT                   = 0x00000040,
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT          = 0x00000080,
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT         = 0x00000100,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT  = 0x00000200,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
  VK_ACCESS_TRANSFER_READ_BIT                  = 0x00000800,
  VK_ACCESS_TRANSFER_WRITE_BIT                 = 0x00001000,
  VK_ACCESS_HOST_READ_BIT                      = 0x00002000,
  VK_ACCESS_HOST_WRITE_BIT                     = 0x00004000,
  VK_ACCESS_MEMORY_READ_BIT                    = 0x00008000,
  VK_ACCESS_MEMORY_WRITE_BIT                   = 0x00010000,
}
type VkFlags VkAccessFlags

@unused
bitfield VkDependencyFlagBits {
  VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
}
type VkFlags VkDependencyFlags

@unused
bitfield VkCommandPoolCreateFlagBits {
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT            = 0x00000001, /// Command buffers have a short lifetime
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002, /// Command buffers may release their memory individually
}
type VkFlags VkCommandPoolCreateFlags

@unused
bitfield VkCommandPoolResetFlagBits {
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the pool
}
type VkFlags VkCommandPoolResetFlags

@unused
bitfield VkCommandBufferUsageFlagBits {
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT      = 0x00000001,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT     = 0x00000004,
}
type VkFlags VkCommandBufferUsageFlags

@unused
bitfield VkQueryControlFlagBits {
  VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
}
type VkFlags VkQueryControlFlags

@unused
bitfield VkCommandBufferResetFlagBits {
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001, /// Release resources owned by the buffer
}
type VkFlags VkCommandBufferResetFlags

@unused
bitfield VkStencilFaceFlagBits {
  VK_STENCIL_FACE_FRONT_BIT = 0x00000001, /// Front face
  VK_STENCIL_FACE_BACK_BIT  = 0x00000002, /// Back face
  VK_STENCIL_FRONT_AND_BACK = 0x00000003,
}
type VkFlags VkStencilFaceFlags



// Function pointers. TODO: add support for function pointers.

@external type void* PFN_vkAllocationFunction
@pfn cmd void* vkAllocationFunction(
    void*                   pUserData,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkReallocationFunction
@pfn cmd void* vkReallocationFunction(
    void*                   pUserData,
    void*                   pOriginal,
    size                    size,
    size                    alignment,
    VkSystemAllocationScope allocationScope) {
  return ?
}

@external type void* PFN_vkFreeFunction
@pfn cmd void vkFreeFunction(
    void* pUserData,
    void* pMemory) {
}

@external type void* PFN_vkInternalAllocationNotification
@pfn cmd void vkInternalAllocationNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkInternalFreeNotification
@pfn cmd void vkInternalFreeNotification(
    void*                    pUserData,
    size                     size,
    VkInternalAllocationType allocationType,
    VkSystemAllocationScope  allocationScope) {
}

@external type void* PFN_vkVoidFunction
@pfn cmd void vkVoidFunction() {
}

@serialize
class VkApplicationInfo {
  VkStructureType sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO
  const void*     pNext              /// Next structure in chain
  const char*     pApplicationName
  u32             applicationVersion
  const char*     pEngineName
  u32             engineVersion
  u32             apiVersion
}

@serialize
class VkInstanceCreateInfo {
  VkStructureType          sType                   /// Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
  const void*              pNext                   /// Pointer to next structure
  VkInstanceCreateFlags    flags
  const VkApplicationInfo* pApplicationInfo
  u32                      enabledLayerCount
  const char* const*       ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                      enabledExtensionCount
  const char* const*       ppEnabledExtensionNames /// Extension names to be enabled
}

@serialize
class VkAllocationCallbacks {
  void*                                pUserData
  PFN_vkAllocationFunction             pfnAllocation
  PFN_vkReallocationFunction           pfnReallocation
  PFN_vkFreeFunction                   pfnFree
  PFN_vkInternalAllocationNotification pfnInternalAllocation
  PFN_vkInternalFreeNotification       pfnInternalFree
}

@serialize
class VkPhysicalDeviceFeatures {
  VkBool32 robustBufferAccess                      /// out of bounds buffer accesses are well defined
  VkBool32 fullDrawIndexUint32                     /// full 32-bit range of indices for indexed draw calls
  VkBool32 imageCubeArray                          /// image views which are arrays of cube maps
  VkBool32 independentBlend                        /// blending operations are controlled per-attachment
  VkBool32 geometryShader                          /// geometry stage
  VkBool32 tessellationShader                      /// tessellation control and evaluation stage
  VkBool32 sampleRateShading                       /// per-sample shading and interpolation
  VkBool32 dualSrcBlend                            /// blend operations which take two sources
  VkBool32 logicOp                                 /// logic operations
  VkBool32 multiDrawIndirect                       /// multi draw indirect
  VkBool32 drawIndirectFirstInstance
  VkBool32 depthClamp                              /// depth clamping
  VkBool32 depthBiasClamp                          /// depth bias clamping
  VkBool32 fillModeNonSolid                        /// point and wireframe fill modes
  VkBool32 depthBounds                             /// depth bounds test
  VkBool32 wideLines                               /// lines with width greater than 1
  VkBool32 largePoints                             /// points with size greater than 1
  VkBool32 alphaToOne                              /// The fragment alpha channel can be forced to maximum representable alpha value
  VkBool32 multiViewport
  VkBool32 samplerAnisotropy
  VkBool32 textureCompressionETC2                  /// ETC texture compression formats
  VkBool32 textureCompressionASTC_LDR              /// ASTC LDR texture compression formats
  VkBool32 textureCompressionBC                    /// BC1-7 texture compressed formats
  VkBool32 occlusionQueryPrecise
  VkBool32 pipelineStatisticsQuery                 /// pipeline statistics query
  VkBool32 vertexPipelineStoresAndAtomics
  VkBool32 fragmentStoresAndAtomics
  VkBool32 shaderTessellationAndGeometryPointSize
  VkBool32 shaderImageGatherExtended               /// texture gather with run-time values and independent offsets
  VkBool32 shaderStorageImageExtendedFormats       /// the extended set of formats can be used for storage images
  VkBool32 shaderStorageImageMultisample           /// multisample images can be used for storage images
  VkBool32 shaderStorageImageReadWithoutFormat
  VkBool32 shaderStorageImageWriteWithoutFormat
  VkBool32 shaderUniformBufferArrayDynamicIndexing /// arrays of uniform buffers can be accessed with dynamically uniform indices
  VkBool32 shaderSampledImageArrayDynamicIndexing  /// arrays of sampled images can be accessed with dynamically uniform indices
  VkBool32 shaderStorageBufferArrayDynamicIndexing /// arrays of storage buffers can be accessed with dynamically uniform indices
  VkBool32 shaderStorageImageArrayDynamicIndexing  /// arrays of storage images can be accessed with dynamically uniform indices
  VkBool32 shaderClipDistance                      /// clip distance in shaders
  VkBool32 shaderCullDistance                      /// cull distance in shaders
  VkBool32 shaderFloat64                           /// 64-bit floats (doubles) in shaders
  VkBool32 shaderInt64                             /// 64-bit integers in shaders
  VkBool32 shaderInt16                             /// 16-bit integers in shaders
  VkBool32 shaderResourceResidency                 /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
  VkBool32 shaderResourceMinLod                    /// shader can use texture operations that specify minimum resource LOD
  VkBool32 sparseBinding                           /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
  VkBool32 sparseResidencyBuffer                   /// Sparse resources support: GPU can access partially resident buffers
  VkBool32 sparseResidencyImage2D                  /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images
  VkBool32 sparseResidencyImage3D                  /// Sparse resources support: GPU can access partially resident 3D images
  VkBool32 sparseResidency2Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
  VkBool32 sparseResidency4Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
  VkBool32 sparseResidency8Samples                 /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
  VkBool32 sparseResidency16Samples                /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
  VkBool32 sparseResidencyAliased                  /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
  VkBool32 variableMultisampleRate
  VkBool32 inheritedQueries
}

@serialize
class VkFormatProperties {
  VkFormatFeatureFlags linearTilingFeatures  /// Format features in case of linear tiling
  VkFormatFeatureFlags optimalTilingFeatures /// Format features in case of optimal tiling
  VkFormatFeatureFlags bufferFeatures        /// Format features supported by buffers
}

@serialize
class VkExtent3D {
  u32 Width
  u32 Height
  u32 Depth
}

@serialize
class VkImageFormatProperties {
  VkExtent3D         maxExtent       /// max image dimensions for this resource type
  u32                maxMipLevels    /// max number of mipmap levels for this resource type
  u32                maxArrayLayers  /// max array layers for this resource type
  VkSampleCountFlags sampleCounts    /// supported sample counts for this resource type
  VkDeviceSize       maxResourceSize /// max size (in bytes) of this resource type
}

@serialize
class VkPhysicalDeviceLimits {
  /// resource maximum sizes
  u32 maxImageDimension1D    /// max 1D image dimension
  u32 maxImageDimension2D    /// max 2D image dimension
  u32 maxImageDimension3D    /// max 3D image dimension
  u32 maxImageDimensionCube  /// max cubemap image dimension
  u32 maxImageArrayLayers    /// max layers for image arrays
  u32 maxTexelBufferElements
  u32 maxUniformBufferRange  /// max uniform buffer size (bytes)
  u32 maxStorageBufferRange  /// max storage buffer size (bytes)
  u32 maxPushConstantsSize   /// max size of the push constants pool (bytes)
  /// memory limits
  u32          maxMemoryAllocationCount  /// max number of device memory allocations supported
  u32          maxSamplerAllocationCount
  VkDeviceSize bufferImageGranularity    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
  VkDeviceSize sparseAddressSpaceSize    /// Total address space available for sparse allocations (bytes)
  /// descriptor set limits
  u32 maxBoundDescriptorSets                /// max number of descriptors sets that can be bound to a pipeline
  u32 maxPerStageDescriptorSamplers         /// max num of samplers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorUniformBuffers   /// max num of uniform buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageBuffers   /// max num of storage buffers allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorSampledImages    /// max num of sampled images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorStorageImages    /// max num of storage images allowed per-stage in a descriptor set
  u32 maxPerStageDescriptorInputAttachments
  u32 maxPerStageResources
  u32 maxDescriptorSetSamplers              /// max num of samplers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffers        /// max num of uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetUniformBuffersDynamic /// max num of dynamic uniform buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffers        /// max num of storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageBuffersDynamic /// max num of dynamic storage buffers allowed in all stages in a descriptor set
  u32 maxDescriptorSetSampledImages         /// max num of sampled images allowed in all stages in a descriptor set
  u32 maxDescriptorSetStorageImages         /// max num of storage images allowed in all stages in a descriptor set
  u32 maxDescriptorSetInputAttachments
  /// vertex stage limits
  u32 maxVertexInputAttributes      /// max num of vertex input attribute slots
  u32 maxVertexInputBindings        /// max num of vertex input binding slots
  u32 maxVertexInputAttributeOffset /// max vertex input attribute offset added to vertex buffer offset
  u32 maxVertexInputBindingStride   /// max vertex input binding stride
  u32 maxVertexOutputComponents     /// max num of output components written by vertex shader
  /// tessellation control stage limits
  u32 maxTessellationGenerationLevel                  /// max level supported by tess primitive generator
  u32 maxTessellationPatchSize                        /// max patch size (vertices)
  u32 maxTessellationControlPerVertexInputComponents  /// max num of input components per-vertex in TCS
  u32 maxTessellationControlPerVertexOutputComponents /// max num of output components per-vertex in TCS
  u32 maxTessellationControlPerPatchOutputComponents  /// max num of output components per-patch in TCS
  u32 maxTessellationControlTotalOutputComponents     /// max total num of per-vertex and per-patch output components in TCS
  u32 maxTessellationEvaluationInputComponents        /// max num of input components per vertex in TES
  u32 maxTessellationEvaluationOutputComponents       /// max num of output components per vertex in TES
  /// geometry stage limits
  u32 maxGeometryShaderInvocations     /// max invocation count supported in geometry shader
  u32 maxGeometryInputComponents       /// max num of input components read in geometry stage
  u32 maxGeometryOutputComponents      /// max num of output components written in geometry stage
  u32 maxGeometryOutputVertices        /// max num of vertices that can be emitted in geometry stage
  u32 maxGeometryTotalOutputComponents /// max total num of components (all vertices) written in geometry stage
  /// fragment stage limits
  u32 maxFragmentInputComponents         /// max num of input compontents read in fragment stage
  u32 maxFragmentOutputAttachments       /// max num of output attachments written in fragment stage
  u32 maxFragmentDualSrcAttachments      /// max num of output attachments written when using dual source blending
  u32 maxFragmentCombinedOutputResources /// max total num of storage buffers, storage images and output buffers
  /// compute stage limits
  u32    maxComputeSharedMemorySize     /// max total storage size of work group local storage (bytes)
  u32[3] maxComputeWorkGroupCount       /// max num of compute work groups that may be dispatched by a single command (x,y,z)
  u32    maxComputeWorkGroupInvocations /// max total compute invocations in a single local work group
  u32[3] maxComputeWorkGroupSize        /// max local size of a compute work group (x,y,z)

  u32 subPixelPrecisionBits /// num bits of subpixel precision in screen x and y
  u32 subTexelPrecisionBits /// num bits of subtexel precision
  u32 mipmapPrecisionBits   /// num bits of mipmap precision

  u32 maxDrawIndexedIndexValue /// max index value for indexed draw calls (for 32-bit indices)
  u32 maxDrawIndirectCount

  f32 maxSamplerLodBias    /// max absolute sampler level of detail bias
  f32 maxSamplerAnisotropy /// max degree of sampler anisotropy

  u32    maxViewports          /// max number of active viewports
  u32[2] maxViewportDimensions /// max viewport dimensions (x,y)
  f32[2] viewportBoundsRange   /// viewport bounds range (min,max)
  u32    viewportSubPixelBits  /// num bits of subpixel precision for viewport

  size         minMemoryMapAlignment           /// min required alignment of pointers returned by MapMemory (bytes)
  VkDeviceSize minTexelBufferOffsetAlignment   /// min required alignment for texel buffer offsets (bytes)
  VkDeviceSize minUniformBufferOffsetAlignment /// min required alignment for uniform buffer sizes and offsets (bytes)
  VkDeviceSize minStorageBufferOffsetAlignment /// min required alignment for storage buffer offsets (bytes)

  s32 minTexelOffset                  /// min texel offset for OpTextureSampleOffset
  u32 maxTexelOffset                  /// max texel offset for OpTextureSampleOffset
  s32 minTexelGatherOffset            /// min texel offset for OpTextureGatherOffset
  u32 maxTexelGatherOffset            /// max texel offset for OpTextureGatherOffset
  f32 minInterpolationOffset          /// furthest negative offset for interpolateAtOffset
  f32 maxInterpolationOffset          /// furthest positive offset for interpolateAtOffset
  u32 subPixelInterpolationOffsetBits /// num of subpixel bits for interpolateAtOffset

  u32                maxFramebufferWidth                 /// max width for a framebuffer
  u32                maxFramebufferHeight                /// max height for a framebuffer
  u32                maxFramebufferLayers                /// max layer count for a layered framebuffer
  VkSampleCountFlags framebufferColorSampleCounts
  VkSampleCountFlags framebufferDepthSampleCounts
  VkSampleCountFlags framebufferStencilSampleCounts
  VkSampleCountFlags framebufferNoAttachmentSampleCounts
  u32                maxColorAttachments                 /// max num of framebuffer color attachments

  VkSampleCountFlags sampledImageColorSampleCounts
  VkSampleCountFlags sampledImageIntegerSampleCounts
  VkSampleCountFlags sampledImageDepthSampleCounts
  VkSampleCountFlags sampledImageStencilSampleCounts
  VkSampleCountFlags storageImageSampleCounts
  u32                maxSampleMaskWords              /// max num of sample mask words
  VkBool32           timestampComputeAndGraphics

  f32 timestampPeriod

  u32 maxClipDistances                /// max number of clip distances
  u32 maxCullDistances                /// max number of cull distances
  u32 maxCombinedClipAndCullDistances /// max combined number of user clipping

  u32 discreteQueuePriorities

  f32[2]   pointSizeRange          /// range (min,max) of supported point sizes
  f32[2]   lineWidthRange          /// range (min,max) of supported line widths
  f32      pointSizeGranularity    /// granularity of supported point sizes
  f32      lineWidthGranularity    /// granularity of supported line widths
  VkBool32 strictLines
  VkBool32 standardSampleLocations

  VkDeviceSize optimalBufferCopyOffsetAlignment
  VkDeviceSize optimalBufferCopyRowPitchAlignment
  VkDeviceSize nonCoherentAtomSize
}

@serialize
class VkPhysicalDeviceSparseProperties {
  VkBool32 residencyStandard2DBlockShape            /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard2DMultisampleBlockShape /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyStandard3DBlockShape            /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
  VkBool32 residencyAlignedMipSize                  /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
  VkBool32 residencyNonResidentStrict               /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

@serialize
class VkPhysicalDeviceProperties {
  u32                                    apiVersion
  u32                                    driverVersion
  u32                                    vendorID
  u32                                    deviceID
  VkPhysicalDeviceType                   deviceType
  char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] deviceName
  u8[VK_UUID_SIZE]                       pipelineCacheUUID
  VkPhysicalDeviceLimits                 limits
  VkPhysicalDeviceSparseProperties       sparseProperties
}

@serialize
class VkQueueFamilyProperties {
  VkQueueFlags queueFlags                  /// Queue flags
  u32          queueCount
  u32          timestampValidBits
  VkExtent3D   minImageTransferGranularity
}

@serialize
class VkMemoryType {
  VkMemoryPropertyFlags propertyFlags /// Memory properties of this memory type
  u32                   heapIndex     /// Index of the memory heap allocations of this memory type are taken from
}

@serialize
class VkMemoryHeap {
  VkDeviceSize      size  /// Available memory in the heap
  VkMemoryHeapFlags flags /// Flags for the heap
}

@serialize
class VkPhysicalDeviceMemoryProperties {
  u32                               memoryTypeCount
  VkMemoryType[VK_MAX_MEMORY_TYPES] memoryTypes
  u32                               memoryHeapCount
  VkMemoryHeap[VK_MAX_MEMORY_HEAPS] memoryHeaps
}

@serialize
class VkDeviceQueueCreateInfo {
  VkStructureType          sType            /// Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkDeviceQueueCreateFlags flags
  u32                      queueFamilyIndex
  u32                      queueCount
  const f32*               pQueuePriorities
}

@serialize
class VkDeviceCreateInfo {
  VkStructureType                 sType                   /// Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
  const void*                     pNext                   /// Pointer to next structure
  VkDeviceCreateFlags             flags
  u32                             queueCreateInfoCount
  const VkDeviceQueueCreateInfo*  pQueueCreateInfos
  u32                             enabledLayerCount
  const char* const*              ppEnabledLayerNames     /// Ordered list of layer names to be enabled
  u32                             enabledExtensionCount
  const char* const*              ppEnabledExtensionNames
  const VkPhysicalDeviceFeatures* pEnabledFeatures
}

@serialize
class VkExtensionProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] extensionName /// extension name
  u32                              specVersion   /// version of the extension specification implemented
}

@serialize
class VkLayerProperties {
  char[VK_MAX_EXTENSION_NAME_SIZE] layerName             /// layer name
  u32                              specVersion           /// version of the layer specification implemented
  u32                              implementationVersion /// build or release version of the layer's library
  char[VK_MAX_DESCRIPTION_SIZE]    description           /// Free-form description of the layer
}

@serialize
class VkSubmitInfo {
  VkStructureType             sType                /// Type of structure. Should be VK_STRUCTURE_TYPE_SUBMIT_INFO
  const void*                 pNext                /// Next structure in chain
  u32                         waitSemaphoreCount
  const VkSemaphore*          pWaitSemaphores
  const VkPipelineStageFlags* pWaitDstStageMask
  u32                         commandBufferCount
  const VkCommandBuffer*      pCommandBuffers
  u32                         signalSemaphoreCount
  const VkSemaphore*          pSignalSemaphores
}

@serialize
class VkMemoryAllocateInfo {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
  const void*     pNext           /// Pointer to next structure
  VkDeviceSize    allocationSize  /// Size of memory allocation
  u32             memoryTypeIndex /// Index of the of the memory type to allocate from
}

@serialize
class VkMappedMemoryRange {
  VkStructureType sType  /// Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
  const void*     pNext  /// Pointer to next structure
  VkDeviceMemory  memory /// Mapped memory object
  VkDeviceSize    offset /// Offset within the mapped memory the range starts from
  VkDeviceSize    size   /// Size of the range within the mapped memory
}

@serialize
class VkMemoryRequirements {
  VkDeviceSize size           /// Specified in bytes
  VkDeviceSize alignment      /// Specified in bytes
  u32          memoryTypeBits /// Bitfield of the allowed memory type indices into memoryTypes[] for this object
}

@serialize
class VkSparseImageFormatProperties {
  VkImageAspectFlagBits    aspectMask
  VkExtent3D               imageGranularity
  VkSparseImageFormatFlags flags
}

@serialize
class VkSparseImageMemoryRequirements {
  VkSparseImageFormatProperties formatProperties
  u32                           imageMipTailFirstLod
  VkDeviceSize                  imageMipTailSize     /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailOffset   /// Specified in bytes, must be a multiple of image block size / alignment
  VkDeviceSize                  imageMipTailStride   /// Specified in bytes, must be a multiple of image block size / alignment
}

@serialize
class VkSparseMemoryBind {
  VkDeviceSize            resourceOffset /// Specified in bytes
  VkDeviceSize            size           /// Specified in bytes
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset   /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

@serialize
class VkSparseBufferMemoryBindInfo {
  VkBuffer                  buffer
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

@serialize
class VkSparseImageOpaqueMemoryBindInfo {
  VkImage                   image
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

@serialize
class VkImageSubresource {
  VkImageAspectFlagBits aspectMask
  u32                   mipLevel
  u32                   arrayLayer
}

@serialize
class VkOffset3D {
  s32 x
  s32 y
  s32 z
}

@serialize @unused
class VkSparseImageMemoryBind {
  VkImageSubresource      subresource
  VkOffset3D              offset
  VkExtent3D              extent
  VkDeviceMemory          memory
  VkDeviceSize            memoryOffset /// Specified in bytes
  VkSparseMemoryBindFlags flags
}

@serialize
class VkSparseImageMemoryBindInfo {
  VkImage                   image
  u32                       bindCount
  const VkSparseMemoryBind* pBinds
}

@serialize
class VkBindSparseInfo {
  VkStructureType                          sType                /// Must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
  const void*                              pNext
  u32                                      waitSemaphoreCount
  const VkSemaphore*                       pWaitSemaphores
  u32                                      numBufferBinds
  const VkSparseBufferMemoryBindInfo*      pBufferBinds
  u32                                      numImageOpaqueBinds
  const VkSparseImageOpaqueMemoryBindInfo* pImageOpaqueBinds
  u32                                      numImageBinds
  const VkSparseImageMemoryBindInfo*       pImageBinds
  u32                                      signalSemaphoreCount
  const VkSemaphore*                       pSignalSemaphores
}

@serialize
class VkFenceCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkFenceCreateFlags flags /// Fence creation flags
}

@serialize
class VkSemaphoreCreateInfo {
  VkStructureType        sType /// Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
  const void*            pNext /// Pointer to next structure
  VkSemaphoreCreateFlags flags /// Semaphore creation flags
}

@serialize
class VkEventCreateInfo {
  VkStructureType    sType /// Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
  const void*        pNext /// Pointer to next structure
  VkEventCreateFlags flags /// Event creation flags
}

@serialize
class VkQueryPoolCreateInfo {
  VkStructureType               sType              /// Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
  const void*                   pNext              /// Pointer to next structure
  VkQueryPoolCreateFlags        flags
  VkQueryType                   queryType
  u32                           queryCount
  VkQueryPipelineStatisticFlags pipelineStatistics /// Optional
}

@serialize
class VkBufferCreateInfo {
  VkStructureType     sType                 /// Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
  const void*         pNext                 /// Pointer to next structure.
  VkBufferCreateFlags flags                 /// Buffer creation flags
  VkDeviceSize        size                  /// Specified in bytes
  VkBufferUsageFlags  usage                 /// Buffer usage flags
  VkSharingMode       sharingMode
  u32                 queueFamilyIndexCount
  const u32*          pQueueFamilyIndices
}

@serialize
class VkBufferViewCreateInfo {
  VkStructureType         sType  /// Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
  const void*             pNext  /// Pointer to next structure.
  VkBufferViewCreateFlags flags
  VkBuffer                buffer
  VkFormat                format /// Optionally specifies format of elements
  VkDeviceSize            offset /// Specified in bytes
  VkDeviceSize            range  /// View size specified in bytes
}

@serialize
class VkImageCreateInfo {
  VkStructureType       sType                 /// Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
  const void*           pNext                 /// Pointer to next structure.
  VkImageCreateFlags    flags                 /// Image creation flags
  VkImageType           imageType
  VkFormat              format
  VkExtent3D            extent
  u32                   mipLevels
  u32                   arrayLayers
  VkSampleCountFlagBits samples
  VkImageTiling         tiling
  VkImageUsageFlags     usage                 /// Image usage flags
  VkSharingMode         sharingMode           /// Cross-queue-family sharing mode
  u32                   queueFamilyIndexCount /// Number of queue families to share across
  const u32*            pQueueFamilyIndices   /// Array of queue family indices to share across
  VkImageLayout         initialLayout         /// Initial image layout for all subresources
}

@serialize
class VkSubresourceLayout {
  VkDeviceSize offset     /// Specified in bytes
  VkDeviceSize size       /// Specified in bytes
  VkDeviceSize rowPitch   /// Specified in bytes
  VkDeviceSize arrayPitch /// Specified in bytes
  VkDeviceSize depthPitch /// Specified in bytes
}

@serialize
class VkComponentMapping {
  VkComponentSwizzle r
  VkComponentSwizzle g
  VkComponentSwizzle b
  VkComponentSwizzle a
}

@serialize
class VkImageSubresourceRange {
  VkImageAspectFlags aspectMask
  u32                baseMipLevel
  u32                levelCount
  u32                baseArrayLayer
  u32                layerCount
}

@serialize
class VkImageViewCreateInfo {
  VkStructureType         sType            /// Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
  const void*             pNext            /// Pointer to next structure
  VkImageViewCreateFlags  flags
  VkImage                 image
  VkImageViewType         viewType
  VkFormat                format
  VkComponentMapping      components
  VkImageSubresourceRange subresourceRange
}

@serialize
class VkShaderModuleCreateInfo {
  VkStructureType           sType    /// Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
  const void*               pNext    /// Pointer to next structure
  VkShaderModuleCreateFlags flags    /// Reserved
  size                      codeSize /// Specified in bytes
  const u32*                pCode    /// Binary code of size codeSize
}

@serialize
class VkPipelineCacheCreateInfo {
  VkStructureType            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
  const void*                pNext           /// Pointer to next structure
  VkPipelineCacheCreateFlags flags
  size                       initialDataSize /// Size of initial data to populate cache, in bytes
  const void*                pInitialData    /// Initial data to populate cache
}

@serialize
class VkSpecializationMapEntry {
  u32  constantID /// The SpecConstant ID specified in the BIL
  u32  offset     /// Offset of the value in the data block
  size size       /// Size in bytes of the SpecConstant
}

@serialize
class VkSpecializationInfo {
  u32                             mapEntryCount /// Number of entries in the map
  const VkSpecializationMapEntry* pMapEntries   /// Array of map entries
  size                            dataSize      /// Size in bytes of pData
  const void*                     pData         /// Pointer to SpecConstant data
}

@serialize
class VkPipelineShaderStageCreateInfo {
  VkStructureType                  sType               /// Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
  const void*                      pNext               /// Pointer to next structure
  VkPipelineShaderStageCreateFlags flags
  VkShaderStageFlagBits            stage
  VkShaderModule                   module
  const char*                      pName
  const VkSpecializationInfo*      pSpecializationInfo
}

@serialize
class VkVertexInputBindingDescription {
  u32               binding   /// Vertex buffer binding id
  u32               stride    /// Distance between vertices in bytes (0 = no advancement)
  VkVertexInputRate inputRate /// Rate at which binding is incremented
}

@serialize
class VkVertexInputAttributeDescription {
  u32      location /// location of the shader vertex attrib
  u32      binding  /// Vertex buffer binding id
  VkFormat format   /// format of source data
  u32      offset   /// Offset of first element in bytes from base of vertex
}

@serialize
class VkPipelineVertexInputStateCreateInfo {
  VkStructureType                          sType                           /// Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
  const void*                              pNext                           /// Pointer to next structure
  VkPipelineVertexInputStateCreateFlags    flags
  u32                                      vertexBindingDescriptionCount   /// number of bindings
  const VkVertexInputBindingDescription*   pVertexBindingDescriptions
  u32                                      vertexAttributeDescriptionCount /// number of attributes
  const VkVertexInputAttributeDescription* pVertexAttributeDescriptions
}

@serialize
class VkPipelineInputAssemblyStateCreateInfo {
  VkStructureType                         sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
  const void*                             pNext                  /// Pointer to next structure
  VkPipelineInputAssemblyStateCreateFlags flags
  VkPrimitiveTopology                     topology
  VkBool32                                primitiveRestartEnable
}

@serialize
class VkPipelineTessellationStateCreateInfo {
  VkStructureType                        sType              /// Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
  const void*                            pNext              /// Pointer to next structure
  VkPipelineTessellationStateCreateFlags flags
  u32                                    patchControlPoints
}

@serialize
class VkViewport {
  f32 x
  f32 y
  f32 width
  f32 height
  f32 minDepth
  f32 maxDepth
}

@serialize
class VkOffset2D {
  s32 x
  s32 y
}

@serialize
class VkExtent2D {
  u32 Width
  u32 Height
}

@serialize
class VkRect2D {
  VkOffset2D offset
  VkExtent2D extent
}

@serialize
class VkPipelineViewportStateCreateInfo {
  VkStructureType                    sType         /// Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
  const void*                        pNext         /// Pointer to next structure
  VkPipelineViewportStateCreateFlags flags
  u32                                viewportCount
  const VkViewport*                  pViewports
  u32                                scissorCount
  const VkRect2D*                    pScissors
}

@serialize
class VkPipelineRasterizationStateCreateInfo {
  VkStructureType                         sType                   /// Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
  const void*                             pNext                   /// Pointer to next structure
  VkPipelineRasterizationStateCreateFlags flags
  VkBool32                                depthClampEnable
  VkBool32                                rasterizerDiscardEnable
  VkPolygonMode                           polygonMode             /// optional (GL45)
  VkCullModeFlags                         cullMode
  VkFrontFace                             frontFace
  VkBool32                                depthBiasEnable
  f32                                     depthBiasConstantFactor
  f32                                     depthBiasClamp
  f32                                     depthBiasSlopeFactor
  f32                                     lineWidth
}

@serialize
class VkPipelineMultisampleStateCreateInfo {
  VkStructureType                       sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
  const void*                           pNext                 /// Pointer to next structure
  VkPipelineMultisampleStateCreateFlags flags
  VkSampleCountFlagBits                 rasterizationSamples  /// Number of samples used for rasterization
  VkBool32                              sampleShadingEnable   /// optional (GL45)
  f32                                   minSampleShading      /// optional (GL45)
  const VkSampleMask*                   pSampleMask
  VkBool32                              alphaToCoverageEnable
  VkBool32                              alphaToOneEnable
}

@serialize
class VkStencilOpState {
  VkStencilOp failOp
  VkStencilOp passOp
  VkStencilOp depthFailOp
  VkCompareOp compareOp
  u32         compareMask
  u32         writeMask
  u32         reference
}

@serialize
class VkPipelineDepthStencilStateCreateInfo {
  VkStructureType                        sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
  const void*                            pNext                 /// Pointer to next structure
  VkPipelineDepthStencilStateCreateFlags flags
  VkBool32                               depthTestEnable
  VkBool32                               depthWriteEnable
  VkCompareOp                            depthCompareOp
  VkBool32                               depthBoundsTestEnable /// optional (depth_bounds_test)
  VkBool32                               stencilTestEnable
  VkStencilOpState                       front
  VkStencilOpState                       back
  f32                                    minDepthBounds
  f32                                    maxDepthBounds
}

@serialize
class VkPipelineColorBlendAttachmentState {
  VkBool32              blendEnable
  VkBlendFactor         srcColorBlendFactor
  VkBlendFactor         dstColorBlendFactor
  VkBlendOp             colorBlendOp
  VkBlendFactor         srcAlphaBlendFactor
  VkBlendFactor         dstAlphaBlendFactor
  VkBlendOp             alphaBlendOp
  VkColorComponentFlags colorWriteMask
}

@serialize
class VkPipelineColorBlendStateCreateInfo {
  VkStructureType                            sType           /// Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
  const void*                                pNext           /// Pointer to next structure
  VkPipelineColorBlendStateCreateFlags       flags
  VkBool32                                   logicOpEnable
  VkLogicOp                                  logicOp
  u32                                        attachmentCount /// # of pAttachments
  const VkPipelineColorBlendAttachmentState* pAttachments
  f32[4]                                     blendConstants
}

@serialize
class VkPipelineDynamicStateCreateInfo {
  VkStructureType                   sType             /// Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
  const void*                       pNext             /// Pointer to next structure
  VkPipelineDynamicStateCreateFlags flags
  u32                               dynamicStateCount
  const VkDynamicState*             pDynamicStates
}

@serialize
class VkGraphicsPipelineCreateInfo {
  VkStructureType                               sType               /// Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
  const void*                                   pNext               /// Pointer to next structure
  VkPipelineCreateFlags                         flags               /// Pipeline creation flags
  u32                                           stageCount
  const VkPipelineShaderStageCreateInfo*        pStages             /// One entry for each active shader stage
  const VkPipelineVertexInputStateCreateInfo*   pVertexInputState
  const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState
  const VkPipelineTessellationStateCreateInfo*  pTessellationState
  const VkPipelineViewportStateCreateInfo*      pViewportState
  const VkPipelineRasterizationStateCreateInfo* pRasterizationState
  const VkPipelineMultisampleStateCreateInfo*   pMultisampleState
  const VkPipelineDepthStencilStateCreateInfo*  pDepthStencilState
  const VkPipelineColorBlendStateCreateInfo*    pColorBlendState
  const VkPipelineDynamicStateCreateInfo*       pDynamicState
  VkPipelineLayout                              layout              /// Interface layout of the pipeline
  VkRenderPass                                  renderPass
  u32                                           subpass
  VkPipeline                                    basePipelineHandle  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                                           basePipelineIndex   /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

@serialize
class VkComputePipelineCreateInfo {
  VkStructureType                 sType              /// Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
  const void*                     pNext              /// Pointer to next structure
  VkPipelineCreateFlags           flags              /// Pipeline creation flags
  VkPipelineShaderStageCreateInfo stage
  VkPipelineLayout                layout             /// Interface layout of the pipeline
  VkPipeline                      basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
  s32                             basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

@serialize
class VkPushConstantRange {
  VkShaderStageFlags stageFlags /// Which stages use the range
  u32                offset     /// Start of the range, in bytes
  u32                size       /// Length of the range, in bytes
}

@serialize
class VkPipelineLayoutCreateInfo {
  VkStructureType              sType                  /// Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
  const void*                  pNext                  /// Pointer to next structure
  VkPipelineLayoutCreateFlags  flags
  u32                          setLayoutCount         /// Number of descriptor sets interfaced by the pipeline
  const VkDescriptorSetLayout* pSetLayouts            /// Array of <setCount> number of descriptor set layout objects defining the layout of the
  u32                          pushConstantRangeCount /// Number of push-constant ranges used by the pipeline
  const VkPushConstantRange*   pPushConstantRanges    /// Array of pushConstantRangeCount number of ranges used by various shader stages
}

@serialize
class VkSamplerCreateInfo {
  VkStructureType      sType                   /// Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
  const void*          pNext                   /// Pointer to next structure
  VkSamplerCreateFlags flags
  VkFilter             magFilter               /// Filter mode for magnification
  VkFilter             minFilter               /// Filter mode for minifiation
  VkSamplerMipmapMode  mipmapMode              /// Mipmap selection mode
  VkSamplerAddressMode addressModeU
  VkSamplerAddressMode addressModeV
  VkSamplerAddressMode addressModeW
  f32                  mipLodBias
  VkBool32             anisotropyEnable
  f32                  maxAnisotropy
  VkBool32             compareEnable
  VkCompareOp          compareOp
  f32                  minLod
  f32                  maxLod
  VkBorderColor        borderColor
  VkBool32             unnormalizedCoordinates
}

@serialize
class VkDescriptorSetLayoutBinding {
  u32                binding
  VkDescriptorType   descriptorType     /// Type of the descriptors in this binding
  u32                descriptorCount    /// Number of descriptors in this binding
  VkShaderStageFlags stageFlags         /// Shader stages this binding is visible to
  const VkSampler*   pImmutableSamplers /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains <count> number of elements)
}

@serialize
class VkDescriptorSetLayoutCreateInfo {
  VkStructureType                     sType        /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
  const void*                         pNext        /// Pointer to next structure
  VkDescriptorSetLayoutCreateFlags    flags
  u32                                 bindingCount /// Number of bindings in the descriptor set layout
  const VkDescriptorSetLayoutBinding* pBindings    /// Array of descriptor set layout bindings
}

@serialize
class VkDescriptorPoolSize {
  VkDescriptorType type
  u32              descriptorCount
}

@serialize
class VkDescriptorPoolCreateInfo {
  VkStructureType             sType         /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
  const void*                 pNext         /// Pointer to next structure
  VkDescriptorPoolCreateFlags flags
  u32                         maxSets
  u32                         poolSizeCount
  const VkDescriptorPoolSize* pPoolSizes
}

@serialize
class VkDescriptorSetAllocateInfo {
  VkStructureType              sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
  const void*                  pNext              /// Pointer to next structure
  VkDescriptorPool             descriptorPool
  u32                          descriptorSetCount
  const VkDescriptorSetLayout* pSetLayouts
}

@serialize
class VkDescriptorImageInfo {
  VkSampler     Sampler
  VkImageView   ImageView
  VkImageLayout ImageLayout
}

@serialize
class VkDescriptorBufferInfo {
  VkBuffer     Buffer /// Buffer used for this descriptor when the descriptor is UNIFORM_BUFFER[_DYNAMIC]
  VkDeviceSize Offset /// Base offset from buffer start in bytes to update in the descriptor set.
  VkDeviceSize Range  /// Size in bytes of the buffer resource for this descriptor update.
}

@serialize
class VkWriteDescriptorSet {
  VkStructureType               sType            /// Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
  const void*                   pNext            /// Pointer to next structure
  VkDescriptorSet               dstSet           /// Destination descriptor set
  u32                           dstBinding       /// Binding within the destination descriptor set to write
  u32                           dstArrayElement  /// Array element within the destination binding to write
  u32                           descriptorCount  /// Number of descriptors to write (determines the size of the array pointed by <pDescriptors>)
  VkDescriptorType              descriptorType   /// Descriptor type to write (determines which fields of the array pointed by <pDescriptors> are going to be used)
  const VkDescriptorImageInfo*  pImageInfo
  const VkDescriptorBufferInfo* pBufferInfo
  const VkBufferView*           pTexelBufferView
}

@serialize
class VkCopyDescriptorSet {
  VkStructureType sType           /// Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
  const void*     pNext           /// Pointer to next structure
  VkDescriptorSet srcSet          /// Source descriptor set
  u32             srcBinding      /// Binding within the source descriptor set to copy from
  u32             srcArrayElement /// Array element within the source binding to copy from
  VkDescriptorSet dstSet          /// Destination descriptor set
  u32             dstBinding      /// Binding within the destination descriptor set to copy to
  u32             dstArrayElement /// Array element within the destination binding to copy to
  u32             descriptorCount /// Number of descriptors to copy
}

@serialize
class VkFramebufferCreateInfo {
  VkStructureType          sType           /// Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
  const void*              pNext           /// Pointer to next structure
  VkFramebufferCreateFlags flags
  VkRenderPass             renderPass
  u32                      attachmentCount
  const VkImageView*       pAttachments
  u32                      width
  u32                      height
  u32                      layers
}

@serialize
class VkAttachmentDescription {
  VkAttachmentDescriptionFlags flags
  VkFormat                     format
  VkSampleCountFlagBits        samples
  VkAttachmentLoadOp           loadOp         /// Load op for color or depth data
  VkAttachmentStoreOp          storeOp        /// Store op for color or depth data
  VkAttachmentLoadOp           stencilLoadOp  /// Load op for stencil data
  VkAttachmentStoreOp          stencilStoreOp /// Store op for stencil data
  VkImageLayout                initialLayout
  VkImageLayout                finalLayout
}

@serialize
class VkAttachmentReference {
  u32           Attachment // We have capitalized these so we can manipulate
  VkImageLayout Layout     // them in Go
}

@serialize
class VkSubpassDescription {
  VkSubpassDescriptionFlags    flags
  VkPipelineBindPoint          pipelineBindPoint       /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
  u32                          inputAttachmentCount
  const VkAttachmentReference* pInputAttachments
  u32                          colorAttachmentCount
  const VkAttachmentReference* pColorAttachments
  const VkAttachmentReference* pResolveAttachments
  const VkAttachmentReference* pDepthStencilAttachment
  u32                          preserveAttachmentCount
  const u32*                   pPreserveAttachments
}

@serialize
class VkSubpassDependency {
  u32                  srcSubpass
  u32                  dstSubpass
  VkPipelineStageFlags srcStageMask
  VkPipelineStageFlags dstStageMask
  VkAccessFlags        srcAccessMask
  VkAccessFlags        dstAccessMask
  VkDependencyFlags    dependencyFlags
}

@serialize
class VkRenderPassCreateInfo {
  VkStructureType                sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
  const void*                    pNext           /// Pointer to next structure
  VkRenderPassCreateFlags        flags
  u32                            attachmentCount
  const VkAttachmentDescription* pAttachments
  u32                            subpassCount
  const VkSubpassDescription*    pSubpasses
  u32                            dependencyCount
  const VkSubpassDependency*     pDependencies
}

@serialize
class VkCommandPoolCreateInfo {
  VkStructureType          sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
  const void*              pNext            /// Pointer to next structure
  VkCommandPoolCreateFlags flags            /// Command pool creation flags
  u32                      queueFamilyIndex
}

@serialize
class VkCommandBufferAllocateInfo {
  VkStructureType      sType              /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
  const void*          pNext              /// Pointer to next structure
  VkCommandPool        commandPool
  VkCommandBufferLevel level
  u32                  commandBufferCount
}

@serialize
class VkCommandBufferInheritanceInfo {
  VkStructureType               sType                /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
  const void*                   pNext                /// Pointer to next structure
  VkRenderPass                  renderPass           /// Render pass for secondary command buffers
  u32                           subpass
  VkFramebuffer                 framebuffer          /// Framebuffer for secondary command buffers
  VkBool32                      occlusionQueryEnable
  VkQueryControlFlags           queryFlags
  VkQueryPipelineStatisticFlags pipelineStatistics
}

@serialize
class VkCommandBufferBeginInfo {
  VkStructureType                       sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
  const void*                           pNext            /// Pointer to next structure
  VkCommandBufferUsageFlags             flags            /// Command buffer usage flags
  const VkCommandBufferInheritanceInfo* pInheritanceInfo
}

@serialize
class VkBufferCopy {
  VkDeviceSize srcOffset /// Specified in bytes
  VkDeviceSize dstOffset /// Specified in bytes
  VkDeviceSize size      /// Specified in bytes
}

@serialize
class VkImageSubresourceLayers {
  VkImageAspectFlags aspectMask
  u32                mipLevel
  u32                baseArrayLayer
  u32                layerCount
}

@serialize
class VkImageCopy {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset      /// Specified in pixels for both compressed and uncompressed images
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset      /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               extent         /// Specified in pixels for both compressed and uncompressed images
}

@serialize
class VkImageBlit {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D[2]            srcOffsets
  VkImageSubresourceLayers dstSubresource
  VkOffset3D[2]            dstOffsets
}

@serialize
class VkBufferImageCopy {
  VkDeviceSize             bufferOffset      /// Specified in bytes
  u32                      bufferRowLength   /// Specified in texels
  u32                      bufferImageHeight
  VkImageSubresourceLayers imageSubresource
  VkOffset3D               imageOffset       /// Specified in pixels for both compressed and uncompressed images
  VkExtent3D               imageExtent       /// Specified in pixels for both compressed and uncompressed images
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
@serialize
class VkClearColorValue {
  //f32[4]                                      float32
  //s32[4]                                      int32
  u32[4] uint32
}

@serialize
class VkClearDepthStencilValue {
  f32 depth
  u32 stencil
}

// TODO: We can't use unions of StaticArrays - it has a copy-constructor
// bclayton: Instead of this, I'd recommend using a void* and casting to
//           the wanted type in the cmd.
// @union
/// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.
@serialize
class VkClearValue {
  VkClearColorValue color
//    VkClearDepthStencilValue                    depthStencil
}

@serialize
class VkClearAttachment {
  VkImageAspectFlags aspectMask
  u32                colorAttachment
  VkClearValue       clearValue
}

@serialize
class VkClearRect {
  VkRect2D rect
  u32      baseArrayLayer
  u32      layerCount
}

@serialize
class VkImageResolve {
  VkImageSubresourceLayers srcSubresource
  VkOffset3D               srcOffset
  VkImageSubresourceLayers dstSubresource
  VkOffset3D               dstOffset
  VkExtent3D               extent
}

@serialize
class VkMemoryBarrier {
  VkStructureType sType         /// Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
  const void*     pNext         /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
}

@serialize
class VkBufferMemoryBarrier {
  VkStructureType sType               /// Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
  const void*     pNext               /// Pointer to next structure.
  VkAccessFlags   srcAccessMask
  VkAccessFlags   dstAccessMask
  u32             srcQueueFamilyIndex /// Queue family to transition ownership from
  u32             dstQueueFamilyIndex /// Queue family to transition ownership to
  VkBuffer        buffer              /// Buffer to sync
  VkDeviceSize    offset              /// Offset within the buffer to sync
  VkDeviceSize    size                /// Amount of bytes to sync
}

@serialize
class VkImageMemoryBarrier {
  VkStructureType         sType               /// Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
  const void*             pNext               /// Pointer to next structure.
  VkAccessFlags           srcAccessMask
  VkAccessFlags           dstAccessMask
  VkImageLayout           oldLayout           /// Current layout of the image
  VkImageLayout           newLayout           /// New layout to transition the image to
  u32                     srcQueueFamilyIndex /// Queue family to transition ownership from
  u32                     dstQueueFamilyIndex /// Queue family to transition ownership to
  VkImage                 image               /// Image to sync
  VkImageSubresourceRange subresourceRange    /// Subresource range to sync
}

@serialize
class VkRenderPassBeginInfo {
  VkStructureType     sType           /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
  const void*         pNext           /// Pointer to next structure
  VkRenderPass        renderPass
  VkFramebuffer       framebuffer
  VkRect2D            renderArea
  u32                 clearValueCount
  const VkClearValue* pClearValues
}

@serialize @unused
class VkDispatchIndirectCommand {
  u32 x
  u32 y
  u32 z
}

@serialize @unused
class VkDrawIndexedIndirectCommand {
  u32 indexCount
  u32 instanceCount
  u32 firstIndex
  s32 vertexOffset
  u32 firstInstance
}

@serialize @unused
class VkDrawIndirectCommand {
  u32 vertexCount
  u32 instanceCount
  u32 firstVertex
  u32 firstInstance
}

////////////////////////////////////////////////////////////////////////////////
////////// Extensions //////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// VK_NV_dedicated_allocation

/// Format capability flags
@unused
bitfield VkExternalMemoryHandleTypeFlagBitsNV {
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV     = 0x00000001,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV      = 0x00000004,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV  = 0x00000008,
}
@unused
type VkFlags VkExternalMemoryHandleTypeFlagsNV

@serialize
class VkDedicatedAllocationImageCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@serialize
class VkDedicatedAllocationBufferCreateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  @unused VkBool32        dedicatedAllocation
}

@serialize
class VkDedicatedAllocationMemoryAllocateInfoNV {
  @unused VkStructureType sType
  @unused const void*     pNext
  VkImage         image
  VkBuffer        buffer
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@internal class MutableVoidPtr {
  void* Ptr
}

type void* VoidPtr
// Declare the type so external function: numberOfPNext can use the type.
type const void** ConstVoidPtrPtr
// Returns the number of structs in the linked list pointed by the pNext pointer.
extern u32 numberOfPNext(const void* pNext)

@override
@custom
@no_replay
cmd void RecreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    VkInstance*                  pInstance) {

  info := pCreateInfo[0]

  // TODO: handle pNext
  if (info.pApplicationInfo != null) {
    _ = readVkApplicationInfo(info.pApplicationInfo)
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    _ = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    _ = as!string(extensionNames[i])
  }

  fence
  write(pInstance[0:1])
}

@custom
@threadSafety("system")
@override
cmd VkResult vkCreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance*                  pInstance) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkInstance() in synthetic.api. Change both together.

  instance := createInstanceObject(pCreateInfo)
  // TODO: pAllocator
  handle := ?
  pInstance[0] = handle
  instance.VulkanHandle = handle
  Instances[handle] = instance
  return ?
}

@threadSafety("system")
@indirect("VkInstance")
@override
@custom
cmd void vkDestroyInstance(
    VkInstance                   instance,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Instances, instance)
}

@override
@custom
@no_replay
cmd void RecreatePhysicalDevices(
    VkInstance instance,
    u32* count,
    VkPhysicalDevice* pPhysicalDevices) {
  read(count[0:1])
  physicalDeviceCount := count[0]
  fence
  write(pPhysicalDevices[0:physicalDeviceCount])
}

@override
@custom
@no_replay
cmd void RecreatePhysicalDeviceProperties(
    VkPhysicalDevice         physicalDevice,
    u32*                     pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  count := pQueueFamilyPropertyCount[0]
  read(pQueueFamilyProperties[0:count])
  write(pQueueFamilyPropertyCount[0:1])
  write(pMemoryProperties[0:1])
}

@threadSafety("system")
@indirect("VkInstance")
cmd VkResult vkEnumeratePhysicalDevices(
    VkInstance        instance,
    u32*              pPhysicalDeviceCount,
    VkPhysicalDevice* pPhysicalDevices) {
  _ = pPhysicalDeviceCount[0]

  if pPhysicalDevices == null {
    pPhysicalDeviceCount[0] = ?
  } else {
    count := as!u32(?)
    devices := pPhysicalDevices[0:count]
    for i in (0 .. count) {
      device := ?
      PhysicalDevices[device] = new!PhysicalDeviceObject(Instance: instance, Index: i,
                                                         VulkanHandle:device)
      devices[i] = device
    }
    pPhysicalDeviceCount[0] = count
  }

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice          physicalDevice,
    VkPhysicalDeviceFeatures* pFeatures) {
  pFeatures[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice    physicalDevice,
    VkFormat            format,
    VkFormatProperties* pFormatProperties) {
  pFormatProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice         physicalDevice,
    VkFormat                 format,
    VkImageType              type,
    VkImageTiling            tiling,
    VkImageUsageFlags        usage,
    VkImageCreateFlags       flags,
    VkImageFormatProperties* pImageFormatProperties) {
  pImageFormatProperties[0] = ?
  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice            physicalDevice,
    VkPhysicalDeviceProperties* pProperties) {
  pProperties[0] = ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice         physicalDevice,
    u32*                     pQueueFamilyPropertyCount,
    VkQueueFamilyProperties* pQueueFamilyProperties) {
  _ = pQueueFamilyPropertyCount[0]

  fence

  if pQueueFamilyProperties == null {
    pQueueFamilyPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pQueueFamilyProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pQueueFamilyPropertyCount[0] = count
    for i in (0 .. count) {
      PhysicalDevices[physicalDevice].QueueFamilyProperties[i] = properties[i]
    }
  }
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                  physicalDevice,
    VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
  memoryProperties := ?
  pMemoryProperties[0] = memoryProperties

  dev := PhysicalDevices[physicalDevice]
  dev.MemoryProperties = memoryProperties
  PhysicalDevices[physicalDevice] = dev

}

@indirect("VkInstance")
@override
cmd PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance instance,
    string     pName) {
  return ?
}

@indirect("VkDevice")
@override
cmd PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice device,
    string   pName) {
  return ?
}

@override
@custom
@no_replay
cmd void RecreateDevice(
    VkPhysicalDevice physicalDevice,
    const VkDeviceCreateInfo*  pCreateInfo,
    VkDevice*                  pDevice) {
  device := createDeviceObject(pCreateInfo)
  handle := ?

  pDevice[0] = handle
  device.PhysicalDevice = physicalDevice
  device.VulkanHandle = handle
  if (!(handle in Devices)) {
    Devices[handle] = device
  }
}

@threadSafety("system")
@indirect("VkPhysicalDevice", "VkInstance")
@override
@custom
cmd VkResult vkCreateDevice(
    VkPhysicalDevice             physicalDevice,
    const VkDeviceCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDevice*                    pDevice) {
  // NOTE: The logic for this function should be identical to the one of
  // replayCreateVkDevice() in synthetic.api. Change both together.

  device := createDeviceObject(pCreateInfo)
  device.PhysicalDevice = physicalDevice
  // TODO: pAllocator

  handle := ?
  pDevice[0] = handle
  device.VulkanHandle = handle
  Devices[handle] = device

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@override
@custom
cmd void vkDestroyDevice(
    VkDevice                     device,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Devices, device)
}

sub void queryExtensionProperties(u32* pPropertyCount, VkExtensionProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceExtensionProperties(
    string                 pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice       physicalDevice,
    string                 pLayerName,
    u32*                   pPropertyCount,
    VkExtensionProperties* pProperties) {
  queryExtensionProperties(pPropertyCount, pProperties)

  return ?
}

sub void queryLayerProperties(u32* pPropertyCount, VkLayerProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@override
cmd VkResult vkEnumerateInstanceLayerProperties(
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)

  return ?
}

@indirect("VkPhysicalDevice", "VkInstance")
@override
cmd VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice   physicalDevice,
    u32*               pPropertyCount,
    VkLayerProperties* pProperties) {
  queryLayerProperties(pPropertyCount, pProperties)

  return ?
}

@override
@custom
@no_replay
cmd void RecreateQueue(VkDevice device,
    u32      queueFamilyIndex,
    u32      queueIndex,
    VkQueue* pQueue) {

  handle := ?
  pQueue[0] = handle
  if (!(handle in Queues)) {
     Queues[handle] = new!QueueObject(Device: device,Family:  queueFamilyIndex,Index:  queueIndex,VulkanHandle:  handle)
  }
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkGetDeviceQueue(
    VkDevice device,
    u32      queueFamilyIndex,
    u32      queueIndex,
    VkQueue* pQueue) {
  id := ?
  Queues[id] = new!QueueObject(Device: device,Family:  queueFamilyIndex,Index:  queueIndex,VulkanHandle:  id)
  pQueue[0] = id
}

// TODO: Not all vkQueueSubmit calls submit vkCmdDrawXXX commands. Need better
// a way so that only those recorded with draw commands will be labelled as
// draw call.
@DrawCall
@threadSafety("app")
@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueSubmit(
    VkQueue             queue,
    u32                 submitCount,
    const VkSubmitInfo* pSubmits,
    VkFence             fence) {
  LastSubmission = SUBMIT
  submitInfo := pSubmits[0:submitCount]
  LastBoundQueue = Queues[queue]

  for i in (0 .. submitCount) {
    info := submitInfo[i]
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for j in (0 .. info.waitSemaphoreCount) {
      recordUpdateSemaphoreSignal(wait_semaphores[j], false)
    }
    read(info.pWaitDstStageMask[0:info.waitSemaphoreCount])

    command_buffers := info.pCommandBuffers[0:info.commandBufferCount]

    for j in (0 .. info.commandBufferCount) {
      execCommands(command_buffers[j])
    }

    signal_semaphores := info.pSignalSemaphores[0:info.signalSemaphoreCount]
    for j in (0 .. info.signalSemaphoreCount) {
      recordUpdateSemaphoreSignal(signal_semaphores[j], true)
    }

  }
  return ?
}

@threadSafety("system")
@indirect("VkQueue", "VkDevice")
@blocking
cmd VkResult vkQueueWaitIdle(
    VkQueue queue) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkDeviceWaitIdle(
    VkDevice device) {
  return ?
}

sub bool IsMemoryCoherent(ref!DeviceMemoryObject memory) {
  physical_device := PhysicalDevices[Devices[memory.Device].PhysicalDevice]
  return 0 != (as!u32(physical_device.MemoryProperties.memoryTypes[memory.MemoryTypeIndex].propertyFlags) &
  as!u32(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))
}

@override
@custom
@no_replay
cmd void RecreateDeviceMemory(
    VkDevice device,
    const VkMemoryAllocateInfo*  pAllocateInfo,
    VkDeviceSize mappedOffset,
    VkDeviceSize mappedSize,
    void**           ppData,
    VkDeviceMemory* pMemory) {
  allocateInfo := pAllocateInfo[0]

  // Handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
          _ = as!VkDedicatedAllocationMemoryAllocateInfoNV*(next.Ptr)[0:1][0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  if (mappedSize > as!VkDeviceSize(0)) {
    read(ppData[0:1])
  }

  fence
  if (mappedSize > 0) {
    write(ppData[0:1])
  }
  memory := pMemory[0:1][0]

  memoryObject := DeviceMemories[memory]
  if (IsMemoryCoherent(memoryObject)) {
    trackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkAllocateMemory(
    VkDevice                     device,
    const VkMemoryAllocateInfo*  pAllocateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDeviceMemory*              pMemory) {
  allocateInfo := pAllocateInfo[0]

  memoryObject := new!DeviceMemoryObject(
    Device:                    device,
    VulkanHandle:              0,
    AllocationSize:            allocateInfo.allocationSize,
    MappedOffset:              0,
    MappedSize:                0,
    MappedLocation:            null,
    MemoryTypeIndex:           allocateInfo.memoryTypeIndex,
    Data:                      make!u8(allocateInfo.allocationSize),
  )

  // Handle pNext
  if allocateInfo.pNext != null {
    numPNext := numberOfPNext(allocateInfo.pNext)
    next := MutableVoidPtr(as!void*(allocateInfo.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {
          ext := as!VkDedicatedAllocationMemoryAllocateInfoNV*(next.Ptr)[0:1][0]
          memoryObject.DedicatedAllocationNV = new!DedicatedAllocationMemoryAllocateInfoNV(
            Image: ext.image,
            Buffer: ext.buffer,
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  memory := ?
  pMemory[0] = memory

  memoryObject.VulkanHandle = memory
  DeviceMemories[memory] = memoryObject
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkFreeMemory(
    VkDevice                     device,
    VkDeviceMemory               memory,
    const VkAllocationCallbacks* pAllocator) {
  if (memory != as!VkDeviceMemory(0)) {
    memoryObject := DeviceMemories[memory]

    if (memoryObject.MappedSize != 0) {
      mappedLocation := as!u8*(memoryObject.MappedLocation)
      unmapMemory(mappedLocation[0:memoryObject.MappedSize])
    }
    delete(DeviceMemories, memory)
  }
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkMapMemory(
    VkDevice         device,
    VkDeviceMemory   memory,
    VkDeviceSize     offset,
    VkDeviceSize     size,
    VkMemoryMapFlags flags,
    void**           ppData) {
  // TODO(awoloszyn): Figure out why we need the read/write here
  // in order for the replay to allocate the memory we need.
  // see: b/32300796
  memoryObject := DeviceMemories[memory]
  memoryObject.MappedOffset = offset
  if (size == 0xFFFFFFFFFFFFFFFF) {
    memoryObject.MappedSize = memoryObject.AllocationSize - offset
  } else {
    memoryObject.MappedSize = size
  }
  read(ppData[0:1])
  memoryLocation := ?
  ppData[0] = memoryLocation

  mapMemory(ppData, as!u8*(memoryLocation)[0:memoryObject.MappedSize])
  memoryObject.MappedLocation = memoryLocation
  DeviceMemories[memory] = memoryObject
  if (IsMemoryCoherent(memoryObject)) {
    trackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  return ?
}

@threadSafety("app")
@indirect("VkDevice")
cmd void vkUnmapMemory(
    VkDevice       device,
    VkDeviceMemory memory) {
  memoryObject := DeviceMemories[memory]
  mappedLocation := as!u8*(memoryObject.MappedLocation)
  if (IsMemoryCoherent(memoryObject)) {
    readCoherentMemory(memoryObject, memoryObject.MappedOffset, memoryObject.MappedSize)
    untrackMappedCoherentMemory(as!u64(memoryObject.MappedLocation), as!size(memoryObject.MappedSize))
  }
  unmapMemory(mappedLocation[0:memoryObject.MappedSize])
  memoryObject.MappedSize = 0
  memoryObject.MappedLocation = null
}

@indirect("VkDevice")
cmd VkResult vkFlushMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount
    const VkMappedMemoryRange* pMemoryRanges) {
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    flushRange := memoryRanges[i]
    memoryObject := DeviceMemories[flushRange.memory]
    mappedLocation := as!u8*(memoryObject.MappedLocation)
    flushStart := flushRange.offset - memoryObject.MappedOffset
    // TODO: Log errors if flush offset - mapped offset is negative or
    // flushRange.size is out of bounds.
    if (flushRange.size == 0xFFFFFFFFFFFFFFFF) {
      // copy() contains an implicit read observation
      copy(memoryObject.Data[flushRange.offset:memoryObject.MappedOffset + memoryObject.MappedSize], (mappedLocation)[flushStart:memoryObject.MappedSize])
    } else {
      // copy() contains an implicit read observation
      copy(memoryObject.Data[flushRange.offset:flushRange.offset + flushRange.size], (mappedLocation)[flushStart:flushStart + flushRange.size])
    }
  }
  return ?
}

@internal
class MemoryRangeArray {
  map!(u32, void*) PData
  map!(u32, u64)   Start
  map!(u32, u64)   End
}

@indirect("VkDevice")
cmd VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                   device,
    u32                        memoryRangeCount,
    const VkMappedMemoryRange* pMemoryRanges) {
  ranges := new!MemoryRangeArray()
  memoryRanges := pMemoryRanges[0:memoryRangeCount]
  for i in (0 .. memoryRangeCount) {
    invalidateRange := memoryRanges[i]
    invalidateOffset := invalidateRange.offset
    mappedLocation := DeviceMemories[invalidateRange.memory].MappedLocation
    mappedOffset := DeviceMemories[invalidateRange.memory].MappedOffset
    mappedSize := DeviceMemories[invalidateRange.memory].MappedSize
    ranges.PData[i] = mappedLocation
    ranges.Start[i] = as!u64(invalidateOffset - mappedOffset)
    // TODO: Log errors if invalidate offset - mapped offset is negative or
    // invalidateRange.size is out of bounds.
    if (invalidateRange.size == 0xFFFFFFFFFFFFFFFF) {
      ranges.End[i] = as!u64(mappedSize)
    } else {
      ranges.End[i] = ranges.Start[i] + as!u64(invalidateRange.size)
    }
  }
  for i in (0 .. memoryRangeCount) {
    write(ranges.PData[i][ranges.Start[i]:ranges.End[i]])
  }
  return ?
}


// Memory management API functions

@indirect("VkDevice")
cmd void vkGetDeviceMemoryCommitment(
    VkDevice       device,
    VkDeviceMemory memory,
    VkDeviceSize*  pCommittedMemoryInBytes) {
}

@override
@custom
@no_replay
cmd void RecreateBufferData(
    VkDevice device,
    VkBuffer buffer,
    u32 hostBufferMemoryIndex,
    VkQueue lastBoundQueue,
    void* data) {
  read(as!u8*(data)[0:Buffers[buffer].Info.Size])
  // If the backing memory is mapped and is coherent memory, we need to read its initial data
  // so combined with following read observations of new writen data, we can get the complete
  // data.
  bufferObject := Buffers[buffer]
  if (bufferObject.Memory.MappedLocation != null) && IsMemoryCoherent(bufferObject.Memory) {
    start := bufferObject.MemoryOffset - bufferObject.Memory.MappedOffset
    read(bufferObject.Memory.MappedLocation[as!u64(start):as!u64(start) + as!u64(bufferObject.Info.Size)])
  }
}

@override
@custom
@no_replay
cmd void RecreateBindBufferMemory(
    VkDevice       device,
    VkBuffer       buffer,
    VkDeviceMemory memory,
    VkDeviceSize   offset) {
}

@indirect("VkDevice")
cmd VkResult vkBindBufferMemory(
    VkDevice       device,
    VkBuffer       buffer,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  Buffers[buffer].Memory = DeviceMemories[memory]
  Buffers[buffer].MemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(buffer)] = memoryOffset
  return ?
}

@override
@custom
@no_replay
cmd void RecreateImageData(
    VkDevice device,
    VkImage image,
    VkImageLayout lastLayout,
    u32 hostMemoryIndex,
    VkQueue lastBoundQueue,
    VkDeviceSize dataSize,
    void* data) {
  read(as!u8*(data)[0:dataSize])
  // If the backing memory is mapped and is coherent memory, we need to read its initial data
  // so combined with following read observations of new writen data, we can get the complete
  // data.
  imageObject := Images[image]
  if (imageObject.BoundMemory.MappedLocation != null) && IsMemoryCoherent(imageObject.BoundMemory) {
    start := imageObject.BoundMemoryOffset - imageObject.BoundMemory.MappedOffset
    read(imageObject.BoundMemory.MappedLocation[as!u64(start):as!u64(start)+as!u64(dataSize)])
  }
}

@override
@custom
@no_replay
cmd void RecreateBindImageMemory(
    VkDevice device,
    VkImage image,
    VkDeviceMemory memory,
    VkDeviceSize offset) {
}

@indirect("VkDevice")
cmd VkResult vkBindImageMemory(
    VkDevice       device,
    VkImage        image,
    VkDeviceMemory memory,
    VkDeviceSize   memoryOffset) {
  Images[image].BoundMemory = DeviceMemories[memory]
  Images[image].BoundMemoryOffset = memoryOffset
  DeviceMemories[memory].BoundObjects[as!u64(image)] = memoryOffset
  return ?
}

@indirect("VkDevice")
cmd void vkGetBufferMemoryRequirements(
    VkDevice              device,
    VkBuffer              buffer,
    VkMemoryRequirements* pMemoryRequirements) {
  requirements := ?
  pMemoryRequirements[0] = requirements
}

@indirect("VkDevice")
cmd void vkGetImageMemoryRequirements(
    VkDevice              device,
    VkImage               image,
    VkMemoryRequirements* pMemoryRequirements) {
  requirements := ?
  pMemoryRequirements[0] = requirements
}

@indirect("VkDevice")
cmd void vkGetImageSparseMemoryRequirements(
    VkDevice                         device,
    VkImage                          image,
    u32*                             pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
}

@indirect("VkPhysicalDevice", "VkInstance")
cmd void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice               physicalDevice,
    VkFormat                       format,
    VkImageType                    type,
    VkSampleCountFlagBits          samples,
    VkImageUsageFlags              usage,
    VkImageTiling                  tiling,
    u32*                           pPropertyCount,
    VkSparseImageFormatProperties* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }
}

@indirect("VkQueue", "VkDevice")
cmd VkResult vkQueueBindSparse(
    VkQueue                 queue,
    u32                     bindInfoCount,
    const VkBindSparseInfo* pBindInfo,
    VkFence                 fence) {
  return ?
}

@override
@custom
@no_replay
cmd void RecreateFence(
    VkDevice                     device,
    const VkFenceCreateInfo*     pCreateInfo
    VkFence*                     pFence) {
  read(pCreateInfo[0:1])
  write(pFence[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFence(
    VkDevice                     device,
    const VkFenceCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkFence*                     pFence) {

  f := new!FenceObject()
  create_info := pCreateInfo[0]
  f.Device = device

  if ((as!u32(create_info.flags) & as!u32(VK_FENCE_CREATE_SIGNALED_BIT)) != 0) {
    f.Signaled = true
  } else {
    f.Signaled = false
  }
  handle := ?
  pFence[0] = handle
  f.VulkanHandle = handle
  Fences[handle] = f
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFence(
    VkDevice                     device,
    VkFence                      fence,
    const VkAllocationCallbacks* pAllocator) {
  delete(Fences, fence)
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences) {
  read(pFences[0:fenceCount])
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetFenceStatus(
    VkDevice device,
    VkFence  fence) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkWaitForFences(
    VkDevice       device,
    u32            fenceCount,
    const VkFence* pFences,
    VkBool32       waitAll,
    u64            timeout) { /// timeout in nanoseconds
  read(pFences[0:fenceCount])
  return ?
}

@override
@custom
@no_replay
cmd void RecreateSemaphore(
    VkDevice                     device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    VkBool32                     signaled,
    VkSemaphore*                 pSemaphore) {
  read(pCreateInfo[0:1])
  write(pSemaphore[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSemaphore(
    VkDevice                     device,
    const VkSemaphoreCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSemaphore*                 pSemaphore) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  semaphoreObject := new!SemaphoreObject(Device: device,
    VulkanHandle:           handle)
  pSemaphore[0] = handle
  Semaphores[handle] = semaphoreObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySemaphore(
    VkDevice                     device,
    VkSemaphore                  semaphore,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Semaphores, semaphore)
}

@override
@custom
@no_replay
cmd void RecreateEvent(
    VkDevice                     device,
    const VkEventCreateInfo*     pCreateInfo,
    VkBool32                     signaled,
    VkEvent*                     pEvent) {
  read(pCreateInfo[0:1])
  write(pEvent[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateEvent(
    VkDevice                     device,
    const VkEventCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkEvent*                     pEvent) {
  read(pCreateInfo[0:1])
  event := new!EventObject()
  event.Device = device
  event.Signaled = false
  event.SubmitQueue = as!VkQueue(0)
  handle := ?
  pEvent[0] = handle
  event.VulkanHandle = handle
  Events[handle] = event
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyEvent(
    VkDevice                     device,
    VkEvent                      event,
    const VkAllocationCallbacks* pAllocator) {
  delete(Events, event)
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkGetEventStatus(
    VkDevice device,
    VkEvent  event) {
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkSetEvent(
    VkDevice device,
    VkEvent  event) {
  e := Events[event]
  e.Signaled = true
  queue := e.SubmitQueue
  if queue != as!VkQueue(0) {
    q := Queues[queue]
    if e.VulkanHandle in q.PendingEvents {
      delete(q.PendingEvents, e.VulkanHandle)
    }
    // If all pending events are signaled, so all removed from the pending
    // event list in the queue object, we should roll out the pending commands
    if len(q.PendingEvents) == 0 {
      execPendingCommands(queue)
    }
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkResetEvent(
    VkDevice device,
    VkEvent  event) {
  Events[event].Signaled = false
  return ?
}

@override
@custom
@no_replay
cmd void RecreateQueryPool(
    VkDevice device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const QueryStatus* pQueryStatuses
    VkQueryPool* pPool) {
  create_info := pCreateInfo[0]
  read(pQueryStatuses[0:create_info.queryCount])
  write(pPool[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateQueryPool(
    VkDevice                     device,
    const VkQueryPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkQueryPool*                 pQueryPool) {
  info := pCreateInfo[0]

  handle := ?
  pool := new!QueryPoolObject(
    Device: device,
    VulkanHandle: handle,
    QueryType: info.queryType,
    QueryCount: info.queryCount,
    PipelineStatistics: info.pipelineStatistics)
  for i in (0 .. info.queryCount) {
    pool.Status[i] = QUERY_STATUS_INACTIVE
  }

  QueryPools[handle] = pool
  pQueryPool[0] = handle

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyQueryPool(
    VkDevice                     device,
    VkQueryPool                  queryPool,
    const VkAllocationCallbacks* pAllocator) {
  delete(QueryPools, queryPool)
}

@threadSafety("system")
@indirect("VkDevice")
@blocking
cmd VkResult vkGetQueryPoolResults(
    VkDevice           device,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    size               dataSize,
    void*              pData,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  write(as!u8*(pData)[0:dataSize])
  return ?
}

@override
@custom
@no_replay
cmd void RecreateBuffer(
    VkDevice device,
    const VkBufferCreateInfo* pCreateInfo,
    VkBuffer* pBuffer) {
  create_info := pCreateInfo[0]
  if (create_info.queueFamilyIndexCount > 0) {
    read(create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount])
  }
  // Handle pNext
  if create_info.pNext != null {
    numPNext := numberOfPNext(create_info.pNext)
    next := MutableVoidPtr(as!void*(create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
          _ = as!VkDedicatedAllocationBufferCreateInfoNV*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }
  write(pBuffer[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateBuffer(
    VkDevice                     device,
    const VkBufferCreateInfo*    pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkBuffer*                    pBuffer) {
  buffer_create_info := pCreateInfo[0]

  queueFamilyIndices := buffer_create_info.pQueueFamilyIndices[
      0:buffer_create_info.queueFamilyIndexCount]

  bufferInfo := BufferInfo(
    CreateFlags: buffer_create_info.flags,
    Size: buffer_create_info.size,
    Usage: buffer_create_info.usage,
    SharingMode: buffer_create_info.sharingMode,
  )
  for i in (0 .. buffer_create_info.queueFamilyIndexCount) {
    bufferInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  // Handle pNext
  if buffer_create_info.pNext != null {
    numPNext := numberOfPNext(buffer_create_info.pNext)
    next := MutableVoidPtr(as!void*(buffer_create_info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationBufferCreateInfoNV*(next.Ptr)[0]
          bufferInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
              DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  bufferObject := new!BufferObject(Device: device,
    Memory:              null,
    MemoryOffset:        0,
    Info:                bufferInfo,
  )

  buffer := ?
  pBuffer[0] = buffer
  bufferObject.VulkanHandle = buffer
  Buffers[buffer] = bufferObject
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBuffer(
    VkDevice                     device,
    VkBuffer                     buffer,
    const VkAllocationCallbacks* pAllocator) {
  if (buffer != as!VkBuffer(0)) {
    bufferObject := Buffers[buffer]
    if (bufferObject.Memory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(bufferObject.Memory.BoundObjects,
      as!u64(buffer))
    }
    delete(Buffers, buffer)
  }
}



@override
@custom
@no_replay
cmd void RecreateBufferView(
    VkDevice                      device,
    const VkBufferViewCreateInfo* pCreateInfo,
    VkBufferView*                 pBufferView) {
  read(pCreateInfo[0:1])
  write(pBufferView[0:1])
}

// Buffer view functions
@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateBufferView(
    VkDevice                      device,
    const VkBufferViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkBufferView*                 pView) {
  buffer_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  bufferViewObject := new!BufferViewObject(
    Device:        device,
    VulkanHandle:  handle,
    Buffer:        Buffers[buffer_view_create_info.buffer],
    Format:        buffer_view_create_info.format,
    Offset:        buffer_view_create_info.offset,
    Range:         buffer_view_create_info.range)
  pView[0] = handle
  BufferViews[handle] = bufferViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyBufferView(
    VkDevice                     device,
    VkBufferView                 bufferView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(BufferViews, bufferView)
}

sub u32 getMipSize(u32 original, u32 level) {
  value := original / (1 << level)
  return switch (value) {
    case 0: 1
    default: value
  }
}

sub u32 roundUpTo(u32 dividend, u32 divisor) {
  return (dividend + divisor - 1) / divisor
}

@override
@custom
@no_replay
cmd void RecreateImage(
    VkDevice device,
    const VkImageCreateInfo* pCreateInfo,
    VkImage* pImage) {
  info := pCreateInfo[0]

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          _ = as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  write(pImage[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
@override
cmd VkResult vkCreateImage(
    VkDevice                     device,
    const VkImageCreateInfo*     pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImage*                     pImage) {
  // TODO: pAllocator

  info := pCreateInfo[0]

  queueFamilyIndices := info.pQueueFamilyIndices[0:info.queueFamilyIndexCount]

  imageInfo := ImageInfo(
    Flags:                info.flags,
    ImageType:            info.imageType,
    Format:               info.format,
    Extent:               info.extent,
    MipLevels:            info.mipLevels,
    ArrayLayers:          info.arrayLayers,
    Samples:              info.samples,
    Tiling:               info.tiling,
    Usage:                info.usage,
    SharingMode:          info.sharingMode,
    Layout:               info.initialLayout,
  )

  // Handle pNext
  if info.pNext != null {
    numPNext := numberOfPNext(info.pNext)
    next := MutableVoidPtr(as!void*(info.pNext))
    for i in (0 .. numPNext) {
      sType := as!const VkStructureType*(next.Ptr)[0:1][0]
      switch sType {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {
          ext := as!VkDedicatedAllocationImageCreateInfoNV*(next.Ptr)[0]
          imageInfo.DedicatedAllocationNV = new!DedicatedAllocationBufferImageCreateInfoNV(
              DedicatedAllocation: ext.dedicatedAllocation
          )
        }
      }
      next.Ptr = as!VulkanStructHeader*(next.Ptr)[0:1][0].PNext
    }
  }

  for i in (0 .. info.queueFamilyIndexCount) {
    imageInfo.QueueFamilyIndices[i] = queueFamilyIndices[i]
  }

  imageAspect := as!VkImageAspectFlags(
    switch info.format {
      case VK_FORMAT_D16_UNORM,
          VK_FORMAT_X8_D24_UNORM_PACK32,
          VK_FORMAT_D32_SFLOAT:
            VK_IMAGE_ASPECT_DEPTH_BIT
      case VK_FORMAT_S8_UINT:
            VK_IMAGE_ASPECT_STENCIL_BIT
      case VK_FORMAT_D16_UNORM_S8_UINT,
          VK_FORMAT_D24_UNORM_S8_UINT,
          VK_FORMAT_D32_SFLOAT_S8_UINT:
            VK_IMAGE_ASPECT_DEPTH_BIT |
              VK_IMAGE_ASPECT_COLOR_BIT
      default:
          VK_IMAGE_ASPECT_COLOR_BIT
  })

  handle := ?
  pImage[0] = handle

  object := new!ImageObject(
    Device:                   device,
    BoundMemory:              null,
    IsSwapchainImage:         false,
    VulkanHandle:             handle,
    Info:                     imageInfo,
    ImageAspect:              imageAspect,
  )

  for j in (0 .. info.arrayLayers) {
    layer := new!ImageLayer()
    object.Layers[j] = layer
    for i in (0 .. info.mipLevels) {
      width := getMipSize(info.extent.Width, i)
      height := getMipSize(info.extent.Height, i)
      depth := getMipSize(info.extent.Depth, i)
      level := new!ImageLevel(Width: width,Height:  height,Depth:  depth)
      elementAndTexelBlockSize := getElementAndTexelBlockSize(object.Info.Format)
      // Roundup the width and height in the number of blocks.
      widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
      heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
      size := widthInBlocks * heightInBlocks * depth * elementAndTexelBlockSize.ElementSize
      level.Data = make!u8(size)
      object.Layers[j].Levels[i] = level
    }
  }

  Images[handle] = object
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImage(
    VkDevice                     device,
    VkImage                      image,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  if (image != as!VkImage(0)) {
    imageObject := Images[image]
    if (imageObject.BoundMemory != null) {
      // If the memory is deleted first, then do not try to remove ourselves.
      delete(imageObject.BoundMemory.BoundObjects, as!u64(image))
    }
    delete(Images, image)
  }

}

@indirect("VkDevice")
cmd void vkGetImageSubresourceLayout(
    VkDevice                  device,
    VkImage                   image,
    const VkImageSubresource* pSubresource,
    VkSubresourceLayout*      pLayout) {
  _ = pSubresource[0]

  pLayout[0] = ?
}

@override
@custom
@no_replay
cmd void RecreateImageView(
    VkDevice device,
    const VkImageViewCreateInfo* pCreateInfo,
    VkImageView*                 pImageView) {
  read(pCreateInfo[0:1])
  write(pImageView[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateImageView(
    VkDevice                     device,
    const VkImageViewCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkImageView*                 pView) {
  image_view_create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  imageViewObject := new!ImageViewObject(Device: device,
    VulkanHandle:           handle,
    Image:                  Images[image_view_create_info.image],
    Type:                   image_view_create_info.viewType,
    Format:                 image_view_create_info.format,
    Components:             image_view_create_info.components,
    SubresourceRange:       image_view_create_info.subresourceRange
    )
  pView[0] = handle
  ImageViews[handle] = imageViewObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyImageView(
    VkDevice                     device,
    VkImageView                  imageView,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(ImageViews, imageView)
}

@override
@custom
@no_replay
cmd void RecreateShaderModule(VkDevice device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    VkShaderModule*                 pShaderModule) {
  create_info := pCreateInfo[0]

  num_words := as!u64(create_info.codeSize) / 4
  read(create_info.pCode[0:num_words])
  write(pShaderModule[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateShaderModule(
    VkDevice                        device,
    const VkShaderModuleCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkShaderModule*                 pShaderModule) {
  create_info := pCreateInfo[0]

  num_words := as!u64(create_info.codeSize) / 4
  object := new!ShaderModuleObject(device, clone(create_info.pCode[0:num_words]))

  handle := ?
  pShaderModule[0] = handle
  object.VulkanHandle = handle
  ShaderModules[handle] = object
  addWords(handle, create_info.codeSize, create_info.pCode)

  return ?
}

@override
@custom
@no_replay
cmd void RecreateDestroyShaderModule(
  VkDevice       device,
  VkShaderModule shaderModule) {}

@indirect("VkDevice")
cmd void vkDestroyShaderModule(
    VkDevice                     device,
    VkShaderModule               shaderModule,
    const VkAllocationCallbacks* pAllocator) {
  delete(ShaderModules, shaderModule)
}

@override
@custom
@no_replay
cmd void RecreatePipelineCache(VkDevice device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    VkPipelineCache*                 pPipelineCache) {
  info := pCreateInfo[0]
  if info.pInitialData != null {
    read(info.pInitialData[0:info.initialDataSize])
  }
  write(pPipelineCache[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreatePipelineCache(
    VkDevice                         device,
    const VkPipelineCacheCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*     pAllocator,
    VkPipelineCache*                 pPipelineCache) {
  //TODO(awoloszyn): Add Allocator support
  create_info := pCreateInfo[0]
  read(as!u8*(create_info.pInitialData)[0:create_info.initialDataSize])
  handle := ?
  pPipelineCache[0] = handle
  PipelineCaches[handle] = new!PipelineCacheObject(device, handle)
  return ?
}

@indirect("VkDevice")
cmd void vkDestroyPipelineCache(
    VkDevice                     device,
    VkPipelineCache              pipelineCache,
    const VkAllocationCallbacks* pAllocator) {
  delete(PipelineCaches, pipelineCache)
}

@indirect("VkDevice")
cmd VkResult vkGetPipelineCacheData(
    VkDevice        device,
    VkPipelineCache pipelineCache,
    size*           pDataSize,
    void*           pData) {
  _ = pDataSize[0]

  writeDataSize := ?
  pDataSize[0] = writeDataSize
  if pData != null {
    write(as!u8*(pData)[0:writeDataSize])
  }
  return ?
}

@indirect("VkDevice")
cmd VkResult vkMergePipelineCaches(
    VkDevice               device,
    VkPipelineCache        dstCache,
    u32                    srcCacheCount,
    const VkPipelineCache* pSrcCaches) {
  return ?
}

extern bool hasDynamicProperty(const VkPipelineDynamicStateCreateInfo* info,
                               VkDynamicState                          state)

@internal
class CreatedGraphicsPipelines {
  map!(u32, ref!GraphicsPipelineObject) Objects
}

@override
@custom
@no_replay
cmd void RecreateGraphicsPipeline(
  VkDevice                            device,
  VkPipelineCache                     pipelineCache,
  const VkGraphicsPipelineCreateInfo* pCreateInfo,
  VkPipeline*                         pPipeline) {
  create_info := pCreateInfo[0]
  pipeline_shader_stage_create_infos :=
    create_info.pStages[0:create_info.stageCount]
  for j in (0 .. create_info.stageCount) {
    stage_create_info := pipeline_shader_stage_create_infos[j]
    _ = as!string(stage_create_info.pName)
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      read(spec_info.pMapEntries[0:spec_info.mapEntryCount])
      read(as!char*(spec_info.pData)[0:spec_info.dataSize])
    }
  }

  vertex_input_state := create_info.pVertexInputState[0]
  read(vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount])
  read(vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount])

  read(create_info.pInputAssemblyState[0:1])

  if (create_info.pTessellationState != null) {
    read(create_info.pTessellationState[0:1])
  }
  if (create_info.pViewportState != null) {
    pipeline_viewport_state_create_info := create_info.pViewportState[0]
    if (!hasDynamicProperty(
          create_info.pDynamicState,
          VK_DYNAMIC_STATE_VIEWPORT)) {
      read(pipeline_viewport_state_create_info.pViewports[0:
        pipeline_viewport_state_create_info.viewportCount])
    }
    if (!hasDynamicProperty(
          create_info.pDynamicState,
          VK_DYNAMIC_STATE_SCISSOR)) {
      read(pipeline_viewport_state_create_info.pScissors[0:
        pipeline_viewport_state_create_info.scissorCount])
    }
  }
  read(create_info.pRasterizationState[0:1])

  if (create_info.pMultisampleState != null) {
    multisample_state := create_info.pMultisampleState[0]
    if (multisample_state.pSampleMask != null) {
      num_samples := as!u32(multisample_state.rasterizationSamples)
      sizeof_samplemask := (num_samples + 31) / 32
      read(multisample_state.pSampleMask[0:sizeof_samplemask])
    }
  }

  if (create_info.pDepthStencilState != null) {
    read(create_info.pDepthStencilState[0:1])
  }
  if (create_info.pColorBlendState != null) {
    color_blend_state := create_info.pColorBlendState[0]
    read(color_blend_state.pAttachments[0:
        color_blend_state.attachmentCount])
  }
  if (create_info.pDynamicState != null) {
    dynamic_state_info := create_info.pDynamicState[0]
    read(dynamic_state_info.pDynamicStates[0:
      dynamic_state_info.dynamicStateCount])
  }

  write(pPipeline[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateGraphicsPipelines(
    VkDevice                            device,
    VkPipelineCache                     pipelineCache,
    u32                                 createInfoCount,
    const VkGraphicsPipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*        pAllocator,
    VkPipeline*                         pPipelines) {
  // TODO(awoloszyn): Figure out what fields we want to store off
  //    in the state block.
  infos := pCreateInfos[0:createInfoCount]
  pipelines := pPipelines[0:createInfoCount]

  createdPipelines := CreatedGraphicsPipelines()

  for i in (0 .. createInfoCount) {
    obj := new!GraphicsPipelineObject(
      PipelineCache: PipelineCaches[pipelineCache]
    )
    obj.Device = device
    create_info := infos[i]
    // TODO: create_info.pNext
    obj.Flags = create_info.flags

    pipeline_shader_stage_create_infos :=
    create_info.pStages[0:create_info.stageCount]
    for j in (0 .. create_info.stageCount) {
      stage_create_info := pipeline_shader_stage_create_infos[j]
      stage_data := StageData(
        Stage: stage_create_info.stage,
        Module: ShaderModules[stage_create_info.module],
        EntryPoint: as!string(stage_create_info.pName),
      )
      if (stage_create_info.pSpecializationInfo != null) {
        spec_info := stage_create_info.pSpecializationInfo[0]
        spec_data := new!SpecializationInfo()
        spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
        for k in (0 .. spec_info.mapEntryCount) {
          spec_data.Specializations[k] = spec_map[k]
        }
        read(as!char*(spec_info.pData)[0:spec_info.dataSize])
        setSpecData(spec_data, spec_info.dataSize, spec_info.pData)
        stage_data.Specialization = spec_data
      }
      obj.Stages[j] = stage_data
    }

    vertex_input_state := create_info.pVertexInputState[0]
    vertex_descriptions := vertex_input_state.pVertexBindingDescriptions[0:
    vertex_input_state.vertexBindingDescriptionCount]
    // TODO: vertex_input_state.pNext
    for b in (0 .. vertex_input_state.vertexBindingDescriptionCount) {
      vertex_binding := vertex_descriptions[b]
      obj.VertexInputState.BindingDescriptions[vertex_binding.binding] = vertex_binding
    }

    vertex_attributes := vertex_input_state.pVertexAttributeDescriptions[0:
    vertex_input_state.vertexAttributeDescriptionCount]

    for b in (0 .. vertex_input_state.vertexAttributeDescriptionCount) {
      attribute := vertex_attributes[b]
      obj.VertexInputState.AttributeDescriptions[b] = attribute
    }

    input_assembly_state := create_info.pInputAssemblyState[0]
    obj.InputAssemblyState.Topology = input_assembly_state.topology
    obj.InputAssemblyState.PrimitiveRestartEnable = input_assembly_state.primitiveRestartEnable

    // TODO: pInputAssemblypNext
    if (create_info.pTessellationState != null) {
      tessellation_state := create_info.pTessellationState[0]
      obj.TessellationState = new!TessellationStateData(
        PatchControlPoints: tessellation_state.patchControlPoints
      )
    }
    if (create_info.pViewportState != null) {

      // TODO: pViewportpNext
      pipeline_viewport_state_create_info := create_info.pViewportState[0]

      viewport_data := new!ViewportData()

      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_VIEWPORT)) {

        viewports := pipeline_viewport_state_create_info.pViewports[0:
          pipeline_viewport_state_create_info.viewportCount]
        for k in (0 .. pipeline_viewport_state_create_info.viewportCount) {
          viewport_data.Viewports[k] = viewports[k]
        }
      }
      if (!hasDynamicProperty(
            create_info.pDynamicState,
            VK_DYNAMIC_STATE_SCISSOR)) {
        scissors := pipeline_viewport_state_create_info.pScissors[0:
          pipeline_viewport_state_create_info.scissorCount]
        for k in (0 .. pipeline_viewport_state_create_info.scissorCount) {
          viewport_data.Scissors[k] = scissors[k]
        }
      }
      obj.ViewportState = viewport_data
    }
    rasterization_state := create_info.pRasterizationState[0]

    obj.RasterizationState.DepthClampEnable = rasterization_state.depthClampEnable
    obj.RasterizationState.RasterizerDiscardEnable = rasterization_state.rasterizerDiscardEnable
    obj.RasterizationState.PolygonMode = rasterization_state.polygonMode
    obj.RasterizationState.CullMode = rasterization_state.cullMode
    obj.RasterizationState.FrontFace = rasterization_state.frontFace
    obj.RasterizationState.DepthBiasEnable = rasterization_state.depthBiasEnable
    obj.RasterizationState.DepthBiasConstantFactor = rasterization_state.depthBiasConstantFactor
    obj.RasterizationState.DepthBiasClamp = rasterization_state.depthBiasClamp
    obj.RasterizationState.DepthBiasSlopeFactor = rasterization_state.depthBiasSlopeFactor
    obj.RasterizationState.LineWidth = rasterization_state.lineWidth

    // TODO _.pNext

    if (create_info.pMultisampleState != null) {
      multisample_state := create_info.pMultisampleState[0]
      multisample_data := new!MultisampleData(
        RasterizationSamples: multisample_state.rasterizationSamples,
        SampleShadingEnable: multisample_state.sampleShadingEnable,
        MinSampleShading: multisample_state.minSampleShading,
        AlphaToCoverageEnable: multisample_state.alphaToCoverageEnable,
        AlphaToOneEnable: multisample_state.alphaToOneEnable
      )
      // TODO: multisample_state.pNext
      if (multisample_state.pSampleMask != null) {
        num_samples := as!u32(multisample_state.rasterizationSamples)
        sizeof_samplemask := (num_samples + 31) / 32
        sample_masks := multisample_state.pSampleMask[0:sizeof_samplemask]
        for k in (0 .. sizeof_samplemask) {
          multisample_data.SampleMask[k] = sample_masks[k]
        }
      }
      obj.MultisampleState = multisample_data
    }

    if (create_info.pDepthStencilState != null) {
      // TODO: pDepthStencilpNext
      depth_stencil_state := create_info.pDepthStencilState[0]
      obj.DepthState = new!DepthData(
        DepthTestEnable:depth_stencil_state.depthTestEnable,
        DepthWriteEnable:depth_stencil_state.depthWriteEnable,
        DepthCompareOp:depth_stencil_state.depthCompareOp,
        DepthBoundsTestEnable:depth_stencil_state.depthBoundsTestEnable,
        StencilTestEnable:depth_stencil_state.stencilTestEnable,
        Front:depth_stencil_state.front,
        Back:depth_stencil_state.back,
        MinDepthBounds:depth_stencil_state.minDepthBounds,
        MaxDepthBounds:depth_stencil_state.maxDepthBounds)
    }
    if (create_info.pColorBlendState != null) {
      color_blend_state := create_info.pColorBlendState[0]
      color_blend_data := new!ColorBlendData(
        LogicOpEnable:  color_blend_state.logicOpEnable,
        LogicOp:        color_blend_state.logicOp,
        BlendConstants: color_blend_state.blendConstants
      )
      // TODO: color_blend_state.pNext
      attachments := color_blend_state.pAttachments[0:
          color_blend_state.attachmentCount]
      for k in (0 .. color_blend_state.attachmentCount) {
        color_blend_data.Attachments[k] = attachments[k]
      }
      obj.ColorBlendState = color_blend_data
    }
    if (create_info.pDynamicState != null) {
      dynamic_state_info := create_info.pDynamicState[0]
      dynamic_data := new!DynamicData()
      // TODO: dynamic_state_info.pNext
      states := dynamic_state_info.pDynamicStates[0:
        dynamic_state_info.dynamicStateCount]
      for k in (0 .. dynamic_state_info.dynamicStateCount) {
        dynamic_data.DynamicStates[k] = states[k]
      }
      obj.DynamicState = dynamic_data
    }
    obj.Layout = PipelineLayouts[create_info.layout]
    obj.RenderPass = RenderPasses[create_info.renderPass]
    obj.Subpass = create_info.subpass
    if ((as!u32(create_info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (create_info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = create_info.basePipelineIndex
      } else {
        obj.BasePipeline = create_info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    createdPipelines.Objects[i] = obj
  }

  fence

  for i in (0 .. createInfoCount) {
    pipeline := ?
    pipelines[i] = pipeline
    createdPipelines.Objects[i].VulkanHandle = pipeline
    if (createdPipelines.Objects[i].BasePipelineIndex != -1) {
      createdPipelines.Objects[i].BasePipeline = pipelines[createdPipelines.Objects[i].BasePipelineIndex]
    }
    GraphicsPipelines[pipeline] = createdPipelines.Objects[i]
  }

  return ?
}

@internal
class CreatedComputePipelines {
  map!(u32, ref!ComputePipelineObject) Objects
}

@override
@custom
@no_replay
cmd void RecreateComputePipeline(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    const VkComputePipelineCreateInfo* pCreateInfo,
    VkPipeline*                        pPipeline) {
  create_info := pCreateInfo[0]
  _ = as!string(create_info.stage.pName)
  if (create_info.stage.pSpecializationInfo != null) {
    spec_info := create_info.stage.pSpecializationInfo[0]
    read(spec_info.pMapEntries[0:spec_info.mapEntryCount])
    read(as!char*(spec_info.pData)[0:spec_info.dataSize])
  }
  write(pPipeline[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateComputePipelines(
    VkDevice                           device,
    VkPipelineCache                    pipelineCache,
    u32                                createInfoCount,
    const VkComputePipelineCreateInfo* pCreateInfos,
    const VkAllocationCallbacks*       pAllocator,
    VkPipeline*                        pPipelines) {
  created_pipelines := CreatedComputePipelines()
  infos := pCreateInfos[0:createInfoCount]
  for i in (0 .. createInfoCount) {
    info := infos[i]
    obj := new!ComputePipelineObject(
      PipelineCache: PipelineCaches[pipelineCache],
      Device: device,
      Flags: info.flags,
      PipelineLayout: PipelineLayouts[info.layout]
    )
    stage_create_info := infos[i].stage
    stage_data := StageData(
      Stage: stage_create_info.stage,
      Module: ShaderModules[stage_create_info.module],
      EntryPoint: as!string(stage_create_info.pName),
    )
    if (stage_create_info.pSpecializationInfo != null) {
      spec_info := stage_create_info.pSpecializationInfo[0]
      spec_data := new!SpecializationInfo()
      spec_map := spec_info.pMapEntries[0:spec_info.mapEntryCount]
      for k in (0 .. spec_info.mapEntryCount) {
        spec_data.Specializations[k] = spec_map[k]
      }
      read(as!char*(spec_info.pData)[0:spec_info.dataSize])
      setSpecData(spec_data, spec_info.dataSize, spec_info.pData)
      stage_data.Specialization = spec_data
    }
    obj.Stage = stage_data
    if ((as!u32(info.flags) & as!u32(VK_PIPELINE_CREATE_DERIVATIVE_BIT)) != 0) {
      if (info.basePipelineIndex != -1) {
        obj.BasePipelineIndex = info.basePipelineIndex
      } else {
        obj.BasePipeline = info.basePipelineHandle
      }
    } else {
      obj.BasePipelineIndex = 0
      obj.BasePipeline = as!VkPipeline(0)
    }
    created_pipelines.Objects[i] = obj
  }
  // TODO: pAllocator

  pipelines := pPipelines[0:createInfoCount]
  for i in (0 .. createInfoCount) {
      pipeline := ?
      pipelines[i] = pipeline
      created_pipelines.Objects[i].VulkanHandle = pipeline
      if (created_pipelines.Objects[i].BasePipelineIndex != -1) {
        created_pipelines.Objects[i].BasePipeline = pipelines[created_pipelines.Objects[i].BasePipelineIndex]
      }
      ComputePipelines[pipeline] = created_pipelines.Objects[i]
    }

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipeline(
    VkDevice                     device,
    VkPipeline                   pipeline,
    const VkAllocationCallbacks* pAllocator) {
  if pipeline in GraphicsPipelines {
    delete(GraphicsPipelines, pipeline)
  }
  if pipeline in ComputePipelines {
    delete(ComputePipelines, pipeline)
  }
}

@override
@custom
@no_replay
cmd void RecreatePipelineLayout(VkDevice device,
  const VkPipelineLayoutCreateInfo* pCreateInfo,
  VkPipelineLayout*                 pPipelineLayout) {
  info := pCreateInfo[0]
  read(info.pSetLayouts[0:info.setLayoutCount])
  read(info.pPushConstantRanges[0:info.pushConstantRangeCount])
  write(pPipelineLayout[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreatePipelineLayout(
    VkDevice                          device,
    const VkPipelineLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkPipelineLayout*                 pPipelineLayout) {

  info := pCreateInfo[0]
  pipelineLayout := new!PipelineLayoutObject(Device: device)
  // TODO: info.pNext
  // TODO: pAllocator

  layoutCount := info.setLayoutCount
  layouts := info.pSetLayouts[0:layoutCount]
  for i in (0 .. layoutCount) {
    pipelineLayout.SetLayouts[i] = DescriptorSetLayouts[layouts[i]]
  }
  pushConstantCount := info.pushConstantRangeCount
  pushConstants := info.pPushConstantRanges[0:pushConstantCount]
  for i in (0 .. pushConstantCount) {
    pipelineLayout.PushConstantRanges[i] = pushConstants[i]
  }

  handle := ?
  pPipelineLayout[0] = handle
  pipelineLayout.VulkanHandle = handle
  PipelineLayouts[handle] = pipelineLayout
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyPipelineLayout(
    VkDevice                     device,
    VkPipelineLayout             pipelineLayout,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(PipelineLayouts, pipelineLayout)
}

@override
@custom
@no_replay
cmd void RecreateSampler(VkDevice device,
  const VkSamplerCreateInfo*   pCreateInfo,
  VkSampler*                   pSampler) {
    read(pCreateInfo[0:1])
    write(pSampler[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateSampler(
    VkDevice                     device,
    const VkSamplerCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkSampler*                   pSampler) {
  create_info := pCreateInfo[0]
  sampler := new!SamplerObject(
      Device: device,
      MagFilter: create_info.magFilter,
      MinFilter: create_info.minFilter,
      MipMapMode: create_info.mipmapMode,
      AddressModeU: create_info.addressModeU,
      AddressModeV: create_info.addressModeV,
      AddressModeW: create_info.addressModeW,
      MipLodBias: create_info.mipLodBias,
      AnisotropyEnable: create_info.anisotropyEnable,
      MaxAnisotropy: create_info.maxAnisotropy,
      CompareEnable: create_info.compareEnable,
      CompareOp: create_info.compareOp,
      MinLod: create_info.minLod,
      MaxLod: create_info.maxLod,
      BorderColor: create_info.borderColor,
      UnnormalizedCoordinates: create_info.unnormalizedCoordinates
  )
  handle := ?
  pSampler[0] = handle
  sampler.VulkanHandle = handle
  Samplers[handle] = sampler
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroySampler(
    VkDevice                     device,
    VkSampler                    sampler,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Samplers, sampler)
}

@internal class MutableU32 {
  u32 Val
}

@override
@custom
@no_replay
cmd void RecreateDescriptorSetLayout(VkDevice device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    VkDescriptorSetLayout*                 pSetLayout) {
  info := pCreateInfo[0]
  count := info.bindingCount
  bindings := info.pBindings[0:count]
  for i in (0 .. count) {
    if (bindings[i].pImmutableSamplers != null) {
      c := bindings[i].descriptorCount
      read(bindings[i].pImmutableSamplers[0:c])
    }
  }
  write(pSetLayout[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorSetLayout(
    VkDevice                               device,
    const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*           pAllocator,
    VkDescriptorSetLayout*                 pSetLayout) {
  info := pCreateInfo[0]
  // TODO: info.pNext
  count := info.bindingCount
  bindings := info.pBindings[0:count]
  descriptorSetLayout := new!DescriptorSetLayoutObject()
  descriptorSetLayout.Device = device
  largestBinding := MutableU32(0)

  for i in (0 .. count) {
    descriptorBinding := DescriptorSetLayoutBinding(
      Type:    bindings[i].descriptorType,
      Count:   bindings[i].descriptorCount,
      Stages:  bindings[i].stageFlags
    )
    c := bindings[i].descriptorCount
    if (c != 0) && (bindings[i].pImmutableSamplers != null) {
      samplers := bindings[i].pImmutableSamplers[0:c]
      for j in (0 .. c) {
        sampler := samplers[j]
        descriptorBinding.ImmutableSamplers[j] = Samplers[sampler]
      }
    }
    descriptorSetLayout.Bindings[bindings[i].binding] = descriptorBinding
    if (bindings[i].binding > largestBinding.Val) {
      largestBinding.Val = bindings[i].binding
    }
  }
  descriptorSetLayout.MaximumBinding = largestBinding.Val

  // TODO: pAllocator

  handle := ?
  pSetLayout[0] = handle
  descriptorSetLayout.VulkanHandle = handle
  DescriptorSetLayouts[handle] = descriptorSetLayout

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorSetLayout(
    VkDevice                     device,
    VkDescriptorSetLayout        descriptorSetLayout,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(DescriptorSetLayouts, descriptorSetLayout)
}


@override
@custom
@no_replay
cmd void RecreateDescriptorPool(VkDevice device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    VkDescriptorPool*                 pDescriptorPool) {
  info := pCreateInfo[0]
  read(info.pPoolSizes[0:info.poolSizeCount])
  write(pDescriptorPool[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateDescriptorPool(
    VkDevice                          device,
    const VkDescriptorPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDescriptorPool*                 pDescriptorPool) {
  info := pCreateInfo[0]
  pool := new!DescriptorPoolObject(
    Device: device,
    Flags: info.flags,
    MaxSets: info.maxSets)

  sizes := info.pPoolSizes[0:info.poolSizeCount]
  for i in(0 .. info.poolSizeCount) {
    pool.Sizes[i] = sizes[i]
  }
  // TODO: info.pNext

  // TODO: pAllocator

  handle := ?
  pDescriptorPool[0] = handle
  pool.VulkanHandle = handle
  DescriptorPools[handle] = pool

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyDescriptorPool(
    VkDevice                     device,
    VkDescriptorPool             descriptorPool,
    const VkAllocationCallbacks* pAllocator) {
  delete(DescriptorPools, descriptorPool)
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkResetDescriptorPool(
    VkDevice                   device,
    VkDescriptorPool           descriptorPool,
    VkDescriptorPoolResetFlags flags) {
  return ?
}

@override
@custom
@no_replay // allocateInfo.descriptorSetCount MUST be 1
cmd void RecreateDescriptorSet(
    VkDevice device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    u32                                descriptorWriteCount,
    const VkWriteDescriptorSet*        pDescriptorWrites,
    VkDescriptorSet*                   pDescriptorSet) {
  info := pAllocateInfo[0]
  read(info.pSetLayouts[0:info.descriptorSetCount])
  descriptorWrites := pDescriptorWrites[0:descriptorWriteCount]
  for i in (0 .. descriptorWriteCount) {
    write := descriptorWrites[i]
    switch write.descriptorType {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
          read(write.pImageInfo[0:write.descriptorCount])
      case  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
          read(write.pTexelBufferView[0:write.descriptorCount])
      case  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
          read(write.pBufferInfo[0:write.descriptorCount])
    }
  }

  write(pDescriptorSet[0:1])
}

@threadSafety("app")
@indirect("VkDevice")
cmd VkResult vkAllocateDescriptorSets(
    VkDevice                           device,
    const VkDescriptorSetAllocateInfo* pAllocateInfo,
    VkDescriptorSet*                   pDescriptorSets) {
  info := pAllocateInfo[0]
  // TODO: info.pNext
  count := info.descriptorSetCount

  layouts := info.pSetLayouts[0:count]
  read(info.pSetLayouts[0:count])
  sets := pDescriptorSets[0:count]

  for i in (0 .. count) {
    handle := ?
    sets[i] = handle
    object := new!DescriptorSetObject(device, handle,
      DescriptorPools[info.descriptorPool])
    object.Layout = DescriptorSetLayouts[layouts[i]]
    for j in (0 .. object.Layout.MaximumBinding + 1) {
      if j in object.Layout.Bindings {
        binding := object.Layout.Bindings[j]
        descriptorBinding := DescriptorBinding(
          BindingType: binding.Type)
        imageInfos := descriptorBinding.ImageBinding
        bufferInfos := descriptorBinding.BufferBinding
        bufferViews := descriptorBinding.BufferViewBindings
        for k in (0 .. binding.Count) {
          switch binding.Type {
            case VK_DESCRIPTOR_TYPE_SAMPLER,
              VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
              VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
              VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
              VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
              imageInfos[k] = new!VkDescriptorImageInfo()
            case  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
                  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
              bufferViews[k] = as!VkBufferView(0)
            case  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
                  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              bufferInfos[k] = new!VkDescriptorBufferInfo()
          }
        }
        descriptorBinding.ImageBinding = imageInfos
        descriptorBinding.BufferBinding = bufferInfos
        descriptorBinding.BufferViewBindings = bufferViews
        object.Bindings[j] = descriptorBinding
      }
    }
    DescriptorSets[handle] = object
  }

  return ?
}

@indirect("VkDevice")
cmd VkResult vkFreeDescriptorSets(
    VkDevice               device,
    VkDescriptorPool       descriptorPool,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets) {
  sets := pDescriptorSets[0:descriptorSetCount]
  for i in (0 .. descriptorSetCount) {
    delete(DescriptorSets, sets[i])
  }

  return ?
}

@internal class ProcessedDescriptorSet {
  u32 Binding
  u32 ArrayIndex
  u32 BindingElementCount
  u32 BindingIndex
}

@internal class DescriptorSetWrite {
  u32 Binding
  u32 BindingArrayIndex
  VkDescriptorType           Type
  VkDescriptorSet            DstSet
  ref!VkDescriptorImageInfo  ImageInfo
  ref!VkDescriptorBufferInfo BufferInfo
  VkBufferView           BufferView
}

@internal class WriteReturnMap {
  map!(u32, DescriptorSetWrite) Map
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetWrite) RewriteWriteDescriptorSets
    (u32                         descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites) {
  descriptor_set := ProcessedDescriptorSet(0, 0, 0)
  descriptor_writes := pDescriptorWrites[0:descriptorWriteCount]
  ret_val := WriteReturnMap()
  for i in (0 .. descriptorWriteCount) {
    write := descriptor_writes[i]
    count := write.descriptorCount
    set := DescriptorSets[write.dstSet]
    descriptor_set.Binding = write.dstBinding
    descriptor_set.ArrayIndex = write.dstArrayElement
    descriptor_set.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      descriptor_set.BindingElementCount =
        len(set.Bindings[descriptor_set.Binding].ImageBinding) +
        len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
        len(set.Bindings[descriptor_set.Binding].BufferBinding)
      base_binding := descriptor_set.Binding
      for k in (base_binding .. len(set.Bindings)) {
        if (descriptor_set.ArrayIndex > descriptor_set.BindingElementCount - 1) {
          descriptor_set.ArrayIndex = 0
          descriptor_set.Binding = descriptor_set.Binding + 1
          descriptor_set.BindingElementCount =
            len(set.Bindings[descriptor_set.Binding].ImageBinding) +
            len(set.Bindings[descriptor_set.Binding].BufferViewBindings) +
            len(set.Bindings[descriptor_set.Binding].BufferBinding)
        }
      }
      switch(write.descriptorType) {
        case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
          imageInfos := write.pImageInfo[0: descriptor_set.BindingIndex+1]
          imageInfo := imageInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding: descriptor_set.Binding,
            BindingArrayIndex : descriptor_set.ArrayIndex,
            DstSet: write.dstSet,
            Type : write.descriptorType,
            ImageInfo: new!VkDescriptorImageInfo(
              Sampler: imageInfo.Sampler,
              ImageView: imageInfo.ImageView,
              ImageLayout: imageInfo.ImageLayout
            )
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
          bufferViews := write.pTexelBufferView[0: descriptor_set.BindingIndex+1]
          bufferView := bufferViews[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding: descriptor_set.Binding,
            Type : write.descriptorType,
            DstSet: write.dstSet,
            BindingArrayIndex : descriptor_set.ArrayIndex,
            BufferView: bufferView
          )
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
          VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
          VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:{
          bufferInfos := write.pBufferInfo[0:descriptor_set.BindingIndex+1]
          bufferInfo := bufferInfos[descriptor_set.BindingIndex]
          ret_val.Map[len(ret_val.Map)] = DescriptorSetWrite(
            Binding: descriptor_set.Binding,
            Type : write.descriptorType,
            DstSet: write.dstSet,
            BindingArrayIndex : descriptor_set.ArrayIndex,
            BufferInfo: new!VkDescriptorBufferInfo(
              Buffer: bufferInfo.Buffer,
              Offset: bufferInfo.Offset,
              Range: bufferInfo.Range
            )
          )
        }
        default: {
          // Do nothing, we should also never get here
        }
      }
      descriptor_set.BindingIndex =
        descriptor_set.BindingIndex + 1
      descriptor_set.ArrayIndex = descriptor_set.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@internal class CopyReturnMap {
  map!(u32, DescriptorSetCopy) Map
}

@internal class DescriptorSetCopy {
  u32             SrcBinding
  u32             DstBinding
  u32             SrcArrayIndex
  u32             DstArrayIndex
  VkDescriptorSet SrcSet
  VkDescriptorSet DstSet
}

// Rewrites all descriptor-set writes to be single updates
sub map!(u32, DescriptorSetCopy) RewriteWriteDescriptorCopies
    (u32                         descriptorCopyCount,
    const VkCopyDescriptorSet* pDescriptorCopies) {
  srcDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  dstDescriptorSet := ProcessedDescriptorSet(0, 0, 0)
  descriptorCopies := pDescriptorCopies[0:descriptorCopyCount]
  ret_val := CopyReturnMap()
  for i in (0 .. descriptorCopyCount) {
    copy := descriptorCopies[i]
    count := copy.descriptorCount
    srcSet := DescriptorSets[copy.srcSet]
    dstSet := DescriptorSets[copy.dstSet]

    srcDescriptorSet.Binding = copy.srcBinding
    srcDescriptorSet.ArrayIndex = copy.srcArrayElement
    srcDescriptorSet.BindingIndex = 0

    dstDescriptorSet.Binding = copy.dstBinding
    dstDescriptorSet.ArrayIndex = copy.dstArrayElement
    dstDescriptorSet.BindingIndex = 0
    for j in (0 .. count) {
      // Only one of the 3 should actually exist
      srcDescriptorSet.BindingElementCount =
        len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
        len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
        len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
      dstDescriptorSet.BindingElementCount =
        len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
        len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
        len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
      srcBaseBinding := srcDescriptorSet.Binding
      dstBaseBinding := dstDescriptorSet.Binding

      for k in (srcBaseBinding .. len(srcSet.Bindings)) {
        if (srcDescriptorSet.ArrayIndex > srcDescriptorSet.BindingElementCount - 1) {
          srcDescriptorSet.ArrayIndex = 0
          srcDescriptorSet.Binding = srcDescriptorSet.Binding + 1
          srcDescriptorSet.BindingElementCount =
            len(srcSet.Bindings[srcDescriptorSet.Binding].ImageBinding) +
            len(srcSet.Bindings[srcDescriptorSet.Binding].BufferViewBindings) +
            len(srcSet.Bindings[srcDescriptorSet.Binding].BufferBinding)
        }
      }

      for k in (dstBaseBinding .. len(dstSet.Bindings)) {
        if (dstDescriptorSet.ArrayIndex > dstDescriptorSet.BindingElementCount - 1) {
          dstDescriptorSet.ArrayIndex = 0
          dstDescriptorSet.Binding = dstDescriptorSet.Binding + 1
          dstDescriptorSet.BindingElementCount =
            len(dstSet.Bindings[dstDescriptorSet.Binding].ImageBinding) +
            len(dstSet.Bindings[dstDescriptorSet.Binding].BufferViewBindings) +
            len(dstSet.Bindings[dstDescriptorSet.Binding].BufferBinding)
        }
      }


      ret_val.Map[len(ret_val.Map)] = DescriptorSetCopy(
          SrcBinding: srcDescriptorSet.Binding,
          DstBinding: dstDescriptorSet.Binding,
          SrcArrayIndex: srcDescriptorSet.ArrayIndex,
          DstArrayIndex: dstDescriptorSet.ArrayIndex,
          SrcSet: copy.srcSet,
          DstSet: copy.dstSet)

      srcDescriptorSet.BindingIndex =
        srcDescriptorSet.BindingIndex + 1
      srcDescriptorSet.ArrayIndex = srcDescriptorSet.ArrayIndex + 1
      dstDescriptorSet.BindingIndex =
        dstDescriptorSet.BindingIndex + 1
      dstDescriptorSet.ArrayIndex = dstDescriptorSet.ArrayIndex + 1
    }
  }
  return ret_val.Map
}

@indirect("VkDevice")
cmd void vkUpdateDescriptorSets(
    VkDevice                    device,
    u32                         descriptorWriteCount,
    const VkWriteDescriptorSet* pDescriptorWrites,
    u32                         descriptorCopyCount,
    const VkCopyDescriptorSet*  pDescriptorCopies) {

  writes := RewriteWriteDescriptorSets(
                descriptorWriteCount,
                pDescriptorWrites)
  for _, _, w in writes {
    set := DescriptorSets[w.DstSet]
    binding := w.Binding
    arrayIndex := w.BindingArrayIndex
    setBinding := set.Bindings[binding]
    switch w.Type {
      case VK_DESCRIPTOR_TYPE_SAMPLER,
            VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
            imageBinding := setBinding.ImageBinding
            imageBinding[arrayIndex] = w.ImageInfo
            setBinding.ImageBinding = imageBinding
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
          viewBindings := setBinding.BufferViewBindings
          viewBindings[arrayIndex] = w.BufferView
          setBinding.BufferViewBindings = viewBindings
        }
        case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
          bufferBindings := setBinding.BufferBinding
          bufferBindings[arrayIndex] = w.BufferInfo
          setBinding.BufferBinding = bufferBindings
        }
    }
    set.Bindings[binding] = setBinding
  }

  copies := RewriteWriteDescriptorCopies(
    descriptorCopyCount,
    pDescriptorCopies)
  for _, _, c in copies {
    srcSet := DescriptorSets[c.SrcSet]
    dstSet := DescriptorSets[c.DstSet]
    srcBinding := srcSet.Bindings[c.SrcBinding]
    dstBinding := dstSet.Bindings[c.DstBinding]
    switch(srcBinding.BindingType) {
       case VK_DESCRIPTOR_TYPE_SAMPLER,
          VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
          VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
          VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
          VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:{
        imageBinding := dstBinding.ImageBinding
        imageBinding[c.DstArrayIndex] =
          srcBinding.ImageBinding[c.SrcArrayIndex]
        dstBinding.ImageBinding = imageBinding
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:{
        bufferViews := dstBinding.BufferViewBindings
        bufferViews[c.DstArrayIndex] =
          srcBinding.BufferViewBindings[c.SrcArrayIndex]
        dstBinding.BufferViewBindings = bufferViews
      }
      case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
            VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:{
        bufferBinding := dstBinding.BufferBinding
        bufferBinding[c.DstArrayIndex] =
          srcBinding.BufferBinding[c.SrcArrayIndex]
        dstBinding.BufferBinding = bufferBinding
      }
    }
    dstSet.Bindings[c.DstBinding] = dstBinding
  }
}

@override
@custom
@no_replay
cmd void RecreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    VkFramebuffer*                 pFramebuffer) {
  create_info := pCreateInfo[0]
  read(create_info.pAttachments[0:create_info.attachmentCount])
  write(pFramebuffer[0:1])
}

@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateFramebuffer(
    VkDevice                       device,
    const VkFramebufferCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkFramebuffer*                 pFramebuffer) {
  create_info := pCreateInfo[0]
  attachments := create_info.pAttachments[0:create_info.attachmentCount]

  framebufferObject := new!FramebufferObject(Device: device,
    Width:                    create_info.width,
    Height:                   create_info.height,
    Layers:                   create_info.layers,
    RenderPass:               RenderPasses[create_info.renderPass])
  for i in (0 .. create_info.attachmentCount) {
    framebufferObject.ImageAttachments[i] = ImageViews[attachments[i]]
  }

  handle := ?
  pFramebuffer[0] = handle
  framebufferObject.VulkanHandle = handle
  Framebuffers[handle] = framebufferObject

  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyFramebuffer(
    VkDevice                     device,
    VkFramebuffer                framebuffer,
    const VkAllocationCallbacks* pAllocator) {
  delete(Framebuffers, framebuffer)
}

@override
@custom
@no_replay
cmd void RecreateRenderPass(VkDevice device,
    const VkRenderPassCreateInfo* pCreateInfo,
    VkRenderPass*                 pRenderPass) {
  info := pCreateInfo[0]
  read(info.pAttachments[0:info.attachmentCount])
  subpasses := info.pSubpasses[0:info.subpassCount]
  for i in (0 .. info.subpassCount) {
    description := subpasses[i]
    read(description.pInputAttachments[0:description.inputAttachmentCount])
    read(description.pColorAttachments[0:description.colorAttachmentCount])
    if description.pResolveAttachments != null {
      read(description.pResolveAttachments[0:description.colorAttachmentCount])
    }
    if description.pDepthStencilAttachment != null {
      read(description.pDepthStencilAttachment[0:1])
    }

    read(description.pPreserveAttachments[0:description.preserveAttachmentCount])
  }
  read(info.pDependencies[0:info.dependencyCount])
  write(pRenderPass[0:1])
}


@threadSafety("system")
@indirect("VkDevice")
cmd VkResult vkCreateRenderPass(
    VkDevice                      device,
    const VkRenderPassCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*  pAllocator,
    VkRenderPass*                 pRenderPass) {
  renderPass := new!RenderPassObject()
  renderPass.Device = device
  info := pCreateInfo[0]

  attachments := info.pAttachments[0:info.attachmentCount]
  for i in (0 .. info.attachmentCount) {
    renderPass.AttachmentDescriptions[i] = attachments[i]
  }
  subpasses := info.pSubpasses[0:info.subpassCount]
  read(subpasses)
  for i in (0 .. info.subpassCount) {
    subpass := subpasses[i]
    description := SubpassDescription(
        PipelineBindPoint: subpass.pipelineBindPoint,
    )
    inputAttachments := subpass.pInputAttachments[0:subpass.inputAttachmentCount]
    for j in (0 .. subpass.inputAttachmentCount) {
      description.InputAttachments[j] = inputAttachments[j]
    }
    colorAttachments := subpass.pColorAttachments[0:subpass.colorAttachmentCount]
    for j in (0 .. subpass.colorAttachmentCount) {
      description.ColorAttachments[j] = colorAttachments[j]
    }
    if subpass.pResolveAttachments != null {
      resolveAttachments := subpass.pResolveAttachments[0:subpass.colorAttachmentCount]
      for j in (0 .. subpass.colorAttachmentCount) {
        description.ResolveAttachments[j] = resolveAttachments[j]
      }
    }
    if (subpass.pDepthStencilAttachment != null) {
      depth_attachment := subpass.pDepthStencilAttachment[0]
      description.DepthStencilAttachment = new!VkAttachmentReference(
          Attachment: depth_attachment.Attachment,
          Layout: depth_attachment.Layout)
    }
    preserveAttachments := subpass.pPreserveAttachments[0:subpass.preserveAttachmentCount]
    for j in (0 .. subpass.preserveAttachmentCount) {
      description.PreserveAttachments[j] = preserveAttachments[j]
    }
    renderPass.SubpassDescriptions[i] = description
  }
  dependencies := info.pDependencies[0:info.dependencyCount]
  for i in (0 .. info.dependencyCount) {
    renderPass.SubpassDependencies[i] = dependencies[i]
  }
  handle := ?
  pRenderPass[0] = handle
  renderPass.VulkanHandle = pRenderPass[0]
  RenderPasses[handle] = renderPass
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
cmd void vkDestroyRenderPass(
    VkDevice                     device,
    VkRenderPass                 renderPass,
    const VkAllocationCallbacks* pAllocator) {
  delete(RenderPasses, renderPass)
}

@indirect("VkDevice")
cmd void vkGetRenderAreaGranularity(
    VkDevice     device,
    VkRenderPass renderPass,
    VkExtent2D*  pGranularity) {
}

@override
@custom
@no_replay
cmd void RecreateCommandPool(VkDevice device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    VkCommandPool*                 pCommandPool) {
  read(pCreateInfo[0:1])
  write(pCommandPool[0:1])
}

@indirect("VkDevice")
cmd VkResult vkCreateCommandPool(
    VkDevice                       device,
    const VkCommandPoolCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*   pAllocator,
    VkCommandPool*                 pCommandPool) {
  create_info := pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pCommandPool[0] = handle
  commandPoolObject := new!CommandPoolObject(Device: device,
    VulkanHandle:             handle,
    Flags : create_info.flags,
    QueueFamilyIndex : create_info.queueFamilyIndex)
  CommandPools[handle] = commandPoolObject

  return ?
}

@indirect("VkDevice")
cmd void vkDestroyCommandPool(
    VkDevice                     device,
    VkCommandPool                commandPool,
    const VkAllocationCallbacks* pAllocator) {
  fence
  for _, k, _ in CommandPools[commandPool].CommandBuffers {
    delete(CommandBuffers, k)
  }
  delete(CommandPools, commandPool)
}

@indirect("VkDevice")
cmd VkResult vkResetCommandPool(
    VkDevice                device,
    VkCommandPool           commandPool,
    VkCommandPoolResetFlags flags) {
  return ?
}

@override
@custom
@no_replay
cmd void RecreateAndBeginCommandBuffer(
    VkDevice            device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    const VkCommandBufferBeginInfo*    pBeginInfo,
    VkCommandBuffer*                   pCommandBuffer
    ) {
  read(pAllocateInfo[0:1])
  if pBeginInfo != null {
    beginInfo := pBeginInfo[0]
    if beginInfo.pInheritanceInfo != null {
      read(beginInfo.pInheritanceInfo[0:1])
    }
  }

  write(pCommandBuffer[0:1])
}


@threadSafety("system")
@indirect("VkDevice")
@custom
cmd VkResult vkAllocateCommandBuffers(
    VkDevice                           device,
    const VkCommandBufferAllocateInfo* pAllocateInfo,
    VkCommandBuffer*                   pCommandBuffers) {
  allocateInfo := pAllocateInfo[0]
  count := allocateInfo.commandBufferCount

  fence
  cb := pCommandBuffers[0:count]

  for i in (0 .. count) {
    command_buffer := ?
    cb[i] = command_buffer
    CommandBuffers[command_buffer] = new!CommandBufferObject(
                                          Device: device,
                                          VulkanHandle: command_buffer,
                                          Recording: NOT_STARTED,
                                          Pool: allocateInfo.commandPool,
                                          Level: allocateInfo.level)
    command_pool := CommandPools[allocateInfo.commandPool]
    command_pool.CommandBuffers[command_buffer] = CommandBuffers[command_buffer]
    CommandPools[allocateInfo.commandPool] = command_pool
  }
  return ?
}

@threadSafety("system")
@indirect("VkDevice")
@custom
cmd void vkFreeCommandBuffers(
    VkDevice               device,
    VkCommandPool          commandPool,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  cb := pCommandBuffers[0:commandBufferCount]
  for i in (0 .. commandBufferCount) {
    buffer := cb[i]
    buffer_object := CommandBuffers[buffer]
    pool := buffer_object.Pool
    pool_object := CommandPools[pool]
    delete(pool_object.CommandBuffers, buffer)
    CommandPools[pool] = pool_object
    delete(CommandBuffers, buffer)
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkBeginCommandBuffer(
    VkCommandBuffer                 commandBuffer,
    const VkCommandBufferBeginInfo* pBeginInfo) {
  info := pBeginInfo[0]
  begin := new!CommandBufferBegin(Flags: info.flags, Inherited: false)

  // TODO: pBeginInfo->pNext
  if info.pInheritanceInfo != null {
    inheritanceInfo := info.pInheritanceInfo[0]
    begin.Inherited = true
    begin.InheritedRenderPass = inheritanceInfo.renderPass
    begin.InheritedSubpass = inheritanceInfo.subpass
    begin.InheritedFramebuffer = inheritanceInfo.framebuffer
    begin.InheritedOcclusionQuery = inheritanceInfo.occlusionQueryEnable
    begin.InheritedQueryFlags = inheritanceInfo.queryFlags
    begin.InheritedPipelineStatsFlags = inheritanceInfo.pipelineStatistics
    // TODO: pBeginInfo->pInheritanceInfo->pNext
  }
  buff := CommandBuffers[commandBuffer]
  buff.BeginInfo = begin
  buff.Recording = RECORDING
  CommandBuffers[commandBuffer] = buff
  resetCmd(commandBuffer)
  return ?
}

@override
@custom
@no_replay
cmd void RecreateEndCommandBuffer(VkCommandBuffer commandBuffer) {}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkEndCommandBuffer(
    VkCommandBuffer commandBuffer) {
  buff := CommandBuffers[commandBuffer]
  buff.Recording = COMPLETED
  CommandBuffers[commandBuffer] = buff
  return ?
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd VkResult vkResetCommandBuffer(
    VkCommandBuffer           commandBuffer,
    VkCommandBufferResetFlags flags) {
  buff := CommandBuffers[commandBuffer]
  buff.Recording = NOT_STARTED
  buff.BeginInfo = null
  CommandBuffers[commandBuffer] = buff
  return ?
}

class CmdBindPipeline {
  VkPipelineBindPoint PipelineBindPoint
  VkPipeline          Pipeline
}

@override
@custom
@no_replay
cmd void RecreateCmdBindPipeline(
    VkCommandBuffer     commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline          pipeline) {
}

@internal class
RecreateCmdBindPipelineData {
  VkPipelineBindPoint PipelineBindPoint,
  VkPipeline          Pipeline
}


@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindPipeline(
    VkCommandBuffer     commandBuffer,
    VkPipelineBindPoint pipelineBindPoint,
    VkPipeline          pipeline) {
  addCmd(commandBuffer, new!RecreateCmdBindPipelineData(
    PipelineBindPoint: pipelineBindPoint,
    Pipeline: pipeline
  ), CmdBindPipeline(pipelineBindPoint, pipeline), doCmdBindPipeline)
}

@internal
class Unimplemented {
}

sub void doCmdNop(Unimplemented args) {}

extern void addCmd(VkCommandBuffer cmdBuf, any recreatePayload, any payload, any func)
extern void setSpecData(ref!SpecializationInfo info, size numBytes, const void* pData)
extern void resetCmd(VkCommandBuffer cmdBuf)
extern void execCommands(VkCommandBuffer cmdBuf)
extern void execPendingCommands(VkQueue queue)
extern void recordUpdateSemaphoreSignal(VkSemaphore semaphore, bool Signaled)
extern void addWords(VkShaderModule module, size numBytes, const u32* pData)
extern ref!RecreateCmdUpdateBufferData createUpdateBufferData(
  VkBuffer        dstBuffer
  VkDeviceSize    dstOffset
  VkDeviceSize    dataSize
  const void*     data)

extern ref!RecreateCmdPushConstantsData createPushConstantsData(
  VkPipelineLayout   layout,
  VkShaderStageFlags stageFlags,
  u32                offset,
  u32                size,
  const void*        pValues)

sub void doCmdBindPipeline(CmdBindPipeline args) {
  switch args.PipelineBindPoint {
    case VK_PIPELINE_BIND_POINT_COMPUTE:
      CurrentComputePipeline = ComputePipelines[args.Pipeline]
    case VK_PIPELINE_BIND_POINT_GRAPHICS:
      LastDrawInfo.GraphicsPipeline = GraphicsPipelines[args.Pipeline]
  }
}


@internal
class RecreateCmdSetViewportData{
  u32 FirstViewport
  map!(u32, VkViewport) Viewports
}

@override
@custom
@no_replay
cmd void RecreateCmdSetViewport(
    VkCommandBuffer commandBuffer,
    u32             firstViewport,
    u32             viewportCount,
    const VkViewport* pViewports) {
  read(pViewports[0:viewportCount])
}

sub void doCmdSetViewport(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetViewport(
    VkCommandBuffer   commandBuffer,
    u32               firstViewport,
    u32               viewportCount,
    const VkViewport* pViewports) {
  viewports := pViewports[0:viewportCount]
  recreate_info := new!RecreateCmdSetViewportData(
    firstViewport
  )
  for i in (0 .. viewportCount) {
    recreate_info.Viewports[i] = viewports[i]
  }
  addCmd(commandBuffer, recreate_info, as!u32(0), doCmdSetViewport)
}

@internal
class RecreateCmdSetScissorData{
  u32 FirstScissor
  map!(u32, VkRect2D) Scissors
}

@override
@custom
@no_replay
cmd void RecreateCmdSetScissor(
    VkCommandBuffer commandBuffer,
    u32             firstScissor,
    u32             scissorCount,
    const VkRect2D* pScissors) {
  read(pScissors[0:scissorCount])
}

sub void doCmdSetScissor(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetScissor(
    VkCommandBuffer commandBuffer,
    u32             firstScissor,
    u32             scissorCount,
    const VkRect2D* pScissors) {
  scissors := pScissors[0:scissorCount]
  recreate_info := new!RecreateCmdSetScissorData(
    firstScissor
  )
  for i in (0 .. scissorCount) {
    recreate_info.Scissors[i] = scissors[i]
  }
  addCmd(commandBuffer, recreate_info, as!u32(0), doCmdSetScissor)
}


@internal
class RecreateCmdSetLineWidthData{
  f32             LineWidth
}

@override
@custom
@no_replay
cmd void RecreateCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    f32             lineWidth) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetLineWidth(
    VkCommandBuffer commandBuffer,
    f32             lineWidth) {
  addCmd(commandBuffer, new!RecreateCmdSetLineWidthData(lineWidth),Unimplemented(), doCmdNop)
}

@internal
class RecreateCmdSetDepthBiasData{
  f32             DepthBiasConstantFactor
  f32             DepthBiasClamp
  f32             DepthBiasSlopeFactor
}

@override
@custom
@no_replay
cmd void RecreateCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    f32             depthBiasConstantFactor
    f32             depthBiasClamp
    f32             depthBiasSlopeFactor) {
}

sub void doCmdSetDepthBias(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBias(
    VkCommandBuffer commandBuffer,
    f32             depthBiasConstantFactor,
    f32             depthBiasClamp,
    f32             depthBiasSlopeFactor) {
  addCmd(commandBuffer, new!RecreateCmdSetDepthBiasData(
    depthBiasConstantFactor,
    depthBiasClamp,
    depthBiasSlopeFactor
  ), as!u32(0), doCmdSetDepthBias)
}

@internal
class RecreateCmdSetBlendConstantsData{
  f32 R
  f32 G
  f32 B
  f32 A
}

@override
@custom
@no_replay
cmd void RecreateCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    @readonly f32[4] blendConstants) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetBlendConstants(
    VkCommandBuffer commandBuffer,
    @readonly f32[4] blendConstants) {
  addCmd(commandBuffer,
    new!RecreateCmdSetBlendConstantsData(
      blendConstants[0],
      blendConstants[1],
      blendConstants[2],
      blendConstants[3]), Unimplemented(), doCmdNop)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetDepthBounds(
    VkCommandBuffer commandBuffer,
    f32             minDepthBounds,
    f32             maxDepthBounds) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilCompareMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                compareMask) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilWriteMask(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                writeMask) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetStencilReference(
    VkCommandBuffer    commandBuffer,
    VkStencilFaceFlags faceMask,
    u32                reference) {
}

@internal
class CmdBindDescriptorSets {
  // map from binding to set
  map!(u32, ref!DescriptorSetObject) DescriptorSets
  map!(u32, BoundBuffer)             BoundBuffers
}

sub void doCmdBindDescriptorSets(CmdBindDescriptorSets bind) {
  for _ , _ , v in bind.BoundBuffers {
    if (v.Buffer != null) {
      v.Buffer.LastBoundQueue = LastBoundQueue
      readCoherentMemoryInBuffer(v.Buffer, v.Offset, v.Range)
    }
  }
  for _, binding, set in bind.DescriptorSets {
      LastDrawInfo.DescriptorSets[binding] = set
  }
}

@override
@custom
@no_replay
cmd void RecreateCmdBindDescriptorSets(
    VkCommandBuffer        commandBuffer,
    VkPipelineBindPoint    pipelineBindPoint,
    VkPipelineLayout       layout,
    u32                    firstSet,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    u32                    dynamicOffsetCount,
    const u32*             pDynamicOffsets) {
  read(pDescriptorSets[0:descriptorSetCount])
  read(pDynamicOffsets[0:dynamicOffsetCount])
}

@internal class
RecreateCmdBindDescriptorSetsData {
  VkPipelineBindPoint        PipelineBindPoint,
  VkPipelineLayout           Layout,
  u32                        FirstSet,
  map!(u32, VkDescriptorSet) DescriptorSets
  map!(u32, u32)             DynamicOffsets
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindDescriptorSets(
    VkCommandBuffer        commandBuffer,
    VkPipelineBindPoint    pipelineBindPoint,
    VkPipelineLayout       layout,
    u32                    firstSet,
    u32                    descriptorSetCount,
    const VkDescriptorSet* pDescriptorSets,
    u32                    dynamicOffsetCount,
    const u32*             pDynamicOffsets) {
  sets := pDescriptorSets[0:descriptorSetCount]
  recreate_info := new!RecreateCmdBindDescriptorSetsData(
    PipelineBindPoint: pipelineBindPoint,
    Layout: layout,
    FirstSet: firstSet
  )

  dynamic_offsets := pDynamicOffsets[0:dynamicOffsetCount]
  for i in (0 .. dynamicOffsetCount) {
    recreate_info.DynamicOffsets[i] = dynamic_offsets[i]
  }

  bind_buffer_and_descriptor_sets := CmdBindDescriptorSets()
  dynamic_offset_index := MutableU32(0)

  for i in (0 .. descriptorSetCount) {
    recreate_info.DescriptorSets[i] = sets[i]
    if sets[i] in DescriptorSets {
      set := DescriptorSets[sets[i]]
      bind_buffer_and_descriptor_sets.DescriptorSets[firstSet + i] = set
      // Since the pDynamicOffsets point into the bindings in order of
      // binding index, and then array index, we have to loop over all
      // of the BoundBuffers in order of the binding number.

      // Since `for _, k, v in set.BoundBuffers` loops over in an
      // arbitrary order, instead we loop over all bindings for the layout
      // and see if it is a buffer.
      for j in (0 .. len(set.Bindings)) {
        binding := set.Bindings[as!u32(j)]
        for k in (0 .. len(binding.BufferBinding)) {
          bufferBinding := binding.BufferBinding[as!u32(k)]

          binding_offset := switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              as!VkDeviceSize(dynamic_offsets[dynamic_offset_index.Val]) + bufferBinding.Offset
            default:
              bufferBinding.Offset
          }
          dynamic_offset_index.Val = switch binding.BindingType {
            case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
              dynamic_offset_index.Val + 1
            default:
              dynamic_offset_index.Val
          }
          bind_buffer_and_descriptor_sets.BoundBuffers[len(bind_buffer_and_descriptor_sets.BoundBuffers)] = BoundBuffer(
              Buffers[bufferBinding.Buffer], binding_offset, bufferBinding.Range)
        }
        for k in (0 .. len(binding.BufferViewBindings)) {
          buffer_view := binding.BufferViewBindings[as!u32(k)]
          buffer_view_object := BufferViews[buffer_view]
          bind_buffer_and_descriptor_sets.BoundBuffers[len(bind_buffer_and_descriptor_sets.BoundBuffers)] = BoundBuffer(
            buffer_view_object.Buffer, buffer_view_object.Offset, buffer_view_object.Range)
        }
      }
    }
  }
  addCmd(commandBuffer, recreate_info, bind_buffer_and_descriptor_sets, doCmdBindDescriptorSets)
}

@internal
class BoundBuffer {
  ref!BufferObject Buffer
  VkDeviceSize     Offset
  VkDeviceSize     Range
}

@internal
class BoundIndexBuffer {
  VkIndexType Type
  BoundBuffer BoundBuffer
}


class CmdBindIndexBuffer {
    VkBuffer        Buffer,
    VkDeviceSize    Offset,
    VkIndexType     IndexType
}

sub void doCmdBindIndexBuffer(CmdBindIndexBuffer buffer) {
  LastDrawInfo.BoundIndexBuffer = new!BoundIndexBuffer(buffer.IndexType,
    BoundBuffer(Buffers[buffer.Buffer], buffer.Offset, 0))
  Buffers[buffer.Buffer].LastBoundQueue = LastBoundQueue
}

@override
@custom
@no_replay
cmd void RecreateCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    VkIndexType     indexType) {
}

@internal class
RecreateCmdBindIndexBufferData {
   VkBuffer        Buffer,
   VkDeviceSize    Offset,
   VkIndexType     IndexType
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindIndexBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    VkIndexType     indexType) {

  addCmd(commandBuffer,
    new!RecreateCmdBindIndexBufferData(
      Buffer:buffer,
      Offset:offset,
      IndexType:indexType),
    CmdBindIndexBuffer(Buffer: buffer, Offset: offset, IndexType: indexType),
    doCmdBindIndexBuffer)
}

@internal
class CmdBindBuffer {
  map!(u32, BoundBuffer) BoundBuffers
}

sub void doCmdBindVertexBuffers(CmdBindBuffer bind) {
  for _ , k , v in bind.BoundBuffers {
    LastDrawInfo.BoundVertexBuffers[k] = v
    v.Buffer.LastBoundQueue = LastBoundQueue
  }
}

@override
@custom
@no_replay
cmd void RecreateCmdBindVertexBuffers(
    VkCommandBuffer     commandBuffer,
    u32                 firstBinding,
    u32                 bindingCount,
    const VkBuffer*     pBuffers,
    const VkDeviceSize* pOffsets) {
  read(pBuffers[0:bindingCount])
  read(pOffsets[0:bindingCount])
}

@internal class
RecreateCmdBindVertexBuffersData {
  u32                                FirstBinding,
  u32                                BindingCount,
  map!(u32, VkBuffer)                Buffers
  map!(u32, VkDeviceSize)            Offsets
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBindVertexBuffers(
    VkCommandBuffer     commandBuffer,
    u32                 firstBinding,
    u32                 bindingCount,
    const VkBuffer*     pBuffers,
    const VkDeviceSize* pOffsets) {
  recreate_data := new!RecreateCmdBindVertexBuffersData(
    FirstBinding: firstBinding,
    BindingCount: bindingCount
  )
  buffers := pBuffers[0:bindingCount]
  offsets := pOffsets[0:bindingCount]
  bindBuffer := CmdBindBuffer()
  for i in (0 .. bindingCount) {
    recreate_data.Buffers[i] = buffers[i]
    recreate_data.Offsets[i] = offsets[i]
    bindBuffer.BoundBuffers[firstBinding + i] = BoundBuffer(Buffers[buffers[i]], offsets[i],
      Buffers[buffers[i]].Info.Size - offsets[i])
  }
  addCmd(commandBuffer, recreate_data, bindBuffer, doCmdBindVertexBuffers)
}

sub void readCoherentMemory(ref!DeviceMemoryObject memory, VkDeviceSize readOffset, VkDeviceSize readSize) {
  if IsMemoryCoherent(memory) && (memory.MappedLocation != null) {
    if (as!VkDeviceSize(readOffset) >= memory.MappedOffset) && (as!VkDeviceSize(readOffset) < memory.MappedOffset + memory.MappedSize) {
      offset_in_mapped := as!u64(readOffset) - as!u64(memory.MappedOffset)
      read_size_in_mapped := switch ((as!u64(readSize) == 0xFFFFFFFFFFFFFFFF) || ((offset_in_mapped + as!u64(readSize)) > as!u64(memory.MappedSize))) {
        case true:
          memory.MappedSize -  as!VkDeviceSize(offset_in_mapped)
        case false:
          readSize
      }
      if ((offset_in_mapped + as!u64(read_size_in_mapped)) > offset_in_mapped) {
        readMappedCoherentMemory(memory.VulkanHandle, offset_in_mapped, as!size(read_size_in_mapped))
      }
    }
  }
}

sub void readCoherentMemoryInBuffer(ref!BufferObject buffer, VkDeviceSize readOffset, VkDeviceSize readSize) {
  mem := buffer.Memory
  if mem != null {
    if as!u64(readSize) == 0xFFFFFFFFFFFFFFFF {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, buffer.Info.Size - readOffset)
    } else {
      readCoherentMemory(mem, buffer.MemoryOffset + readOffset, readSize)
    }
  }
}

sub void readCoherentMemoryInImage(ref!ImageObject image) {
  mem := image.BoundMemory
  if mem != null {
    // Host access to image memory is only well-defined for images created with
    // VK_IMAGE_TILING_LINEAR tiling and for image subresources of those images
    // which are currently in either VK_IMAGE_LAYOUT_PREINITIALIZED or
    // VK_IMAGE_LAYOUT_GENERAL layout.
    // TODO: Complete the layout tracking logic then update this if statement
    // to check the layout of the underlying image.
    if image.Info.Tiling == VK_IMAGE_TILING_LINEAR {
      readCoherentMemory(mem, image.BoundMemoryOffset, inferImageSize(image))
    }
  }
}

sub void readCoherentMemoryInCurrentPipelineBoundVertexBuffers(u32 vertexCount, u32 instanceCount, u32 firstVertex, u32 firstInstance) {
  for _, _, vertex_binding in LastDrawInfo.GraphicsPipeline.VertexInputState.BindingDescriptions {
    if vertex_binding.binding in LastDrawInfo.BoundVertexBuffers {
      bound_vertex_buffer := LastDrawInfo.BoundVertexBuffers[vertex_binding.binding]
      backing_buf := bound_vertex_buffer.Buffer
      if ((backing_buf.Memory != null) && IsMemoryCoherent(backing_buf.Memory)) {
        start_vertex := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            firstVertex
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            firstInstance
        }
        num_vertices := switch vertex_binding.inputRate {
          case VK_VERTEX_INPUT_RATE_VERTEX:
            vertexCount
          case VK_VERTEX_INPUT_RATE_INSTANCE:
            instanceCount
        }
        start_offset := bound_vertex_buffer.Offset + as!VkDeviceSize(start_vertex * vertex_binding.stride)
        num := switch vertexCount == 0xFFFFFFFF {
          case true:
            backing_buf.Info.Size - start_offset
          case false:
            as!VkDeviceSize(num_vertices * vertex_binding.stride)
        }
        readCoherentMemoryInBuffer(backing_buf, start_offset, num)
      }
    }
  }
}

@internal class CmdDraw {
  u32 VertexCount
  u32 InstanceCount
  u32 FirstVertex
  u32 FirstInstance
}

@internal class RecreateCmdDrawData {
  u32 VertexCount
  u32 InstanceCount
  u32 FirstVertex
  u32 FirstInstance
}

sub void doCmdDraw(CmdDraw draw) {
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(draw.VertexCount, draw.InstanceCount, draw.FirstVertex, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  LastDrawInfo.CommandParameters.Draw = new!CmdDraw(
      draw.VertexCount, draw.InstanceCount, draw.FirstVertex, draw.FirstInstance)
}

@override
@custom
@no_replay
cmd void RecreateCmdDraw(
    VkCommandBuffer commandBuffer,
    u32             vertexCount,
    u32             instanceCount,
    u32             firstVertex,
    u32             firstInstance) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDraw(
    VkCommandBuffer commandBuffer,
    u32             vertexCount,
    u32             instanceCount,
    u32             firstVertex,
    u32             firstInstance) {
  addCmd(commandBuffer,
    new!RecreateCmdDrawData(vertexCount, instanceCount, firstVertex, firstInstance),
    CmdDraw(vertexCount, instanceCount, firstVertex, firstInstance), doCmdDraw)
}

@internal class CmdDrawIndexed {
  u32 IndexCount
  u32 InstanceCount
  u32 FirstIndex
  s32 VertexOffset
  u32 FirstInstance
}

sub void doCmdDrawIndexed(CmdDrawIndexed draw) {
  // Loop through the index buffer, and find the low and high
  // vertices. Then read all of the applicable vertex buffers.
  indexBuffer := LastDrawInfo.BoundIndexBuffer.BoundBuffer.Buffer
  indexSize := switch (LastDrawInfo.BoundIndexBuffer.Type) {
    case VK_INDEX_TYPE_UINT16:
      as!VkDeviceSize(2)
    case VK_INDEX_TYPE_UINT32:
      as!VkDeviceSize(4)
  }

  numBytes := as!VkDeviceSize(draw.IndexCount) * indexSize
  startOffset := LastDrawInfo.BoundIndexBuffer.BoundBuffer.Offset + (indexSize * as!VkDeviceSize(draw.FirstIndex))

  // Read the data of the index buffer if the index buffer is backed with coherent memory.
  readCoherentMemoryInBuffer(indexBuffer, startOffset, numBytes)
  // Read the whole vertex buffer if a buffer is backed with coherent memory.
  readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, draw.InstanceCount, 0, draw.FirstInstance)
  clearLastDrawInfoDrawCommandParameters()
  LastDrawInfo.CommandParameters.DrawIndexed = new!CmdDrawIndexed(
      draw.IndexCount, draw.InstanceCount, draw.FirstIndex, draw.VertexOffset,
      draw.FirstInstance)
}

@override
@custom
@no_replay
cmd void RecreateCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    u32             indexCount,
    u32             instanceCount,
    u32             firstIndex,
    s32             vertexOffset,
    u32             firstInstance) {
}

@internal class
RecreateCmdDrawIndexedData {
    u32             IndexCount,
    u32             InstanceCount,
    u32             FirstIndex,
    s32             VertexOffset,
    u32             FirstInstance
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexed(
    VkCommandBuffer commandBuffer,
    u32             indexCount,
    u32             instanceCount,
    u32             firstIndex,
    s32             vertexOffset,
    u32             firstInstance) {
  addCmd(commandBuffer, new!RecreateCmdDrawIndexedData(
    IndexCount: indexCount,
    InstanceCount: instanceCount,
    FirstIndex: firstIndex,
    VertexOffset: vertexOffset,
    FirstInstance: firstInstance
  ), CmdDrawIndexed(indexCount, instanceCount, firstIndex, vertexOffset, firstInstance), doCmdDrawIndexed)
}

@override
@custom
@no_replay
cmd void RecreateCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
}

@internal class
RecreateCmdDrawIndirectData {
    VkBuffer        Buffer
    VkDeviceSize    Offset
    u32             DrawCount
    u32             Stride
}

@internal class CmdDrawIndirect {
  VkBuffer Buffer
  VkDeviceSize Offset
  u32 DrawCount
  u32 Stride
}

sub void doCmdDrawIndirect(CmdDrawIndirect draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through all the vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    LastDrawInfo.CommandParameters.DrawIndirect = new!CmdDrawIndirect(
        draw.Buffer, draw.Offset, draw.DrawCount, draw.Stride)
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  addCmd(commandBuffer,
    new!RecreateCmdDrawIndirectData(buffer, offset, drawCount, stride),
    CmdDrawIndirect(buffer, offset, drawCount, stride), doCmdDrawIndirect)
}

@override
@custom
@no_replay
cmd void RecreateCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
}

@internal class
RecreateCmdDrawIndexedIndirectData {
    VkBuffer        Buffer
    VkDeviceSize    Offset
    u32             DrawCount
    u32             Stride
}

@internal class CmdDrawIndexedIndirect {
  VkBuffer Buffer
  VkDeviceSize Offset
  u32 DrawCount
  u32 Stride
}

sub void doCmdDrawIndexedIndirect(CmdDrawIndexedIndirect draw) {
  if draw.DrawCount > 0 {
    command_size := as!VkDeviceSize(16)
    indirect_buffer_read_size := as!VkDeviceSize((draw.DrawCount - 1) * draw.Stride) + command_size
    readCoherentMemoryInBuffer(Buffers[draw.Buffer], draw.Offset, indirect_buffer_read_size)
    // Read through the whole index buffer if it uses coherent menory.
    indexBuffer := LastDrawInfo.BoundIndexBuffer.BoundBuffer.Buffer
    readCoherentMemoryInBuffer(indexBuffer, 0, indexBuffer.Info.Size)
    // Read through all the coherent memory vertex buffers, as we cannot assume the buffer given to indirect draw is host
    readCoherentMemoryInCurrentPipelineBoundVertexBuffers(0xFFFFFFFF, 0xFFFFFFFF, 0, 0)
    clearLastDrawInfoDrawCommandParameters()
    LastDrawInfo.CommandParameters.DrawIndexedIndirect = new!CmdDrawIndexedIndirect(
        draw.Buffer, draw.Offset, draw.DrawCount, draw.Stride)
  }
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDrawIndexedIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset,
    u32             drawCount,
    u32             stride) {
  addCmd(commandBuffer,
    new!RecreateCmdDrawIndexedIndirectData(buffer, offset, drawCount, stride),
    CmdDrawIndexedIndirect(buffer, offset, drawCount, stride), doCmdDrawIndexedIndirect)
}

@override
@custom
@no_replay
cmd void RecreateCmdDispatch(
    VkCommandBuffer commandBuffer,
    u32             groupCountX,
    u32             groupCountY,
    u32             groupCountZ) {
}

@internal class
RecreateCmdDispatchData {
    u32             GroupCountX,
    u32             GroupCountY,
    u32             GroupCountZ
}

sub void doCmdDispatch(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatch(
    VkCommandBuffer commandBuffer,
    u32             groupCountX,
    u32             groupCountY,
    u32             groupCountZ) {
  addCmd(commandBuffer,
    new!RecreateCmdDispatchData(groupCountX, groupCountY, groupCountZ), as!u32(0), doCmdDispatch)
}

@internal class CmdDispatchIndirect {
  VkBuffer Buffer
  VkDeviceSize Offset
}

sub void doCmdDispatchIndirect(CmdDispatchIndirect dispatch) {
  command_size := as!VkDeviceSize(12)
  readCoherentMemoryInBuffer(Buffers[dispatch.Buffer], dispatch.Offset, command_size)
}

@internal
class RecreateCmdDispatchIndirectData {
  VkBuffer Buffer,
  VkDeviceSize Offset
}

@override
@custom
@no_replay
cmd void RecreateCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdDispatchIndirect(
    VkCommandBuffer commandBuffer,
    VkBuffer        buffer,
    VkDeviceSize    offset) {
  addCmd(commandBuffer,
      new!RecreateCmdDispatchIndirectData(buffer, offset),
      CmdDispatchIndirect(buffer, offset),
      doCmdDispatchIndirect)
}


@internal class CmdCopyBuffer {
  VkBuffer                SrcBuffer
  VkBuffer                DstBuffer
  map!(u32, VkBufferCopy) CopyRegions
}

sub void doCmdCopyBuffer(CmdCopyBuffer buffer) {
  sourceBuffer := Buffers[buffer.SrcBuffer]
  destBuffer := Buffers[buffer.DstBuffer]
  for _ , _ , region in buffer.CopyRegions {
    srcMemoryOffset := sourceBuffer.MemoryOffset + region.srcOffset
    dstMemoryOffset := destBuffer.MemoryOffset + region.dstOffset
    readCoherentMemoryInBuffer(sourceBuffer, region.srcOffset, region.size)
    copy(destBuffer.Memory.Data[dstMemoryOffset:dstMemoryOffset + region.size],
      sourceBuffer.Memory.Data[srcMemoryOffset:srcMemoryOffset + region.size])
  }
}

@override
@custom
@no_replay
cmd void RecreateCmdCopyBuffer(
    VkCommandBuffer     commandBuffer,
    VkBuffer            srcBuffer,
    VkBuffer            dstBuffer,
    u32                 regionCount,
    const VkBufferCopy* pRegions) {
  read(pRegions[0:regionCount])
}

@internal class
RecreateCmdCopyBufferData {
  VkBuffer                           SrcBuffer,
  VkBuffer                           DstBuffer,
  map!(u32, VkBufferCopy)            CopyRegions
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBuffer(
    VkCommandBuffer     commandBuffer,
    VkBuffer            srcBuffer,
    VkBuffer            dstBuffer,
    u32                 regionCount,
    const VkBufferCopy* pRegions) {
  recreate_data := new!RecreateCmdCopyBufferData(
    SrcBuffer: srcBuffer,
    DstBuffer: dstBuffer
  )
  copy := CmdCopyBuffer(srcBuffer, dstBuffer)
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    copy.CopyRegions[i] = regions[i]
    recreate_data.CopyRegions[i] = regions[i]
  }
  addCmd(commandBuffer, recreate_data, copy, doCmdCopyBuffer)
}

@internal
class CmdCopyImage {
  VkImage                SrcImage
  VkImage                DstImage
  map!(u64, VkImageCopy) Regions
}

sub void doCmdCopyImage(CmdCopyImage args) {
  srcImageObject := Images[args.SrcImage]
  dstImageObject := Images[args.DstImage]

  // The following read on coherent memory of the source image does not affect the data in imageLevel.Data, as they are different memory spaces.
  // But such a read is necessary if the backing memory of the source image is coherent, as we need the read observations on all memory changes
  // in order to replay correctly. However, as the UI's texture data comes from imageLevel.Data, just using the following call will not bring
  // the changes in coherent memory to the UI's texture view.
  readCoherentMemoryInImage(srcImageObject)

  srcFormat := srcImageObject.Info.Format
  srcElementAndTexelBlockSize := getElementAndTexelBlockSize(srcFormat)
  dstFormat := dstImageObject.Info.Format
  dstElementAndTexelBlockSize := getElementAndTexelBlockSize(dstFormat)
  for r in (0 .. len(args.Regions)) {
    // TODO: (qining) Handle the apsect mask
    region := args.Regions[as!u64(r)]
    srcBaseLayer := region.srcSubresource.baseArrayLayer
    dstBaseLayer := region.srcSubresource.baseArrayLayer
    srcMipLevel := region.srcSubresource.mipLevel
    dstMipLevel := region.dstSubresource.mipLevel

    srcElementSize := as!u64(srcElementAndTexelBlockSize.ElementSize)
    srcBlockWidth := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Width)
    srcBlockHeight := as!u64(srcElementAndTexelBlockSize.TexelBlockSize.Height)
    dstElementSize := as!u64(dstElementAndTexelBlockSize.ElementSize)
    dstBlockWidth := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Width)
    dstBlockHeight := as!u64(dstElementAndTexelBlockSize.TexelBlockSize.Height)

    srcXStartInBlocks := as!u64(as!u64(region.srcOffset.x) / srcBlockWidth)
    srcYStartInBlocks := as!u64(as!u64(region.srcOffset.y) / srcBlockHeight)
    srcZStart := as!u64(region.srcOffset.z)
    dstXStartInBlocks := as!u64(as!u64(region.dstOffset.x) / dstBlockWidth)
    dstYStartInBlocks := as!u64(as!u64(region.dstOffset.y) / dstBlockHeight)
    dstZStart := as!u64(region.dstOffset.z)

    extentXInBlocks := roundUpTo(region.extent.Width, as!u32(srcBlockWidth))
    extentYInBlocks := roundUpTo(region.extent.Height, as!u32(srcBlockHeight))
    extentZ := region.extent.Depth

    for l in (0 .. region.srcSubresource.layerCount) {
      srcImageLevel := srcImageObject.Layers[srcBaseLayer + l].Levels[srcMipLevel]
      dstImageLevel := dstImageObject.Layers[dstBaseLayer + l].Levels[dstMipLevel]

      srcImageLevelWidthInBlocks := as!u64(roundUpTo(srcImageLevel.Width, as!u32(srcBlockWidth)))
      srcImageLevelHeightInBlocks := as!u64(roundUpTo(srcImageLevel.Height, as!u32(srcBlockHeight)))
      dstImageLevelWidthInBlocks := as!u64(roundUpTo(dstImageLevel.Width, as!u32(dstBlockWidth)))
      dstImageLevelHeightInBlocks := as!u64(roundUpTo(dstImageLevel.Height, as!u32(dstBlockHeight)))

      srcData := srcImageLevel.Data
      dstData := dstImageLevel.Data

      for z in (0 .. extentZ) {
        for y in (0 .. extentYInBlocks) {
          copySize := as!u64(extentXInBlocks) * srcElementSize
          dstY := dstYStartInBlocks + as!u64(y)
          dstZ := dstZStart + as!u64(z)
          srcY := srcYStartInBlocks + as!u64(y)
          srcZ := srcZStart + as!u64(z)
          dstStart := ((((dstZ * dstImageLevelHeightInBlocks) + dstY) * dstImageLevelWidthInBlocks) + dstXStartInBlocks) * dstElementSize
          srcStart := ((((srcZ * srcImageLevelHeightInBlocks) + srcY) * srcImageLevelWidthInBlocks) + srcXStartInBlocks) * srcElementSize
          copy(dstData[dstStart:dstStart + copySize], srcData[srcStart:srcStart + copySize])
        }
      }
    }
  }
}

@internal
class RecreateCmdCopyImageData{
  VkImage            SrcImage
  VkImageLayout      SrcImageLayout
  VkImage            DstImage
  VkImageLayout      DstImageLayout
  map!(u32, VkImageCopy) Regions
}

@override
@custom
@no_replay
cmd void RecreateCmdCopyImage(
    VkCommandBuffer commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageCopy* pRegions) {
  read(pRegions[0:regionCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageCopy* pRegions) {
  recreate_data := new!RecreateCmdCopyImageData(
    SrcImage: srcImage,
    SrcImageLayout: srcImageLayout,
    DstImage: dstImage,
    DstImageLayout: dstImageLayout
  )
  regions := pRegions[0:regionCount]
  copyArgs := CmdCopyImage(srcImage, dstImage)
  for i in (0 .. regionCount) {
    copyArgs.Regions[as!u64(i)] = regions[i]
    recreate_data.Regions[as!u32(i)] = regions[i]
  }
  addCmd(commandBuffer, recreate_data, copyArgs, doCmdCopyImage)
}

@internal
class RecreateCmdBlitImageData{
  VkImage                 SrcImage
  VkImageLayout           SrcImageLayout
  VkImage                 DstImage
  VkImageLayout           DstImageLayout
  map!(u32, VkImageBlit)  Regions
  VkFilter                Filter
}

@override
@custom
@no_replay
cmd void RecreateCmdBlitImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageBlit* pRegions,
    VkFilter           filter) {
  read(pRegions[0:regionCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBlitImage(
    VkCommandBuffer    commandBuffer,
    VkImage            srcImage,
    VkImageLayout      srcImageLayout,
    VkImage            dstImage,
    VkImageLayout      dstImageLayout,
    u32                regionCount,
    const VkImageBlit* pRegions,
    VkFilter           filter) {
  recreate_data := new!RecreateCmdBlitImageData(
    SrcImage: srcImage,
    SrcImageLayout: srcImageLayout,
    DstImage: dstImage,
    DstImageLayout: dstImageLayout,
    Filter: filter
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    recreate_data.Regions[as!u32(i)] = regions[i]
  }
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

@internal
class TexelBlockSizePair {
  u32 Width
  u32 Height
}

@internal
class ElementAndTexelBlockSize {
  u32                ElementSize
  TexelBlockSizePair TexelBlockSize
}

// This should roughly correspond to "Compatible formats" in the Vulkan spec
sub ElementAndTexelBlockSize getElementAndTexelBlockSize(VkFormat format) {
  return switch (format) {
    case VK_FORMAT_R4G4_UNORM_PACK8,
         VK_FORMAT_R8_UNORM,
         VK_FORMAT_R8_SNORM,
         VK_FORMAT_R8_USCALED,
         VK_FORMAT_R8_SSCALED,
         VK_FORMAT_R8_UINT,
         VK_FORMAT_R8_SINT,
         VK_FORMAT_R8_SRGB:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R4G4B4A4_UNORM_PACK16,
         VK_FORMAT_B4G4R4A4_UNORM_PACK16,
         VK_FORMAT_R5G6B5_UNORM_PACK16,
         VK_FORMAT_B5G6R5_UNORM_PACK16,
         VK_FORMAT_R5G5B5A1_UNORM_PACK16,
         VK_FORMAT_B5G5R5A1_UNORM_PACK16,
         VK_FORMAT_A1R5G5B5_UNORM_PACK16,
         VK_FORMAT_R8G8_UNORM,
         VK_FORMAT_R8G8_SNORM,
         VK_FORMAT_R8G8_USCALED,
         VK_FORMAT_R8G8_SSCALED,
         VK_FORMAT_R8G8_UINT,
         VK_FORMAT_R8G8_SINT,
         VK_FORMAT_R8G8_SRGB,
         VK_FORMAT_R16_UNORM,
         VK_FORMAT_R16_SNORM,
         VK_FORMAT_R16_USCALED,
         VK_FORMAT_R16_SSCALED,
         VK_FORMAT_R16_UINT,
         VK_FORMAT_R16_SINT,
         VK_FORMAT_R16_SFLOAT:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8_UNORM,
         VK_FORMAT_R8G8B8_SNORM,
         VK_FORMAT_R8G8B8_USCALED,
         VK_FORMAT_R8G8B8_SSCALED,
         VK_FORMAT_R8G8B8_UINT,
         VK_FORMAT_R8G8B8_SINT,
         VK_FORMAT_R8G8B8_SRGB,
         VK_FORMAT_B8G8R8_UNORM,
         VK_FORMAT_B8G8R8_SNORM,
         VK_FORMAT_B8G8R8_USCALED,
         VK_FORMAT_B8G8R8_SSCALED,
         VK_FORMAT_B8G8R8_UINT,
         VK_FORMAT_B8G8R8_SINT,
         VK_FORMAT_B8G8R8_SRGB:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R8G8B8A8_UNORM,
         VK_FORMAT_R8G8B8A8_SNORM,
         VK_FORMAT_R8G8B8A8_USCALED,
         VK_FORMAT_R8G8B8A8_SSCALED,
         VK_FORMAT_R8G8B8A8_UINT,
         VK_FORMAT_R8G8B8A8_SINT,
         VK_FORMAT_R8G8B8A8_SRGB,
         VK_FORMAT_B8G8R8A8_UNORM,
         VK_FORMAT_B8G8R8A8_SNORM,
         VK_FORMAT_B8G8R8A8_USCALED,
         VK_FORMAT_B8G8R8A8_SSCALED,
         VK_FORMAT_B8G8R8A8_UINT,
         VK_FORMAT_B8G8R8A8_SINT,
         VK_FORMAT_B8G8R8A8_SRGB,
         VK_FORMAT_A8B8G8R8_UNORM_PACK32,
         VK_FORMAT_A8B8G8R8_SNORM_PACK32,
         VK_FORMAT_A8B8G8R8_USCALED_PACK32,
         VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
         VK_FORMAT_A8B8G8R8_UINT_PACK32,
         VK_FORMAT_A8B8G8R8_SINT_PACK32,
         VK_FORMAT_A8B8G8R8_SRGB_PACK32,
         VK_FORMAT_A2R10G10B10_UNORM_PACK32,
         VK_FORMAT_A2R10G10B10_SNORM_PACK32,
         VK_FORMAT_A2R10G10B10_USCALED_PACK32,
         VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
         VK_FORMAT_A2R10G10B10_UINT_PACK32,
         VK_FORMAT_A2R10G10B10_SINT_PACK32,
         VK_FORMAT_A2B10G10R10_UNORM_PACK32,
         VK_FORMAT_A2B10G10R10_SNORM_PACK32,
         VK_FORMAT_A2B10G10R10_USCALED_PACK32,
         VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
         VK_FORMAT_A2B10G10R10_UINT_PACK32,
         VK_FORMAT_A2B10G10R10_SINT_PACK32,
         VK_FORMAT_R16G16_UNORM,
         VK_FORMAT_R16G16_SNORM,
         VK_FORMAT_R16G16_USCALED,
         VK_FORMAT_R16G16_SSCALED,
         VK_FORMAT_R16G16_UINT,
         VK_FORMAT_R16G16_SINT,
         VK_FORMAT_R16G16_SFLOAT,
         VK_FORMAT_R32_UINT,
         VK_FORMAT_R32_SINT,
         VK_FORMAT_R32_SFLOAT,
         VK_FORMAT_B10G11R11_UFLOAT_PACK32,
         VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16_UNORM,
         VK_FORMAT_R16G16B16_SNORM,
         VK_FORMAT_R16G16B16_USCALED,
         VK_FORMAT_R16G16B16_SSCALED,
         VK_FORMAT_R16G16B16_UINT,
         VK_FORMAT_R16G16B16_SINT,
         VK_FORMAT_R16G16B16_SFLOAT:
      ElementAndTexelBlockSize(6, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R16G16B16A16_UNORM,
         VK_FORMAT_R16G16B16A16_SNORM,
         VK_FORMAT_R16G16B16A16_USCALED,
         VK_FORMAT_R16G16B16A16_SSCALED,
         VK_FORMAT_R16G16B16A16_UINT,
         VK_FORMAT_R16G16B16A16_SINT,
         VK_FORMAT_R16G16B16A16_SFLOAT,
         VK_FORMAT_R32G32_UINT,
         VK_FORMAT_R32G32_SINT,
         VK_FORMAT_R32G32_SFLOAT,
         VK_FORMAT_R64_UINT,
         VK_FORMAT_R64_SINT,
         VK_FORMAT_R64_SFLOAT:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32_UINT,
         VK_FORMAT_R32G32B32_SINT,
         VK_FORMAT_R32G32B32_SFLOAT:
      ElementAndTexelBlockSize(12, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R32G32B32A32_UINT,
         VK_FORMAT_R32G32B32A32_SINT,
         VK_FORMAT_R32G32B32A32_SFLOAT,
         VK_FORMAT_R64G64_UINT,
         VK_FORMAT_R64G64_SINT,
         VK_FORMAT_R64G64_SFLOAT:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64_UINT,
         VK_FORMAT_R64G64B64_SINT,
         VK_FORMAT_R64G64B64_SFLOAT:
      ElementAndTexelBlockSize(24, TexelBlockSizePair(1, 1))
    case VK_FORMAT_R64G64B64A64_UINT,
         VK_FORMAT_R64G64B64A64_SINT,
         VK_FORMAT_R64G64B64A64_SFLOAT:
      ElementAndTexelBlockSize(32, TexelBlockSizePair(1, 1))
    case VK_FORMAT_BC1_RGB_UNORM_BLOCK,
         VK_FORMAT_BC1_RGB_SRGB_BLOCK,
         VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
         VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC2_UNORM_BLOCK,
         VK_FORMAT_BC2_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC3_UNORM_BLOCK,
         VK_FORMAT_BC3_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC4_UNORM_BLOCK,
         VK_FORMAT_BC4_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC5_UNORM_BLOCK,
         VK_FORMAT_BC5_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC6H_UFLOAT_BLOCK,
         VK_FORMAT_BC6H_SFLOAT_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_BC7_UNORM_BLOCK,
         VK_FORMAT_BC7_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
         VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
         VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
         VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
         VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11_UNORM_BLOCK,
         VK_FORMAT_EAC_R11_SNORM_BLOCK:
      ElementAndTexelBlockSize(8, TexelBlockSizePair(4, 4))
    case VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
         VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
         VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(4, 4))
    case VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
         VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 4))
    case VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
         VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(5, 5))
    case VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
         VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 5))
    case VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
         VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(6, 6))
    case VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
         VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 5))
    case VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
         VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 6))
    case VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
         VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(8, 8))
    case VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
         VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 5))
    case VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
         VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 6))
    case VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
         VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 8))
    case VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
         VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(10, 10))
    case VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
         VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 10))
    case VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
         VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
      ElementAndTexelBlockSize(16, TexelBlockSizePair(12, 12))
    case VK_FORMAT_D16_UNORM:
      ElementAndTexelBlockSize(2, TexelBlockSizePair(1, 1))
    case VK_FORMAT_X8_D24_UNORM_PACK32:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
    case VK_FORMAT_S8_UINT:
      ElementAndTexelBlockSize(1, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D16_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D24_UNORM_S8_UINT:
      ElementAndTexelBlockSize(3, TexelBlockSizePair(1, 1))
    case VK_FORMAT_D32_SFLOAT_S8_UINT:
      ElementAndTexelBlockSize(5, TexelBlockSizePair(1, 1))
    default:
      ElementAndTexelBlockSize(4, TexelBlockSizePair(1, 1))
  }
}

@internal
class RowLengthAndImageHeight {
  u32 RowLength
  u32 ImageHeight
}

sub RowLengthAndImageHeight getRowLengthAndImageHeight(VkBufferImageCopy region) {
  rowLength := switch region.bufferRowLength == 0 {
    case true:  region.imageExtent.Width
    case false: region.bufferRowLength
  }
  imageHeight := switch region.bufferImageHeight == 0 {
    case true:  region.imageExtent.Height
    case false: region.bufferImageHeight
  }
  return RowLengthAndImageHeight(rowLength, imageHeight)
}

@interal
class MutableVkDeviceSize {
  VkDeviceSize Val
}

sub VkDeviceSize inferImageSize(ref!ImageObject img) {
  img_info := img.Info
  img_size := MutableVkDeviceSize(0)
  for m in (0 .. img_info.MipLevels) {
    img_size.Val += inferImageLevelSize(img, m)
  }
  return img_size.Val
}

sub VkDeviceSize inferImageLevelSize(ref!ImageObject img, u32 level) {
  img_info := img.Info
  level_size := MutableVkDeviceSize(0)
  if level < img_info.MipLevels {
    block_info := getElementAndTexelBlockSize(img_info.Format)
    width := getMipSize(img_info.Extent.Width, level)
    height := getMipSize(img_info.Extent.Height, level)
    depth := getMipSize(img_info.Extent.Depth, level)
    width_in_blocks := roundUpTo(width, block_info.TexelBlockSize.Width)
    height_in_blocks := roundUpTo(height, block_info.TexelBlockSize.Height)
    level_size.Val += as!VkDeviceSize(width_in_blocks * height_in_blocks * depth * block_info.ElementSize * img_info.ArrayLayers)
  }
  return level_size.Val
}

@internal
class CmdCopyBufferToImage {
  VkBuffer                     SrcBuffer
  VkImage                      DstImage
  map!(u64, VkBufferImageCopy) Regions
}

sub void doCmdCopyBufferToImage(CmdCopyBufferToImage args) {
  bufferObject := Buffers[args.SrcBuffer]
  srcData := bufferObject.Memory.Data
  imageObject := Images[args.DstImage]
  format := imageObject.Info.Format
  elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
  // Iterate through regions
  for i in (0 .. len(args.Regions)) {
    region := args.Regions[as!u64(i)]
    rowLengthAndImageHeight := getRowLengthAndImageHeight(region)
    rowLength := as!u64(rowLengthAndImageHeight.RowLength / elementAndTexelBlockSize.TexelBlockSize.Width)
    imageHeight := as!u64(rowLengthAndImageHeight.ImageHeight / elementAndTexelBlockSize.TexelBlockSize.Height)
    elementSize := as!u64(elementAndTexelBlockSize.ElementSize)
    layerSize := rowLength * imageHeight * elementSize
    zStart := as!u64(region.imageOffset.z)
    zEnd := zStart + as!u64(region.imageExtent.Depth)
    yStart := as!u64(as!u32(region.imageOffset.y) / elementAndTexelBlockSize.TexelBlockSize.Height)
    yEnd := yStart + as!u64(region.imageExtent.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
    xStart := as!u64(as!u32(region.imageOffset.x) / elementAndTexelBlockSize.TexelBlockSize.Width)
    xEnd := xStart + as!u64(region.imageExtent.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
    // When multiple layers are specified in the buffer image copy region,
    // Vulkan assumes the data of all the layers are placed continuously in
    // the source buffer memory.
    // TODO: (qining) Handle aspect mask
    for j in (0 .. region.imageSubresource.layerCount) {
      layerIndex := region.imageSubresource.baseArrayLayer + j
      bufferLayerOffset := as!u64(j) * layerSize
      imageLevel := imageObject.Layers[layerIndex].Levels[region.imageSubresource.mipLevel]
      imageLevelWidthInBlocks := as!u64(imageLevel.Width / elementAndTexelBlockSize.TexelBlockSize.Width)
      imageLevelHeightInBlocks := as!u64(imageLevel.Height / elementAndTexelBlockSize.TexelBlockSize.Height)
      dstData := imageLevel.Data
      // Iterate through depths and rows to copy
      for z in (zStart .. zEnd) {
        for y in (yStart .. yEnd) {
          copySize := (xEnd - xStart) * elementSize
          dstStart := ((((z * imageLevelHeightInBlocks) + y) * imageLevelWidthInBlocks) + xStart) * elementSize
          dstEnd := dstStart + copySize
          zInExtent := z - zStart
          yInExtent := y - yStart
          rowStartInExtent := (((zInExtent * imageHeight) + yInExtent) * rowLength) * elementSize
          srcStart := as!u64(bufferObject.MemoryOffset) + as!u64(region.bufferOffset) + bufferLayerOffset + rowStartInExtent
          srcEnd := srcStart + copySize
          readCoherentMemoryInBuffer(bufferObject, region.bufferOffset + as!VkDeviceSize(bufferLayerOffset + rowStartInExtent), as!VkDeviceSize(copySize))
          copy(dstData[dstStart:dstEnd], srcData[srcStart:srcEnd])
        }
      }
    }
  }
}

@internal
class RecreateCopyBufferToImageData {
  VkBuffer      SrcBuffer
  VkImage       DstImage
  VkImageLayout Layout
  map!(u64, VkBufferImageCopy) Regions
}

@override
@custom
@no_replay
cmd void RecreateCmdCopyBufferToImage(
    VkCommandBuffer          commandBuffer,
    VkBuffer                 srcBuffer,
    VkImage                  dstImage,
    VkImageLayout            dstImageLayout,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  read(pRegions[0:regionCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyBufferToImage(
    VkCommandBuffer          commandBuffer,
    VkBuffer                 srcBuffer,
    VkImage                  dstImage,
    VkImageLayout            dstImageLayout,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  regions := pRegions[0:regionCount]
  read(regions)
  copyArgs := CmdCopyBufferToImage(srcBuffer, dstImage)
  recreateArgs := new!RecreateCopyBufferToImageData(srcBuffer, dstImage, dstImageLayout)
  for i in (0 .. regionCount) {
    copyArgs.Regions[as!u64(i)] = regions[i]
    recreateArgs.Regions[as!u64(i)] = regions[i]
  }
  addCmd(commandBuffer, recreateArgs, copyArgs, doCmdCopyBufferToImage)
}

@internal
class RecreateCopyImageToBufferData {
  VkImage                       SrcImage
  VkImageLayout                 SrcImageLayout
  VkBuffer                      DstBuffer
  map!(u32, VkBufferImageCopy)  Regions
}

@override
@custom
@no_replay
cmd void RecreateCmdCopyImageToBuffer(
    VkCommandBuffer          commandBuffer,
    VkImage                  srcImage,
    VkImageLayout            srcImageLayout,
    VkBuffer                 dstBuffer,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  read(pRegions[0:regionCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyImageToBuffer(
    VkCommandBuffer          commandBuffer,
    VkImage                  srcImage,
    VkImageLayout            srcImageLayout,
    VkBuffer                 dstBuffer,
    u32                      regionCount,
    const VkBufferImageCopy* pRegions) {
  regions := pRegions[0:regionCount]
  recreate_data := new!RecreateCopyImageToBufferData(
      SrcImage: srcImage,
      SrcImageLayout: srcImageLayout,
      DstBuffer: dstBuffer,
  )
  for i in (0 .. regionCount) {
    recreate_data.Regions[as!u32(i)] = regions[i]
  }
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

sub void doCmdUpdateBuffer(VkBuffer args) {
  Buffers[args].LastBoundQueue = LastBoundQueue
}

@internal class RecreateCmdUpdateBufferData {
  VkBuffer        dstBuffer
  VkDeviceSize    dstOffset
  VkDeviceSize    dataSize
}

@override
@custom
@no_replay
cmd void RecreateCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    dataSize,
    const void*     pData) {
  read(as!u8*(pData)[0:dataSize])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdUpdateBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    dataSize,
    const void*     pData) {
  read(as!u8*(pData)[0:dataSize])
  addCmd(commandBuffer, createUpdateBufferData(
      dstBuffer,
      dstOffset,
      dataSize,
      pData),
    dstBuffer,
    doCmdUpdateBuffer)
}

@internal
class RecreateCmdFillBufferData{
  VkBuffer Buffer
  VkDeviceSize DstBuffer
  VkDeviceSize Size
  u32 Data
}

@override
@custom
@no_replay
cmd void RecreateCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    size,
    u32             data) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdFillBuffer(
    VkCommandBuffer commandBuffer,
    VkBuffer        dstBuffer,
    VkDeviceSize    dstOffset,
    VkDeviceSize    size,
    u32             data) {
  addCmd(commandBuffer,
    new!RecreateCmdFillBufferData(
      dstBuffer,
      dstOffset,
      size,
      data), Unimplemented(), doCmdNop)
}

@internal
class RecreateCmdClearColorImageData{
  VkImage Image
  VkImageLayout ImageLayout
  VkClearColorValue Color
  map!(u32, VkImageSubresourceRange) Ranges
}

@override
@custom
@no_replay
cmd void RecreateCmdClearColorImage(
    VkCommandBuffer                commandBuffer,
    VkImage                        image,
    VkImageLayout                  imageLayout,
    const VkClearColorValue*       pColor,
    u32                            rangeCount,
    const VkImageSubresourceRange* pRanges) {
  _ = pColor[0]
  read(pRanges[0:rangeCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearColorImage(
    VkCommandBuffer                commandBuffer,
    VkImage                        image,
    VkImageLayout                  imageLayout,
    const VkClearColorValue*       pColor,
    u32                            rangeCount,
    const VkImageSubresourceRange* pRanges) {
  color := pColor[0]
  ranges := pRanges[0:rangeCount]
  recreate_data := new!RecreateCmdClearColorImageData(
      Image: image,
      ImageLayout: imageLayout,
      Color: color,
  )
  for i in (0 .. rangeCount) {
    recreate_data.Ranges[as!u32(i)] = ranges[i]
  }
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

@internal
class RecreateCmdClearDepthStencilImageData{
  VkImage Image
  VkImageLayout ImageLayout
  VkClearDepthStencilValue DepthStencil
  map!(u32, VkImageSubresourceRange) Ranges
}

@override
@custom
@no_replay
cmd void RecreateCmdClearDepthStencilImage(
    VkCommandBuffer                 commandBuffer,
    VkImage                         image,
    VkImageLayout                   imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    u32                             rangeCount,
    const VkImageSubresourceRange*  pRanges) {
  _ = pDepthStencil[0]
  read(pRanges[0:rangeCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearDepthStencilImage(
    VkCommandBuffer                 commandBuffer,
    VkImage                         image,
    VkImageLayout                   imageLayout,
    const VkClearDepthStencilValue* pDepthStencil,
    u32                             rangeCount,
    const VkImageSubresourceRange*  pRanges) {
  depthStencil := pDepthStencil[0]
  ranges := pRanges[0:rangeCount]
  recreate_data := new!RecreateCmdClearDepthStencilImageData(
      Image: image,
      ImageLayout: imageLayout,
      DepthStencil: depthStencil,
  )
  for i in (0 .. rangeCount) {
    recreate_data.Ranges[as!u32(i)] = ranges[i]
  }
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

@internal
class RecreateCmdClearAttachmentsData{
  map!(u32, VkClearAttachment) Attachments
  map!(u32, VkClearRect) Rects
}

@override
@custom
@no_replay
cmd void RecreateCmdClearAttachments(
    VkCommandBuffer          commandBuffer,
    u32                      attachmentCount,
    const VkClearAttachment* pAttachments,
    u32                      rectCount,
    const VkClearRect*       pRects) {
  read(pAttachments[0:attachmentCount])
  read(pRects[0:rectCount])
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdClearAttachments(
    VkCommandBuffer          commandBuffer,
    u32                      attachmentCount,
    const VkClearAttachment* pAttachments,
    u32                      rectCount,
    const VkClearRect*       pRects) {
  recreate_data := new!RecreateCmdClearAttachmentsData()
  attachments := pAttachments[0:attachmentCount]
  rects := pRects[0:rectCount]
  for i in (0 .. attachmentCount) {
    recreate_data.Attachments[as!u32(i)] = attachments[i]
  }
  for i in (0 .. rectCount) {
    recreate_data.Rects[as!u32(i)] = rects[i]
  }
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

@override
@custom
@no_replay
cmd void RecreateCmdResolveImage(
    VkCommandBuffer     commandBuffer,
    VkImage             srcImage,
    VkImageLayout       srcImageLayout,
    VkImage             dstImage,
    VkImageLayout       dstImageLayout,
    u32                 regionCount,
    const VkImageResolve* pRegions) {
  read(pRegions[0:regionCount])
}

@internal class
RecreateCmdResolveImageData {
  VkImage             SrcImage,
  VkImageLayout       SrcImageLayout,
  VkImage             DstImage,
  VkImageLayout       DstImageLayout,
  map!(u32, VkImageResolve) ResolveRegions
}

sub void doCmdResolveImage(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResolveImage(
    VkCommandBuffer       commandBuffer,
    VkImage               srcImage,
    VkImageLayout         srcImageLayout,
    VkImage               dstImage,
    VkImageLayout         dstImageLayout,
    u32                   regionCount,
    const VkImageResolve* pRegions) {
  recreate_data := new!RecreateCmdResolveImageData(
    SrcImage: srcImage,
    SrcImageLayout: srcImageLayout,
    DstImage: dstImage,
    DstImageLayout: dstImageLayout
  )
  regions := pRegions[0:regionCount]
  for i in (0 .. regionCount) {
    recreate_data.ResolveRegions[i] = regions[i]
  }
  addCmd(commandBuffer, recreate_data, as!(u32)(0), doCmdResolveImage)
}

sub void doCmdSetEvent(VkEvent event) {
  Events[event].Signaled = true
  Events[event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@override
@custom
@no_replay
cmd void RecreateCmdSetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
}

@internal class RecreateCmdSetEventData {
    VkEvent              Event,
    VkPipelineStageFlags StageMask,
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdSetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  recreate_data := new!RecreateCmdSetEventData(
    Event:     event,
    StageMask: stageMask
  )
  addCmd(commandBuffer, recreate_data, event, doCmdSetEvent)
}

sub void doCmdResetEvent(VkEvent event) {
  Events[event].Signaled = false
  Events[event].SubmitQueue = LastBoundQueue.VulkanHandle
}

@override
@custom
@no_replay
cmd void RecreateCmdResetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
}

@internal class RecreateCmdResetEventData {
  VkEvent              Event,
  VkPipelineStageFlags StageMask
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetEvent(
    VkCommandBuffer      commandBuffer,
    VkEvent              event,
    VkPipelineStageFlags stageMask) {
  recreate_data := new!RecreateCmdResetEventData(
    Event:     event,
    StageMask: stageMask,
  )
  addCmd(commandBuffer, recreate_data, event, doCmdResetEvent)
}

@internal class CmdWaitEvents {
  map!(u32, VkEvent)              Events,
  map!(u32, VkImageMemoryBarrier) ImageMemoryBarriers
}

sub void doCmdWaitEvents(CmdWaitEvents args) {
  for _, _, e in args.Events {
    event := Events[e]
    event.SubmitQueue = LastBoundQueue.VulkanHandle
    if event.Signaled != true {
      LastBoundQueue.PendingEvents[e] = event
    }
  }
  if len(LastBoundQueue.PendingEvents) == 0 {
    for _ , _ , b in args.ImageMemoryBarriers {
      image := Images[b.image]
      image.Info.Layout = b.newLayout
      image.LastBoundQueue = LastBoundQueue
    }
  }
}

@override
@custom
@no_replay
cmd void RecreateCmdWaitEvents(
    VkCommandBuffer              commandBuffer,
    u32                          eventCount,
    const VkEvent*               pEvents,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  if pEvents != null {
    read(pEvents[0:eventCount])
  }
  if pMemoryBarriers != null {
    read(pMemoryBarriers[0:memoryBarrierCount])
  }
  if pBufferMemoryBarriers != null {
    read(pBufferMemoryBarriers[0:bufferMemoryBarrierCount])
  }
  if pImageMemoryBarriers != null {
    read(pImageMemoryBarriers[0:imageMemoryBarrierCount])
  }
}

@internal class RecreateCmdWaitEventsData {
  map!(u32, VkEvent)                Events,
  VkPipelineStageFlags              SrcStageMask,
  VkPipelineStageFlags              DstStageMask,
  map!(u32, VkMemoryBarrier)        MemoryBarriers
  map!(u32, VkBufferMemoryBarrier)  BufferMemoryBarriers,
  map!(u32, VkImageMemoryBarrier)   ImageMemoryBarriers,
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWaitEvents(
    VkCommandBuffer              commandBuffer,
    u32                          eventCount,
    const VkEvent*               pEvents,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  recreate_data := new!RecreateCmdWaitEventsData(
      SrcStageMask: srcStageMask,
      DstStageMask: dstStageMask,
  )
  wait := CmdWaitEvents()
  events := pEvents[0:eventCount]
  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. eventCount) {
    recreate_data.Events[i] = events[i]
    wait.Events[i] = events[i]
  }
  for i in (0 .. memoryBarrierCount) {
    recreate_data.MemoryBarriers[i] = memoryBarriers[i]
  }
  for i in (0 .. bufferMemoryBarrierCount) {
    recreate_data.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }
  for i in (0 .. imageMemoryBarrierCount) {
    recreate_data.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
    wait.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }
  addCmd(commandBuffer, recreate_data, wait, doCmdWaitEvents)
}

@override
@custom
@no_replay
cmd void RecreateCmdPipelineBarrier(
    VkCommandBuffer              commandBuffer,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    VkDependencyFlags            dependencyFlags,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  read(pMemoryBarriers[0:memoryBarrierCount])
  read(pBufferMemoryBarriers[0:bufferMemoryBarrierCount])
  read(pImageMemoryBarriers[0:imageMemoryBarrierCount])
}


@internal class
RecreateCmdPipelineBarrierData {
  VkPipelineStageFlags               SrcStageMask,
  VkPipelineStageFlags               DstStageMask,
  VkDependencyFlags                  DependencyFlags,
  map!(u32, VkMemoryBarrier)         MemoryBarriers,
  map!(u32, VkBufferMemoryBarrier)   BufferMemoryBarriers,
  map!(u32, VkImageMemoryBarrier)    ImageMemoryBarriers
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPipelineBarrier(
    VkCommandBuffer              commandBuffer,
    VkPipelineStageFlags         srcStageMask,
    VkPipelineStageFlags         dstStageMask,
    VkDependencyFlags            dependencyFlags,
    u32                          memoryBarrierCount,
    const VkMemoryBarrier*       pMemoryBarriers,
    u32                          bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    u32                          imageMemoryBarrierCount,
    const VkImageMemoryBarrier*  pImageMemoryBarriers) {
  create_data := new!RecreateCmdPipelineBarrierData(
    SrcStageMask: srcStageMask,
    DstStageMask: dstStageMask,
    DependencyFlags: dependencyFlags
  )
  barrier := CmdPipelineBarrier()

  memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
  for i in (0 .. memoryBarrierCount) {
    create_data.MemoryBarriers[i] = memoryBarriers[i]
  }

  bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
  for i in (0 .. bufferMemoryBarrierCount) {
    create_data.BufferMemoryBarriers[i] = bufferMemoryBarriers[i]
  }

  imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
  for i in (0 .. imageMemoryBarrierCount) {
    barrier.ImageBarriers[i] = imageMemoryBarriers[i]
    create_data.ImageMemoryBarriers[i] = imageMemoryBarriers[i]
  }
  addCmd(commandBuffer, create_data, barrier, doCmdPipelineBarrier)
}

@internal
class CmdPipelineBarrier {
  map!(u32, VkImageMemoryBarrier) ImageBarriers
}

sub void doCmdPipelineBarrier(CmdPipelineBarrier args) {
  for _ , _ , v in args.ImageBarriers {
    image := Images[v.image]
    image.Info.Layout = v.newLayout
    image.LastBoundQueue = LastBoundQueue
  }
}

@internal class
RecreateCmdBeginQueryData {
  VkQueryPool QueryPool
  u32         Query
  VkQueryControlFlags Flags
}

sub void doCmdBeginQuery(RecreateCmdBeginQueryData args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_ACTIVE
}

@internal class
RecreateCmdEndQueryData {
  VkQueryPool QueryPool
  u32         Query
}

sub void doCmdEndQuery(RecreateCmdEndQueryData args) {
  pool := QueryPools[args.QueryPool]
  pool.Status[args.Query] = QUERY_STATUS_COMPLETE
}

@override
@custom
@no_replay
cmd void RecreateCmdBeginQuery(
    VkCommandBuffer     commandBuffer,
    VkQueryPool         queryPool,
    u32                 query,
    VkQueryControlFlags flags) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginQuery(
    VkCommandBuffer     commandBuffer,
    VkQueryPool         queryPool,
    u32                 query,
    VkQueryControlFlags flags) {
  addCmd(commandBuffer, new!RecreateCmdBeginQueryData(
    queryPool, query, flags
  ), RecreateCmdBeginQueryData(queryPool, query, flags), doCmdBeginQuery)
}

@override
@custom
@no_replay
cmd void RecreateCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             query) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndQuery(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             query) {
  addCmd(commandBuffer, new!RecreateCmdEndQueryData(
    queryPool, query
  ), RecreateCmdEndQueryData(queryPool, query), doCmdEndQuery)
}

@internal class
RecreateCmdResetQueryPoolData {
  VkQueryPool QueryPool
  u32         FirstQuery
  u32         QueryCount
}

sub void doCmdResetQueryPool(RecreateCmdResetQueryPoolData args) {
  pool := QueryPools[args.QueryPool]
  for i in (0 .. args.QueryCount) {
    pool.Status[args.FirstQuery + i] = QUERY_STATUS_INACTIVE
  }
}

@override
@custom
@no_replay
cmd void RecreateCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             firstQuery
    u32             queryCount) {
  addCmd(commandBuffer, new!RecreateCmdResetQueryPoolData(
    queryPool, firstQuery, queryCount
  ), RecreateCmdResetQueryPoolData(queryPool, firstQuery, queryCount),
  doCmdResetQueryPool)
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdResetQueryPool(
    VkCommandBuffer commandBuffer,
    VkQueryPool     queryPool,
    u32             firstQuery,
    u32             queryCount) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdWriteTimestamp(
    VkCommandBuffer         commandBuffer,
    VkPipelineStageFlagBits pipelineStage,
    VkQueryPool             queryPool,
    u32                     query) {
}

@internal
class RecreateCmdCopyQueryPoolResultsData{
  VkQueryPool        QueryPool
  u32                FirstQuery
  u32                QueryCount
  VkBuffer           DstBuffer
  VkDeviceSize       DstOffset
  VkDeviceSize       Stride
  VkQueryResultFlags Flags
}

@override
@custom
@no_replay
cmd void RecreateCmdCopyQueryPoolResults(
    VkCommandBuffer    commandBuffer,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    VkBuffer           dstBuffer,
    VkDeviceSize       dstOffset,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdCopyQueryPoolResults(
    VkCommandBuffer    commandBuffer,
    VkQueryPool        queryPool,
    u32                firstQuery,
    u32                queryCount,
    VkBuffer           dstBuffer,
    VkDeviceSize       dstOffset,
    VkDeviceSize       stride,
    VkQueryResultFlags flags) {
  recreate_data := new!RecreateCmdCopyQueryPoolResultsData(
    QueryPool: queryPool,
    FirstQuery: firstQuery,
    QueryCount: queryCount,
    DstBuffer: dstBuffer,
    DstOffset: dstOffset,
    Stride: stride,
    Flags: flags
  )
  addCmd(commandBuffer, recreate_data, Unimplemented(), doCmdNop)
}

@override
@custom
@no_replay
cmd void RecreateCmdPushConstants(
    VkCommandBuffer    commandBuffer,
    VkPipelineLayout   layout,
    VkShaderStageFlags stageFlags,
    u32                offset,
    u32                size,
    const void*        pValues) {
  read(as!u8*(pValues)[0:size])
}

@internal class
RecreateCmdPushConstantsData {
  VkPipelineLayout   Layout,
  VkShaderStageFlags StageFlags,
  u32                Offset,
  u32                Size,
}

sub void doCmdPushConstants(u32 unused) {
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdPushConstants(
    VkCommandBuffer    commandBuffer,
    VkPipelineLayout   layout,
    VkShaderStageFlags stageFlags,
    u32                offset,
    u32                size,
    const void*        pValues) {
  read(as!u8*(pValues)[0:size])
  addCmd(commandBuffer, createPushConstantsData(
    layout, stageFlags, offset, size, pValues
  ), as!u32(0), doCmdPushConstants)
}

@override
@custom
@no_replay
cmd void RecreateCmdBeginRenderPass(
    VkCommandBuffer              commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents            contents) {
  begin_info := pRenderPassBegin[0]
  read(begin_info.pClearValues[0:begin_info.clearValueCount])
}

@internal class
RecreateCmdBeginRenderPassData {
  VkSubpassContents             Contents,
  VkRenderPass                  RenderPass,
  VkFramebuffer                 Framebuffer,
  VkRect2D                      RenderArea,
  map!(u32, VkClearValue)       ClearValues
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdBeginRenderPass(
    VkCommandBuffer              commandBuffer,
    const VkRenderPassBeginInfo* pRenderPassBegin,
    VkSubpassContents            contents) {
  begin_info := pRenderPassBegin[0]
  recreate_data := new!RecreateCmdBeginRenderPassData(
    Contents: contents,
    RenderPass: begin_info.renderPass,
    Framebuffer: begin_info.framebuffer,
    RenderArea: begin_info.renderArea
  )
  clear_values := begin_info.pClearValues[0:begin_info.clearValueCount]
  for i in (0 .. begin_info.clearValueCount) {
    recreate_data.ClearValues[i] = clear_values[i]
  }

  addCmd(commandBuffer, recreate_data, CmdBeginRenderPass(begin_info.framebuffer,
    begin_info.renderPass), doCmdBeginRenderPass)
}

class CmdBeginRenderPass {
  VkFramebuffer Framebuffer
  VkRenderPass RenderPass
}

sub void doCmdBeginRenderPass(CmdBeginRenderPass args) {
  LastDrawInfo.Framebuffer = Framebuffers[args.Framebuffer]
  LastDrawInfo.LastSubpass = 0
  LastDrawInfo.RenderPass = RenderPasses[args.RenderPass]
  for _ , _ , v in LastDrawInfo.Framebuffer.ImageAttachments {
    v.Image.LastBoundQueue = LastBoundQueue
  }
}

sub void doCmdNextSubpass(u32 Unused) {
  LastDrawInfo.LastSubpass += 1
}

@internal class
RecreateCmdNextSubpassData {
  VkSubpassContents Contents
}

@override
@custom
@no_replay
cmd void RecreateCmdNextSubpass(
    VkCommandBuffer   commandBuffer,
    VkSubpassContents contents) {}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdNextSubpass(
    VkCommandBuffer   commandBuffer,
    VkSubpassContents contents) {
  addCmd(commandBuffer, new!RecreateCmdNextSubpassData(contents), as!u32(0), doCmdNextSubpass)
}

@override
@custom
@no_replay
cmd void RecreateCmdEndRenderPass(
    VkCommandBuffer     commandBuffer) {
}

@internal class
RecreateCmdEndRenderPassData {
}

sub void doCmdEndRenderPass(u32 unused) {
}

@threadSafety("app")
@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdEndRenderPass(
    VkCommandBuffer commandBuffer) {
  addCmd(commandBuffer, new!RecreateCmdEndRenderPassData(), as!u32(0), doCmdEndRenderPass)
}

@internal
class CmdExecuteCommands {
  map!(u32, VkCommandBuffer) CommandBuffers
}

sub void doCmdExecuteCommands(CmdExecuteCommands cmds) {
  for i in (0 .. len(cmds.CommandBuffers)) {
    execCommands(cmds.CommandBuffers[as!u32(i)])
  }
}

@internal
class RecreateCmdExecuteCommandsData {
  map!(u32, VkCommandBuffer) CommandBuffers
}

@override
@custom
@no_replay
cmd void RecreateCmdExecuteCommands(
    VkCommandBuffer        commandBuffer,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  read(pCommandBuffers[0:commandBufferCount])
}

@indirect("VkCommandBuffer", "VkDevice")
cmd void vkCmdExecuteCommands(
    VkCommandBuffer        commandBuffer,
    u32                    commandBufferCount,
    const VkCommandBuffer* pCommandBuffers) {
  cmd_buffers := pCommandBuffers[0:commandBufferCount]
  recreate_data := new!RecreateCmdExecuteCommandsData()
  for i in (0 .. commandBufferCount) {
    recreate_data.CommandBuffers[as!u32(i)] = cmd_buffers[i]
  }
  cmdExecuteCommands := CmdExecuteCommands()
  for i in (0 .. commandBufferCount) {
    cmdExecuteCommands.CommandBuffers[as!u32(i)] = cmd_buffers[i]
  }
  addCmd(commandBuffer, recreate_data, cmdExecuteCommands, doCmdExecuteCommands)
}

// ----------------------------------------------------------------------------
// VK_KHR_surface
// ----------------------------------------------------------------------------

@extension("VK_KHR_surface")
enum VkColorSpaceKHR {
  VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0x00000000,
}

@extension("VK_KHR_surface")
enum VkPresentModeKHR {
  VK_PRESENT_MODE_IMMEDIATE_KHR    = 0x00000000,
  VK_PRESENT_MODE_MAILBOX_KHR      = 0x00000001,
  VK_PRESENT_MODE_FIFO_KHR         = 0x00000002,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 0x00000003,
}

@extension("VK_KHR_surface")
bitfield VkSurfaceTransformFlagBitsKHR {
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                     = 0x00000001,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                    = 0x00000002,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                   = 0x00000004,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                   = 0x00000008,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR            = 0x00000010,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR  = 0x00000020,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                      = 0x00000100,
}
@extension("VK_KHR_surface")
type VkFlags VkSurfaceTransformFlagsKHR

@extension("VK_KHR_surface")
bitfield VkCompositeAlphaFlagBitsKHR {
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR          = 0x00000001,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR  = 0x00000002,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR         = 0x00000008,
}

@extension("VK_KHR_surface")
type VkFlags VkCompositeAlphaFlagsKHR

@extension("VK_KHR_surface")
@serialize
class VkSurfaceCapabilitiesKHR {
  u32                           minImageCount
  u32                           maxImageCount
  VkExtent2D                    currentExtent
  VkExtent2D                    minImageExtent
  VkExtent2D                    maxImageExtent
  u32                           maxImageArrayLayers
  VkSurfaceTransformFlagsKHR    supportedTransforms
  VkSurfaceTransformFlagBitsKHR currentTransform
  VkCompositeAlphaFlagsKHR      supportedCompositeAlpha
  VkImageUsageFlags             supportedUsageFlags
}

@extension("VK_KHR_surface")
@serialize
class VkSurfaceFormatKHR {
  VkFormat        format
  VkColorSpaceKHR colorSpace
}

@extension("VK_KHR_surface")
@indirect("VkInstance")
cmd void vkDestroySurfaceKHR(
    VkInstance                   instance,
    VkSurfaceKHR                 surface,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  delete(Surfaces, surface)
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice physicalDevice,
    u32              queueFamilyIndex,
    VkSurfaceKHR     surface,
    VkBool32*        pSupported) {
  pSupported[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice          physicalDevice,
    VkSurfaceKHR              surface,
    VkSurfaceCapabilitiesKHR* pSurfaceCapabilities) {
  pSurfaceCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice    physicalDevice,
    VkSurfaceKHR        surface,
    u32*                pSurfaceFormatCount,
    VkSurfaceFormatKHR* pSurfaceFormats) {
  _ = pSurfaceFormatCount[0]

  if pSurfaceFormats == null {
    pSurfaceFormatCount[0] = ?
  } else {
    count := as!u32(?)
    formats := pSurfaceFormats[0:count]
    for i in (0 .. count) {
      formats[i] = ?
    }
    pSurfaceFormatCount[0] = count
  }

  return ?
}

@extension("VK_KHR_surface")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice  physicalDevice,
    VkSurfaceKHR      surface,
    u32*              pPresentModeCount,
    VkPresentModeKHR* pPresentModes) {
  _ = pPresentModeCount[0]

  if pPresentModes == null {
    pPresentModeCount[0] = ?
  } else {
    count := as!u32(?)
    modes := pPresentModes[0:count]
    for i in (0 .. count) {
      modes[i] = ?
    }
    pPresentModeCount[0] = count
  }

  return ?
}


// ----------------------------------------------------------------------------
// VK_KHR_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_swapchain")
@reserved_flags
type VkFlags VkSwapchainCreateFlagsKHR

@extension("VK_KHR_swapchain")
@serialize
class VkSwapchainCreateInfoKHR {
  VkStructureType               sType
  const void*                   pNext
  VkSwapchainCreateFlagsKHR     flags
  VkSurfaceKHR                  surface
  u32                           minImageCount
  VkFormat                      imageFormat
  VkColorSpaceKHR               imageColorSpace
  VkExtent2D                    imageExtent
  u32                           imageArrayLayers
  VkImageUsageFlags             imageUsage
  VkSharingMode                 imageSharingMode
  u32                           queueFamilyIndexCount
  const u32*                    pQueueFamilyIndices
  VkSurfaceTransformFlagBitsKHR preTransform
  VkCompositeAlphaFlagBitsKHR   compositeAlpha
  VkPresentModeKHR              presentMode
  VkBool32                      clipped
  VkSwapchainKHR                oldSwapchain
}

@extension("VK_KHR_swapchain")
@serialize
class VkPresentInfoKHR {
  VkStructureType       sType
  const void*           pNext
  u32                   waitSemaphoreCount
  const VkSemaphore*    pWaitSemaphores
  u32                   swapchainCount
  const VkSwapchainKHR* pSwapchains
  const u32*            pImageIndices
  VkResult*             pResults
}

@override
@custom
@no_replay
cmd void RecreateSwapchain(VkDevice device,
  VkSwapchainCreateInfoKHR* pCreateInfo,
  VkImage* pSwapchainImages,
  const VkImageLayout* pSwapchainLayouts,
  const VkQueue*       pInitialQueues,
  VkSwapchainKHR* pSwapchain) {
  create_info := pCreateInfo[0]
  read(create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount])
  read(pSwapchainLayouts[0:create_info.minImageCount])
  read(pInitialQueues[0:create_info.minImageCount])
  write(pSwapchainImages[0:create_info.minImageCount])
  write(pSwapchain[0:1])
}

@custom
@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@override
cmd VkResult vkCreateSwapchainKHR(
    VkDevice                        device,
    const VkSwapchainCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchain) {
  create_info := pCreateInfo[0]
  queueFamilyIndices := create_info.pQueueFamilyIndices[0:create_info.queueFamilyIndexCount]
  // TODO: pAllocator

  swapchainObject := new!SwapchainObject(Device: device,
    Info:                   ImageInfo(
      ImageType: VK_IMAGE_TYPE_2D,
      Format: create_info.imageFormat,
      Extent: VkExtent3D(create_info.imageExtent.Width, create_info.imageExtent.Height, 1),
      MipLevels: 1,
      ArrayLayers: create_info.imageArrayLayers,
      Samples: VK_SAMPLE_COUNT_1_BIT,
      Tiling: VK_IMAGE_TILING_OPTIMAL,
      Usage: create_info.imageUsage,
      SharingMode: create_info.imageSharingMode,
      Layout: VK_IMAGE_LAYOUT_UNDEFINED
    ),
    Surface:  Surfaces[create_info.surface],
    ColorSpace: create_info.imageColorSpace,
    PreTransform: create_info.preTransform,
    CompositeAlpha: create_info.compositeAlpha,
    PresentMode: create_info.presentMode,
    Clipped: create_info.clipped
  )

  for i in (0 .. create_info.queueFamilyIndexCount) {
    swapchainObject.Info.QueueFamilyIndices[i] =
      queueFamilyIndices[i]
  }

  handle := ?
  pSwapchain[0] = handle
  swapchainObject.VulkanHandle = handle
  Swapchains[handle] = swapchainObject

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd void vkDestroySwapchainKHR(
    VkDevice                     device,
    VkSwapchainKHR               swapchain,
    const VkAllocationCallbacks* pAllocator) {
  // TODO: pAllocator
  swapObject := Swapchains[swapchain]
  if swapObject != null {
    for _ , _ , v in swapObject.SwapchainImages {
      delete(Images, v.VulkanHandle)
    }
    delete(Swapchains, swapchain)
  }
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
cmd VkResult vkGetSwapchainImagesKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u32*           pSwapchainImageCount,
    VkImage*       pSwapchainImages) {
  swapchainObject := Swapchains[swapchain]
  // Need to do a read observation of the image count as the number of images
  // requested from users might be different from the number offered by the
  // swapchain. Besides, the virtual swapchain creates swapchain images
  // depends on this number.
  if pSwapchainImages != null {
    _ = pSwapchainImageCount[0]
  }
  fence
  if pSwapchainImages == null {
    pSwapchainImageCount[0] = ?
  } else {
    count := pSwapchainImageCount[0]
    images := pSwapchainImages[0:count]
    for i in (0 .. count) {
      images[i] = ?
      object := new!ImageObject(BoundMemory: null,
        Device:              device,
        VulkanHandle:        images[i],
        BoundMemoryOffset:   0,
        Info:                swapchainObject.Info,
        ImageAspect:         as!VkImageAspectFlags(VK_IMAGE_ASPECT_COLOR_BIT)
      )
      object.IsSwapchainImage = true
      width := swapchainObject.Info.Extent.Width
      height := swapchainObject.Info.Extent.Height
      format := swapchainObject.Info.Format
      layer := new!ImageLayer()
      level := new!ImageLevel(Width: width,Height:  height,Depth:  1)
      elementAndTexelBlockSize := getElementAndTexelBlockSize(format)
      // Roundup the width and height in the number of blocks.
      widthInBlocks := roundUpTo(width, elementAndTexelBlockSize.TexelBlockSize.Width)
      heightInBlocks := roundUpTo(height, elementAndTexelBlockSize.TexelBlockSize.Height)
      size := widthInBlocks * heightInBlocks * elementAndTexelBlockSize.ElementSize
      level.Data = make!u8(size)
      object.Layers[0] = layer
      object.Layers[0].Levels[0] = level
      if !(images[i] in Images) {
        Images[images[i]] = object
        swapchainObject.SwapchainImages[i] = Images[images[i]]
      }
    }
    pSwapchainImageCount[0] = count
  }

  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkDevice")
@custom
@blocking
cmd VkResult vkAcquireNextImageKHR(
    VkDevice       device,
    VkSwapchainKHR swapchain,
    u64            timeout,
    VkSemaphore    semaphore,
    VkFence        fence,
    u32*           pImageIndex) {
  _ = pImageIndex[0]
  pImageIndex[0] = ?
  if (semaphore != as!VkSemaphore(0)) {
    Semaphores[semaphore].Signaled = true
  }
  return ?
}

@extension("VK_KHR_swapchain")
@indirect("VkQueue", "VkDevice")
@EndOfFrame
cmd VkResult vkQueuePresentKHR(
    VkQueue                 queue,
    const VkPresentInfoKHR* pPresentInfo) {
  LastSubmission = PRESENT
  LastBoundQueue = Queues[queue]
  for i in (0 .. LastPresentInfo.PresentImageCount) {
    delete(LastPresentInfo.PresentImages, i)
  }
  LastPresentInfo.PresentImageCount = 0


  info := pPresentInfo[0]
  // TODO: handle pNext

  if (info.pWaitSemaphores != null) {
    wait_semaphores := info.pWaitSemaphores[0:info.waitSemaphoreCount]
    for i in (0 .. info.waitSemaphoreCount) {
      Semaphores[wait_semaphores[i]].Signaled = false
    }
  }
  swapchains := info.pSwapchains[0:info.swapchainCount]
  imageIndices := info.pImageIndices[0:info.swapchainCount]
  for i in (0 .. info.swapchainCount) {
    swapchain := Swapchains[swapchains[i]]
    image := swapchain.SwapchainImages[imageIndices[i]]
    LastPresentInfo.PresentImages[LastPresentInfo.PresentImageCount] =
      image
    LastPresentInfo.PresentImageCount = LastPresentInfo.PresentImageCount + 1
    image.LastBoundQueue = Queues[queue]
  }
  fence
  if (info.pResults != null) {
    // TODO(qining): Remove the use of fence once the inference can be done
    // correctly for arrays specified as struct members.
    read(info.pResults[0:info.swapchainCount])
    /*results := info.pResults[0:info.swapchainCount]
        for i in (0 .. info.swapchainCount) {
            result := as!VkResult(?)
            results[i] = result
        }*/
  }
  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display
// ----------------------------------------------------------------------------

@extension("VK_KHR_display")
bitfield VkDisplayPlaneAlphaFlagBitsKHR {
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                  = 0x00000001,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                  = 0x00000002,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR               = 0x00000004,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
}
@extension("VK_KHR_display")
type VkFlags VkDisplayPlaneAlphaFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplayModeCreateFlagsKHR

@extension("VK_KHR_display")
@reserved_flags
type VkFlags VkDisplaySurfaceCreateFlagsKHR

@extension("VK_KHR_display")
@serialize
class VkDisplayPropertiesKHR {
  VkDisplayKHR               display
  string                     displayName
  VkExtent2D                 physicalDimensions
  VkExtent2D                 physicalResolution
  VkSurfaceTransformFlagsKHR supportedTransforms
  VkBool32                   planeReorderPossible
  VkBool32                   persistentContent
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModeParametersKHR {
  VkExtent2D visibleRegion
  u32        refreshRate
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModePropertiesKHR {
  VkDisplayModeKHR           displayMode
  VkDisplayModeParametersKHR parameters
}

@extension("VK_KHR_display")
@serialize
class VkDisplayModeCreateInfoKHR {
  VkStructureType             sType
  const void*                 pNext
  VkDisplayModeCreateFlagsKHR flags
  VkDisplayModeParametersKHR  parameters
}

@extension("VK_KHR_display")
@serialize
class VkDisplayPlaneCapabilitiesKHR {
  VkDisplayPlaneAlphaFlagsKHR supportedAlpha
  VkOffset2D                  minSrcPosition
  VkOffset2D                  maxSrcPosition
  VkExtent2D                  minSrcExtent
  VkExtent2D                  maxSrcExtent
  VkOffset2D                  minDstPosition
  VkOffset2D                  maxDstPosition
  VkExtent2D                  minDstExtent
  VkExtent2D                  maxDstExtent
}

@extension("VK_KHR_display")
@serialize
class VkDisplayPlanePropertiesKHR {
  VkDisplayKHR currentDisplay
  u32          currentStackIndex
}

@extension("VK_KHR_display")
@serialize
class VkDisplaySurfaceCreateInfoKHR {
  VkStructureType                sType
  const void*                    pNext
  VkDisplaySurfaceCreateFlagsKHR flags
  VkDisplayModeKHR               displayMode
  u32                            planeIndex
  u32                            planeStackIndex
  VkSurfaceTransformFlagBitsKHR  transform
  f32                            globalAlpha
  VkDisplayPlaneAlphaFlagBitsKHR alphaMode
  VkExtent2D                     imageExtent
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice        physicalDevice,
    u32*                    pPropertyCount,
    VkDisplayPropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
      // TODO: also need to observe VkDisplayPropertiesKHR.displayName
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice             physicalDevice,
    u32*                         pPropertyCount,
    VkDisplayPlanePropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice physicalDevice,
    u32              planeIndex,
    u32*             pDisplayCount,
    VkDisplayKHR*    pDisplays) {
  _ = pDisplayCount[0]

  if pDisplays == null {
    pDisplayCount[0] = ?
  } else {
    count := as!u32(?)
    displays := pDisplays[0:count]
    for i in (0 .. count) {
      displays[i] = ?
    }
    pDisplayCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice            physicalDevice,
    VkDisplayKHR                display,
    u32*                        pPropertyCount,
    VkDisplayModePropertiesKHR* pProperties) {
  _ = pPropertyCount[0]

  if pProperties == null {
    pPropertyCount[0] = ?
  } else {
    count := as!u32(?)
    properties := pProperties[0:count]
    for i in (0 .. count) {
      properties[i] = ?
    }
    pPropertyCount[0] = count
  }

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice                  physicalDevice,
    VkDisplayKHR                      display,
    const VkDisplayModeCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*      pAllocator,
    VkDisplayModeKHR*                 pMode) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pMode[0] = handle
  modeObject := new!DisplayModeObject(PhysicalDevice: physicalDevice,
    Display:                          display,
    VulkanHandle:                     handle)
  DisplayModes[handle] = modeObject

  return ?
}

@extension("VK_KHR_display")
@indirect("VkPhysicalDevice", "VkInstance")
cmd VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice               physicalDevice,
    VkDisplayModeKHR               mode,
    u32                            planeIndex,
    VkDisplayPlaneCapabilitiesKHR* pCapabilities) {
  pCapabilities[0] = ?
  return ?
}

@extension("VK_KHR_display")
@indirect("VkInstance")
cmd VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                           instance,
    const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*         pAllocator,
    VkSurfaceKHR*                        pSurface) {
  _ = pCreateInfo[0]
  // TODO: pAllocator

  handle := ?
  pSurface[0] = handle
  surfaceObject := new!SurfaceObject(Instance: instance,
    VulkanHandle:           handle)
  Surfaces[handle] = surfaceObject

  return ?
}

// ----------------------------------------------------------------------------
// VK_KHR_display_swapchain
// ----------------------------------------------------------------------------

@extension("VK_KHR_display_swapchain")
@serialize @unused
class VkDisplayPresentInfoKHR {
  VkStructureType sType
  const void*     pNext
  VkRect2D        srcRect
  VkRect2D        dstRect
  VkBool32        persistent
}

@extension("VK_KHR_display_swapchain")
@indirect("VkDevice")
cmd VkResult vkCreateSharedSwapchainsKHR(
    VkDevice                        device,
    u32                             swapchainCount,
    const VkSwapchainCreateInfoKHR* pCreateInfos,
    const VkAllocationCallbacks*    pAllocator,
    VkSwapchainKHR*                 pSwapchains) {
  return ?
}

// ----------------------------------------------------------------------------
// VK_EXT_debug_report
// ----------------------------------------------------------------------------

@extension("VK_EXT_debug_report")
enum VkDebugReportObjectTypeEXT {
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT               = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT              = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT       = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                 = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT             = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT        = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                 = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT         = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                 = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                 = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT            = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT           = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT            = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT         = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT        = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT       = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT           = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT              = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT               = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT       = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT        = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT           = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT          = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT           = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT         = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT          = 28,
}

@extension("VK_EXT_debug_report")
@unused
enum VkDebugReportErrorEXT {
  VK_DEBUG_REPORT_ERROR_NONE_EXT         = 0,
  VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
}

@extension("VK_EXT_debug_report")
@unused
bitfield VkDebugReportFlagBitsEXT {
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT         = 0x00000001,
  VK_DEBUG_REPORT_WARNING_BIT_EXT             = 0x00000002,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
  VK_DEBUG_REPORT_ERROR_BIT_EXT               = 0x00000008,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT               = 0x00000010,
}
@extension("VK_EXT_debug_report")
type VkFlags VkDebugReportFlagsEXT

@extension("VK_EXT_debug_report")
@external type void* PFN_vkDebugReportCallbackEXT

@extension("VK_EXT_debug_report")
@pfn cmd VkBool32 vkDebugReportCallbackEXT(
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    string                     pLayerPrefix,
    string                     pMessage,
    void*                      pUserData) {
  return ?
}

@extension("VK_EXT_debug_report")
@serialize
class VkDebugReportCallbackCreateInfoEXT {
  VkStructureType              sType
  const void*                  pNext
  VkDebugReportFlagsEXT        flags
  PFN_vkDebugReportCallbackEXT pfnCallback
  void*                        pUserData
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd VkResult vkCreateDebugReportCallbackEXT(
    VkInstance                                instance,
    const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks*              pAllocator,
    VkDebugReportCallbackEXT*                 pCallback) {
  return ?
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd void vkDestroyDebugReportCallbackEXT(
    VkInstance                   instance,
    VkDebugReportCallbackEXT     callback,
    const VkAllocationCallbacks* pAllocator) {
}

@extension("VK_EXT_debug_report")
@indirect("VkInstance")
cmd void vkDebugReportMessageEXT(
    VkInstance                 instance,
    VkDebugReportFlagsEXT      flags,
    VkDebugReportObjectTypeEXT objectType,
    u64                        object,
    size                       location,
    s32                        messageCode,
    string                     pLayerPrefix,
    string                     pMessage) {
}
extern void validate(string layerName, bool condition, string message)

/////////////////////////////
// Struct subroutines      //
/////////////////////////////

// Marks the fields that need to be observed in a VkApplicationInfo struct and returns the API version.
sub u32 readVkApplicationInfo(const VkApplicationInfo* applicationInfo) {
  info := applicationInfo[0]

  // TODO: handle pNext
  if (info.pApplicationName != null) {
    _ = as!string(info.pApplicationName)
  }
  if (info.pEngineName != null) {
    _ = as!string(info.pEngineName)
  }
  return info.apiVersion
}

// Marks the fields that need to be observed in a VkInstanceCreateInfo struct and populates and returns an InstanceObject.
sub ref!InstanceObject createInstanceObject(const VkInstanceCreateInfo* createInfo) {
  object := new!InstanceObject()
  info := createInfo[0]

  // TODO: handle pNext
  if (info.pApplicationInfo != null) {
    object.ApiVersion = readVkApplicationInfo(info.pApplicationInfo)
  } else {
    object.ApiVersion = 0
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    // We do not need to store off the list of enabled layers, since
    // a layer's presence should not affect any other calls in the API,
    // only an enabled extension that is provided by a layer.
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    object.EnabledExtensions[i] = as!string(extensionNames[i])
  }

  return object
}

// Marks the fields that need to be observed in a VkDeviceCreateInfo struct and populates and returns a DeviceObject.
sub ref!DeviceObject createDeviceObject(const VkDeviceCreateInfo* data) {
  object := new!DeviceObject()
  info := data[0]

  // TODO: pNext
  queueCreateInfos := info.pQueueCreateInfos[0:info.queueCreateInfoCount]
  for i in (0 .. info.queueCreateInfoCount) {
    queue_info := queueCreateInfos[i]
    queue_priorities := queue_info.pQueuePriorities[0:queue_info.queueCount]
    for j in (0 .. queue_info.queueCount) {
      object.Queues[len(object.Queues)] =
        QueueInfo(QueueFamilyIndex: queue_info.queueFamilyIndex,
                  QueueIndex: j,
                  Priority: queue_priorities[j])
    }
  }

  layerNames := info.ppEnabledLayerNames[0:info.enabledLayerCount]
  for i in (0 .. info.enabledLayerCount) {
    object.EnabledLayers[i] = as!string(layerNames[i])
  }

  extensionNames := info.ppEnabledExtensionNames[0:info.enabledExtensionCount]
  for i in (0 .. info.enabledExtensionCount) {
    object.EnabledExtensions[i] = as!string(extensionNames[i])
  }

  if info.pEnabledFeatures != null {
    object.EnabledFeatures = info.pEnabledFeatures[0]
  }

  return object
}

/////////////////////////////
// Internal State Tracking //
/////////////////////////////

// Dispatchable objects.
map!(VkInstance, ref!InstanceObject)             Instances
map!(VkPhysicalDevice, ref!PhysicalDeviceObject) PhysicalDevices
map!(VkDevice, ref!DeviceObject)                 Devices
map!(VkQueue, ref!QueueObject)                   Queues
map!(VkCommandBuffer, ref!CommandBufferObject)   CommandBuffers
// Non-dispatchable objects.
map!(VkDeviceMemory, ref!DeviceMemoryObject)               DeviceMemories
map!(VkBuffer, ref!BufferObject)                           Buffers
map!(VkBufferView, ref!BufferViewObject)                   BufferViews
map!(VkImage, ref!ImageObject)                             Images
map!(VkImageView, ref!ImageViewObject)                     ImageViews
map!(VkShaderModule, ref!ShaderModuleObject)               ShaderModules
map!(VkPipeline, ref!GraphicsPipelineObject)               GraphicsPipelines
map!(VkPipeline, ref!ComputePipelineObject)                ComputePipelines
map!(VkPipelineLayout, ref!PipelineLayoutObject)           PipelineLayouts
map!(VkSampler, ref!SamplerObject)                         Samplers
map!(VkDescriptorSet, ref!DescriptorSetObject)             DescriptorSets
map!(VkDescriptorSetLayout, ref!DescriptorSetLayoutObject) DescriptorSetLayouts
map!(VkDescriptorPool, ref!DescriptorPoolObject)           DescriptorPools
map!(VkFence, ref!FenceObject)                             Fences
map!(VkSemaphore, ref!SemaphoreObject)                     Semaphores
map!(VkEvent, ref!EventObject)                             Events
map!(VkQueryPool, ref!QueryPoolObject)                     QueryPools
map!(VkFramebuffer, ref!FramebufferObject)                 Framebuffers
map!(VkRenderPass, ref!RenderPassObject)                   RenderPasses
map!(VkPipelineCache, ref!PipelineCacheObject)             PipelineCaches
map!(VkCommandPool, ref!CommandPoolObject)                 CommandPools
map!(VkSurfaceKHR, ref!SurfaceObject)                      Surfaces
map!(VkSwapchainKHR, ref!SwapchainObject)                  Swapchains
map!(VkDisplayModeKHR, ref!DisplayModeObject)              DisplayModes
// Other state Tracking
ref!QueueObject       LastBoundQueue
ref!ComputePipelineObject  CurrentComputePipeline

// This contains the draw command parameters. Only one of the draw data should be
// valid at a time. Others should be null.
@internal class DrawParameters {
  ref!CmdDraw                Draw
  ref!CmdDrawIndexed         DrawIndexed
  ref!CmdDrawIndirect        DrawIndirect
  ref!CmdDrawIndexedIndirect DrawIndexedIndirect
}

// This contains the information about a draw
@internal class DrawInfo {
  ref!FramebufferObject               Framebuffer
  // A mapping from the descriptor set bound numbers to descriptor set objects
  map!(u32, ref!DescriptorSetObject)  DescriptorSets
  // The Last subpass number used in the draw
  u32                                 LastSubpass
  // The graphics pipeline used for the draw
  ref!GraphicsPipelineObject          GraphicsPipeline
  // The vertex buffers used for the draw. This is a map of binding number to
  // buffer bound do that binding.
  map!(u32, BoundBuffer)              BoundVertexBuffers
  // The index buffer used for the draw
  ref!BoundIndexBuffer                BoundIndexBuffer
  // The draw parameters used for the draw
  DrawParameters                      CommandParameters
  // The render pass in which this draw takes place
  ref!RenderPassObject                RenderPass
}
// Records the draw information of the last draw.
DrawInfo LastDrawInfo

@internal class PresentInfo {
  // The number of images presented last present
  u32                                 PresentImageCount
  // The images presented in the last present
  map!(u32, ref!ImageObject)          PresentImages
}

PresentInfo LastPresentInfo

enum LastSubmissionType {
  SUBMIT = 0
  PRESENT = 1
}

LastSubmissionType LastSubmission

// Clear the recorded descriptor sets in the last draw
sub void clearLastDrawInfoDescriptorSets() {
  for i in (0 .. len(LastDrawInfo.DescriptorSets)) {
    LastDrawInfo.DescriptorSets[as!u32(i)] = null
  }
}

// Clear the draw command parameters in the last draw info
sub void clearLastDrawInfoDrawCommandParameters() {
  LastDrawInfo.CommandParameters.Draw = null
  LastDrawInfo.CommandParameters.DrawIndexed = null
  LastDrawInfo.CommandParameters.DrawIndirect = null
  LastDrawInfo.CommandParameters.DrawIndexedIndirect = null
}

// Internal struct for holding useful instance level information from VkInstanceCreateInfo.
@internal class InstanceObject {
  @unused u32               ApiVersion        // The api version the app requested when setting up the instance
  @unused map!(u32, string) EnabledExtensions // Map from enabled extension index to extension name
  @unused map!(u32, string) EnabledLayers
  @unused VkInstance        VulkanHandle
}

@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_EXTENSION_NAME "VK_KHR_xlib_surface"

@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_SPEC_VERSION   6
@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_EXTENSION_NAME "VK_KHR_xcb_surface"

@internal class PhysicalDeviceObject {
  @unused VkInstance               Instance
  @unused u32                      Index
  VkPhysicalDeviceMemoryProperties MemoryProperties
  @unused VkPhysicalDevice         VulkanHandle
  // A map of queue family indices to queue properties.
  @unused map!(u32, VkQueueFamilyProperties) QueueFamilyProperties
}

@intenral class QueueInfo {
  u32 QueueFamilyIndex
  u32 QueueIndex
  f32 Priority
}

@internal class DeviceObject {
  VkPhysicalDevice                 PhysicalDevice
  @unused map!(u32, string)        EnabledExtensions
  @unused map!(u32, string)        EnabledLayers
  @unused map!(u32, QueueInfo)     Queues
  @unused VkPhysicalDeviceFeatures EnabledFeatures
  @unused VkDevice                 VulkanHandle
}

@internal class QueueObject {
  @unused VkDevice               Device
  @unused u32                    Family
  @unused u32                    Index
  @unused VkQueue                VulkanHandle
  map!(VkEvent, ref!EventObject) PendingEvents
}

enum RecordingState {
    NOT_STARTED = 0,
    RECORDING = 1,
    COMPLETED = 2
}

@internal class CommandBufferBegin {
  VkCommandBufferUsageFlags Flags
  bool Inherited
  VkRenderPass InheritedRenderPass
  u32 InheritedSubpass
  VkFramebuffer InheritedFramebuffer
  VkBool32 InheritedOcclusionQuery
  VkQueryControlFlags InheritedQueryFlags
  VkQueryPipelineStatisticFlags InheritedPipelineStatsFlags
}

@internal class CommandBufferObject {
  @unused VkDevice        Device
  @unused RecordingState  Recording
  @unused VkCommandBuffer VulkanHandle
  @unused VkCommandPool   Pool
  @unused VkCommandBufferLevel Level
  @unused ref!CommandBufferBegin BeginInfo
}

@internal class DeviceMemoryObject {
  VkDevice                Device
  @unused VkDeviceMemory  VulkanHandle
  VkDeviceSize            AllocationSize
  map!(u64, VkDeviceSize) BoundObjects
  VkDeviceSize            MappedOffset
  VkDeviceSize            MappedSize
  void*                   MappedLocation
  u32                     MemoryTypeIndex
  @internal u8[]          Data
  ref!DedicatedAllocationMemoryAllocateInfoNV DedicatedAllocationNV
}

@internal class BufferInfo {
  @unused VkBufferCreateFlags CreateFlags
  @unused VkDeviceSize        Size
  @unused VkBufferUsageFlags  Usage
  @unused VkSharingMode       SharingMode
  @unused map!(u32, u32)      QueueFamilyIndices
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@internal class BufferObject {
  @unused VkDevice       Device
  @unused VkBuffer       VulkanHandle
  @unused BufferInfo     Info
  ref!DeviceMemoryObject Memory
  VkDeviceSize           MemoryOffset
  @unused ref!QueueObject       LastBoundQueue
}

@internal class BufferViewObject {
  @unused VkDevice         Device
  @unused VkBufferView     VulkanHandle
  @unused ref!BufferObject Buffer
  @unused VkFormat         Format
  @unused VkDeviceSize     Offset
  @unused VkDeviceSize     Range
}

@internal class ImageInfo {
  VkImageCreateFlags    Flags
  VkImageType           ImageType
  VkFormat              Format
  VkExtent3D            Extent
  u32                   MipLevels
  u32                   ArrayLayers
  VkSampleCountFlagBits Samples
  VkImageTiling         Tiling
  VkImageUsageFlags     Usage
  VkSharingMode         SharingMode
  map!(u32, u32)        QueueFamilyIndices
  VkImageLayout         Layout
  ref!DedicatedAllocationBufferImageCreateInfoNV DedicatedAllocationNV
}

@resource
@internal class ImageObject {
  @unused VkDevice              Device
  @unused ref!QueueObject       LastBoundQueue
  ref!DeviceMemoryObject        BoundMemory
  VkDeviceSize                  BoundMemoryOffset
  @unused bool                  IsSwapchainImage
  VkImage                       VulkanHandle
  ImageInfo                     Info
  VkImageAspectFlags            ImageAspect
  map!(u32, ref!ImageLayer)     Layers
}

@internal class ImageLayer {
  map!(u32, ref!ImageLevel) Levels
}

@internal class ImageLevel {
  u32            Width
  u32            Height
  @unused u32    Depth
  @internal u8[] Data
  @unused u32    Size
}

@internal class ImageViewObject {
  @unused VkDevice    Device
  @unused VkImageView VulkanHandle
  @unused VkImageViewType Type
  @unused VkFormat        Format
  @unused VkComponentMapping Components
  @unused VkImageSubresourceRange SubresourceRange
  ref!ImageObject     Image
}

@resource
@internal class ShaderModuleObject {
  @unused VkDevice       Device
  @unused u32[]          Words
  @unused VkShaderModule VulkanHandle
}

@internal class SpecializationInfo {
  map!(u32, VkSpecializationMapEntry) Specializations
}

@internal class StageData {
  @unused VkShaderStageFlagBits Stage
  @unused ref!ShaderModuleObject      Module
  @unused string                EntryPoint
  @unused ref!SpecializationInfo Specialization
}

@internal class VertexData {
  @unused map!(u32, VkVertexInputBindingDescription) BindingDescriptions
  @unused map!(u32, VkVertexInputAttributeDescription) AttributeDescriptions
}

@internal class InputAssemblyData {
  @unused VkPrimitiveTopology Topology
  @unused VkBool32 PrimitiveRestartEnable
}

@internal class TessellationStateData {
  @unused u32 PatchControlPoints
}

@internal class ViewportData {
  @unused map!(u32, VkViewport) Viewports
  @unused map!(u32, VkRect2D) Scissors
}

@internal class RasterizationData {
  @unused VkBool32  DepthClampEnable
  @unused VkBool32  RasterizerDiscardEnable
  @unused VkPolygonMode PolygonMode
  @unused VkCullModeFlags CullMode
  @unused VkFrontFace FrontFace
  @unused VkBool32   DepthBiasEnable
  @unused f32 DepthBiasConstantFactor
  @unused f32 DepthBiasClamp
  @unused f32 DepthBiasSlopeFactor
  @unused f32 LineWidth
}

@internal class MultisampleData {
  @unused VkSampleCountFlagBits RasterizationSamples
  @unused VkBool32              SampleShadingEnable
  @unused f32                   MinSampleShading
  @unused map!(u32, VkSampleMask) SampleMask
  @unused VkBool32              AlphaToCoverageEnable
  @unused VkBool32              AlphaToOneEnable
}

@internal class DepthData {
  @unused VkBool32            DepthTestEnable
  @unused VkBool32            DepthWriteEnable
  @unused VkCompareOp         DepthCompareOp
  @unused VkBool32            DepthBoundsTestEnable
  @unused VkBool32            StencilTestEnable
  @unused VkStencilOpState    Front
  @unused VkStencilOpState    Back
  @unused f32                 MinDepthBounds
  @unused f32                 MaxDepthBounds
}

@internal class ColorBlendData {
  @unused VkBool32            LogicOpEnable
  @unused VkLogicOp           LogicOp
  @unused map!(u32, VkPipelineColorBlendAttachmentState) Attachments
  @unused f32[4]              BlendConstants
}

@internal class DynamicData {
  @unused map!(u32, VkDynamicState) DynamicStates
}

@internal class GraphicsPipelineObject {
  @unused VkDevice                                     Device
  @unused ref!PipelineCacheObject                      PipelineCache
  @unused VkPipelineCreateFlags                        Flags
  @unused VkPipeline                                   VulkanHandle
  @unused map!(u32, StageData)                         Stages
  @unused VertexData                                   VertexInputState
  @unused InputAssemblyData                            InputAssemblyState
  @unused ref!TessellationStateData                    TessellationState
  @unused ref!ViewportData                             ViewportState
  @unused RasterizationData                            RasterizationState
  @unused ref!MultisampleData                          MultisampleState
  @unused ref!DepthData                                DepthState
  @unused ref!ColorBlendData                           ColorBlendState
  @unused ref!DynamicData                              DynamicState
  @unused ref!PipelineLayoutObject                     Layout
  @unused ref!RenderPassObject                         RenderPass
  @unused u32                                          Subpass
  @unused VkPipeline                                   BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                                          BasePipelineIndex
}

@internal class ComputePipelineObject {
  @unused VkDevice                                    Device
  @unused VkPipeline                                  VulkanHandle
  @unused ref!PipelineCacheObject                     PipelineCache
  @unused VkPipelineCreateFlags                       Flags
  @unused StageData                                   Stage
  @unused ref!PipelineLayoutObject                    PipelineLayout
  @unused VkPipeline                                  BasePipeline
  // Note: When doing MEC, use BasePipeline instead of BasePipelineIndex
  //       It will have been set for you correctly
  @unused s32                                         BasePipelineIndex
}

@internal class PipelineLayoutObject {
  @unused VkDevice         Device
  @unused VkPipelineLayout VulkanHandle
  @unused map!(u32, ref!DescriptorSetLayoutObject) SetLayouts
  @unused map!(u32, VkPushConstantRange) PushConstantRanges
}

@internal class SamplerObject {
  @unused VkDevice  Device
  @unused VkSampler VulkanHandle
  @unused VkFilter  MagFilter
  @unused VkFilter  MinFilter
  @unused VkSamplerMipmapMode MipMapMode
  @unused VkSamplerAddressMode AddressModeU
  @unused VkSamplerAddressMode AddressModeV
  @unused VkSamplerAddressMode AddressModeW
  @unused f32                  MipLodBias
  @unused VkBool32             AnisotropyEnable
  @unused f32                  MaxAnisotropy
  @unused VkBool32             CompareEnable
  @unused VkCompareOp          CompareOp
  @unused f32                  MinLod
  @unused f32                  MaxLod
  @unused VkBorderColor        BorderColor
  @unsued VkBool32             UnnormalizedCoordinates
}

@internal class DescriptorBinding {
  VkDescriptorType BindingType
  map!(u32, ref!VkDescriptorBufferInfo) BufferBinding
  map!(u32, ref!VkDescriptorImageInfo) ImageBinding
  map!(u32, VkBufferView) BufferViewBindings
}

@internal class DescriptorSetObject {
  @unused VkDevice        Device
  @unused VkDescriptorSet VulkanHandle
  @unused ref!DescriptorPoolObject DescriptorPool
  // Map from a binding number to its bound array of buffers.
  map!(u32, DescriptorBinding)      Bindings
  ref!DescriptorSetLayoutObject     Layout
}

@internal class DescriptorSetLayoutBinding {
  VkDescriptorType                     Type
  @unused u32                          Count
  @unused VkShaderStageFlags           Stages
  @unused map!(u32, ref!SamplerObject) ImmutableSamplers
}

@internal class DescriptorSetLayoutObject {
  @unused VkDevice              Device
  @unused VkDescriptorSetLayout VulkanHandle
  u32                           MaximumBinding
  // Map of binding numbers to binding information
  map!(u32, DescriptorSetLayoutBinding) Bindings
}

@internal class DescriptorPoolObject {
  @unused VkDevice         Device
  @unused VkDescriptorPool VulkanHandle
  @unused VkDescriptorPoolCreateFlags Flags
  @unused u32             MaxSets
  @unused map!(u32, VkDescriptorPoolSize) Sizes
}

@internal class FenceObject {
  @unused VkDevice Device
  @unused VkFence  VulkanHandle
  @unused bool     Signaled
}


@internal class SemaphoreObject {
  @unused VkDevice    Device
  @unused VkSemaphore VulkanHandle
  @unused VkQueue     LastQueue
  @unused bool        Signaled
}

@internal class EventObject {
  @unused VkDevice Device
  @unused VkEvent  VulkanHandle
  @unused bool Signaled
  @unused VkQueue SubmitQueue
}

enum QueryStatus {
  QUERY_STATUS_INACTIVE = 0
  QUERY_STATUS_ACTIVE = 1
  QUERY_STATUS_COMPLETE = 2
}

@internal class QueryPoolObject {
  @unused VkDevice    Device
  @unused VkQueryPool VulkanHandle
  @unused VkQueryType QueryType
  @unused u32         QueryCount
  @unused VkQueryPipelineStatisticFlags PipelineStatistics
  @unused map!(u32, QueryStatus) Status
}

@internal class FramebufferObject {
  @unused VkDevice               Device
  @unused VkFramebuffer          VulkanHandle
  @unused ref!RenderPassObject   RenderPass
  map!(u32, ref!ImageViewObject) ImageAttachments
  @unused u32                    Width
  @unused u32                    Height
  @unused u32                    Layers
}

@internal class SubpassDescription {
  @unused VkSubpassDescriptionFlags Flags
  @unused VkPipelineBindPoint PipelineBindPoint
  @unused map!(u32, VkAttachmentReference) InputAttachments
  @unused map!(u32, VkAttachmentReference) ColorAttachments
  @unused map!(u32, VkAttachmentReference) ResolveAttachments
  @unused ref!VkAttachmentReference DepthStencilAttachment
  @unused map!(u32, u32) PreserveAttachments
}

@internal class RenderPassObject {
  @unused VkDevice     Device
  @unused VkRenderPass VulkanHandle
  @unused map!(u32, VkAttachmentDescription) AttachmentDescriptions
  @unused map!(u32, SubpassDescription) SubpassDescriptions
  @unused map!(u32, VkSubpassDependency) SubpassDependencies
}

@internal class PipelineCacheObject {
  @unused VkDevice        Device
  @unused VkPipelineCache VulkanHandle
}

@internal class CommandPoolObject {
  @unused VkDevice      Device
  @unused VkCommandPool VulkanHandle
  @unsued VkCommandPoolCreateFlags Flags
  @unused u32           QueueFamilyIndex
  @unused map!(VkCommandBuffer, ref!CommandBufferObject) CommandBuffers
}

enum SurfaceType {
  SURFACE_TYPE_UNKNOWN = 0
  SURFACE_TYPE_XCB = 1
  SURFACE_TYPE_ANDROID = 2
  SURFACE_TYPE_WIN32 = 3
}

@internal class SurfaceObject {
  @unused VkInstance   Instance
  @unused VkSurfaceKHR VulkanHandle
  @unused SurfaceType  Type
}

@internal class SwapchainObject {
  @unused VkDevice           Device
  @unused VkSwapchainKHR     VulkanHandle
  @unused ImageInfo          Info
  @unused ref!SurfaceObject  Surface
  @unused VkColorSpaceKHR    ColorSpace
  @unused VkSurfaceTransformFlagBitsKHR PreTransform
  @unused VkCompositeAlphaFlagBitsKHR CompositeAlpha
  @unused VkPresentModeKHR PresentMode
  @unused VkBool32           Clipped
  map!(u32, ref!ImageObject) SwapchainImages
}

@internal class DisplayModeObject {
  @unused VkPhysicalDevice PhysicalDevice
  @unused VkDisplayKHR     Display
  @unused VkDisplayModeKHR VulkanHandle
}

sub VkQueueFlags AddQueueFlag(VkQueueFlags flags, VkQueueFlagBits bit) {
  return as!VkQueueFlags(as!u32(flags) | as!u32(bit))
}

@serialize
class VulkanStructHeader {
  VkStructureType  SType
  void*            PNext
}

@internal class DedicatedAllocationBufferImageCreateInfoNV {
  VkBool32        DedicatedAllocation
}

@internal class DedicatedAllocationMemoryAllocateInfoNV {
  VkImage         Image
  VkBuffer        Buffer
}
