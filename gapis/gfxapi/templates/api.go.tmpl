{{/*
 * Copyright (C) 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{Global "module" ""}}
{{Include "go_common.tmpl"}}
{{$ | Macro "api.go" | GoFmt | Write "api.go"}}
{{$ | Macro "enum.go" | GoFmt | Write "enum.go"}}

{{define "api.go"}}
  {{template "Go.GeneratedHeader" (Global "OutputDir")}}

  import (
    "context"
    "fmt"

    "github.com/google/gapid/core/data/binary"
    "github.com/google/gapid/core/data/id"
    "github.com/google/gapid/core/math/u64"
    "github.com/google/gapid/gapis/atom"
    "github.com/google/gapid/gapis/capture"
    "github.com/google/gapid/gapis/gfxapi"
    "github.com/google/gapid/gapis/gfxapi/test/gfxapi_test_import"
    "github.com/google/gapid/gapis/memory"
    "github.com/google/gapid/gapis/replay/builder"
    "github.com/google/gapid/gapis/replay/protocol"
    "github.com/google/gapid/gapis/replay/value"
    "github.com/google/gapid/gapis/resolve"
    "github.com/google/gapid/gapis/service"
    "github.com/google/gapid/gapis/service/path"
)

  {{range $p := $.Pseudonyms}}
    {{template "Pseudonym" $p}}
  {{end}}

  {{range $p := $.Pointers}}
    {{template "Pointer" $p}}
  {{end}}

  {{range $s := $.StaticArrays}}
    {{template "Array" $s}}
  {{end}}

  {{range $s := $.Slices}}
    {{template "Slice" $s}}
  {{end}}

  {{range $m := $.Maps}}
    {{template "Map" $m}}
  {{end}}

  {{range $i, $c := AllCommands $}}
    {{Template "CommandEntry" "Command" $c "Index" $i}}
  {{end}}

  {{range $c := $.Classes}}
    {{template "Class" $c}}
  {{end}}

  {{template "State" $}}

  {{template "NewAtoms" $}}

  {{template "API" $}}

  func init() {
    gfxapi.Register(API())
  }

  func min(a, b uint64) uint64 {
    if a < b {
      return a
    } else {
      return b
    }
  }
{{end}}


{{define "enum.go"}}
  {{template "Go.GeneratedHeader" (Global "OutputDir")}}

  import (
    "fmt"

    "github.com/google/gapid/gapis/atom"
    "github.com/google/gapid/gapis/gfxapi"
    "github.com/google/gapid/core/log"
    "github.com/google/gapid/gapis/memory"
    "github.com/google/gapid/gapis/replay/builder"
    "github.com/google/gapid/gapis/service"
  )

  {{range $e := $.Enums}}
    {{template "Enum" $e}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration for the specified pseudonym.
-------------------------------------------------------------------------------
*/}}
{{define "Pseudonym"}}
  {{AssertType $ "Pseudonym"}}

  {{$u := $ | Underlying}}
  {{     if IsPointer  $u}}{{Template "Pointer" $}}
  {{else if IsSlice    $u}}{{Template "Slice"   $}}
  {{else if IsVoid     $u}}
  {{else}}
    {{$to := Macro "Go.Type" $.To}}

    type {{$.Name}} {{$to}}

    {{$out := print "(*(*" $to ")(a))"}}

    func (a *{{$.Name}}) Encode(ϟl *device.MemoryLayout, e binary.Writer) {
      {{Template "Go.Encode" "Name" $out "Type" $.To "ErrHandler" "panic(e.Error())"}}
    }

    func (a *{{$.Name}}) Decode(ϟl *device.MemoryLayout, d binary.Reader) {
      {{Template "Go.Decode" "Name" $out "Type" $.To "ErrHandler" "panic(d.Error())"}}
    }
  {{end}}

  {{template "LabelsForLabeledType" $}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration for the static-array type.
-------------------------------------------------------------------------------
*/}}
{{define "Array"}}
  {{AssertType $ "StaticArray"}}

  {{$ty := Macro "Go.Type" $}}
  type {{$ty}} struct {
    Elements [{{$.Size}}]{{Template "Go.Type" $.ValueType}}
  }

  func (a *{{$ty}}) Encode(ϟl *device.MemoryLayout, e binary.Writer) {
    for _, v := range a.Elements {
      {{Template "Go.Encode" "Name" "v" "Type" $.ValueType "ErrHandler" "panic(e.Error())"}}
    }
  }

  func (a *{{$ty}}) Decode(ϟl *device.MemoryLayout, d binary.Reader) {
    for i := range a.Elements {
      {{Template "Go.Decode" "Name" "a.Elements[i]" "Type" $.ValueType "ErrHandler" "panic(d.Error())"}}
    }
  }

  {{if IsNumericType $.ValueType}}
    func (a {{$ty}}) value(ϟb *builder.Builder, ϟa atom.Atom, ϟs *gfxapi.State) value.Pointer {
      for _, v := range a.Elements {
        ϟb.Push({{Template "Go.Replay.Value" "Type" $.ValueType "Name" "v"}})
      }
      return ϟb.Buffer({{$.Size}})
    }
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the Pointer type or indirect
  type (Pseudonym) to Pointer.
-------------------------------------------------------------------------------
*/}}
{{define "Pointer"}}
  {{AssertType $ "Pointer" "Pseudonym"}}

  {{$p          := $ | Underlying | Unpack                 }}
  {{$slice_ty   := Macro "Go.Type"   $p.Slice              }}
  {{$ptr_ty     := Macro "Go.Type"   $                     }}
  {{$el_ty      := Macro "Go.Type"   $p.To                 }}
  {{$el_is_void := IsVoid    ($p.To | Underlying | Unpack) }}
  {{$el_is_char := IsChar    ($p.To | Underlying | Unpack) }}
  {{$el_is_ptr  := IsPointer ($p.To | Underlying | Unpack) }}

  // {{$ptr_ty}} is a pointer to a {{$el_ty}} element.
  {{if $el_is_ptr}}
  // Note: Pointers are stored differently between the application pool and internal pools.
  //  * The application pool stores pointers as an address of an architecture-dependant size.
  //  * Internal pools store pointers as an 64-bit unsigned address and a 32-bit unsigned
  //    pool identifier.
  {{end}}
  type {{$ptr_ty}} memory.Pointer

  // New{{$ptr_ty}} returns a {{$ptr_ty}} that points to addr in the application pool.
  func New{{$ptr_ty}}(addr uint64) {{$ptr_ty}} {
    return {{$ptr_ty}}{ Address: addr, Pool: memory.ApplicationPool }
  }

  func (p {{$ptr_ty}}) Encode(ϟl *device.MemoryLayout, e binary.Writer) {
      e.Uint64(p.Address);
      e.Uint32(uint32(p.Pool));
  }

  func (p *{{$ptr_ty}}) Decode(ϟl *device.MemoryLayout, d binary.Reader) {
      p.Address = d.Uint64();
      p.Pool = memory.PoolID(d.Uint32());
  }

  // ElementSize returns the size in bytes of an element that {{$ptr_ty}} points to.
  func (p {{$ptr_ty}}) ElementSize(ϟl *device.MemoryLayout) uint64 {
    {{if $el_is_ptr}}
      if p.Pool == memory.ApplicationPool {
        return uint64(ϟl.GetPointer().GetSize())
      } else {
        return 12
      }
    {{else}}
      return {{Template "Go.SizeOf" $p.To}}
    {{end}}
  }

  {{if not $el_is_void}}
    // Read reads and returns the {{$el_ty}} element at the pointer.
    func (p {{$ptr_ty}}) Read(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {{$el_ty}} {
      return p.Slice(0, 1, ϟs.MemoryLayout).Read(ϟctx, ϟa, ϟs, ϟb)[0]
    }

    // Write writes value to the {{$el_ty}} element at the pointer.
    func (p {{$ptr_ty}}) Write(ϟctx context.Context, value {{$el_ty}}, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {
      p.Slice(0, 1, ϟs.MemoryLayout).Write(ϟctx, []{{$el_ty}}{value}, ϟa, ϟs, ϟb)
    }
  {{end}}

  {{if $el_is_char}}
    // StringSlice returns a slice starting at p and ending at the first 0 byte null-terminator.
    func (p {{$ptr_ty}}) StringSlice(ϟctx context.Context, ϟs *gfxapi.State) Charˢ {
      i, d := uint64(0), ϟs.MemoryDecoder(ϟctx, ϟs.Memory[p.Pool].At(p.Address))
      for {
        i++
        if b := d.Uint8(); b == 0 {
          return Charˢ(p.Slice(0, i, ϟs.MemoryLayout))
        }
      }
    }
  {{end}}

  // Slice returns a new {{$slice_ty}} from the pointer using start and end indices.
  func (p {{$ptr_ty}}) Slice(start, end uint64, ϟl *device.MemoryLayout) {{$slice_ty}} {
    if start > end {
      panic(fmt.Errorf("Slice start (%d) is greater than the end (%d)", start, end))
    }
    return {{$slice_ty}}{root: p.Address, base: p.Address + start * p.ElementSize(ϟl), count: end-start, pool: p.Pool}
  }

  // Check interface conformance
  var _ path.Linker = {{$ptr_ty}}{}

  // Link returns a path to the object that this is a link to, or error
  // if you can not follow this path. Typically the incoming path ϟp
  // is a path to the atom and resulting path is a path to an object
  // identified by p. Once resolved the path will return a representation
  // of the value of the instance after the atom has executed.
  func (p {{$ptr_ty}}) Link(ϟctx context.Context, ϟp path.Node) (path.Node, error) {
    if cmd := path.FindCommand(ϟp); cmd != nil {
      return cmd.MemoryAfter(uint32(p.Pool), p.Address, 0), nil
    }
    return nil, nil
  }

  {{if not (GetAnnotation $ "replay_custom_value")}}
    func (p {{$ptr_ty}}) value(ϟb *builder.Builder, ϟa atom.Atom, ϟs *gfxapi.State) value.Pointer {
      if p.Address != 0 {
        {{if $el_is_ptr}}
          return value.PointerIndex(p.Address / uint64(ϟs.MemoryLayout.GetPointer().GetSize()))
        {{else}}
          return value.ObservedPointer(p.Address)
        {{end}}
      } else {
        return value.AbsolutePointer(0)
      }
    }
  {{end}}

{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits code for reading a slice of structures and remapping all of their
  elements.
-------------------------------------------------------------------------------
*/}}
{{define "ReadStructWithRemapping"}}
  {{AssertType $ "Class"}}
  {{if $.Fields}}
    s.ReserveMemory(ϟctx, ϟa, ϟs, ϟb)
    // Write out the entire structure, then over-write
    // any pointer fields.
    ϟb.Write(s.Range(ϟs.MemoryLayout), s.ResourceID(ϟctx, ϟs))
    d := s.Decoder(ϟctx, ϟs)
    base := value.ObservedPointer(s.base)
    // If there are no members, then lets not have Go complain
    // about unused variables.
    _ = d
    _ = base
    offset := uint64(0)
    _ = offset // Silence warnings for objects with no fields
  {{end}}
  for i := uint64(0); i < s.count; i++ {
    {{Template "ReadStructFieldsWithRemapping" $}}
  }
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits remapping code for all of the elements in a structure.
-------------------------------------------------------------------------------
*/}}
{{define "ReadStructFieldsWithRemapping"}}
  {{AssertType $ "Class"}}
  {{/* TODO: Handle member alignment here */}}
  {{range $f := $.Fields}}
    {
      required_alignment := {{Template "Go.AlignmentOf" (TypeOf $f)}}
      if (offset % required_alignment != 0) {
          extra_reads := required_alignment - (offset % required_alignment)
          offset += extra_reads
          for i := uint64(0); i < extra_reads; i++ {
            if binary.ReadUint(d, 8); d.Error() != nil {
              panic(d.Error())
            }
            base += value.ObservedPointer(1)
          }
      }
      {{if IsPointer ($f.Type | Underlying)}}
          offset += {{Template "Go.SizeOf" (TypeOf $f)}}
          i := binary.ReadUint(d, ϟs.MemoryLayout.GetPointer().GetSize()*8)
          v := New{{Macro "Go.Type" $f}}(i).value(ϟb, ϟa, ϟs)
          ϟb.Push(v)
          ϟb.Store(base)
          base += value.ObservedPointer(ϟs.MemoryLayout.GetPointer().GetSize())
      {{else if IsClass ($f.Type | Underlying)}}
          {{Template "ReadStructFieldsWithRemapping" $f.Type}}
      {{else}}
        offset += {{Template "Go.SizeOf" (TypeOf $f)}}
        var v {{Macro "Go.Type" $f}}
        {{Template "Go.Decode" "Name" "v" "Type" $f.Type "ErrHandler" "panic(d.Error())"}}
        {{if GetAnnotation $f.Type "replay_remap"}}
          if key, remap := v.remap(ϟa, ϟs); remap {
            loadRemap(ϟb, key, {{Template "Go.Replay.Type" $f.Type}}, {{Template "Go.Replay.Value" "Type" $f.Type "Name" "v"}})
            ϟb.Store(base)
          }
        {{else}}
          var _ = v
          // We don't actually have to write the type here since we wrote
          // the entire range, we just need to keep the decoder in sync.
        {{end}}
        base += value.ObservedPointer({{Template "Go.SizeOf" $f.Type}})
      {{end}}
    }
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the Slice type or indirect
  type (Pseudonym) to Slice.
-------------------------------------------------------------------------------
*/}}
{{define "Slice"}}
  {{AssertType $ "Slice" "Pseudonym"}}

  {{$s          := $ | Underlying | Unpack                 }}
  {{$slice_ty   := Macro "Go.Type"   $                     }}
  {{$ptr_ty     := Macro "Go.Type"   $s.Pointer            }}
  {{$el_ty      := Macro "Go.Type"   $s.To                 }}
  {{$el_size    := Macro "Go.SizeOf" $s.To                 }}
  {{$el_is_char := IsChar    ($s.To | Underlying | Unpack) }}
  {{$el_is_void := IsVoid    ($s.To | Underlying | Unpack) }}
  {{$el_is_ptr  := IsPointer ($s.To | Underlying | Unpack) }}
  {{$el_is_class := IsClass  ($s.To | Underlying | Unpack) }}

  // {{$slice_ty}} is a slice of {{$el_ty}}.
  type {{$slice_ty}} struct {
    root  uint64        // Original pointer this slice derives from.
    base  uint64        // Address of first element.
    count uint64        // Number of elements in the slice.
    pool  memory.PoolID // The pool identifier.
  }

  {{if $el_is_char}}
    // Make{{$slice_ty}}FromString returns a {{$slice_ty}} backed by a new
    // memory pool containing a copy of str.
    func Make{{$slice_ty}}FromString(str string, ϟs *gfxapi.State) {{$slice_ty}} {
      pool := &memory.Pool{}
      pool.Write(0, memory.Blob([]byte(str)))
      id := ϟs.NextPoolID
      ϟs.Memory[id] = pool
      ϟs.NextPoolID++
      return {{$slice_ty}}{ count: uint64(len(str)), pool: id }
    }
  {{end}}

  // Make{{$slice_ty}} returns a {{$slice_ty}} backed by a new memory pool.
  func Make{{$slice_ty}}(count uint64, ϟs *gfxapi.State) {{$slice_ty}} {
    id := ϟs.NextPoolID
    ϟs.Memory[id] = &memory.Pool{}
    ϟs.NextPoolID++
    return {{$slice_ty}}{ count: count, pool: id }
  }

  // Clone returns a copy of the {{$slice_ty}} in a new memory pool.
  func (s {{$slice_ty}}) Clone(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {{$slice_ty}} {
    s.OnRead(ϟctx, ϟa, ϟs, ϟb)
    pool := &memory.Pool{}
    pool.Write(0, ϟs.Memory[s.pool].Slice(s.Range(ϟs.MemoryLayout)))
    id := ϟs.NextPoolID
    ϟs.Memory[id] = pool
    ϟs.NextPoolID++
    dst := {{$slice_ty}}{ count: s.count, pool: id }
    return dst
  }

	// Root returns the original pointer this slice derives from.
	func (s {{$slice_ty}}) Root() uint64 { return s.root }

	// Base returns the address of first element.
	func (s {{$slice_ty}}) Base() uint64 { return s.base }

	// Count returns the number of elements in the slice.
	func (s {{$slice_ty}}) Count() uint64 { return s.count }

	// Pool returns the the pool identifier.
	func (s {{$slice_ty}}) Pool() memory.PoolID { return s.pool }

  // ElementSize returns the size in bytes of an element that {{$slice_ty}} points to.
  func (s {{$slice_ty}}) ElementSize(ϟl *device.MemoryLayout) uint64 {
    {{if $el_is_ptr}}
      if s.pool == memory.ApplicationPool {
        return uint64(ϟl.GetPointer().GetSize())
      } else {
        return 12
      }
    {{else}}
      return {{Template "Go.SizeOf" $s.To}}
    {{end}}
  }

  // ElementTypeName returns the name of the type of element in {{$slice_ty}}.
  func (s {{$slice_ty}}) ElementTypeName() string {
    return "{{Replace "ᵖ" "*" (Replace "ᶜ" "" $el_ty)}}"
  }

  // Range returns the memory range this slice represents in the underlying pool.
  func (s {{$slice_ty}}) Range(ϟl *device.MemoryLayout) memory.Range {
    return memory.Range{Base: s.base, Size: s.count * s.ElementSize(ϟl) }
  }

  // ResourceID returns an identifier to a resource representing the data of
  // this slice.
  func (s {{$slice_ty}}) ResourceID(ϟctx context.Context, ϟs *gfxapi.State) id.ID {
    id, err := ϟs.Memory[s.pool].Slice(s.Range(ϟs.MemoryLayout)).ResourceID(ϟctx)
    if err != nil {
      panic(err)
    }
    return id
  }

  // Decoder returns a memory decoder for the slice.
  func (s {{$slice_ty}}) Decoder(ϟctx context.Context, ϟs *gfxapi.State) binary.Reader {
    return ϟs.MemoryDecoder(ϟctx, ϟs.Memory[s.pool].Slice(s.Range(ϟs.MemoryLayout)))
  }

  // Encoder returns a memory encoder for the slice.
  func (s {{$slice_ty}}) Encoder(ϟs *gfxapi.State) binary.Writer {
    return ϟs.MemoryEncoder(ϟs.Memory[s.pool], s.Range(ϟs.MemoryLayout))
  }

  {{if not $el_is_void}}
    // As{{$slice_ty}} returns s cast to a {{$slice_ty}}.
    // The returned slice length will be calculated so that the returned slice is
    // no longer (in bytes) than s.
    func As{{$slice_ty}}(s memory.Slice, ϟl *device.MemoryLayout) {{$slice_ty}} {
      out := {{$slice_ty}}{
        root: s.Root(),
        base: s.Base(),
        pool: s.Pool(),
      }
      out.count = (s.Count() * s.ElementSize(ϟl)) / out.ElementSize(ϟl)
      return out
    }

    // Read reads and returns all the {{$el_ty}} elements in this {{$slice_ty}}.
    func (s {{$slice_ty}}) Read(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) []{{$el_ty}} {
      d, res, ϟl := s.Decoder(ϟctx, ϟs), make([]{{$el_ty}}, s.count), ϟs.MemoryLayout
      _ = ϟl
      s.OnRead(ϟctx, ϟa, ϟs, ϟb)
      for i := range res {
        {{if $el_is_ptr}}
          if s.pool == memory.ApplicationPool {
            ptr := binary.ReadUint(d, ϟl.GetPointer().GetSize()*8)
            if d.Error() != nil {
              panic(d.Error())
            }
            res[i] = New{{$el_ty}}(ptr)
          } else {
        {{else if $el_is_class}}
          if s.pool == memory.ApplicationPool {
            {{$el_ty}}DecodeRaw(ϟl, d, &res[i])
            if d.Error() != nil {
              panic(d.Error())
            }
          } else {
        {{end}}
        {{Template "Go.Decode" "Name" "res[i]" "Type" $s.To "ErrHandler" "panic(d.Error())"}}
        {{if $el_is_ptr}} } {{end}}
        {{if $el_is_class}} } {{end}}
      }
      return res
    }

    // Write copies elements from src to this slice. The number of elements copied is returned
    // which is the minimum of s.count and len(src).
    func (s {{$slice_ty}}) Write(ϟctx context.Context, src []{{$el_ty}}, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) uint64 {
      count, ϟl := min(s.count, uint64(len(src))), ϟs.MemoryLayout
      s = s.Slice(0, count, ϟl)
      e := s.Encoder(ϟs)
      for i := uint64(0); i < count; i++ {
        {{if $el_is_ptr}}
          if s.pool == memory.ApplicationPool {
            if binary.WriteUint(e, ϟl.GetPointer().GetSize()*8, src[i].Address); e.Error() != nil {
              panic(e.Error())
            }
          } else {
        {{else if $el_is_class}}
          if s.pool == memory.ApplicationPool {
            {{$el_ty}}EncodeRaw(ϟl, e, &src[i])
            if e.Error() != nil {
              panic(e.Error())
            }
          } else {
        {{end}}
        {{Template "Go.Encode" "Name" "src[i]" "Type" $s.To "ErrHandler" "panic(e.Error())"}}
        {{if $el_is_ptr}} } {{end}}
        {{if $el_is_class}} } {{end}}
      }
      s.OnWrite(ϟctx, ϟa, ϟs, ϟb)
      return count
    }

    // Copy copies elements from src to this slice.
    // The number of elements copied is the minimum of dst.Count and src.Count.
    // The slices of this and dst to the copied elements is returned.
    func (dst {{$slice_ty}}) Copy(ϟctx context.Context, src {{$slice_ty}}, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) (d, s {{$slice_ty}}) {
      count := min(dst.count, src.count)
      dst, src = dst.Slice(0, count, ϟs.MemoryLayout), src.Slice(0, count, ϟs.MemoryLayout)
    {{if $el_is_ptr}}
      if (dst.pool == memory.ApplicationPool) != (src.pool == memory.ApplicationPool) {
        dst.Write(ϟctx, src.Read(ϟctx, ϟa, ϟs, ϟb), ϟa, ϟs, ϟb) // Element-wise copy so we can convert u64 <-> {{$ptr_ty}}
      } else {
    {{end}}
      src.OnRead(ϟctx, ϟa, ϟs, ϟb)
      ϟs.Memory[dst.pool].Write(dst.base, ϟs.Memory[src.pool].Slice(src.Range(ϟs.MemoryLayout)))
      dst.OnWrite(ϟctx, ϟa, ϟs, ϟb)
    {{if $el_is_ptr}} } {{end}}
      return dst, src
    }

    // Contains returns true if the slice contains the specified value.
    func (s {{$slice_ty}}) Contains(ϟctx context.Context, val {{$el_ty}}, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) bool {
      for _, e := range s.Read(ϟctx, ϟa, ϟs, ϟb) {
        if e == val {
          return true
        }
      }
      return false
    }

  {{end}}

  // OnRead calls the backing pool's OnRead callback. s is returned so calls can be chained.
  func (s {{$slice_ty}}) OnRead(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {{$slice_ty}} {
    ϟl := ϟs.MemoryLayout
    if f := ϟs.Memory[s.pool].OnRead; f != nil {
      f(s.Range(ϟl))
    }
    if ϟb != nil && s.pool == memory.ApplicationPool {
      {{if IsPointer ($s.To | Underlying)}}
        {{/* Pointers need remapping to replay addresses.
             Pointer sizes may vary between capture and replay.
             To handle this, we store pointers in a separate table and refer to
             these using pointer indices.
        */}}
        d, dst := s.Decoder(ϟctx, ϟs), value.PointerIndex(s.base / uint64(ϟl.GetPointer().GetSize()))
        for i := uint64(0); i < s.count; i++ {
          {{if (GetAnnotation $s.To "replay_remap")}}{{Error "Remappings of pointers not implemented"}}{{end}}
          i := binary.ReadUint(d, ϟl.GetPointer().GetSize()*8)
          ptr := New{{$el_ty}}(i).value(ϟb, ϟa, ϟs)
          ϟb.StorePointer(dst, ptr)
          dst++
        }
        if d.Error() != nil { panic(d.Error()) }
      {{else if IsClass ($s.To | Underlying)}}
          {{Template "ReadStructWithRemapping" $s.To}}
      {{else}}
        s.ReserveMemory(ϟctx, ϟa, ϟs, ϟb)
        {{if (GetAnnotation $s.To "replay_remap")}}
          {{/* Element type has explicitly stated it needs custom remapping */}}
          ptr, step, d := value.ObservedPointer(s.base), value.ObservedPointer(s.ElementSize(ϟl)), s.Decoder(ϟctx, ϟs)
          for i := uint64(0); i < s.count; i++ {
            var v {{$el_ty}}
            {{Template "Go.Decode" "Name" "v" "Type" $s.To "ErrHandler" "panic(d.Error())"}}
            if key, remap := v.remap(ϟa, ϟs); remap {
              loadRemap(ϟb, key, {{Template "Go.Replay.Type" $s.To}}, {{Template "Go.Replay.Value" "Type" $s.To "Name" "v"}})
            } else {
              ϟb.Push({{Template "Go.Replay.Value" "Type" $s.To "Name" "v"}})
            }
            ϟb.Store(ptr)
            ptr += step
          }
        {{else}}
          ϟb.Write(s.Range(ϟl), s.ResourceID(ϟctx, ϟs))
        {{end}}
      {{end}}
    }
    return s
  }

  // OnWrite calls the backing pool's OnWrite callback. s is returned so calls can be chained.
  func (s {{$slice_ty}}) OnWrite(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {{$slice_ty}} {
    ϟl := ϟs.MemoryLayout
    if f := ϟs.Memory[s.pool].OnWrite; f != nil {
      f(s.Range(ϟl))
    }
    if ϟb != nil && s.pool == memory.ApplicationPool {
      ϟb.ReserveMemory(memory.Range{Base: s.root, Size: uint64(s.Range(ϟl).End() - s.root)})
      {{if (GetAnnotation $s.To "replay_remap")}}
        {{/* Element type has explicitly stated it needs custom remapping */}}
        size := s.ElementSize(ϟl)
        ptr, step, d := value.ObservedPointer(s.base), value.ObservedPointer(size), s.Decoder(ϟctx, ϟs)
        for i := uint64(0); i < s.count; i++ {
          var v {{$el_ty}}
          {{Template "Go.Decode" "Name" "v" "Type" $s.To "ErrHandler" "panic(d.Error())"}}
          if key, remap := v.remap(ϟa, ϟs); remap {
            dst, found := ϟb.Remappings[key]
            if !found {
              dst = ϟb.AllocateMemory(size)
              ϟb.Remappings[key] = dst
            }
            ϟb.Load({{Template "Go.Replay.Type" $s.To}}, ptr)
            ϟb.Store(dst)
          }
          ptr += step
        }
      {{end}}
    }
    return s
  }

  func (s {{$slice_ty}}) ReserveMemory(ϟctx context.Context, ϟa atom.Atom, ϟs *gfxapi.State, ϟb *builder.Builder) {{$slice_ty}} {
    if ϟb != nil && s.pool == memory.ApplicationPool {
      rng := s.Range(ϟs.MemoryLayout)
      ϟb.ReserveMemory(memory.Range{Base: s.root, Size: uint64(rng.End() - s.root)})
    }
    return s
  }

  // Index returns a {{$ptr_ty}} to the i'th element in this {{$slice_ty}}.
  func (s {{$slice_ty}}) Index(i uint64, ϟl *device.MemoryLayout) {{$ptr_ty}} {
    return {{$ptr_ty}}{ Address: s.base + i * s.ElementSize(ϟl), Pool: s.pool }
  }

  // Slice returns a sub-slice from the {{$slice_ty}} using start and end indices.
  func (s {{$slice_ty}}) Slice(start, end uint64, ϟl *device.MemoryLayout) {{$slice_ty}} {
    if start > end {
      panic(fmt.Errorf("%v.Slice start (%d) is greater than the end (%d)", s, start, end))
    }
    if end > s.count {
      panic(fmt.Errorf("%v.Slice(%d, %d) - out of bounds", s, start, end))
    }
    return {{$slice_ty}}{root: s.root, base: s.base + start * s.ElementSize(ϟl), count: end-start, pool: s.pool}
  }

  // String returns a string description of the {{$slice_ty}} slice.
  func (s {{$slice_ty}}) String() string {
    return fmt.Sprintf("{{$el_ty}}(%v@%v)[%d]", s.base, s.pool, s.count)
  }

  // Check interface conformance
  var _ path.Linker = {{$slice_ty}}{}

  // Link returns a path which can be used to view memory which is referenced
  // by the slice s.
  // If nil, nil is returned then the path cannot be followed.
  func (s {{$slice_ty}}) Link(ϟctx context.Context, ϟp path.Node) (path.Node, error) {
    if cmd := path.FindCommand(ϟp); cmd != nil {
      c, err := capture.ResolveFromPath(ϟctx, cmd.Capture)
      if err != nil {
        return nil, err
      }
      ϟs := c.NewState()
      return cmd.MemoryAfter(uint32(s.pool), s.base, s.count * s.ElementSize(ϟs.MemoryLayout)), nil
    }
    return nil, nil
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified static array.
-------------------------------------------------------------------------------
*/}}
{{define "StaticArray"}}
  {{AssertType $ "StaticArray"}}
  type {{$.Name}} [{{$.Size}}]{{Template "Go.Type" $.ValueType}}
  func (s {{$.Name}}) Len() int { return {{$.Size}} }
  func (s {{$.Name}}) Range() [{{$.Size}}]{{Template "Go.Type" $.ValueType}} { return s}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits non-empty if the specified item can be sorted in Go using '<'.
-------------------------------------------------------------------------------
*/}}

{{define "IsSortable"}}
  {{AssertType $ "Type"}}
  {{     if IsPseudonym     $}}{{Macro "IsSortable" $.To}}
  {{else if IsBool          $}}true
  {{else if IsInt           $}}true
  {{else if IsUint          $}}true
  {{else if IsChar          $}}true
  {{else if IsU8            $}}true
  {{else if IsS8            $}}true
  {{else if IsU16           $}}true
  {{else if IsS16           $}}true
  {{else if IsF32           $}}true
  {{else if IsU32           $}}true
  {{else if IsS32           $}}true
  {{else if IsF64           $}}true
  {{else if IsU64           $}}true
  {{else if IsS64           $}}true
  {{else if IsString        $}}true
  {{else if IsEnum          $}}true
  {{else}}
  {{end}}
{{end}}

{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified map.
-------------------------------------------------------------------------------
*/}}
{{define "Map"}}
  {{AssertType $ "Map"}}
  {{$name  := $.Name}}
  {{$key   := Macro "Go.Type" $.KeyType}}
  {{$value := Macro "Go.Type" $.ValueType}}

  type {{$name}} map[{{$key}}]{{$value}}

  func (m {{$name}}) Get(key {{$key}}) {{$value}} {
    {{if $init := Macro "Go.DefaultInitialValue" $.ValueType}}
      v, ok := m[key]
      if !ok {
        v = {{$init}}
      }
      return v
    {{else}}
      return m[key]
    {{end}}
  }

  func (m {{$name}}) Contains(key {{$key}}) bool {
    _, ok := m[key]
    return ok
  }

  func (m {{$name}}) Delete(key {{$key}}) {
    delete(m, key)
  }

  func (m {{$name}}) Range() []{{$value}} {
    values := make([]{{$value}}, 0, len(m))
    for _, value := range m {
      values = append(values, value)
    }
    return values
  }

  {{$sorted := (print $name "_SortKeys")}}
  type {{$sorted}} []{{$key}}

  func (s {{$sorted}}) Len() int           { return len(s) }
  func (s {{$sorted}}) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

  {{if Macro "IsSortable" $.KeyType}}
    func (s {{$sorted}}) Less(i, j int) bool { return s[i] < s[j] }
  {{else}}
    // Not naturally sorted {{$key}}, using fmt.Sprint
    func (s {{$sorted}}) Less(i, j int) bool { return fmt.Sprint(s[i]) < fmt.Sprint(s[j]) }
  {{end}}

  func (m {{$name}}) KeysSorted() []{{$key}} {
    s := make({{$sorted}}, len(m))
    i := 0
    for k, _ := range m {
      s[i] = k
      i++
    }
    sort.Sort(s)
    return s
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a the tags for the given command parameter.
-------------------------------------------------------------------------------
*/}}
{{define "CommandParameterTags"}}
  {{AssertType $ "Parameter"}}

  {{$cs := ConstantSetIndex $}}

  `§
  {{if $.IsReturn}}
    result:"true"§
  {{else}}
    param:"{{$.Name}}"§
  {{end}}
  {{if ge $cs 0}}§
    •constset:"{{$cs}}"§
  {{end}}§
  `
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified command.
-------------------------------------------------------------------------------
*/}}
{{define "CommandEntry"}}
  {{AssertType $.Command "Function"}}
  {{$name       := $.Command | GoCommandName}}
  {{$ret        := not (IsVoid $.Command.Return.Type)}}
  {{$isDrawCall := GetAnnotation $.Command "DrawCall"}}
  {{$isPFN      := GetAnnotation $.Command "pfn"}}
  {{if not $isPFN}}
    {{template "Go.CommentHeader" $name}}

    type {{$name}} struct {
      extras atom.Extras
      {{range $p := $.Command.FullParameters}}
        {{$p | GoPublicName}} {{Template "Go.Type" $p}} {{Template "CommandParameterTags" $p}}
      {{end}}
    }

    func (ϟa *{{$name}}) AtomName() string { return "{{$.Command | CommandName}}" }

    func (ϟa *{{$name}}) String() string {
      return fmt.Sprintf("{{$.Command | CommandName}}(§
        {{range $i, $p := $.Command.CallParameters}}
          {{if $i}}, §{{end}}
          {{$p.Name}}: %v§
        {{end}}
        ){{if $ret}} → %v{{end}}",§
        {{range $i, $p := $.Command.CallParameters}}
          {{Template "Go.Parameter" $p}}, §
        {{end}}
        {{if $ret}}ϟa.Result§{{end}}
      )
    }

    // AddRead appends a new read observation to the atom of the range rng with
    // the data id.
    // The {{$name}} pointer is returned so that calls can be chained.
    func (ϟa *{{$name}}) AddRead(rng memory.Range, id id.ID) *{{$name}} {
      ϟa.extras.GetOrAppendObservations().AddRead(rng, id)
      return ϟa
    }

    // AddWrite appends a new write observation to the atom of the range rng with
    // the data id.
    // The {{$name}} pointer is returned so that calls can be chained.
    func (ϟa *{{$name}}) AddWrite(rng memory.Range, id id.ID) *{{$name}} {
      ϟa.extras.GetOrAppendObservations().AddWrite(rng, id)
      return ϟa
    }

    func (ϟa *{{$name}}) API() gfxapi.API { return API() }
    func (ϟa *{{$name}}) AtomFlags() atom.Flags { return 0 §
        {{if GetAnnotation $.Command "DrawCall"}} | atom.DrawCall §{{end}}
        {{if GetAnnotation $.Command "EndOfFrame"}} | atom.EndOfFrame §{{end}}
        {{if GetAnnotation $.Command "UserMarker"}} | atom.UserMarker §{{end}}
        {{if GetAnnotation $.Command "PushUserMarker"}} | atom.PushUserMarker §{{end}}
        {{if GetAnnotation $.Command "PopUserMarker"}} | atom.PopUserMarker §{{end}}
    }
    func (ϟa *{{$name}}) Extras() *atom.Extras { return &ϟa.extras }
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified class.
-------------------------------------------------------------------------------
*/}}
{{define "Class"}}
  {{AssertType $ "Class"}}
  {{template "Go.CommentHeader" print "class " $.Name }}
  {{if GetAnnotation $ "Interface"}}
    type {{$.Name}} interface {
      {{Template "ClassInterface" $}}
    }
  {{else}}
    type {{$.Name}} struct {
      {{Template "ClassFields" $}}
      {{/* TODO: Remove this once closure support is in the API language */}}
      {{if (eq $.Name "CommandBufferObject")}}
        Commands CommandBufferCommands `disable:"true"`
      {{end}}
    }

    {{if not (GetAnnotation $ "internal")}}
      func {{$.Name}}Size(ϟl *device.MemoryLayout) uint64 {
        size := uint64(0)
        alignment := uint64(1)
        {{range $v := $.Fields}}
          {
            size, alignment = u64.AlignToNextAndReturnLargestAlignment(size, {{Template "Go.AlignmentOf" (TypeOf $v)}}, alignment)
            size += {{Template "Go.SizeOf" (TypeOf $v)}}
          }
        {{end}}
        if (size % alignment != 0) {
          size += alignment - (size % alignment)
        }
        return size
      }

      func {{$.Name}}Alignment(ϟl *device.MemoryLayout) uint64 {
        alignment := uint64(1)
        {{range $v := $.Fields}}
          {
            required_alignment := {{Template "Go.AlignmentOf" (TypeOf $v)}}
            if (required_alignment > alignment) {
              alignment = required_alignment
            }
          }
        {{end}}
        return alignment
      }

      func (c {{$.Name}}) Encode(ϟl *device.MemoryLayout, e binary.Writer) {
        {{range $v := $.Fields}}
          {{Template "Go.Encode" "Name" (print "c." (Title $v.Name)) "Type" $v.Type "ErrHandler" "panic(e.Error())"}}
        {{end}}
      }

      func (c *{{$.Name}}) Decode(ϟl *device.MemoryLayout, d binary.Reader) {
        {{range $v := $.Fields}}
          {{Template "Go.Decode" "Name" (print "c." (Title $v.Name)) "Type" $v.Type "ErrHandler" "panic(d.Error())"}}
        {{end}}
      }

      // {{$.Name}}DecodeRaw decodes a structure as it would have been stored
      // in memory by the traced application. This means native-width pointers
      // and aligned member variables.
      func {{$.Name}}DecodeRaw(ϟl *device.MemoryLayout, d binary.Reader, o *{{$.Name}}) {
        offset := uint64(0)
        _ = offset // Silence warnings for objects with no fields
        {{range $v := $.Fields}}
          {
            newOffset, _ := u64.AlignToNextAndReturnLargestAlignment(offset, {{Template "Go.AlignmentOf" (TypeOf $v)}}, 0)
            offset = offset + binary.ConsumeBytes(d, newOffset - offset) + {{Template "Go.SizeOf" (TypeOf $v)}}
          }
          {{if IsPointer $v.Type}}
            if ϟv := binary.ReadUint(d, ϟl.GetPointer().GetSize()*8); d.Error() == nil { o.{{Title $v.Name}} = {{$v.Type.Name}}(memory.Pointer{Address: ϟv, Pool: memory.ApplicationPool}) } else { panic(d.Error()) }
          {{else if IsClass $v.Type}}
            {{$el_ty := Macro "Go.Type"   $v.Type}}
            {{$el_ty}}DecodeRaw(ϟl, d, &o.{{Title $v.Name}})
          {{else}}
            {{Template "Go.Decode" "Name" (print "o." (Title $v.Name)) "Type" $v.Type "ErrHandler" "panic(d.Error())"}}
          {{end}}
        {{end}}
      }
      func {{$.Name}}EncodeRaw(ϟl *device.MemoryLayout, e binary.Writer, o *{{$.Name}}) {
        offset := uint64(0)
        _ = offset // Silence warnings for objects with no fields
        {{range $v := $.Fields}}
          {
            required_alignment := {{Template "Go.AlignmentOf" (TypeOf $v)}}
            if (offset % required_alignment != 0) {
              extra_writes := required_alignment - (offset % required_alignment)
              offset += extra_writes
              for i := uint64(0); i < extra_writes; i++ {
                if binary.WriteUint(e, 8, 0); e.Error() != nil {
                  panic(e.Error())
                }
              }
            }
            offset += {{Template "Go.SizeOf" (TypeOf $v)}}
          }
          {{if IsPointer $v.Type}}
            if binary.WriteUint(e, ϟl.GetPointer().GetSize()*8, o.{{Title $v.Name}}.Address); e.Error() != nil { panic(e.Error()) }
          {{else if IsClass $v.Type}}
            {{$el_ty := Macro "Go.Type"   $v.Type}}
            {{$el_ty}}EncodeRaw(ϟl, e, &o.{{Title $v.Name}})
          {{else}}
            {{Template "Go.Encode" "Name" (print "o." (Title $v.Name)) "Type" $v.Type "ErrHandler" "panic(e.Error())"}}
          {{end}}
        {{end}}
      }
    {{end}}

    {{if GetAnnotation $ "resource"}}
      // OnCreate should be called immediately after the {{$.Name}} resource is created.
      func (c *{{$.Name}}) OnCreate(ϟs *gfxapi.State) *{{$.Name}} {
        if f := ϟs.OnResourceCreated; c.IsResource() && f != nil { f(c) }
        return c
      }

      // OnAccess should be called each time the {{$.Name}} resource is used.
      func (c *{{$.Name}}) OnAccess(ϟs *gfxapi.State) *{{$.Name}} {
        if f := ϟs.OnResourceAccessed; c.IsResource() && f != nil { f(c) }
        return c
      }
    {{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an interface declaration for the specified @interface class.
-------------------------------------------------------------------------------
*/}}
{{define "ClassInterface"}}
  {{AssertType $ "Class"}}
  {{range $v := $.Fields}}
    {{$type := TypeOf $v}}
    Get{{Title $v.Name}}() {{Template "Go.Type" $type}}
    Set{{Title $v.Name}}({{Template "Go.Type" $type}})
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a list of fields of the specified class.
-------------------------------------------------------------------------------
*/}}
{{define "ClassFields"}}
  {{AssertType $ "Class"}}
  {{range $v := $.Fields}}
    {{$cs := ConstantSetIndex $v}}
    {{Title $v.Name}} {{Template "Go.Type" $v}} {{if ge $cs 0}}`constset:"{{$cs}}"`{{end}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the default value for the specified type.
-------------------------------------------------------------------------------
*/}}
{{define "Default"}}
  {{     if IsBoolValue    $}}{{$}}
  {{else if IsNumericValue $}}{{$}}
  {{else if IsStringValue  $}}{{$}}
  {{else if IsEnumEntry    $}}{{$.Owner.Name}}_{{$.Name}}
  {{else if IsCast         $}}{{Template "Default" $.Object}}
  {{else}}{{Error "macro Default called with unsupported type: %T" $}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the implementation code for the specified class.
-------------------------------------------------------------------------------
*/}}
{{define "ClassImpl"}}
  {{AssertType $.Class "Class"}}
  {{AssertType $.Impl "string"}}
  {{range $v := $.Class.Fields}}
    {{$type := TypeOf $v}}
    {{$FType := Macro "Go.Type" $type}}
    func (i *{{$.Impl}}) Get{{$v.Name}}() {{$FType}} { return i.{{$v.Name}} }
    func (i *{{$.Impl}}) Set{{$v.Name}}(v {{$FType}}) { i.{{$v.Name}} = v }
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified enum.
-------------------------------------------------------------------------------
*/}}
{{define "Enum"}}
  {{AssertType $ "Enum"}}
  {{template "Go.CommentHeader" print "enum " $.Name }}
  type {{$.Name}} uint32

  {{Template "EnumConstants" "Enum" $ "Name" $.Name}}

  func (e {{$.Name}}) String() string {
    switch e {
      {{range $e := UniqueEnumKeys $}}
        case {{$.Name}}_{{$e.Name}}: return "{{$e.Name}}"
      {{end}}
    }
    return fmt.Sprintf("{{$.Name}}(%d)", e)
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a list of entries for the specified enum.
-------------------------------------------------------------------------------
*/}}
{{define "EnumConstants"}}
  {{AssertType $.Enum "Enum"}}
  {{AssertType $.Name "string"}}
   const (
     {{range $e := $.Enum.Entries}}
        {{$.Name}}_{{$e.Name}} = {{$.Name}}({{$e.Value}})
     {{end}}
   )
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration and implementation for the specified label group.
-------------------------------------------------------------------------------
*/}}
{{define "LabelsForLabeledType"}}
  {{if $.Labels}}
    {{template "Go.CommentHeader" print "Labels (named constants) for " $.Name }}

    {{Template "LabelConstants" "Labeled" $ "Name" $.Name}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a list of labels for the specified labeled type.
-------------------------------------------------------------------------------
*/}}
{{define "LabelConstants"}}
  {{AssertType $.Name "string"}}
  const (
     {{range $e := $.Labeled.Labels}}
        {{$.Name}}_{{$e.Name}} = {{$.Name}}({{Template "Go.ReadNoCast" $e.Value}})
     {{end}}
  )

  func (e {{$.Name}}) String() string {
    switch e {
      {{range $e := $.Labeled.Labels}}
        case {{$.Name}}_{{$e.Name}}: return "{{$e.Name}}"
      {{end}}
    }
    return fmt.Sprintf("{{$.Name}}(%d)", e)
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a type declaration for holding the state.
-------------------------------------------------------------------------------
*/}}
{{define "State"}}
  {{template "Go.CommentHeader" "State"}}
  type State struct {
    {{range $g := $.Globals}}
      {{Title $g.Name}} {{Template "Go.Type" $g}}
    {{end}}
  }

  func (g *State) Init() {
    {{range $g := $.Globals}}
      {{if $init := Macro "Go.DefaultInitialValue" $g.Type}}
        g.{{$g.Name}} = {{$init}}
      {{end}}
    {{end}}
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits a top-level type declaration for the specified API.
-------------------------------------------------------------------------------
*/}}
{{define "API"}}

  {{template "Go.CommentHeader" "API"}}
  var apiID = gfxapi.ID(id.OfString("{{Global "API"}}"))

  type api struct {}

  // Name returns "{{Global "API"}}".
  func (api) Name() string {
    return "{{Global "API"}}"
  }

  // ID returns the unique identifier of the {{Global "API"}} API.
  func (api) ID() gfxapi.ID {
    return apiID
  }

  // Index returns the Index of the {{Global "API"}} API.
  func (api) Index() uint8 {
    return uint8({{$.Index}})
  }

  func API() gfxapi.API {
    return api{}
  }
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the boolean expression testing for equality between LHS and RHS.
-------------------------------------------------------------------------------
*/}}
{{define "Equal"}}
  {{AssertType $.Type "Type"}}

  {{Template "BinaryOp" "Type" $.Type "LHS" $.LHS "RHS" $.RHS "Operator" "==" "Name" "Equal"}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the boolean expression that is true if LHS < RHS, otherwise false.
-------------------------------------------------------------------------------
*/}}
{{define "Less"}}
  {{AssertType $.Type "Type"}}

  {{if IsBool $.Type}}false
  {{else            }}{{Template "BinaryOp" "Type" $.Type "LHS" $.LHS "RHS" $.RHS "Operator" "<" "Name" "Less"}}
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits the binary expression for the given LHS and RHS types.
-------------------------------------------------------------------------------
*/}}
{{define "BinaryOp"}}
  {{AssertType $.Name     "string"}}
  {{AssertType $.Operator "string"}}
  {{AssertType $.Type     "Type"}}

  {{     if IsS8          $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsU8          $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsU16         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsS16         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsF32         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsU32         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsS32         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsF64         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsU64         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsS64         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsInt         $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsUint        $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsString      $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsEnum        $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else if IsPointer     $.Type}}{{$.LHS}} {{$.Operator}} {{$.RHS}}
  {{else                        }}{{$.LHS}}.{{$.Name}}({{$.RHS}})
  {{end}}
{{end}}


{{/*
-------------------------------------------------------------------------------
  Emits an Atom constructor for each command.
-------------------------------------------------------------------------------
*/}}
{{define "NewAtoms"}}
  {{AssertType $ "API"}}

  {{range $c := AllCommands $}}
    {{if not (GetAnnotation $c "pfn")}}
      {{$name := $c | GoCommandName}}
      func New{{$name}}(§
          {{range $p := $c.FullParameters}}
            {{if $p | TypeOf | Underlying | IsPointer}}
              {{Title $p.Name}} memory.Pointer,§
            {{else}}
              {{Title $p.Name}} {{Template "Go.Type" $p}},§
            {{end}}
          {{end}}
        ) *{{$name}} {
        return &{{$name}} {§
          {{range $p := $c.FullParameters}}
            {{if $p | TypeOf | Underlying | IsPointer}}
              {{$p | GoPublicName}}: {{Template "Go.Type" $p}}({{Title $p.Name}}),§
            {{else}}
              {{$p | GoPublicName}}: {{Title $p.Name}},§
            {{end}}
          {{end}}
        }
      }
    {{end}}
  {{end}}
{{end}}
