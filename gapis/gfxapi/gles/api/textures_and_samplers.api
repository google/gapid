// Copyright (C) 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

@internal
class TextureUnit {
  // Table 21.9: Textures (selector; state per texture unit)
  TextureId         Binding2d                 = 0
  TextureId         Binding3d                 = 0
  TextureId         Binding2dArray            = 0
  TextureId         BindingBuffer             = 0
  TextureId         BindingCubeMap            = 0
  TextureId         BindingCubeMapArray       = 0
  TextureId         Binding2dMultisample      = 0
  TextureId         Binding2dMultisampleArray = 0
  TextureId         BindingExternalOes        = 0 // OES_EGL_image_external
  @unused SamplerId SamplerBinding            = 0
}

@internal
@resource
class Texture {
  @unused TextureId         ID
  GLenum                    Kind
  map!(GLint, Level)        Levels

  // Table 21.10: Textures (state per texture object)
  GLenum         SwizzleR                = GL_RED
  GLenum         SwizzleG                = GL_GREEN
  GLenum         SwizzleB                = GL_BLUE
  GLenum         SwizzleA                = GL_ALPHA
  @unused Vec4f  BorderColor             = Vec4f(0.0, 0.0, 0.0, 0.0)
  GLenum         MinFilter               = GL_NEAREST_MIPMAP_LINEAR
  GLenum         MagFilter               = GL_LINEAR
  GLenum         WrapS                   = GL_REPEAT
  GLenum         WrapT                   = GL_REPEAT
  GLenum         WrapR                   = GL_REPEAT
  GLfloat        MinLod                  = -1000
  GLfloat        MaxLod                  = 1000
  GLint          BaseLevel               = 0
  GLint          MaxLevel                = 1000
  GLenum         DepthStencilTextureMode = GL_DEPTH_COMPONENT
  GLenum         CompareMode             = GL_NONE
  GLenum         CompareFunc             = GL_LEQUAL
  GLboolean      ImmutableFormat         = GL_FALSE
  @unused GLuint ImmutableLevels         = 0
  @unused string Label

  // EXT/texture_filter_anisotropic
  GLfloat MaxAnisotropy = 1.0

  // GL_OES_EGL_image
  // EGL image which is used as storage for this texture.
  // TODO: Standard glTex* methods which define new storage should clear this.
  @unused GLeglImageOES EGLImage
}

@internal
class Level {
  map!(GLint, ref!Image) Layers
}

@internal
class Image {
  GLsizei        Width
  GLsizei        Height
  // GPU format of the texture including bit-sizes of the channels.
  // This is unrelated to the format of the data passed to the API.
  GLenum         SizedFormat

  @internal u8[] Data
  // Tuple of (format, type) describing the Data field above.
  // This describes the format of the data the user passed in,
  // not the format of the data stored on the GPU (sizedFormat).
  // TODO: We should use the GPU format, but that needs conversions.
  // One of the following:
  //   (GL_NONE, GL_NONE) - No data was uploaded yet.
  //   (unsizedFormat, ty) - Uncompressed data.
  //   (sizedFormat, GL_NONE) - Compressed data.
  @unused GLenum DataFormat
  @unused GLenum DataType
}

@internal
class Sampler {
  // Table 21.12: Textures (state per sampler object)
  @unused Vec4f  BorderColor = Vec4f(0.0, 0.0, 0.0, 0.0)
  GLenum         MinFilter   = GL_NEAREST_MIPMAP_LINEAR
  GLenum         MagFilter   = GL_LINEAR
  GLenum         WrapS       = GL_REPEAT
  GLenum         WrapT       = GL_REPEAT
  GLenum         WrapR       = GL_REPEAT
  GLfloat        MinLod      = -1000
  GLfloat        MaxLod      = 1000
  GLenum         CompareMode = GL_NONE
  GLenum         CompareFunc = GL_LEQUAL
  @unused string Label

  // EXT/texture_filter_anisotropic
  GLfloat MaxAnisotropy = 1.0
}

@internal
class PixelStorageState {
  // Table 21.18: Pixels
  GLint UnpackImageHeight = 0
  GLint UnpackSkipImages  = 0
  GLint UnpackRowLength   = 0
  GLint UnpackSkipRows    = 0
  GLint UnpackSkipPixels  = 0
  GLint UnpackAlignment   = 4
  GLint PackImageHeight   = 0 // SPEC: Missing in state tables.
  GLint PackSkipImages    = 0 // SPEC: Missing in state tables.
  GLint PackRowLength     = 0
  GLint PackSkipRows      = 0
  GLint PackSkipPixels    = 0
  GLint PackAlignment     = 4
// GLuint PixelPackBufferBinding = 0
// GLuint PixelUnpackBufferBinding = 0
}

@internal
class ImageUnit {
  // Table 21.33: Image State (state per image unit)
  TextureId Name    = 0
  GLint     Level   = 0
  GLboolean Layered = GL_FALSE
  GLint     Layer   = 0
  GLenum    Access  = GL_READ_ONLY
  GLenum    Format  = GL_R32UI
}

// The spec maps cubemap faces to layers 0..5 in the exact order of GLenum values.
sub GLint CubemapFaceToLayer(GLenum target) {
  return switch (target) {
    case GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
         GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      as!GLint(target) - as!GLint(GL_TEXTURE_CUBE_MAP_POSITIVE_X)
    default:
      as!GLint(0)
  }
}

sub ref!Texture GetBoundTextureOrErrorInvalidEnum(GLenum target) {
  ctx := GetContext()
  return GetBoundTextureForUnit(ctx, ctx.ActiveTextureUnit, target)
}

sub ref!Texture GetBoundTextureForUnit(ref!Context ctx, GLenum unit, GLenum target) {
  // TODO: Add back version checks.
  tu := ctx.TextureUnits[unit]
  return switch (target) {
    case GL_TEXTURE_2D: {
      // minRequiredVersion(2, 0)
      switch (tu.Binding2d != 0) {
        case true:  ctx.SharedObjects.Textures[tu.Binding2d]
        case false: ctx.Objects.DefaultTextures.Texture2d
      }
    }
    case GL_TEXTURE_EXTERNAL_OES: {
      // minRequiredVersion(2, 0)
      switch (tu.BindingExternalOes != 0) {
        case true:  ctx.SharedObjects.Textures[tu.BindingExternalOes]
        case false: ctx.Objects.DefaultTextures.TextureExternalOes
      }
    }
    case GL_TEXTURE_2D_ARRAY: {
      // minRequiredVersion(3, 0)
      switch (tu.Binding2dArray != 0) {
        case true:  ctx.SharedObjects.Textures[tu.Binding2dArray]
        case false: ctx.Objects.DefaultTextures.Texture2dArray
      }
    }
    case GL_TEXTURE_2D_MULTISAMPLE: {
      // minRequiredVersion(3, 1)
      switch (tu.Binding2dMultisample != 0) {
        case true:  ctx.SharedObjects.Textures[tu.Binding2dMultisample]
        case false: ctx.Objects.DefaultTextures.Texture2dMultisample
      }
    }
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      // minRequiredVersion(3, 2)
      switch (tu.Binding2dMultisampleArray != 0) {
        case true:  ctx.SharedObjects.Textures[tu.Binding2dMultisampleArray]
        case false: ctx.Objects.DefaultTextures.Texture2dMultisampleArray
      }
    }
    case GL_TEXTURE_3D: {
      // minRequiredVersion(3, 0)
      switch (tu.Binding3d != 0) {
        case true:  ctx.SharedObjects.Textures[tu.Binding3d]
        case false: ctx.Objects.DefaultTextures.Texture3d
      }
    }
    case GL_TEXTURE_BUFFER: {
      // minRequiredVersion(3, 2)
      switch (tu.BindingBuffer != 0) {
        case true:  ctx.SharedObjects.Textures[tu.BindingBuffer]
        case false: ctx.Objects.DefaultTextures.TextureBuffer
      }
    }
    case GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      // minRequiredVersion(2, 0)
      switch (tu.BindingCubeMap != 0) {
        case true:  ctx.SharedObjects.Textures[tu.BindingCubeMap]
        case false: ctx.Objects.DefaultTextures.TextureCubeMap
      }
    }
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
      // minRequiredVersion(3, 2)
      switch (tu.BindingCubeMapArray != 0) {
        case true:  ctx.SharedObjects.Textures[tu.BindingCubeMapArray]
        case false: ctx.Objects.DefaultTextures.TextureCubeMapArray
      }
    }
    default: {
      // glErrorInvalidEnum(target)
      ctx.Objects.DefaultTextures.Texture2d
    }
  }
}

sub GLenum GetTextureTargetFromSamplerType(GLenum samplerType) {
	return switch (samplerType) {
	case GL_INT_SAMPLER_2D, GL_SAMPLER_2D, GL_UNSIGNED_INT_SAMPLER_2D, GL_SAMPLER_2D_SHADOW:
		GL_TEXTURE_2D
	case GL_INT_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, GL_SAMPLER_2D_ARRAY_SHADOW:
		GL_TEXTURE_2D_ARRAY
	case GL_INT_SAMPLER_2D_MULTISAMPLE, GL_SAMPLER_2D_MULTISAMPLE, GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:
		GL_TEXTURE_2D_MULTISAMPLE
	case GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY, GL_SAMPLER_2D_MULTISAMPLE_ARRAY, GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY:
		GL_TEXTURE_2D_MULTISAMPLE_ARRAY
	case GL_INT_SAMPLER_3D, GL_SAMPLER_3D, GL_UNSIGNED_INT_SAMPLER_3D:
		GL_TEXTURE_3D
	case GL_INT_SAMPLER_BUFFER, GL_SAMPLER_BUFFER, GL_UNSIGNED_INT_SAMPLER_BUFFER:
		GL_TEXTURE_BUFFER
	case GL_INT_SAMPLER_CUBE, GL_SAMPLER_CUBE, GL_UNSIGNED_INT_SAMPLER_CUBE, GL_SAMPLER_CUBE_SHADOW:
		GL_TEXTURE_CUBE_MAP
	case GL_INT_SAMPLER_CUBE_MAP_ARRAY, GL_SAMPLER_CUBE_MAP_ARRAY, GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY, GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW:
		GL_TEXTURE_CUBE_MAP_ARRAY
	case GL_SAMPLER_EXTERNAL_OES:
		GL_TEXTURE_EXTERNAL_OES
  default:
    GL_NONE
	}
}

sub SizedFormatInfo GetSizedFormatInfoOrEnumError(GLenum internalformat) {
  info := GetSizedFormatInfo(internalformat)
  if info.UnsizedFormat == GL_NONE {
    glErrorInvalidEnum(internalformat)
  }
  return info
}

sub SizedFormatInfo GetSizedFormatInfoOrValueError(GLint internalformat) {
  info := GetSizedFormatInfo(as!GLenum(internalformat))
  if info.UnsizedFormat == GL_NONE {
    glErrorInvalidValue()
  }
  return info
}

sub UnsizedFormatInfo GetUnsizedFormatInfoOrEnumError(GLenum format) {
  info := GetUnsizedFormatInfo(format)
  if info.Count == 0 {
    glErrorInvalidEnum(format)
  }
  return info
}

@internal
bitfield TexImageFlags {
  IsCompressedTexImageCmd = 1,
  IsCopyTexImageCmd = 2,
  IsTexImageCmd = 4,
  IsTexStorageCmd = 8,
  HasSubModifier = 16,
  Has3DModifier = 32,
  HasMultisampleModifier = 64,
}

// Uber-function to handle all texture image specification commands.
sub void TexImage(TexImageFlags  flags,
                  GLenum         target,
                  // Offsets
                  GLint          loffset,
                  GLint          xoffset,
                  GLint          yoffset,
                  GLint          zoffset,
                  // Dimensions
                  GLsizei        levels,
                  GLsizei        width,
                  GLsizei        height,
                  GLsizei        depth,
                  GLint          border,
                  // Format&data
                  GLenum         sized_format,
                  GLenum         data_format,
                  GLenum         data_type,
                  GLsizei        data_size,
                  TexturePointer data) {
  isCompressedTexImageCmd := IsCompressedTexImageCmd in flags
  isCopyTexImageCmd := IsCopyTexImageCmd in flags
  isTexImageCmd := IsTexImageCmd in flags
  isTexStorageCmd := IsTexStorageCmd in flags
  hasSubModifier := HasSubModifier in flags
  has3DModifier := Has3DModifier in flags
  hasMultisampleModifier := HasMultisampleModifier in flags

  sfBox := Image(SizedFormat: sized_format)

  // Check target
  if hasMultisampleModifier {
    if has3DModifier {
      if target != GL_TEXTURE_2D_MULTISAMPLE_ARRAY { glErrorInvalidEnum(target) }
    } else {
      if target != GL_TEXTURE_2D_MULTISAMPLE { glErrorInvalidEnum(target) }
    }
  } else {
    if has3DModifier {
      switch (target) {
        case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY: { }
        default: { glErrorInvalidEnum(target) }
      }
    } else {
      if isTexStorageCmd {
        switch (target) {
          case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: { }
          default: { glErrorInvalidEnum(target) }
        }
      } else {
        switch (target) {
          case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: { }
          default: { glErrorInvalidEnum(target) }
        }
      }
    }
  }
  t := GetBoundTextureOrErrorInvalidEnum(target)

  // Check offsets and sizes
  if loffset < 0 { glErrorInvalidValue() }
  if xoffset < 0 { glErrorInvalidValue() }
  if yoffset < 0 { glErrorInvalidValue() }
  if zoffset < 0 { glErrorInvalidValue() }
  if levels < 1 { glErrorInvalidValue() }
  if width < 0 { glErrorInvalidValue() }
  if height < 0 { glErrorInvalidValue() }
  if depth < 0 { glErrorInvalidValue() }
  if border != 0 { glErrorInvalidValue() }
  if data_size < 0 { glErrorInvalidValue() }
  switch target {
    case GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      if width != height { glErrorInvalidValue() }
    }
    default: { }
  }

  // Check the data_format and data_type
  if isTexImageCmd {
    _ = GetUnsizedFormatInfoOrEnumError(data_format)
    CheckTextureDataType(data_type)
  }

  // Check the sized_format
  if !hasSubModifier {
    if isTexImageCmd && as!GLenum(sized_format) == data_format {
      sf := GetSizedFormatFromTuple(data_format, data_type)
      if sf == GL_NONE { glErrorInvalidOperation() } // Invalid combination of format and type
      sfBox.SizedFormat = sf // Legacy - sized format is inferred from data format and type
    } else {
      sizedFormatInfo := GetSizedFormatInfoOrEnumError(sized_format)
      isCompressedFmt := sizedFormatInfo.Compression != Uncompressed
      if isCompressedTexImageCmd {
        if !isCompressedFmt { glErrorInvalidEnum(sized_format) } // Requires compressed format
      }
      if isCopyTexImageCmd || isTexImageCmd || hasMultisampleModifier {
        if isCompressedFmt { glErrorInvalidEnum(sized_format) } // Requires uncompressed format
      }
    }
  }

  // We need to do all checks before we start modifying state.
  cubemap_layer := CubemapFaceToLayer(target)
  for l in (0 .. as!GLint(levels)) {
    for z in (0 .. as!GLint(depth)) {
      if hasSubModifier {
        i := t.Levels[loffset + l].Layers[zoffset + z + cubemap_layer]
        if (i == null) { glErrorInvalidOperation() }
        if (as!GLsizei(xoffset) + width) > i.Width { glErrorInvalidValue() }
        if (as!GLsizei(yoffset) + height) > i.Height { glErrorInvalidValue() }
      }
    }
  }

  if isTexStorageCmd {
    t.Levels = Texture().Levels
    t.ImmutableFormat = GL_TRUE
  }

  ctx := GetContext()
  for l in (0 .. as!GLint(levels)) {
    tmpLevel := t.Levels[loffset + l]
    // Depth decreases with each level for 3D textures, but not for arrays.
    mipDepth := max!GLsizei(1, depth >> as!u32(l))
    for z in (0 .. as!GLint(Select!GLsizei(target == GL_TEXTURE_3D, mipDepth, depth))) {
      if !hasSubModifier {
        // Initialize the image with the provided parameters
        tmpLevel.Layers[zoffset + z + cubemap_layer] = new!Image(
          Width: max!GLsizei(1, width >> as!u32(l)),
          Height: max!GLsizei(1, height >> as!u32(l)),
          SizedFormat: sfBox.SizedFormat,
          DataFormat: data_format,
          DataType: data_type)
      }

      // Update the content of the image
      img := tmpLevel.Layers[zoffset + z + cubemap_layer]
      if isTexImageCmd {
        src_skip_images := Select!GLint(has3DModifier, ctx.PixelStorage.UnpackSkipImages, 0) + z
        UpdateImageData(img, xoffset, yoffset, width, height,
                        src_skip_images, data_format, data_type, data)
      } else if isCompressedTexImageCmd {
        if (ctx.BoundBuffers.PixelUnpackBuffer == 0) && (data != null) {
          // TODO: Implement sub-range updates
          img.Data = clone(as!u8*(data)[0:data_size])
        }
      }
    }
    t.Levels[loffset + l] = tmpLevel
  }
}

sub void UpdateImageData(ref!Image      dst_image,
                         GLint          dst_xoffset,
                         GLint          dst_yoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLint          src_skip_images,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  ctx := GetContext()
  opt := ctx.PixelStorage
  url := SelectNonZero!GLint(opt.UnpackRowLength, as!GLint(width))
  pixel_size := as!GLint(uncompressedPixelSize(format, type))

  src_row_size := Align!GLint(url * pixel_size, opt.UnpackAlignment)
  src_image_size := SelectNonZero!GLint(opt.UnpackImageHeight, as!GLint(height)) * src_row_size
  src_offset := (opt.UnpackSkipPixels * pixel_size) +
                (opt.UnpackSkipRows * src_row_size) +
                (src_skip_images * src_image_size)

  dst_row_size := as!GLint(dst_image.Width) * pixel_size
  dst_image_size := as!GLint(dst_image.Height) * dst_row_size
  dst_offset := (dst_xoffset * pixel_size) + (dst_yoffset * dst_row_size)

  // Initialize the buffer if we have not used the image before or
  // if the format changed to one with different size per texel.
  // TODO: Do this properly using data conversion.
  if len(dst_image.Data) != as!s32(dst_image_size) {
    dst_image.Data = make!u8(dst_image_size)
  }
  dst_image.DataFormat = format
  dst_image.DataType = type

  pbo := ctx.SharedObjects.Buffers[ctx.BoundBuffers.PixelUnpackBuffer]
  copy_size := as!GLint(width) * pixel_size
  for y in (0 .. as!GLint(height)) {
    dst := dst_offset + (dst_row_size * y)
    if pbo == null {
      src := src_offset + (src_row_size * y)
      copy(dst_image.Data[dst:dst + copy_size], as!u8*(data)[src:src + copy_size])
    } else {
      src := as!u64(data) + as!u64(src_offset + (src_row_size * y))
      assert((src + as!u64(copy_size)) <= len(pbo.Data))
      copy(dst_image.Data[dst:dst + copy_size], pbo.Data[src:src + as!u64(copy_size)])
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glActiveTexture.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glActiveTexture.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glActiveTexture.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glActiveTexture.xhtml", GLES32)
cmd void glActiveTexture(GLenum unit) {
  minRequiredVersion(1, 0)
  // TODO: Tidy this. This switch case is preserved for the snippet system.
  switch (unit) {
    case GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13,
        GL_TEXTURE14, GL_TEXTURE15, GL_TEXTURE16, GL_TEXTURE17, GL_TEXTURE18, GL_TEXTURE19,
        GL_TEXTURE2, GL_TEXTURE20, GL_TEXTURE21, GL_TEXTURE22, GL_TEXTURE23, GL_TEXTURE24,
        GL_TEXTURE25, GL_TEXTURE26, GL_TEXTURE27, GL_TEXTURE28, GL_TEXTURE29, GL_TEXTURE3,
        GL_TEXTURE30, GL_TEXTURE31, GL_TEXTURE4, GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7,
        GL_TEXTURE8, GL_TEXTURE9: {
      // version 2.0
    }
    default: {
      // Higher texture numbers are still valid, but they do not have GLenum entries.
    }
  }
  ctx := GetContext()
  if !unit in ctx.TextureUnits { glErrorInvalidEnum(unit) }
  ctx.ActiveTextureUnit = unit
}

@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindImageTexture.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindImageTexture.xhtml", GLES32)
cmd void glBindImageTexture(GLuint    unit,
                            TextureId texture,
                            GLint     level,
                            GLboolean layered,
                            GLint     layer,
                            GLenum    access,
                            GLenum    format) {
  minRequiredVersion(3, 1)
  switch (access) {
    case GL_READ_ONLY, GL_READ_WRITE, GL_WRITE_ONLY: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(access)
    }
  }
  switch (format) {
    case GL_R32F, GL_R32I, GL_R32UI, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI, GL_RGBA32F, GL_RGBA32I,
        GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI, GL_RGBA8_SNORM: {
      // version 3.1
    }
    default: {
      glErrorInvalidEnum(format)
    }
  }
  ctx := GetContext()
  ctx.ImageUnits[unit] = ImageUnit(
    Name:     texture,
    Level:    level,
    Layered:  layered,
    Layer:    layer,
    Access:   access,
    Format:   format
  )
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindSampler.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindSampler.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindSampler.xhtml", GLES32)
cmd void glBindSampler(GLuint index, SamplerId sampler) {
  minRequiredVersion(3, 0)
  ctx := GetContext()
  unit := as!GLenum(index + as!GLuint(GL_TEXTURE0))
  ctx.TextureUnits[unit].SamplerBinding = sampler
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindTexture.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glBindTexture.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glBindTexture.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glBindTexture.xhtml", GLES32)
cmd void glBindTexture(GLenum target, TextureId texture) {
  minRequiredVersion(1, 0)
  ctx := GetContext()

  // TODO: Do not initialize if the enum is not valid.
  if (texture != 0) {
    if !(texture in ctx.SharedObjects.Textures) {
      if target == GL_TEXTURE_EXTERNAL_OES {
        ctx.SharedObjects.Textures[texture] = new!Texture(
          ID:         texture,
          WrapS:      GL_CLAMP_TO_EDGE,
          WrapT:      GL_CLAMP_TO_EDGE,
          MinFilter:  GL_LINEAR)
      } else {
        ctx.SharedObjects.Textures[texture] = new!Texture(
          ID: texture,
        )
      }
    }

    t := ctx.SharedObjects.Textures[texture]
    if t.Kind == as!GLenum(0) {
      t.Kind = target
    } else {
      if t.Kind != target { glErrorInvalidOperation() }
    }
  }

  tu := ctx.TextureUnits[ctx.ActiveTextureUnit]
  switch (target) {
    case GL_TEXTURE_2D: {
      minRequiredVersion(2, 0)
      tu.Binding2d = texture
    }
    case GL_TEXTURE_EXTERNAL_OES: {
      minRequiredVersion(2, 0)
      tu.BindingExternalOes = texture
    }
    case GL_TEXTURE_2D_ARRAY: {
      minRequiredVersion(3, 0)
      tu.Binding2dArray = texture
    }
    case GL_TEXTURE_2D_MULTISAMPLE: {
      minRequiredVersion(3, 1)
      tu.Binding2dMultisample = texture
    }
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY: {
      minRequiredVersion(3, 2)
      tu.Binding2dMultisampleArray = texture
    }
    case GL_TEXTURE_3D: {
      minRequiredVersion(3, 0)
      tu.Binding3d = texture
    }
    case GL_TEXTURE_BUFFER: {
      minRequiredVersion(3, 2)
      tu.BindingBuffer = texture
    }
    case GL_TEXTURE_CUBE_MAP: {
      minRequiredVersion(2, 0)
      tu.BindingCubeMap = texture
    }
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
      minRequiredVersion(3, 2)
      tu.BindingCubeMapArray = texture
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCompressedTexImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexImage2D.xhtml", GLES32)
cmd void glCompressedTexImage2D(GLenum         target,
                                GLint          level,
                                GLenum         internalformat,
                                GLsizei        width,
                                GLsizei        height,
                                GLint          border,
                                GLsizei        image_size,
                                TexturePointer data) {
  minRequiredVersion(1, 0)
  TexImage(IsCompressedTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexImage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexImage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexImage3D.xhtml", GLES32)
cmd void glCompressedTexImage3D(GLenum         target,
                                GLint          level,
                                GLenum         internalformat,
                                GLsizei        width,
                                GLsizei        height,
                                GLsizei        depth,
                                GLint          border,
                                GLsizei        image_size,
                                TexturePointer data) {
  minRequiredVersion(3, 0)
  CompressedTexImage3D(target, level, internalformat, width, height, depth, border, image_size, data)
}

sub void CompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei image_size, TexturePointer data) {
  TexImage(IsCompressedTexImageCmd | Has3DModifier, target,
           level, 0, 0, 0, // Offsets
           1, width, height, depth, border, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCompressedTexSubImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexSubImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexSubImage2D.xhtml", GLES32)
cmd void glCompressedTexSubImage2D(GLenum         target,
                                   GLint          level,
                                   GLint          xoffset,
                                   GLint          yoffset,
                                   GLsizei        width,
                                   GLsizei        height,
                                   GLenum         internalformat,
                                   GLsizei        image_size,
                                   TexturePointer data) {
  minRequiredVersion(1, 0)
  TexImage(IsCompressedTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCompressedTexSubImage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCompressedTexSubImage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCompressedTexSubImage3D.xhtml", GLES32)
cmd void glCompressedTexSubImage3D(GLenum         target,
                                   GLint          level,
                                   GLint          xoffset,
                                   GLint          yoffset,
                                   GLint          zoffset,
                                   GLsizei        width,
                                   GLsizei        height,
                                   GLsizei        depth,
                                   GLenum         internalformat,
                                   GLsizei        image_size,
                                   TexturePointer data) {
  minRequiredVersion(3, 0)
  CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, internalformat, image_size, data)
}

sub void CompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum internalformat, GLsizei image_size, TexturePointer data) {
  TexImage(IsCompressedTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, depth, 0, // Dimensions
           internalformat, internalformat, GL_NONE, image_size, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyImageSubData.xhtml", GLES32)
cmd void glCopyImageSubData(SrcImageId srcName,
                            GLenum     srcTarget,
                            GLint      srcLevel,
                            GLint      srcX,
                            GLint      srcY,
                            GLint      srcZ,
                            DstImageId dstName,
                            GLenum     dstTarget,
                            GLint      dstLevel,
                            GLint      dstX,
                            GLint      dstY,
                            GLint      dstZ,
                            GLsizei    srcWidth,
                            GLsizei    srcHeight,
                            GLsizei    srcDepth) {
  minRequiredVersion(3, 2)
  CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)
}

sub void CopyImageSubData(SrcImageId  srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, DstImageId  dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
  switch (srcTarget) {
    case GL_RENDERBUFFER, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
        GL_TEXTURE_CUBE_MAP_ARRAY: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(srcTarget)
    }
  }
  switch (dstTarget) {
    case GL_RENDERBUFFER, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP,
        GL_TEXTURE_CUBE_MAP_ARRAY: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(dstTarget)
    }
  }

  _ = srcName // TODO
  _ = srcLevel // TODO
  _ = srcX // TODO
  _ = srcY // TODO
  _ = srcZ // TODO
  _ = dstName // TODO
  _ = dstLevel // TODO
  _ = dstX // TODO
  _ = dstY // TODO
  _ = dstZ // TODO
  _ = srcWidth // TODO
  _ = srcHeight // TODO
  _ = srcDepth // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCopyTexImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexImage2D.xhtml", GLES32)
cmd void glCopyTexImage2D(GLenum  target,
                          GLint   level,
                          GLenum  internalformat,
                          GLint   x,
                          GLint   y,
                          GLsizei width,
                          GLsizei height,
                          GLint   border) {
  minRequiredVersion(1, 0)
  TexImage(IsCopyTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glCopyTexSubImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexSubImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexSubImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexSubImage2D.xhtml", GLES32)
cmd void glCopyTexSubImage2D(GLenum  target,
                             GLint   level,
                             GLint   xoffset,
                             GLint   yoffset,
                             GLint   x,
                             GLint   y,
                             GLsizei width,
                             GLsizei height) {
  minRequiredVersion(1, 0)
  TexImage(IsCopyTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, // Dimensions
           GL_NONE, GL_NONE, GL_NONE, 0, null) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glCopyTexSubImage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glCopyTexSubImage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glCopyTexSubImage3D.xhtml", GLES32)
cmd void glCopyTexSubImage3D(GLenum  target,
                             GLint   level,
                             GLint   xoffset,
                             GLint   yoffset,
                             GLint   zoffset,
                             GLint   x,
                             GLint   y,
                             GLsizei width,
                             GLsizei height) {
  minRequiredVersion(3, 0)
  CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height)
}

sub void CopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
  TexImage(IsCopyTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, 1, 0, // Dimensions
           GL_NONE, GL_NONE, GL_NONE, 0, null) // Format&data
  _ = x // TODO
  _ = y // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteSamplers.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteSamplers.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteSamplers.xhtml", GLES32)
cmd void glDeleteSamplers(GLsizei count, const SamplerId* samplers) {
  minRequiredVersion(3, 0)

  s := samplers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := s[i]
    if id != 0 {
      delete(ctx.SharedObjects.Samplers, id)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDeleteTextures.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glDeleteTextures.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glDeleteTextures.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glDeleteTextures.xhtml", GLES32)
cmd void glDeleteTextures(GLsizei count, const TextureId* textures) {
  minRequiredVersion(1, 0)

  if count < 0 { glErrorInvalidValue() }
  t := textures[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := t[i]
    if id != 0 {
      delete(ctx.SharedObjects.Textures, id)
    }
    // TODO: Unbind from all texture units.
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenSamplers.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenSamplers.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenSamplers.xhtml", GLES32)
cmd void glGenSamplers(GLsizei count, SamplerId* samplers) {
  minRequiredVersion(3, 0)

  s := samplers[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!SamplerId(?)
    ctx.SharedObjects.Samplers[id] = new!Sampler()
    s[i] = id
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenTextures.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenTextures.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenTextures.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenTextures.xhtml", GLES32)
cmd void glGenTextures(GLsizei count, TextureId* textures) {
  minRequiredVersion(1, 0)
  if count < 0 { glErrorInvalidValue() }

  t := textures[0:count]
  ctx := GetContext()
  for i in (0 .. count) {
    id := as!TextureId(?)
    ctx.SharedObjects.Textures[id] = new!Texture(ID: id)
    t[i] = id
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenerateMipmap.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGenerateMipmap.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGenerateMipmap.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGenerateMipmap.xhtml", GLES32)
cmd void glGenerateMipmap(GLenum target) {
  minRequiredVersion(2, 0)
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: {
      // version 2.0
    }
    case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D: {
      minRequiredVersion(3, 0)
    }
    case GL_TEXTURE_CUBE_MAP_ARRAY: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  // TODO
}

sub void GetSamplerParameterv!T(SamplerId sampler, GLenum pname, T* params) {
  ctx := GetContext()
  s := ctx.SharedObjects.Samplers[sampler]
  switch (pname) {
    case GL_TEXTURE_COMPARE_FUNC: params[0] = as!T(s.CompareFunc)
    case GL_TEXTURE_COMPARE_MODE: params[0] = as!T(s.CompareMode)
    case GL_TEXTURE_MIN_FILTER:   params[0] = as!T(s.MinFilter)
    case GL_TEXTURE_MAG_FILTER:   params[0] = as!T(s.MagFilter)
    case GL_TEXTURE_MIN_LOD:      params[0] = as!T(s.MinLod)
    case GL_TEXTURE_MAX_LOD:      params[0] = as!T(s.MaxLod)
    case GL_TEXTURE_WRAP_R:       params[0] = as!T(s.WrapR)
    case GL_TEXTURE_WRAP_S:       params[0] = as!T(s.WrapS)
    case GL_TEXTURE_WRAP_T:       params[0] = as!T(s.WrapT)
    case GL_TEXTURE_BORDER_COLOR: {
      minRequiredVersion(3, 2)
      // TODO: Different behaviour based on the I suffix.
      p := params[0:4]
      p[0] = as!T(s.BorderColor[0])
      p[1] = as!T(s.BorderColor[1])
      p[2] = as!T(s.BorderColor[2])
      p[3] = as!T(s.BorderColor[3])
    }
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      requiresExtension(GL_EXT_texture_filter_anisotropic)
      params[0] = as!T(s.MaxAnisotropy)
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", GLES32)
cmd void glGetSamplerParameterIiv(SamplerId sampler, GLenum pname, GLint* params) {
  minRequiredVersion(3, 2)
  GetSamplerParameterIiv(sampler, pname, params)
}

sub void GetSamplerParameterIiv(SamplerId sampler, GLenum pname, GLint* params) {
  GetSamplerParameterv!GLint(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", GLES32)
cmd void glGetSamplerParameterIuiv(SamplerId sampler, GLenum pname, GLuint* params) {
  minRequiredVersion(3, 2)
  GetSamplerParameterIuiv(sampler, pname, params)
}

sub void GetSamplerParameterIuiv(SamplerId sampler, GLenum pname, GLuint* params) {
  GetSamplerParameterv!GLuint(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", GLES32)
cmd void glGetSamplerParameterfv(SamplerId sampler, GLenum pname, GLfloat* params) {
  minRequiredVersion(3, 0)
  GetSamplerParameterv!GLfloat(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetSamplerParameter.xhtml", GLES32)
cmd void glGetSamplerParameteriv(SamplerId sampler, GLenum pname, GLint* params) {
  minRequiredVersion(3, 0)
  GetSamplerParameterv!GLint(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexLevelParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexLevelParameter.xhtml", GLES32)
cmd void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) {
  minRequiredVersion(3, 1)
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_3D,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: {
      // version 3.1
    }
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_ARRAY: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (pname) {
    case GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_BLUE_TYPE,
        GL_TEXTURE_COMPRESSED, GL_TEXTURE_DEPTH, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_DEPTH_TYPE,
        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_GREEN_TYPE,
        GL_TEXTURE_HEIGHT, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_RED_TYPE,
        GL_TEXTURE_SAMPLES, GL_TEXTURE_SHARED_SIZE, GL_TEXTURE_STENCIL_SIZE, GL_TEXTURE_WIDTH: {
      // version 3.1
    }
    case GL_TEXTURE_BUFFER_DATA_STORE_BINDING, GL_TEXTURE_BUFFER_OFFSET, GL_TEXTURE_BUFFER_SIZE: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexLevelParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexLevelParameter.xhtml", GLES32)
cmd void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) {
  minRequiredVersion(3, 1)
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_3D,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z: {
      // version 3.1
    }
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_ARRAY: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (pname) {
    case GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_ALPHA_TYPE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_BLUE_TYPE,
        GL_TEXTURE_COMPRESSED, GL_TEXTURE_DEPTH, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_DEPTH_TYPE,
        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_GREEN_TYPE,
        GL_TEXTURE_HEIGHT, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_RED_TYPE,
        GL_TEXTURE_SAMPLES, GL_TEXTURE_SHARED_SIZE, GL_TEXTURE_STENCIL_SIZE, GL_TEXTURE_WIDTH: {
      // version 3.1
    }
    case GL_TEXTURE_BUFFER_DATA_STORE_BINDING, GL_TEXTURE_BUFFER_OFFSET, GL_TEXTURE_BUFFER_SIZE: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
  // TODO
  params[0] = ?
}

sub void GetTexParameter!T(GLenum target, GLenum parameter, T* params) {
  // TODO: Remove and rely on the switch in GetBoundTextureOrErrorInvalidEnum.
  switch (target) {
    case GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP: {
      // version 2.0
    }
    case GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D: {
      minRequiredVersion(3, 0)
    }
    case GL_TEXTURE_2D_MULTISAMPLE: {
      minRequiredVersion(3, 1)
    }
    case GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY: {
      minRequiredVersion(3, 2)
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  t := GetBoundTextureOrErrorInvalidEnum(target)
  switch (parameter) {
    case GL_TEXTURE_MAG_FILTER: {
      minRequiredVersion(2, 0)
      params[0] = as!T(t.MagFilter)
    }
    case GL_TEXTURE_MIN_FILTER: {
      minRequiredVersion(2, 0)
      params[0] = as!T(t.MinFilter)
    }
    case GL_TEXTURE_WRAP_S: {
      minRequiredVersion(2, 0)
      params[0] = as!T(t.WrapS)
    }
    case GL_TEXTURE_WRAP_T: {
      minRequiredVersion(2, 0)
      params[0] = as!T(t.WrapT)
    }
    case GL_TEXTURE_BASE_LEVEL: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.BaseLevel)
    }
    case GL_TEXTURE_COMPARE_FUNC: {
      // TODO: minRequiredVersion(3, 0) or GL_EXT_shadow_samplers
      params[0] = as!T(t.CompareFunc)
    }
    case GL_TEXTURE_COMPARE_MODE: {
      // TODO: minRequiredVersion(3, 0) or GL_EXT_shadow_samplers
      params[0] = as!T(t.CompareMode)
    }
    case GL_TEXTURE_IMMUTABLE_FORMAT: {
      // TODO: minRequiredVersion(3, 0) or GL_EXT_texture_storage
      params[0] = as!T(t.ImmutableFormat)
    }
    case GL_TEXTURE_MAX_LEVEL: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.MaxLevel)
    }
    case GL_TEXTURE_MAX_LOD: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.MaxLod)
    }
    case GL_TEXTURE_MIN_LOD: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.MinLod)
    }
    case GL_TEXTURE_SWIZZLE_A: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.SwizzleA)
    }
    case GL_TEXTURE_SWIZZLE_B: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.SwizzleB)
    }
    case GL_TEXTURE_SWIZZLE_G: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.SwizzleG)
    }
    case GL_TEXTURE_SWIZZLE_R: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.SwizzleR)
    }
    case GL_TEXTURE_WRAP_R: {
      minRequiredVersion(3, 0)
      params[0] = as!T(t.WrapR)
    }
    case GL_DEPTH_STENCIL_TEXTURE_MODE: {
      minRequiredVersion(3, 1)
      params[0] = as!T(t.DepthStencilTextureMode)
    }
    case GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: {
      minRequiredVersion(3, 1)
      params[0] = ? // TODO
    }
    case GL_TEXTURE_IMMUTABLE_LEVELS: {
      minRequiredVersion(3, 1)
      params[0] = as!T(t.ImmutableLevels)
    }
    case GL_TEXTURE_BORDER_COLOR: {
      minRequiredVersion(3, 2)
      // TODO: Depends on the I suffix
      p := params[0:4]
      p[0] = as!T(t.BorderColor[0])
      p[1] = as!T(t.BorderColor[1])
      p[2] = as!T(t.BorderColor[2])
      p[3] = as!T(t.BorderColor[3])
    }
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      requiresExtension(GL_EXT_texture_filter_anisotropic)
      params[0] = as!T(t.MaxAnisotropy)
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", GLES32)
cmd void glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params) {
  minRequiredVersion(3, 2)
  GetTexParameterIiv(target, pname, params)
}

sub void GetTexParameterIiv(GLenum target, GLenum pname, GLint* params) {
  GetTexParameter!GLint(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", GLES32)
cmd void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) {
  minRequiredVersion(3, 2)
  GetTexParameterIuiv(target, pname, params)
}

sub void GetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) {
  GetTexParameter!GLuint(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", GLES32)
cmd void glGetTexParameterfv(GLenum target, GLenum parameter, GLfloat* values) {
  minRequiredVersion(1, 0)
  GetTexParameter!GLfloat(target, parameter, values)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glGetTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glGetTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glGetTexParameter.xhtml", GLES32)
cmd void glGetTexParameteriv(GLenum target, GLenum parameter, GLint* values) {
  minRequiredVersion(1, 0)
  GetTexParameter!GLint(target, parameter, values)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsSampler.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsSampler.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsSampler.xhtml", GLES32)
cmd GLboolean glIsSampler(SamplerId sampler) {
  minRequiredVersion(3, 0)

  ctx := GetContext()
  return as!GLboolean(sampler in ctx.SharedObjects.Samplers)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsTexture.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glIsTexture.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glIsTexture.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glIsTexture.xhtml", GLES32)
cmd GLboolean glIsTexture(TextureId texture) {
  minRequiredVersion(1, 0)

  ctx := GetContext()
  return as!GLboolean(texture in ctx.SharedObjects.Textures)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glPixelStorei.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glPixelStorei.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glPixelStorei.xhtml", GLES32)
cmd void glPixelStorei(GLenum parameter, GLint value) {
  minRequiredVersion(1, 0)
  if value < 0 { glErrorInvalidValue() }
  ctx := GetContext()
  switch (parameter) {
    case GL_PACK_ALIGNMENT: {
      minRequiredVersion(2, 0)
      if (value != 1) && (value != 2) && (value != 4) && (value != 8) { glErrorInvalidValue() }
      ctx.PixelStorage.PackAlignment = value
    }
    case GL_PACK_IMAGE_HEIGHT: {
      minRequiredVersion(3, 0) // SPEC: Missing from online man pages
      ctx.PixelStorage.PackImageHeight = value
    }
    case GL_PACK_ROW_LENGTH: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.PackRowLength = value
    }
    case GL_PACK_SKIP_IMAGES: {
      minRequiredVersion(3, 0) // SPEC: Missing from online man pages
      ctx.PixelStorage.PackSkipImages = value
    }
    case GL_PACK_SKIP_PIXELS: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.PackSkipPixels = value
    }
    case GL_PACK_SKIP_ROWS: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.PackSkipRows = value
    }
    case GL_UNPACK_ALIGNMENT: {
      minRequiredVersion(2, 0)
      if (value != 1) && (value != 2) && (value != 4) && (value != 8) { glErrorInvalidValue() }
      ctx.PixelStorage.UnpackAlignment = value
    }
    case GL_UNPACK_IMAGE_HEIGHT: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.UnpackImageHeight = value
    }
    case GL_UNPACK_ROW_LENGTH: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.UnpackRowLength = value
    }
    case GL_UNPACK_SKIP_IMAGES: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.UnpackSkipImages = value
    }
    case GL_UNPACK_SKIP_PIXELS: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.UnpackSkipPixels = value
    }
    case GL_UNPACK_SKIP_ROWS: {
      minRequiredVersion(3, 0)
      ctx.PixelStorage.UnpackSkipRows = value
    }
    default: {
      glErrorInvalidEnum(parameter)
    }
  }
}

sub void SamplerParameterv!T(SamplerId sampler, GLenum pname, T params) {
  ctx := GetContext()
  s := ctx.SharedObjects.Samplers[sampler]
  switch (pname) {
    case GL_TEXTURE_COMPARE_FUNC: s.CompareFunc = as!GLenum(params[0])
    case GL_TEXTURE_COMPARE_MODE: s.CompareMode = as!GLenum(params[0])
    case GL_TEXTURE_MIN_FILTER:   s.MinFilter = as!GLenum(params[0])
    case GL_TEXTURE_MAG_FILTER:   s.MagFilter = as!GLenum(params[0])
    case GL_TEXTURE_MIN_LOD:      s.MinLod = as!GLfloat(params[0])
    case GL_TEXTURE_MAX_LOD:      s.MaxLod = as!GLfloat(params[0])
    case GL_TEXTURE_WRAP_R:       s.WrapR = as!GLenum(params[0])
    case GL_TEXTURE_WRAP_S:       s.WrapS = as!GLenum(params[0])
    case GL_TEXTURE_WRAP_T:       s.WrapT = as!GLenum(params[0])
    case GL_TEXTURE_BORDER_COLOR: {
      minRequiredVersion(3, 2)
      // TODO: Handle - has different behaviour based on the I suffix.
    }
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      requiresExtension(GL_EXT_texture_filter_anisotropic)
      // This use case is not explicitly mentioned in the extension (presumably
      // because it is written for GLES2, but samplers were introduced in GLES3).
      // However, it is used and supported in practice (which is reasonable).
      s.MaxAnisotropy = as!GLfloat(params[0])
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameterIiv(SamplerId sampler, GLenum pname, const GLint* param) {
  minRequiredVersion(3, 2)
  SamplerParameterIiv(sampler, pname, param)
}

sub void SamplerParameterIiv(SamplerId sampler, GLenum pname, const GLint* param) {
  SamplerParameterv!(const GLint*)(sampler, pname, param)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameterIuiv(SamplerId sampler, GLenum pname, const GLuint* param) {
  minRequiredVersion(3, 2)
  SamplerParameterIuiv(sampler, pname, param)
}

sub void SamplerParameterIuiv(SamplerId sampler, GLenum pname, const GLuint* param) {
  SamplerParameterv!(const GLuint*)(sampler, pname, param)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameterf(SamplerId sampler, GLenum pname, GLfloat param) {
  minRequiredVersion(3, 0)
  params := Vec1f(param)
  SamplerParameterv!Vec1f(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameterfv(SamplerId sampler, GLenum pname, const GLfloat* param) {
  minRequiredVersion(3, 0)
  SamplerParameterv!(const GLfloat*)(sampler, pname, param)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameteri(SamplerId sampler, GLenum pname, GLint param) {
  minRequiredVersion(3, 0)
  params := Vec1i(param)
  SamplerParameterv!Vec1i(sampler, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glSamplerParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glSamplerParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glSamplerParameter.xhtml", GLES32)
cmd void glSamplerParameteriv(SamplerId sampler, GLenum pname, const GLint* param) {
  minRequiredVersion(3, 0)
  SamplerParameterv!(const GLint*)(sampler, pname, param)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexBuffer.xhtml", GLES32)
cmd void glTexBuffer(GLenum target, GLenum internalformat, BufferId buffer) {
  minRequiredVersion(3, 2)
  TexBuffer(target, internalformat, buffer)
}

sub void TexBuffer(GLenum target, GLenum internalformat, BufferId buffer) {
  switch (target) {
    case GL_TEXTURE_BUFFER: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (internalformat) {
    case GL_R16, GL_R16F, GL_R16I, GL_R16UI, GL_R32F, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI,
        GL_RG16, GL_RG16F, GL_RG16I, GL_RG16UI, GL_RG32F, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I,
        GL_RG8UI, GL_RGB32F, GL_RGB32I, GL_RGB32UI, GL_RGBA16, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI,
        GL_RGBA32F, GL_RGBA32I, GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(internalformat)
    }
  }
  _ = buffer // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexBufferRange.xhtml", GLES32)
cmd void glTexBufferRange(GLenum     target,
                          GLenum     internalformat,
                          BufferId   buffer,
                          GLintptr   offset,
                          GLsizeiptr size) {
  minRequiredVersion(3, 2)
  TexBufferRange(target, internalformat, buffer, offset, size)
}

sub void TexBufferRange(GLenum target, GLenum internalformat, BufferId buffer, GLintptr offset, GLsizeiptr size) {
  switch (target) {
    case GL_TEXTURE_BUFFER: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(target)
    }
  }
  switch (internalformat) {
    case GL_R16, GL_R16F, GL_R16I, GL_R16UI, GL_R32F, GL_R32I, GL_R32UI, GL_R8, GL_R8I, GL_R8UI,
        GL_RG16, GL_RG16F, GL_RG16I, GL_RG16UI, GL_RG32F, GL_RG32I, GL_RG32UI, GL_RG8, GL_RG8I,
        GL_RG8UI, GL_RGB32F, GL_RGB32I, GL_RGB32UI, GL_RGBA16, GL_RGBA16F, GL_RGBA16I, GL_RGBA16UI,
        GL_RGBA32F, GL_RGBA32I, GL_RGBA32UI, GL_RGBA8, GL_RGBA8I, GL_RGBA8UI: {
      // version 3.2
    }
    default: {
      glErrorInvalidEnum(internalformat)
    }
  }
  _ = buffer // TODO
  _ = offset // TODO
  _ = size // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexImage2D.xhtml", GLES32)
cmd void glTexImage2D(GLenum         target,
                      GLint          level,
                      GLint          internalformat,
                      GLsizei        width,
                      GLsizei        height,
                      GLint          border,
                      GLenum         format,
                      GLenum         type,
                      TexturePointer data) {
  minRequiredVersion(1, 0)
  TexImage(IsTexImageCmd, target,
           level, 0, 0, 0, // Offsets
           1, width, height, 1, border, // Dimensions
           as!GLenum(internalformat), format, type, 0, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexImage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexImage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexImage3D.xhtml", GLES32)
cmd void glTexImage3D(GLenum         target,
                      GLint          level,
                      GLint          internalformat,
                      GLsizei        width,
                      GLsizei        height,
                      GLsizei        depth,
                      GLint          border,
                      GLenum         format,
                      GLenum         type,
                      TexturePointer data) {
  minRequiredVersion(3, 0)
  TexImage3D(target, level, internalformat, width, height, depth, border, format, type, data)
}

sub void TexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexturePointer data) {
  TexImage(IsTexImageCmd | Has3DModifier, target,
           level, 0, 0, 0, // Offsets
           1, width, height, depth, border, // Dimensions
           as!GLenum(internalformat), format, type, 0, data) // Format&data
}

// Check that wrap is a valid value for GL_TEXTURE_WRAP_* otherwise
// abort with GL_INVALID_ENUM
sub GLenum checkWrapParam(GLenum wrap) {
  switch wrap {
    case GL_CLAMP_TO_EDGE, GL_REPEAT, GL_MIRRORED_REPEAT, GL_CLAMP_TO_BORDER: {
    }
    default: {
      glErrorInvalidEnum(wrap)
    }
  }
  return wrap
}

// Check that swizzle is a valid value for GL_TEXTURE_SWIZZLE_* otherwise
// abort with GL_INVALID_ENUM
sub GLenum checkSwizzleParam(GLenum swizzle) {
  switch swizzle {
    case GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_ZERO, GL_ONE: { /* fine */ }
    default:                                                   {
      glErrorInvalidEnum(swizzle)
    }
  }
  return swizzle
}

sub void TexParameterv!T(GLenum target, GLenum pname, T params) {
  switch target {
    case GL_TEXTURE_BUFFER, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: {
      glErrorInvalidEnum(target) // Excluded.
    }
    default: {
    }
  }

  t := GetBoundTextureOrErrorInvalidEnum(target)
  switch pname {
    case GL_TEXTURE_MAG_FILTER: {
      minRequiredVersion(2, 0)
      magFilter := as!GLenum(params[0])
      switch (magFilter) {
        case GL_NEAREST, GL_LINEAR: { /* fine */ }
        default:                    {
          glErrorInvalidEnum(magFilter)
        }
      }
      t.MagFilter = magFilter
    }
    case GL_TEXTURE_MIN_FILTER: {
      minRequiredVersion(2, 0)
      minFilter := as!GLenum(params[0])
      switch (minFilter) {
        case GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST,
            GL_LINEAR_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR,
            GL_LINEAR_MIPMAP_LINEAR: { /* fine */ }
        default:                     {
          glErrorInvalidEnum(minFilter)
        }
      }
      t.MinFilter = minFilter
    }
    case GL_TEXTURE_WRAP_S: {
      minRequiredVersion(2, 0)
      t.WrapS = checkWrapParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_WRAP_T: {
      minRequiredVersion(2, 0)
      t.WrapT = checkWrapParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_BASE_LEVEL: {
      minRequiredVersion(3, 0)
      baseLevel := as!GLint(params[0])
      if baseLevel < 0 { glErrorInvalidValue() }
      t.BaseLevel = baseLevel
    }
    case GL_TEXTURE_COMPARE_FUNC: {
      // TODO: minRequiredVersion(3, 0) or GL_EXT_shadow_samplers
      t.CompareFunc = as!GLenum(params[0])
    }
    case GL_TEXTURE_COMPARE_MODE: {
      // TODO: minRequiredVersion(3, 0) or GL_EXT_shadow_samplers
      t.CompareMode = as!GLenum(params[0])
    }
    case GL_TEXTURE_MAX_LEVEL: {
      minRequiredVersion(3, 0)
      maxLevel := as!GLint(params[0])
      if maxLevel < 0 { glErrorInvalidValue() }
      t.MaxLevel = maxLevel
    }
    case GL_TEXTURE_MAX_LOD: {
      minRequiredVersion(3, 0)
      t.MaxLod = as!GLfloat(params[0])
    }
    case GL_TEXTURE_MIN_LOD: {
      minRequiredVersion(3, 0)
      t.MinLod = as!GLfloat(params[0])
    }
    case GL_TEXTURE_SWIZZLE_A: {
      minRequiredVersion(3, 0)
      t.SwizzleA = checkSwizzleParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_SWIZZLE_B: {
      minRequiredVersion(3, 0)
      t.SwizzleB = checkSwizzleParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_SWIZZLE_G: {
      minRequiredVersion(3, 0)
      t.SwizzleG = checkSwizzleParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_SWIZZLE_R: {
      minRequiredVersion(3, 0)
      t.SwizzleR = checkSwizzleParam(as!GLenum(params[0]))
    }
    case GL_TEXTURE_WRAP_R: {
      minRequiredVersion(3, 0)
      t.WrapR = as!GLenum(params[0])
    }
    case GL_DEPTH_STENCIL_TEXTURE_MODE: {
      minRequiredVersion(3, 1)
      t.DepthStencilTextureMode = as!GLenum(params[0])
    }
    case GL_TEXTURE_BORDER_COLOR: {
      minRequiredVersion(3, 2)
      // TODO: Handle - has different behaviour based on the I suffix.
    }
    case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
      requiresExtension(GL_EXT_texture_filter_anisotropic)
      t.MaxAnisotropy = as!GLfloat(params[0])
    }
    case GL_TEXTURE_SRGB_DECODE_EXT: {
      requiresExtension(GL_EXT_texture_sRGB_decode)
      // TODO: DECODE_EXT, SKIP_DECODE_EXT
    }
    default: {
      glErrorInvalidEnum(pname)
    }
  }
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameterIiv(GLenum target, GLenum pname, const GLint* params) {
  minRequiredVersion(3, 2)
  TexParameterIiv(target, pname, params)
}

sub void TexParameterIiv(GLenum target, GLenum pname, const GLint* params) {
  TexParameterv!(const GLint*)(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) {
  minRequiredVersion(3, 2)
  TexParameterIuiv(target, pname, params)
}

sub void TexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) {
  TexParameterv!(const GLuint*)(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameterf(GLenum target, GLenum parameter, GLfloat value) {
  minRequiredVersion(1, 0)
  if parameter == GL_TEXTURE_BORDER_COLOR { glErrorInvalidEnum(parameter) } // not scalar
  params := Vec1f(value)
  TexParameterv!Vec1f(target, parameter, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) {
  minRequiredVersion(1, 0)
  TexParameterv!(const GLfloat*)(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameteri(GLenum target, GLenum parameter, GLint value) {
  minRequiredVersion(1, 0)
  if parameter == GL_TEXTURE_BORDER_COLOR { glErrorInvalidEnum(parameter) } // not scalar
  params := Vec1i(value)
  TexParameterv!Vec1i(target, parameter, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexParameter.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexParameter.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexParameter.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexParameter.xhtml", GLES32)
cmd void glTexParameteriv(GLenum target, GLenum pname, const GLint* params) {
  minRequiredVersion(1, 0)
  TexParameterv!(const GLint*)(target, pname, params)
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage2D.xhtml", GLES32)
cmd void glTexStorage2D(GLenum  target,
                        GLsizei levels,
                        GLenum  internalformat,
                        GLsizei width,
                        GLsizei height) {
  minRequiredVersion(3, 0)
  TexStorage2D(target, levels, internalformat, width, height)
}

sub void TexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
  depth := switch (target) {
    case GL_TEXTURE_CUBE_MAP: as!GLsizei(6)
    default: as!GLsizei(1)
  }
  TexImage(IsTexStorageCmd, target,
           0, 0, 0, 0, // Offsets
           levels, width, height, depth, 0, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage2DMultisample.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage2DMultisample.xhtml", GLES32)
cmd void glTexStorage2DMultisample(GLenum    target,
                                   GLsizei   samples,
                                   GLenum    internalformat,
                                   GLsizei   width,
                                   GLsizei   height,
                                   GLboolean fixedsamplelocations) {
  minRequiredVersion(3, 1)
  TexImage(IsTexStorageCmd | HasMultisampleModifier, target,
           0, 0, 0, 0, // Offsets
           1, width, height, 1, 0, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
  _ = samples // TODO
  _ = fixedsamplelocations // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexStorage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexStorage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage3D.xhtml", GLES32)
cmd void glTexStorage3D(GLenum  target,
                        GLsizei levels,
                        GLenum  internalformat,
                        GLsizei width,
                        GLsizei height,
                        GLsizei depth) {
  minRequiredVersion(3, 0)
  TexStorage3D(target, levels, internalformat, width, height, depth)
}

sub void TexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
  TexImage(IsTexStorageCmd | Has3DModifier, target,
           0, 0, 0, 0, // Offsets
           levels, width, height, depth, 0, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexStorage3DMultisample.xhtml", GLES32)
cmd void glTexStorage3DMultisample(GLenum    target,
                                   GLsizei   samples,
                                   GLenum    internalformat,
                                   GLsizei   width,
                                   GLsizei   height,
                                   GLsizei   depth,
                                   GLboolean fixedsamplelocations) {
  minRequiredVersion(3, 2)
  TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations)
}

sub void TexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
  TexImage(IsTexStorageCmd | Has3DModifier | HasMultisampleModifier, target,
           0, 0, 0, 0, // Offsets
           1, width, height, depth, 0, // Dimensions
           internalformat, GL_NONE, GL_NONE, 0, null) // Format&data
  _ = samples // TODO
  _ = fixedsamplelocations // TODO
}

@doc("https://www.khronos.org/opengles/sdk/docs/man/xhtml/glTexSubImage2D.xml", GLES20)
@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage2D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexSubImage2D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexSubImage2D.xhtml", GLES32)
cmd void glTexSubImage2D(GLenum         target,
                         GLint          level,
                         GLint          xoffset,
                         GLint          yoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  minRequiredVersion(1, 0)
  TexImage(IsTexImageCmd | HasSubModifier, target,
           level, xoffset, yoffset, 0, // Offsets
           1, width, height, 1, 0, // Dimensions
           GL_NONE, format, type, 0, data) // Format&data
}

@doc("https://www.khronos.org/opengles/sdk/docs/man3/html/glTexSubImage3D.xhtml", GLES30)
@doc("https://www.khronos.org/opengles/sdk/docs/man31/html/glTexSubImage3D.xhtml", GLES31)
@doc("https://www.khronos.org/opengles/sdk/docs/man32/html/glTexSubImage3D.xhtml", GLES32)
cmd void glTexSubImage3D(GLenum         target,
                         GLint          level,
                         GLint          xoffset,
                         GLint          yoffset,
                         GLint          zoffset,
                         GLsizei        width,
                         GLsizei        height,
                         GLsizei        depth,
                         GLenum         format,
                         GLenum         type,
                         TexturePointer data) {
  minRequiredVersion(3, 0)
  TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data)
}

sub void TexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexturePointer data) {
  TexImage(IsTexImageCmd | HasSubModifier | Has3DModifier, target,
           level, xoffset, yoffset, zoffset, // Offsets
           1, width, height, depth, 0, // Dimensions
           GL_NONE, format, type, 0, data) // Format&data
}
